###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      07/Apr/2014  17:52:36 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW2835_Control.c                                 #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\TW2835_Control.c" -D USE_STDPERIPH_DRIVER -D     #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\TW2835 #
#                    _Control.lst                                             #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\TW2835_ #
#                    Control.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\TW2835_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    TW2835_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   TW2835_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          //==================================================================================
     29          //						Page1 initialize table description
     30          //==================================================================================
     31          unsigned char	tbl_pg1_x_cmn[] = {
     32          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     33          	     0x02,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0xd7,0x23,0x2d,0x1e,0xa7,	//...  0x01
     34          	0x80,0x02,0x00,0x00,0x02,0x00,0x10,0x00,	0x81,0x02,0x00,0x01,0x02,0x00,0x11,0x00,	//...  0x10	//... normal quad
     35          	0x82,0x02,0x00,0x02,0x02,0x00,0x12,0x00,	0x83,0x02,0x00,0x03,0x02,0x00,0x13,0x00,	//...  0x20
     36          //	0x90,0x02,0x00,0x90,0x02,0x00,0x10,0x00,	0x91,0x02,0x00,0x91,0x02,0x00,0x11,0x00,	//... 0x10	//... non-realtime
     37          //	0x92,0x02,0x00,0x92,0x02,0x00,0x12,0x00,	0x93,0x02,0x00,0x93,0x02,0x00,0x13,0x00,	//... 0x20
     38          };
     39          
     40          //--------------------------		NTSC		------------------------------//
     41          //... H:60(3c),90(5a),120(78),180(b4), V:40(28),60(3c),80(50),120(78) for NTSC, 48(30),72(48),96(60),144(90) for PAL
     42          unsigned char	tbl_ntsc_pg1_pic_fl[] = {
     43          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     44          	0x00,0xb4,0x00,0x78,0x00,0xb4,0x00,0x78,	0x00,0xb4,0x00,0x78,0x00,0xb4,0x00,0x78	//...  
     45          };
     46          
     47          unsigned char	tbl_ntsc_pg1_pic_qd[] = {
     48          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     49          	0x00,0x5a,0x00,0x3c,0x5a,0xb4,0x00,0x3c,	0x00,0x5a,0x3c,0x78,0x5a,0xb4,0x3c,0x78	//...  
     50          };
     51          
     52          unsigned char	tbl_ntsc_pg1_pic_9_lt[] = {
     53          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     54          	0x00,0x3c,0x00,0x28,0x3c,0x78,0x00,0x28,	0x78,0xb4,0x00,0x28,0x00,0x3c,0x28,0x50	//...   
     55          };
     56          
     57          unsigned char	tbl_ntsc_pg1_pic_9_rb[] = {
     58          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     59          	0x78,0xb4,0x28,0x50,0x00,0x3c,0x50,0x78,	0x3c,0x78,0x50,0x78,0x78,0xb4,0x50,0x78	//...   
     60          };
     61          
     62          //--------------------------		PAL		------------------------------//
     63          //... H:60(3c),90(5a),120(78),180(b4), V:40(28),60(3c),80(50),120(78) for NTSC, 48(30),72(48),96(60),144(90) for PAL
     64          unsigned char	tbl_pal_pg1_pic_fl[] = {
     65          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     66          	0x00,0xb4,0x00,0x90,0x00,0xb4,0x00,0x90,	0x00,0xb4,0x00,0x90,0x00,0xb4,0x00,0x90	//...  
     67          };
     68          
     69          unsigned char	tbl_pal_pg1_pic_qd[] = {
     70          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     71          	0x00,0x5a,0x00,0x48,0x5a,0xb4,0x00,0x48,	0x00,0x5a,0x48,0x90,0x5a,0xb4,0x48,0x90	//...  
     72          };
     73          
     74          unsigned char	tbl_pal_pg1_pic_9_lt[] = {
     75          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     76          	0x00,0x3c,0x00,0x30,0x3c,0x78,0x00,0x30,	0x78,0xb4,0x00,0x30,0x00,0x3c,0x30,0x60	//...   
     77          };
     78          
     79          unsigned char	tbl_pal_pg1_pic_9_rb[] = {
     80          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     81          	0x78,0xb4,0x30,0x60,0x00,0x3c,0x60,0x90,	0x3c,0x78,0x60,0x90,0x78,0xb4,0x60,0x90	//...   
     82          };
     83          
     84          //=================================================================================
     85          
     86          unsigned char	tbl_pg1_y_cmn[] = {
     87          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     88          	0x28,0x00,0x10,0xa0,0x00,0x00,0x00,0x03,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa7,//... 0x50 
     89          	0x80,0x02,0x00,0x81,0x02,0x00,0x82,0x02,	0x00,0x83,0x02,0x00,0x00,0xe4,0x00,0x00,//... 0x60	//... normal quad
     90          //	0x90,0x02,0x00,0x91,0x02,0x00,0x92,0x02,	0x00,0x93,0x02,0x00,0x00,0xe4,0x00,0x00,//...0x60	//...non-realtime
     91          	0x00,0x03,0x00,0x00,0x00,0x00,0x02,0x00,	0xff,0xff,0xff,0xff,0xf0,0x00,0x8b,0x84,//... 0x70 
     92          //	0xff,0x00,0x51,0x07,0xeb,0x10,0xa8,0x00,	0x51,0xe7,0x80,0x00,0x00,0x00,0x00,0x00,//...0x80
     93          	0xdf,0x00,0x91,0x07,0xeb,0x10,0xa8,0x00,	0x91,0xe7,0x80,0x00,0x00,0x00,0x00,0x00,//... 0x80	//... update:060715
     94          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//... 0x90
     95          };
     96          
     97          //--------------------------		NTSC		------------------------------//
     98          //=================================================================================
     99          unsigned char	tbl_ntsc_pg1_enc[] = {
    100          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    101          	0x77,0x23,0xd7,0x01,0x80,0x20,0x00,0x0c,	0x20,0x09,0xaa,0x00,0x40,0x40,0x00,0x00	//... 0xa0
    102          //	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...0xb0
    103          };
    104          //--------------------------		PAL		------------------------------//
    105          //=================================================================================
    106          unsigned char	tbl_pal_pg1_enc[] = {
    107          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    108          	0x77,0x23,0xd7,0x01,0x80,0x20,0x00,0x0c,	0x20,0x4c,0xaa,0x00,0x40,0x40,0x00,0x00	//... 0xa0
    109          //	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...0xb0
    110          };
    111          //=================================================================================
    112          
    113          //==================================================================================
    114          //						Page2 initialize table description
    115          //==================================================================================
    116          
    117          //--------------------------		PAGE 2		------------------------------//
    118          unsigned char	tbl_pg2_mse_box[] = {		// 80 EA
    119          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    120          	//... mouse & LUT
    121          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x10
    122          	//... single box
    123          	0x00,0xb0,0x00,0x00,0x00,0x00,0x40,0x00,	0x00,0x00,0x00,0x00,0x00,0xb0,0x00,0x00,//...  0x20
    124          	0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x30
    125          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x40
    126          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x40,0x40,0x40,0x42,0xff	//...  0x50
    127          };
    128          
    129          unsigned char	tbl_ntsc_pg2_2dbox[] = {		// 32 EA
    130          	//... 2d array box
    131          	0x88,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,	0x89,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,//...  0x60
    132          	0x8a,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,	0x8b,0x00,0x00,0x00,0x00,0x00,0xfb,0x00	//...  0x70
    133          };
    134          
    135          unsigned char	tbl_ntsc_pg2_mtn[] = {		// 32 EA
    136          	//... sensitivity & mask info
    137          	0x17,0x73,0x88,0x4a,0x07,0x24,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x80
    138          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...  0x90
    139          };
    140          
    141          
    142          unsigned char	tbl_pal_pg2_2dbox[] = {		// 32 EA
    143          	//... 2d array box
    144          	0x20,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,	0x21,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,//...  0x60
    145          	0x22,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,	0x23,0x28,0x00,0x00,0x00,0x00,0xfb,0x00	//...  0x70
    146          };
    147          
    148          unsigned char	tbl_pal_pg2_mtn[] = {		// 32 EA
    149          	//... sensitivity & mask info
    150          	0x17,0x73,0x88,0x4a,0x07,0x24,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x80
    151          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...  0x90
    152          };
    153          
    154          unsigned char Register_Table_Page0[] = {
    155          //  0    1    2    3    4    5    6    7       8    9    a    b    c    d    e    f   
    156              0x00,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x00 
    157              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x10
    158              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x20
    159              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x30
    160              0x00,0x77,0x77,0x45,0xA0,0xD0,0x2F,0x64,   0x80,0x80,0x82,0x82,0x30,0x0F,0x05,0x00, //  0x40
    161              0x00,0x80,0x06,0x00,0x40,0xFF,0x00,0x00,   0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x50
    162              0xFF,0xFF,0x00,0x00,0x10,0x32,0x54,0x76,   0x00,0xBA,0xDC,0xFE,0x00,0x00,0x88,0x88, //  0x60
    163              0x08,0x54,0x00,0x00,0x00,0x00,0x00,0x00,   0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x70
    164              0x01,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0x31,0x00,0xD0,0x00,0xF0,0x08, //  0x80
    165              0x41,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0x71,0x00,0xD0,0x00,0xF0,0x08, //  0x90
    166              0x81,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0xB1,0x00,0xD0,0x00,0xF0,0x08, //  0xa0 
    167              0xC1,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0xF1,0x00,0xD0,0x00,0xF0,0x08, //  0xb0 
    168              0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,   0x00,0x3C,0x4F,0x00,0x00,0x00,0x00,0x00, //  0xc0 
    169              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xd0 
    170              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xe0 
    171              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00  //  0xf0 
    172          };
    173          unsigned char Register_Table_Page1[] = { 
    174          //  0    1    2    3    4    5    6    7                         8    9         a       b       c    d    e    f       
    175              0x00,0x00,0x00,0x00,0x0F,0x04,0x00,0x00,   0x00,0x00,0x20,0xD7,0x23,0x2D,0x1E,0xA3, //  0x00 
    176              0x80,0x02,0x00,0x00,0x02,0x00,0x10,0x00,   0x81,0x02,0x00,0x01,0x02,0x00,0x11,0x00, //  0x10 
    177              0x82,0x02,0x00,0x02,0x02,0x00,0x12,0x00,   0x83,0x02,0x00,0x03,0x02,0x00,0x13,0x00, //  0x20
    178              //0x00,0x02,0x00,0x00,0x02,0x00,0x10,0x00,   0x01,0x02,0x00,0x01,0x02,0x00,0x11,0x00, //  0x10 
    179              //0x02,0x02,0x00,0x02,0x02,0x00,0x12,0x00,   0x03,0x02,0x00,0x03,0x02,0x00,0x13,0x00, //  0x20
    180              0x00,0x58,0x00,0x3C,0x58,0xB0,0x00,0x3C,   0x00,0x58,0x3C,0x78,0x58,0xB0,0x3C,0x78, //  0x30 
    181              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x40 
    182              0x28,0x41,0x10,0xa0,0x00,0x00,0x00,0x03,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa3, //  0x50 
    183              0x80,0x00,0x00,0x81,0x00,0x00,0x82,0x00,   0x00,0x83,0x00,0x00,0x00,0xe4,0x00,0x00, //  0x60 
    184              0x00,0x03,0x00,0x00,0x00,0x00,0x02,0x00,   0xff,0xff,0xff,0xff,0xf0,0x00,0x89,0x84, //  0x70 
    185              0xdf,0x00,0x91,0x07,0xeb,0x10,0xa8,0x00,   0x91,0xe7,0x80,0x00,0x00,0x00,0x00,0x00, //  0x80 
    186              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x90 
    187              0x77,0x88,0x88,0x00,0x80,0x20,0x00,0x0c,   0x20,0x09,0xaa,0x00,0x40,0x40,0x00,0x00, //  0xa0 
    188              0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x0F,   0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xb0 
    189              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xc0 
    190              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xd0 
    191              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xe0 
    192              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //  0xf0
    193          };
    194          
    195          struct	{							//	struct cmn_flg Byte   
    196          	union {							//	ST        
    197                 	u8 BYTE;					//  Byte Access 
    198                 	struct {					//  Bit  Access 
    199                      u8 b_cmn_tmp:1;	    	//  Bit 7     
    200                      u8 b_cmn_NA:1;       	//  Bit 6     
    201                      u8 b_cmn_prtcl_bsy:1;	//  Bit 5     
    202                      u8 b_cmn_irq:1;		    //  Bit 4     
    203                      u8 b_cmn_wndw_mn:1;		//  Bit 3     
    204                      u8 b_cmn_wndw_pop:1;	//  Bit 2     
    205                    	u8 b_cmn_jp_vdo:2;	    //  Bit 1     
    206                     	u8 b_cmn_dtct_vs:1;		//  Bit 0     
    207                    	
    208                	}	BIT;					
    209          	}		ST;						
    210          }			cmn_flg;
    211          
    212          struct	{							//	struct cmn_flg Byte   
    213          	union {							//	ST        
    214                 	u8 BYTE;					//  Byte Access 
    215                 	struct {					//  Bit  Access 
    216                 	    u8 b_cmn_NA:1;	    	//  Bit 7     
    217                      u8 b_cmn_cnt_1s:1;	    //  Bit 6     
    218                      u8 b_cmn_cnt_05s:1;	    //  Bit 5     
    219                      u8 b_cmn_cnt_02s:1;		//  Bit 4     
    220                      u8 b_cmn_cnt_01s:1;		//  Bit 3     
    221                      u8 b_cmn_cnt_tgl:1;	    //  Bit 2     
    222                    	u8 b_cmn_cnt_fld:2;	    //  Bit 1     
    223                     	u8 b_cmn_cnt_vs:1;		//  Bit 0     
    224                    	
    225                	}	BIT;						
    226          	}		ST;							
    227          }			cmn_flg_cnt;
    228          
    229          struct	{							//	struct cmn_flg Byte   
    230          	union {							//	ST        
    231                 	u8 BYTE;					//  Byte Access 
    232                 	struct {					//  Bit  Access 
    233                      u8 b_ds_wth_cif:1;	    //  Bit 7     
    234                      u8 b_ds_wth_4pb:1;	    //  Bit 6     
    235                      u8 b_ds_wth_16pb:1;		//  Bit 5     
    236                      u8 b_ds_wth_rc:1;		//  Bit 4     
    237                      u8 b_ds_in_run:2;	    //  Bit 3     
    238                     	u8 b_ds_in_auto:1;		//  Bit 2     
    239                     	u8 b_cmn_NA:2;	    	//  Bit 0~1
    240                    	
    241                	}	BIT;						
    242          	}		ST;							
    243          }			wndw_flg_ds;
    244          
    245          struct	{							//	struct cmn_flg Byte   
    246          	union {							//	ST        
    247                 	u8 BYTE;					//  Byte Access 
    248                 	struct {					//  Bit  Access 
    249                 	    u8 b_ch_src:1;	    	//  Bit 7     
    250                      u8 b_ado_lv_mr:1;	    //  Bit 6     
    251                      u8 b_ado_lv_mr_arw_pb:1;//  Bit 5     
    252                      u8 b_cmn_NA:5;  		//  Bit 0~4     
    253                      
    254                	}	BIT;						
    255          	}		ST;							
    256          }			wndw_flg;
    257          
    258          
    259          
    260          u8	cmn_bot;
    261          u8	cmn_cnt_vs = 0;
    262          u8	cmn_cnt_vs_sub = 0;
    263          u8	cmn_vga_det = 0;				//... __WTH_VGA__일때 idata 없애면 compile시 error 발생.
    264          
    265          
    266          u8	cmn_dvc = MASTER;
    267          u8	cmn_lst_slvr_x = MASTER;
    268          u8	cmn_lst_slvr_y = MASTER;
    269          u8	cmn_max_ch = 4;
    270          
    271          u8 	read_data[0x0100];
    272          u8 	Temp;
    273          
    274          /* Private function prototypes -----------------------------------------------*/
    275          /* Private functions ---------------------------------------------------------*/
    276          
    277          void SetAsicFlgType(u8 _dvc, u8 _pg, u8 _addr, u8 _flg, u8 _data)
    278          {
    279          	u8 _t1_;
    280          
    281          	_t1_ = ReadAsicByte(_dvc,_pg,_addr);
    282          	_t1_ = (_t1_ & ~_flg)|_data;
    283          	WriteAsicByte(_dvc,_pg,_addr,_t1_);
    284          }
    285          
    286          void InitPg0(void)
    287          {
    288              	WriteAsicTable(MASTER,DVC_PG0,0x00,Register_Table_Page0,0xff);
    289          }
    290          
    291          void InitPg1(void)
    292          {
    293          	WriteAsicTable(MASTER,DVC_PG1,0x00,Register_Table_Page1,0xff);
    294          }
    295          
    296          void InitPg2(void)
    297          {
    298          	u8 _t1_;
    299          
    300          	//... OSD color index
    301          	InitOSDCol();
    302          
    303          	WriteAsicByte(MASTER,DVC_PG2,0x0f,0x0f);		//... OSD Enable for Display/Capture	
    304          
    305          	WriteOSDClrX(MASTER,0,0,0,45,31);				//... max line num is 310 line for OSD
    306          	WriteOSDClrX(MASTER,1,0,0,45,31);				//... max line num is 310 line for OSD
    307          	WriteOSDClrX(MASTER,2,0,0,45,31);				//... max line num is 310 line for OSD
    308          	WriteOSDClrX(MASTER,3,0,0,45,31);				//... max line num is 310 line for OSD
    309          	WriteOSDClrY(MASTER,0,0,45,31);					//... max line num is 310 line for OSD
    310          
    311          	WriteAsicByte(MASTER,DVC_PG2,0x10,0xf0);		//... cursor
    312          
    313          	//... other ( mouse, single box, 2d box, mask ..)
    314          	WriteAsicTable(MASTER,DVC_PG2,0x10,tbl_pg2_mse_box,80);
    315          	if(cmn_flg.ST.BIT.b_cmn_jp_vdo == VDO_NTSC){
    316          		WriteAsicTable(MASTER,DVC_PG2,0x60,tbl_ntsc_pg2_2dbox,32);
    317          		for(_t1_=0;_t1_<4;_t1_++)	WriteAsicTable(MASTER,DVC_PG2,0x80+0x20*_t1_,tbl_ntsc_pg2_mtn,32);
    318          	}
    319          	else{
    320          		WriteAsicTable(MASTER,DVC_PG2,0x60,tbl_pal_pg2_2dbox,32);
    321          		for(_t1_=0;_t1_<4;_t1_++)	WriteAsicTable(MASTER,DVC_PG2,0x80+0x20*_t1_,tbl_pal_pg2_mtn,32);
    322          	}
    323          }
    324          
    325          void WriteAsicByteOSD(u8 _dvc, u8 _addr, u8 _wdat)
    326          {
    327          #if	defined(__EN_ISR__)
    328          	EA = 0;
    329          #endif
    330          	Temp = _dvc;
    331          
    332          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    333          
    334          	HALE_RESET;
    335          	HRDB_SET;
    336          	HWRB_SET;
    337          	HSPB_RESET;
    338          
    339          	_dvc = 0;							//... temporal
    340          	HCSB0_RESET;
    341          	HCSB1_SET;
    342          
    343          	Write_TW2835(_addr);
    344          	HALE_SET;
    345          	HALE_RESET;
    346          
    347          	Write_TW2835(_wdat);
    348          	HWRB_RESET;
    349          	HWRB_SET;
    350          
    351          	HALE_RESET;
    352          	HRDB_SET;
    353          	HWRB_SET;
    354          	HSPB_RESET;
    355          
    356          	HCSB0_SET;
    357          	HCSB1_SET;
    358          
    359          	Write_TW2835(0xFF);
    360          
    361          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    362          #if	defined(__EN_ISR__)
    363          	EA = 1;
    364          #endif
    365          }
    366          
    367          void WriteAsicTableOSD(u8 _dvc, u8 _addr, u8 *_tbl_ptr)
    368          {
    369          	u8 _t1_;
    370          
    371          #if	defined(__EN_ISR__)
    372          	EA = 0;
    373          #endif
    374             	Temp = _dvc;
    375          
    376          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    377          
    378          	HALE_RESET;
    379          	HRDB_SET;
    380          	HWRB_SET;
    381          	HSPB_RESET;
    382          
    383          	_dvc = 0;							//... temporal
    384          	HCSB0_RESET;
    385          	HCSB1_SET;
    386          
    387          	Write_TW2835(_addr);
    388          
    389          	HALE_SET;
    390          	HALE_RESET;
    391          
    392          
    393          	for(_t1_=0;_t1_<5;_t1_++)
    394          	{
    395          		Write_TW2835(_tbl_ptr[_t1_]);
    396          		HWRB_RESET;
    397          		HWRB_SET;
    398          	}
    399          
    400          	HALE_RESET;
    401          	HRDB_SET;
    402          	HWRB_SET;
    403          	HSPB_RESET;
    404          
    405          
    406          	HCSB0_SET;
    407          	HCSB1_SET;
    408          
    409          	Write_TW2835(0xFF);
    410          
    411          
    412          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    413          #if	defined(__EN_ISR__)
    414          	EA = 1;
    415          #endif
    416          
    417          }
    418          
    419          void WriteAsicByte(u8 _dvc, u8 _pg, u8 _addr, u8 _wdat)
    420          {
    421          
    422          #if	defined(__EN_ISR__)
    423          	EA = 0;
    424          #endif
    425             	Temp = _dvc;
    426                  
    427          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    428          
    429          	HALE_RESET;
    430          	HRDB_SET;
    431          	HWRB_SET;
    432          	HSPB_RESET;
    433          
    434          	_dvc = 0;							//... temporal
    435          	if(_pg == DVC_PG0)
    436          	{	
    437          		HCSB1_RESET;	HCSB0_RESET;
    438          	}
    439          	else if(_pg == DVC_PG1)
    440          	{	
    441          		HCSB1_RESET;	
    442          		HCSB0_SET;
    443          	}
    444          	else if(_pg == DVC_PG2)
    445          	{	
    446          		HCSB1_SET;	
    447          		HCSB0_RESET;
    448          	}
    449          
    450          	Write_TW2835(_addr);
    451          	HALE_SET;
    452          	HALE_RESET;
    453          
    454          	Write_TW2835(_wdat);
    455          	HWRB_RESET;
    456          	HWRB_SET;
    457          
    458          	HALE_RESET;
    459          	HRDB_SET;
    460          	HWRB_SET;
    461          	HSPB_RESET;
    462          
    463          	HCSB0_SET;
    464          	HCSB1_SET;
    465          
    466          	Write_TW2835(0xFF);
    467          
    468          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    469          #if	defined(__EN_ISR__)
    470          	EA = 1;
    471          #endif
    472          }
    473          
    474          void WriteAsicTable(u8 _dvc, u8 _pg, u8 _addr, u8 *_tbl_ptr, u16 _tbl_cnt)
    475          {
    476          	u16 _t1_;
    477          
    478          
    479          #if	defined(__EN_ISR__)
    480          	EA = 0;
    481          #endif
    482             	Temp = _dvc;
    483          
    484          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    485          
    486          	HALE_RESET;
    487          	HRDB_SET;
    488          	HWRB_SET;
    489          	HSPB_RESET;
    490          
    491          
    492          	_dvc = 0;							//... temporal
    493          	if(_pg == DVC_PG0)      
    494          	{	
    495          		HCSB1_RESET;	
    496          		HCSB0_RESET;
    497          	}
    498          	else if(_pg == DVC_PG1) 
    499          	{	
    500          		HCSB1_RESET;	
    501          		HCSB0_SET;
    502          	}
    503          	else if(_pg == DVC_PG2)
    504          	{	
    505          		HCSB1_SET;	 
    506          		HCSB0_RESET;
    507          	}
    508          
    509          
    510          	Write_TW2835(_addr);
    511          	HALE_SET;
    512          	HALE_RESET;
    513          
    514          
    515          	for(_t1_=0;_t1_<_tbl_cnt;_t1_++)
    516          	{
    517          		Write_TW2835(_tbl_ptr[_t1_]);
    518          		HWRB_RESET;
    519          		HWRB_SET;   
    520          	}	
    521          
    522          	HALE_RESET;
    523          	HRDB_SET;
    524          	HWRB_SET;
    525          	HSPB_RESET;
    526          
    527          	HCSB0_SET;
    528          	HCSB1_SET;
    529          
    530          	Write_TW2835(0xFF);
    531          
    532          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    533          
    534          #if	defined(__EN_ISR__)
    535          	EA = 1;
    536          #endif
    537          }
    538          
    539          void ReadAsicTable(u8 _dvc, u8 _pg, u8 _addr, u16 _data_cnt)
    540          {
    541          	u16 _t1_;
    542          
    543          #if	defined(__EN_ISR__)
    544          	EA = 0;
    545          #endif
    546             	Temp = _dvc;
    547              
    548          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    549          
    550          	HALE_RESET;
    551          	HRDB_SET;
    552          	HWRB_SET;
    553          	HSPB_RESET;
    554          
    555          	_dvc = 0;							//... temporal
    556          	if(_pg == DVC_PG0)     
    557          	{
    558          		HCSB1_RESET;	
    559          		HCSB0_RESET;
    560          	}
    561          	else if(_pg == DVC_PG1) 
    562          	{
    563          		HCSB1_RESET;	
    564          		HCSB0_SET;
    565          	}
    566          	else if(_pg == DVC_PG2) 
    567          	{
    568          		HCSB1_SET;	    
    569          		HCSB0_RESET;
    570          	}
    571          
    572          	Write_TW2835(_addr);
    573          	HALE_SET;
    574          	HALE_RESET;
    575          
    576          	for(_t1_=0;_t1_<_data_cnt;_t1_++)
    577          	{
    578          		//Write_TW2835(0xFF);
    579          		HRDB_RESET;		
    580          		read_data[_t1_]= Read_TW2835();
    581          		HRDB_SET;
    582          	}
    583          
    584          	HALE_RESET;
    585          	HRDB_SET;
    586          	HWRB_SET;
    587          	HSPB_RESET;
    588          
    589          	HCSB0_SET;
    590          	HCSB1_SET;
    591          
    592          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    593          
    594          #if	defined(__EN_ISR__)
    595          	EA = 1;
    596          #endif
    597          
    598          }
    599          
    600          u8 ReadAsicByte(u8 _dvc, u8 _pg, u8 _addr)
    601          {
    602          	u8 _rdat_;
    603          
    604          #if	defined(__EN_ISR__)
    605          	EA = 0;
    606          #endif
    607             	Temp = _dvc;
    608              
    609          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    610          
    611          	HALE_RESET;
    612          	HRDB_SET;
    613          	HWRB_SET;
    614          	HSPB_RESET;
    615          
    616          	if(_pg == DVC_PG0)      
    617          	{	
    618          		HCSB1_RESET;	
    619          		HCSB0_RESET;
    620          	}
    621          	else if(_pg == DVC_PG1)
    622          	{
    623          		HCSB1_RESET;
    624          		HCSB0_SET;
    625          	}
    626          	else if(_pg == DVC_PG2) 
    627          	{	
    628          		HCSB1_SET;	 
    629          		HCSB0_RESET;
    630          	}
    631          
    632          	Write_TW2835(_addr);
    633          	HALE_SET;
    634          	HALE_RESET;
    635          
    636          	//Write_TW2835(0xFF);
    637          
    638          	HRDB_RESET;
    639          	_rdat_ = Read_TW2835();
    640          	HRDB_SET;
    641          
    642          
    643          	HALE_RESET;
    644          	HRDB_SET;
    645          	HWRB_SET;
    646          	HSPB_RESET;
    647          
    648          	HCSB0_SET;
    649          	HCSB1_SET;
    650          
    651          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    652          
    653          #if	defined(__EN_ISR__)
    654          	EA = 1;
    655          #endif
    656          
    657          	return _rdat_;
    658          }
    659          
    660          u8	ReadAsicOSDMemWr(u8 _dvc)
    661          {
    662          	u8 _rdat_;
    663          //	u16 temp_16;
    664          
    665          #if	defined(__EN_ISR__)
    666          	EA = 0;
    667          #endif
    668             	Temp = _dvc;
    669          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    670          
    671          	HALE_RESET;
    672          	HRDB_SET;
    673          	HWRB_SET;
    674          	HSPB_RESET;
    675          
    676          
    677          	_dvc = 0;							//... temporal
    678          	HCSB0_RESET;
    679          	HCSB1_SET;
    680          
    681          
    682          	Write_TW2835(0x0A);
    683          	HALE_SET;
    684          	HALE_RESET;
    685          
    686          
    687          	Write_TW2835(0xFF);
    688          	HRDB_RESET;
    689          
    690          
    691          	_rdat_ = Read_TW2835();
    692          	HRDB_SET;
    693          
    694          
    695          	HALE_RESET;	
    696          	HRDB_SET;
    697          	HWRB_SET;
    698          	HSPB_RESET;
    699          
    700          	HCSB0_SET;
    701          	HCSB1_SET;
    702          
    703          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    704          
    705          #if	defined(__EN_ISR__)
    706          	EA = 1;
    707          #endif
    708          
    709          	return _rdat_;
    710          }
    711          
    712          void	InitVdo(void)
    713          {
    714          	cmn_flg.ST.BIT.b_cmn_jp_vdo = VDO_NTSC;
    715          	cmn_bot = 120;
    716          	cmn_cnt_vs_sub = 54;
    717          }
    718          
    719          
    720          void Write_TW2835(u8 Data)
    721          {
    722          	u16 TempData;
    723          
    724          	Port_Change(TW2835_WRITE);
    725          
    726          	TempData = GPIO_ReadOutputData(TW2835_DATAPORT) & 0xFF00;
    727          	TempData |= ((u16)Data & 0x00FF);
    728          	
    729          	GPIO_Write(TW2835_DATAPORT,TempData);
    730          }
    731          
    732          u8 Read_TW2835()
    733          {
    734          	u8 Result;
    735          	Port_Change(TW2835_READ);
    736          
    737          	Result = (u8)(GPIO_ReadInputData(TW2835_DATAPORT) & 0x00FF);
    738          	
    739          
    740          	return Result;
    741          }
    742          
    743          void Port_Change(u8 in_Dir)
    744          {
    745          	GPIO_InitTypeDef GPIO_InitStructure;
    746          
    747          
    748          	if(in_Dir == TW2835_WRITE)
    749          	{
    750          		GPIO_InitStructure.GPIO_Pin = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | 
    751          										TW2835_D5 | TW2835_D6 | TW2835_D7;
    752          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    753          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    754                          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    755                          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;    
    756          		GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    757          	}
    758          	else if(in_Dir == TW2835_READ)
    759          	{
    760          		GPIO_InitStructure.GPIO_Pin = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | 
    761          										TW2835_D5 | TW2835_D6 | TW2835_D7;
    762          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    763          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    764                          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    765                          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;    
    766          		GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    767          	}
    768          }
    769          
    770          
    771          
    772          //  ++, kutelf, 131007
    773          //u8 Temp0, Temp1, Temp2, Temp3;
    774          void CheckCamera_Input(u8 Mode)
    775          {
    776          
    777          	//	입력이 없으면, return 0x80
    778          	//	입력이 있으면, return 0x9f
    779          	u8 Signal1 = ReadAsicByte(MASTER,DVC_PG0,0x00); 	//  ch1
    780          	u8 Signal2 = ReadAsicByte(MASTER,DVC_PG0,0x10);	//	ch2
    781          	u8 Signal3 = ReadAsicByte(MASTER,DVC_PG0,0x20);	//	ch3
    782          	u8 Signal4 = ReadAsicByte(MASTER,DVC_PG0,0x30);	//	ch4
    783          
    784          	
    785          
    786          	
    787          
    788          	
    789          
    790          	if(Mode == 0x00)
    791          	{
    792          		if(Signal1 != 0x80)
    793          		{
    794          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_blank);
    795          		}
    796          		else
    797          		{
    798          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_x);
    799          		}
    800          
    801          		
    802          	}
    803          
    804          	else if(Mode == 0x01)
    805          	{
    806          		if(Signal2 != 0x80)
    807          		{
    808          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_blank);
    809          		}
    810          		else
    811          		{
    812          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_x);
    813          		}
    814          
    815          		
    816          	}
    817          
    818          	else if(Mode == 0x02)
    819          	{
    820          		if(Signal3 != 0x80)
    821          		{
    822          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_blank);
    823          		}
    824          		else
    825          		{
    826          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_x);
    827          		}
    828          
    829          		
    830          	}
    831          
    832          	else if(Mode == 0x03)
    833          	{
    834          		if(Signal4 != 0x80)
    835          		{
    836          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_blank);
    837          		}
    838          		else
    839          		{
    840          			WriteOSDBmpX(MASTER,65,100,0x00,0x00,gt_CHANNEL_x);
    841          		}
    842          
    843          		
    844          	}
    845          	else if(Mode == 0x04)
    846          	{
    847          		if(Signal1 != 0x80)
    848          		{
    849          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    850          		}
    851          		else
    852          		{
    853          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    854          		}
    855          
    856          		if(Signal2 != 0x80)
    857          		{
    858          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    859          		}
    860          		else
    861          		{
    862          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    863          		}
    864          	}
    865          
    866          	else if(Mode == 0x05)
    867          	{
    868          		if(Signal1 != 0x80)
    869          		{
    870          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    871          		}
    872          		else
    873          		{
    874          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    875          		}
    876          
    877          		if(Signal3 != 0x80)
    878          		{
    879          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    880          		}
    881          		else
    882          		{
    883          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    884          		}
    885          	}
    886          	else if(Mode == 0x06)
    887          	{
    888          		if(Signal1 != 0x80)
    889          		{
    890          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    891          		}
    892          		else
    893          		{
    894          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    895          		}
    896          
    897          		if(Signal4 != 0x80)
    898          		{
    899          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    900          		}
    901          		else
    902          		{
    903          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    904          		}
    905          	}
    906          	else if(Mode == 0x07)
    907          	{
    908          		if(Signal2 != 0x80)
    909          		{
    910          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    911          		}
    912          		else
    913          		{
    914          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    915          		}
    916          
    917          		if(Signal3 != 0x80)
    918          		{
    919          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    920          		}
    921          		else
    922          		{
    923          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    924          		}
    925          	}
    926          	else if(Mode == 0x08)
    927          	{
    928          		if(Signal2 != 0x80)
    929          		{
    930          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    931          		}
    932          		else
    933          		{
    934          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    935          		}
    936          
    937          		if(Signal4 != 0x80)
    938          		{
    939          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    940          		}
    941          		else
    942          		{
    943          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    944          		}
    945          	}
    946          
    947          	else if(Mode == 0x09)
    948          	{
    949          		if(Signal3 != 0x80)
    950          		{
    951          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_blank);
    952          		}
    953          		else
    954          		{
    955          			WriteOSDBmpX(MASTER,20,100,0x00,0x00,gt_CHANNEL_x);
    956          		}
    957          
    958          		if(Signal4 != 0x80)
    959          		{
    960          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_blank);
    961          		}
    962          		else
    963          		{
    964          			WriteOSDBmpX(MASTER,110,100,0x00,0x00,gt_CHANNEL_x);
    965          		}
    966          	}
    967          
    968          	else if(Mode == 0x0A)
    969          	{
    970          		if(Signal1 != 0x80)
    971          		{
    972          			WriteOSDBmpX(MASTER,20,45,0x00,0x00,gt_CHANNEL_blank);
    973          		}
    974          		else
    975          		{
    976          			WriteOSDBmpX(MASTER,20,45,0x00,0x00,gt_CHANNEL_x);
    977          		}
    978          
    979          		if(Signal2 != 0x80)
    980          		{
    981          			WriteOSDBmpX(MASTER,110,45,0x00,0x00,gt_CHANNEL_blank);
    982          		}
    983          		else
    984          		{
    985          			WriteOSDBmpX(MASTER,110,45,0x00,0x00,gt_CHANNEL_x);
    986          		}
    987          
    988          		if(Signal3 != 0x80)
    989          		{
    990          			WriteOSDBmpX(MASTER,20,165,0x00,0x00,gt_CHANNEL_blank);
    991          		}
    992          		else
    993          		{
    994          			WriteOSDBmpX(MASTER,20,165,0x00,0x00,gt_CHANNEL_x);
    995          		}
    996          
    997          		if(Signal4 != 0x80)
    998          		{
    999          			WriteOSDBmpX(MASTER,110,165,0x00,0x00,gt_CHANNEL_blank);
   1000          		}
   1001          		else
   1002          		{
   1003          			WriteOSDBmpX(MASTER,110,165,0x00,0x00,gt_CHANNEL_x);
   1004          		}
   1005          		
   1006          	}
   1007          
   1008          }
   1009          //  --, kutelf, 131007
   1010          	
   1011          //  ++, kutelf, 131007
   1012          void CameraMode(u8 Mode, u8 OSD)
   1013          {
   1014          
   1015          	if(Mode == 0x00)
   1016          	{
   1017          		if(OSD)
   1018          		{
   1019          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1020          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH1_O);
   1021          		}
   1022          		
   1023          		// Scale CAM_0 // Select CAM
   1024          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
   1025          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
   1026          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
   1027          		WriteAsicByte(MASTER,DVC_PG0,0x83,0xff);
   1028          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
   1029          		    
   1030          		// ON/OFF CAMERA
   1031          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);    // ON CAM_0
   1032          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);	// OFF CAM_1
   1033          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_2
   1034          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_3
   1035          
   1036          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
   1037          		WriteAsicByte(MASTER,DVC_PG1,0x31,0xb0);
   1038          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
   1039          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
   1040          	}
   1041          	else if(Mode == 0x01)
   1042          	{
   1043          		if(OSD)
   1044          		{
   1045          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);	
   1046          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
   1047          		}
   1048          
   1049          		// Scale CAM_1 // Select CAM
   1050          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
   1051          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
   1052          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
   1053          		WriteAsicByte(MASTER,DVC_PG0,0x93,0xff);
   1054          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
   1055          		    
   1056          		// ON/OFF CAMERA
   1057          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
   1058          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
   1059          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_3
   1060          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_4
   1061          
   1062          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x00);    // Position CAM_1
   1063          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
   1064          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
   1065          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
   1066          	}
   1067          	else if(Mode == 0x02)
   1068          	{
   1069          		if(OSD)
   1070          		{
   1071          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1072          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH3_O);
   1073          		}
   1074          
   1075          		// Scale CAM_2 // Select CAM
   1076          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1077          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
   1078          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1079          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0xff);
   1080          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1081          		    
   1082          		// ON/OFF CAMERA
   1083          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
   1084          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1085          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);    // OFF CAM_3
   1086          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_4
   1087          
   1088          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
   1089          		WriteAsicByte(MASTER,DVC_PG1,0x39,0xb0);
   1090          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
   1091          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
   1092          	}
   1093          	else if(Mode == 0x03)
   1094          	{
   1095          		if(OSD)
   1096          		{
   1097          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1098          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
   1099          		}
   1100          		
   1101          		// Scale CAM_3 // Select CAM
   1102          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1103          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
   1104          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1105          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0xff);
   1106          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1107          		    
   1108          		// ON/OFF CAMERA
   1109          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
   1110          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1111          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_3
   1112          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    // OFF CAM_4
   1113          
   1114          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x00);    // Position CAM_3
   1115          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1116          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
   1117          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1118            	}
   1119          	else if(Mode == 0x04)
   1120          	{
   1121          		
   1122          		if(OSD)
   1123          		{
   1124          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1125          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
   1126                 		WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
   1127          		}
   1128          		
   1129          		// Scale CAM_0 // Select CAM
   1130          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
   1131          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
   1132          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
   1133          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
   1134          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
   1135          		// Scale CAM_1 // Select CAM
   1136          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
   1137          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
   1138          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
   1139          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
   1140          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
   1141          
   1142          
   1143          		// ON/OFF CAMERA
   1144          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);  
   1145          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
   1146          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);   
   1147          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);   
   1148          
   1149          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
   1150          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
   1151          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);    //0x00);
   1152          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
   1153          
   1154          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x58);    // Position CAM_1
   1155          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
   1156          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);    //0x00);
   1157          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
   1158          	}
   1159          	else if(Mode == 0x05)
   1160          	{
   1161          		if(OSD)
   1162          		{
   1163          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1164          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
   1165                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH3_O);
   1166          		}
   1167          
   1168          		// Scale CAM_0 // Select CAM
   1169          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
   1170          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
   1171          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
   1172          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
   1173          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
   1174          
   1175          		// Scale CAM_2 // Select CAM
   1176          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1177          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
   1178          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1179          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0xff);
   1180          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1181          		    
   1182          		// ON/OFF CAMERA
   1183          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);  
   1184          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1185          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
   1186          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    
   1187          
   1188          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
   1189          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
   1190          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
   1191          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
   1192          
   1193          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x58);    // Position CAM_2
   1194          		WriteAsicByte(MASTER,DVC_PG1,0x39,0xb0);
   1195          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
   1196          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78); 
   1197          	}
   1198          	else if(Mode == 0x06)
   1199          	{
   1200          		if(OSD)
   1201          		{
   1202          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1203          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
   1204                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
   1205          		}
   1206          
   1207          		// Scale CAM_0 // Select CAM
   1208          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
   1209          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
   1210          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
   1211          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
   1212          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
   1213          
   1214          		// Scale CAM_3 // Select CAM
   1215          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1216          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
   1217          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1218          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0xff);
   1219          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1220          		    
   1221          		// ON/OFF CAMERA
   1222          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);  
   1223          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1224          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);   
   1225          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    
   1226          
   1227          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
   1228          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
   1229          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
   1230          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
   1231          
   1232          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
   1233          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1234          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
   1235          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1236          	}
   1237          	else if(Mode == 0x07)
   1238          	{
   1239          		if(OSD)
   1240          		{
   1241          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1242          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH2_O);
   1243                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH3_O);
   1244          		}
   1245          
   1246          		// Scale CAM_1 // Select CAM
   1247          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
   1248          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
   1249          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
   1250          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
   1251          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
   1252          
   1253          		// Scale CAM_2 // Select CAM
   1254          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1255          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
   1256          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1257          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0x7f);
   1258          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1259          		    
   1260          		// ON/OFF CAMERA
   1261          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);  
   1262          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
   1263          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
   1264          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    
   1265          
   1266          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x00);    // Position CAM_1
   1267          		WriteAsicByte(MASTER,DVC_PG1,0x35,0x58);
   1268          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
   1269          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
   1270          
   1271          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x58);    // Position CAM_2
   1272          		WriteAsicByte(MASTER,DVC_PG1,0x39,0xb0);
   1273          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
   1274          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78); 
   1275          	}
   1276          	else if(Mode == 0x08)
   1277          	{
   1278          		if(OSD)
   1279          		{
   1280          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1281          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH2_O);
   1282                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
   1283          		}
   1284          
   1285          		// Scale CAM_1 // Select CAM
   1286          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
   1287          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
   1288          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
   1289          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
   1290          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
   1291          
   1292          		// Scale CAM_3 // Select CAM
   1293          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1294          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
   1295          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1296          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0xff);
   1297          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1298          		    
   1299          		// ON/OFF CAMERA
   1300          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);  
   1301          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
   1302          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);   
   1303          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    
   1304          
   1305          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x00);    // Position CAM_1
   1306          		WriteAsicByte(MASTER,DVC_PG1,0x35,0x58);
   1307          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
   1308          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
   1309          
   1310          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
   1311          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1312          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
   1313          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1314          	}
   1315          	else if(Mode == 0x09)
   1316          	{
   1317          		if(OSD)
   1318          		{
   1319          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1320          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH3_O);
   1321                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
   1322          		}
   1323          
   1324          		// Scale CAM_2 // Select CAM
   1325          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1326          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
   1327          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1328          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0x7f);
   1329          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1330          
   1331          		// Scale CAM_3 // Select CAM
   1332          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1333          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
   1334          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1335          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0xff);
   1336          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1337          		    
   1338          		// ON/OFF CAMERA
   1339          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);  
   1340          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1341          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
   1342          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    
   1343          
   1344          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
   1345          		WriteAsicByte(MASTER,DVC_PG1,0x39,0x58);
   1346          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
   1347          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
   1348          
   1349          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
   1350          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1351          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
   1352          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1353          	}
   1354          	else if (Mode == 0x0A)
   1355          	{
   1356          		if(OSD)
   1357          		{
   1358          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1359          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
   1360          		    WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
   1361          		    WriteOSDBmpX(MASTER,76,125,0x00,0x00,gt_CHANNEL_CH3_O);
   1362          		    WriteOSDBmpX(MASTER,162,125,0x00,0x00,gt_CHANNEL_CH4_O);
   1363          		}
   1364          		
   1365          		// Scale CAM_0 // Select CAM
   1366          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
   1367          		WriteAsicByte(MASTER,DVC_PG0,0x81,0x7f);
   1368          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
   1369          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
   1370          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
   1371          		// Scale CAM_1 // Select CAM
   1372          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
   1373          		WriteAsicByte(MASTER,DVC_PG0,0x91,0x7f);
   1374          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
   1375          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
   1376          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
   1377          		// Scale CAM_2 // Select CAM
   1378          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1379          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0x7f);
   1380          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1381          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0x7f);
   1382          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1383          		// Scale CAM_3 // Select CAM
   1384          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1385          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0x7f);
   1386          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1387          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0x7f);
   1388          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1389          
   1390          		// ON/OFF CAMERA
   1391          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);   
   1392          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
   1393          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
   1394          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83); 
   1395          
   1396          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
   1397          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
   1398          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
   1399          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x3C);
   1400          
   1401          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x58);    // Position CAM_1
   1402          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
   1403          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
   1404          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x3C);
   1405          
   1406          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
   1407          		WriteAsicByte(MASTER,DVC_PG1,0x39,0x58);
   1408          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x3C);
   1409          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
   1410          
   1411          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
   1412          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1413          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x3C);
   1414          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1415          	}
   1416          }
   1417          //  --, kutelf, 131007
   1418          
   1419          /**\
   1420            * @brief  None
   1421            * @param  None
   1422            * @retval None
   1423            */
   1424          void TW2835_Control_Init(void)
   1425          {
   1426          	DebugMsg_printf("++ TW2835_Control_Init (GPIO Mode), Initialize START\r\n");
   1427          
   1428          	InitPg0();
   1429          	InitPg1();
   1430          	InitPg2();
   1431          
   1432          	DebugMsg_printf("-- TW2835_Control_Init (GPIO Mode), Initialize END\r\n");
   1433          }
   1434          
   1435          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CameraMode
         0   -> WriteAsicByte
        16   -> WriteAsicByte
        16   -> WriteOSDBmpX
        16   -> WriteOSDClrX
      32   CheckCamera_Input
        32   -> ReadAsicByte
        32   -> WriteOSDBmpX
       8   InitPg0
         8   -> WriteAsicTable
       8   InitPg1
         8   -> WriteAsicTable
      16   InitPg2
        16   -> InitOSDCol
        16   -> WriteAsicByte
        16   -> WriteAsicTable
        16   -> WriteOSDClrX
        16   -> WriteOSDClrY
       0   InitVdo
      16   Port_Change
        16   -> GPIO_Init
      24   ReadAsicByte
        24   -> GPIO_ReadInputData
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      24   ReadAsicOSDMemWr
        24   -> GPIO_ReadInputData
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      32   ReadAsicTable
        32   -> GPIO_ReadInputData
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
       8   Read_TW2835
         8   -> GPIO_ReadInputData
         8   -> Port_Change
      24   SetAsicFlgType
        24   -> ReadAsicByte
         0   -> WriteAsicByte
      16   TW2835_Control_Init
         0   -> InitPg2
        16   -> WriteAsicTable
      32   WriteAsicByte
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
      24   WriteAsicByteOSD
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      32   WriteAsicTable
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
      24   WriteAsicTableOSD
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      16   Write_TW2835
        16   -> GPIO_ReadOutputData
         0   -> GPIO_Write
        16   -> Port_Change


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       8  ?Subroutine0
      12  ?Subroutine1
    3326  CameraMode
     434  CheckCamera_Input
      16  InitPg0
      14  InitPg1
     322  InitPg2
      20  InitVdo
      58  Port_Change
     288  ReadAsicByte
     252  ReadAsicOSDMemWr
     288  ReadAsicTable
      18  Read_TW2835
     512  Register_Table_Page0
          Register_Table_Page1
      36  SetAsicFlgType
      48  TW2835_Control_Init
     322  WriteAsicByte
     276  WriteAsicByteOSD
     326  WriteAsicTable
     470  WriteAsicTableOSD
      36  Write_TW2835
     216  cmn_bot
          cmn_cnt_vs_sub
          Temp
          cmn_flg
          tbl_pg2_mse_box
          tbl_ntsc_pg2_2dbox
          tbl_ntsc_pg2_mtn
          tbl_pal_pg2_2dbox
          tbl_pal_pg2_mtn
       1  cmn_cnt_vs
       1  cmn_dvc
       4  cmn_flg_cnt
       1  cmn_lst_slvr_x
       1  cmn_lst_slvr_y
       1  cmn_max_ch
       1  cmn_vga_det
     256  read_data
      16  tbl_ntsc_pg1_enc
      16  tbl_ntsc_pg1_pic_9_lt
      16  tbl_ntsc_pg1_pic_9_rb
      16  tbl_ntsc_pg1_pic_fl
      16  tbl_ntsc_pg1_pic_qd
      16  tbl_pal_pg1_enc
      16  tbl_pal_pg1_pic_9_lt
      16  tbl_pal_pg1_pic_9_rb
      16  tbl_pal_pg1_pic_fl
      16  tbl_pal_pg1_pic_qd
      48  tbl_pg1_x_cmn
      80  tbl_pg1_y_cmn
       4  wndw_flg
       4  wndw_flg_ds

 
   270 bytes in section .bss
 1 020 bytes in section .data
 6 622 bytes in section .text
 
 6 622 bytes of CODE memory
 1 290 bytes of DATA memory

Errors: none
Warnings: none
