###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      04/Feb/2015  20:26:16 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pla #
#                    tform\TaeHa - ECS\SRC\KeySwitch.c                        #
#    Command line =  "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pl #
#                    atform\TaeHa - ECS\SRC\KeySwitch.c" -D                   #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN "C:\Tools\IAR                    #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\Debug\Li #
#                    st\" -o "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monito #
#                    r_APP\Project\Debug\Obj\" --debug --endian=little        #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\IAR       #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\COMMON\INC\" -I "C:\Tools\IAR                        #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\TaeHa - ECS\INC\" -I "C:\Tools\IAR                   #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Libra #
#                    ries\CMSIS\Device\ST\STM32F4xx\Include\" -I              #
#                    "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pr #
#                    oject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -Oh  #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\List\KeySwitch.lst                            #
#    Object file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\Obj\KeySwitch.o                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\KeySwitch.c
      1          /**
      2            ******************************************************************************
      3            * @file    KeySwitch.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   KeySwitch.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          //#define STM32_BUZZER
     26          /* Private define ------------------------------------------------------------*/
     27          
     28          // ++, 150204 sys3215
     29          #if 0
     30          #define	Key_Menu			0x01
     31          #define	Key_Left			0x02
     32          #define	Key_Enter			0x04
     33          #define	Key_Right			0x08
     34          #define	Key_ESC				0x10
     35          #define	Key_Info			0x20
     36          
     37          #define	Key_CAM			    0x41
     38          #define	Key_Work_Load		0x42
     39          #define	Key_EH_MODE		    0x44
     40          #define	Key_Ride_Control	0x48
     41          #define	Key_Quick_Coupler	0x50
     42          #define	Key_Auto_Grease	    0x60
     43          
     44          #define	Key_Beacon			0x81
     45          #define	Key_Mirror_Heat		0x82
     46          #define	Key_Rear_Wiper		0x84
     47          #define	Key_USER			0x88
     48          #define	Key_Reserved1		0x90
     49          #define	Key_Reserved2		0xa0
     50          #endif
     51          
     52          #define MENU                        	0x00000001
     53          #define ESC                        	0x00000002
     54          #define LEFT                         	0x00000004
     55          #define RIGHT                        	0x00000008
     56          #define ENTER                         	0x00000010
     57          
     58          // --, 150204 sys3215
     59          
     60          #define	KEYSwitchSendCountMax	50
     61          
     62          #define Bank1_SRAM1_ADDR  ((uint32_t)0x60000000) 
     63          
     64          
     65          /* Private macro -------------------------------------------------------------*/
     66          /* Private variables ---------------------------------------------------------*/
     67          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Port array
     68          GPIO_TypeDef*  KEYSWITCH_SCANPORT[MAXSCAN]	=   {  
     69                                                          KeySWXX_PORT, 
     70                                                          KeySWXX_PORT, 
     71                                                          KeySWXX_PORT, 
     72                                                      };
     73          
     74          GPIO_TypeDef*  KEYSWITCH_INPUTPORT[MAXINPUT]	=   {  
     75                                                          KeySWXX_PORT, 
     76                                                          KeySWXX_PORT, 
     77                                                          KeySWXX_PORT, 
     78                                                          KeySWXX_PORT, 
     79                                                          KeySWXX_PORT,
     80                                                          KeySWXX_PORT,                                                
     81                                                      };
     82          
     83          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Pin array
     84          const uint16_t KEYSWITCH_SCAN[MAXSCAN]  =   { 
     85                                                          KeySCAN0, 
     86                                                          KeySCAN1, 
     87                                                          KeySCAN2, 
     88                                                      };
     89          
     90          const uint16_t KEYSWITCH_INPUT[MAXINPUT]  =   { 
     91                                                          KeyInput0, 
     92                                                          KeyInput1, 
     93                                                          KeyInput2, 
     94                                                          KeyInput3,
     95                                                          KeyInput4,
     96                                                          KeyInput5,
     97                                                      };
     98          
     99          //  KeySwitch.h -> Press Input KeySwitch Value array
    100          const uint8_t KEYSWITCH_VALUE[MAXSWITCH]   =   {
    101                                                          KEYSWITCH_MENU,    
    102                                                          KEYSWITCH_LEFT,    
    103                                                          KEYSWITCH_ESC,    
    104                                                          KEYSWITCH_RIGHT,    
    105                                                          KEYSWITCH_ENTER,    
    106                                                      };                                                
    107          uint8_t     KeySwitchScan;
    108          uint32_t    Temp_Value1, Temp_Value2, Temp_Value3,Temp_Value4, Temp_Cnt;
    109          uint32_t	New_Value;
    110          uint32_t	KeySwitchSendCount = 0;
    111          
    112          uint8_t		Test1 = 0, Test2 = 0;	
    113          uint16_t		test_buf[10];
    114          uint16_t		test_rx_buf[10];
    115          
    116          unsigned char rear_wiper_oper=0;
    117          
    118          // ++, 150204 sys3215
    119          u8 Input_Key_Value,Key_Status;
    120          // --, 150204 sys3215
    121          
    122          extern Realy_Control		rx_Realy_Control;
    123          /* Private function prototypes -----------------------------------------------*/
    124          /* Private functions ---------------------------------------------------------*/
    125          
    126          void KeySwitch_SendToEXYNOS(uint32_t KeyValue, uint8_t LongKey)
    127          {
    128          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    129          	uint8_t KeyValue_temp;
    130          
    131          	
    132          	memset(KeyValueBuffer, 0, Serial_COM4_TxSize * sizeof(uint8_t));
    133          
    134          	
    135          	KeyValueBuffer[0] = 0x02;				//	STX
    136          	KeyValueBuffer[1] = KeyRES;				//	KeyValue Command, 
    137          	KeyValueBuffer[2] = KeyValue & 0x000000FF;
    138          	KeyValueBuffer[3] = ((KeyValue & 0x0000FF00) >> 8);
    139          	KeyValueBuffer[4] = ((KeyValue & 0x00FF0000) >> 16);
    140          	KeyValueBuffer[5] = LongKey ;			//	Key Value Short/Long Key, 
    141          	
    142          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    143          	
    144             	// ++, 150204 sys3215
    145          
    146          	Make_Key_Status(KeyValue);
    147          	
    148          	// --, 150204 sys3215
    149          ////////////////////////// DPRAM TEST /////////////////////
    150          #if 0
    151          	else if( KeyValue_temp == KEYSWITCH_MENU) 
    152          	{
    153          		if(Test2==0)
    154          		{
    155          			for(Test1=0;Test1<10;Test1++)
    156          			{
    157          				test_buf[Test1]=Test1+0x30;
    158          				test_rx_buf[Test1]=0;
    159          			}
    160          		}
    161          		else if(Test2==1)
    162          		{
    163          			for(Test1=0;Test1<10;Test1++)
    164          			{
    165          				test_buf[Test1]=Test1+0x40;
    166          				test_rx_buf[Test1]=0;
    167          			}
    168          		}
    169          		else if(Test2==2)
    170          		{
    171          			for(Test1=0;Test1<10;Test1++)
    172          			{
    173          				test_buf[Test1]=Test1+0x50;
    174          				test_rx_buf[Test1]=0;
    175          			}
    176          		}
    177          		if(Test2++>2)	Test2=0;
    178          		DPRAM_WriteBuffer(&test_buf[0],0x00,10);
    179          
    180          		//memcpy(&test_buf[0], Bank1_SRAM1_ADDR,10);
    181          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0) = 0x0505;
    182                          
    183                          //test_rx_buf[0]=*(uint16_t *) (Bank1_SRAM1_ADDR + 0);
    184                          
    185                          
    186          		
    187          
    188          	}
    189          	else if( KeyValue_temp == KEYSWITCH_LEFT) 
    190          	{
    191          		DPRAM_ReadBuffer(&test_rx_buf[0],0x00,10);
    192          		for(Test1=0;Test1<10;Test1++)
    193          		{
    194          			test_buf[Test1]=0;
    195          		}
    196          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0x02) = 0x0404;
    197                          //test_rx_buf[1]=*(uint16_t *) (Bank1_SRAM1_ADDR + 2);
    198          
    199          	}
    200          #endif
    201          	if(Change_UART4_for_Download==0)
    202          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    203          
    204              DebugMsg_printf("KEYSWITCH %x\r\n", KeyValueBuffer[2]);
    205          }
    206          
    207          // ++, 150204 sys3215
    208          
    209          void Make_Key_Status(uint32_t KeyValue)
    210          {
    211          	uint32_t temp_Key_Value;
    212          	u8 i,temp_Key_Status;
    213          
    214          	Input_Key_Value=1;
    215          
    216          	temp_Key_Status=0;
    217          	
    218          	temp_Key_Value = KeyValue & 0x0000001f;
    219          
    220          	for(i=0;i<5;i++)
    221          	{
    222          		if(  ((temp_Key_Value>>i)&0x01))
    223          		{
    224          			if(i==0)	temp_Key_Status |= 0x01;
    225          			else if(i==1)	temp_Key_Status |= 0x10;
    226          			else if(i==2)	temp_Key_Status |= 0x02;
    227          			else if(i==3)	temp_Key_Status |= 0x04;
    228          			else if(i==4)	temp_Key_Status |= 0x08;	
    229          		}
    230          	}
    231          
    232          	Key_Status = temp_Key_Status;
    233          	
    234          }
    235          // --,150204 sys3215
    236          
    237          
    238          void SMK_SendToExynos(uint8_t SMK_Auth, uint8_t SMK_Msg, uint8_t SMK_Count)
    239          {
    240          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    241          
    242          	KeyValueBuffer[0] = 0x02;				//	STX
    243          	KeyValueBuffer[1] = SMKRES;				
    244          	KeyValueBuffer[2] = SMK_Auth;	
    245          	KeyValueBuffer[3] = SMK_Msg;	
    246          	KeyValueBuffer[4] = SMK_Count;	
    247          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    248          
    249          	if(Change_UART4_for_Download==0)
    250          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    251          }
    252          
    253          void KeyTest_TEST(uint8_t value)
    254          {
    255          #if 1
    256          	switch (value)
    257          	{
    258          
    259          		case 0x01:
    260          			CameraMode(0,1);
    261          			break;
    262          		case 0x02:
    263          			CameraMode(1,1);
    264          			break;
    265          		case 0x04:
    266          			CameraMode(2,1);
    267          			break;
    268          		case 0x08:
    269          			CameraMode(3,1);
    270          			break;
    271          		case 0x10:
    272          			CameraMode(4,1);
    273          			break;
    274          		case 0x20:
    275          			CameraMode(5,1);
    276          			break;	
    277          	}
    278          #endif
    279          }
    280          
    281          #if 0
    282          void KeySwitch_Process(void)
    283          {
    284          	uint8_t i, j, k;
    285          	uint32_t New_Value,temp_Value;
    286          
    287          	temp_Value = 0;
    288          
    289          	GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    290          	GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    291          	GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);	
    292          
    293          	for (i = 0; i < MAXSWITCH; i++)
    294          	{
    295          		k = 0;	  
    296          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    297          
    298          		if (k == 0) j = 1;	  
    299          		else		j = 0;
    300          
    301          		temp_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    302          		temp_Value  += j;	//	0 or 1
    303          	}
    304          
    305          	if( temp_Value !=0)
    306          	{
    307          		if (KeySwitchScan == 0) 
    308          		{
    309          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    310          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    311          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);	
    312          
    313          			for (i = 0; i < MAXSWITCH; i++)
    314          			{
    315          				k = 0;	  
    316          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    317          		
    318          				if (k == 0) j = 1;	  
    319          				else		j = 0;
    320          		
    321          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    322          				New_Value  += j;	//	0 or 1
    323          			}
    324          		}
    325          		else if (KeySwitchScan == 1) 
    326          		{
    327          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    328          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    329          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);		
    330          			for (i = 0; i < MAXSWITCH; i++)
    331          			{
    332          				k = 0;	  
    333          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    334          		
    335          				if (k == 0) j = 1;	  
    336          				else		j = 0;
    337          		
    338          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    339          				New_Value  += j;	//	0 or 1
    340          			}
    341          		}	
    342          		else if (KeySwitchScan == 2) 
    343          		{
    344          
    345          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    346          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    347          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);
    348          			for (i = 0; i < MAXSWITCH; i++)
    349          			{
    350          				k = 0;	  
    351          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    352          		
    353          				if (k == 0) j = 1;	  
    354          				else		j = 0;
    355          		
    356          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    357          				New_Value  += j;	//	0 or 1
    358          			}
    359          		}	
    360          		
    361          		//	KeySwitch Press Check
    362          		
    363          
    364          		if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    365          		{
    366          			Temp_Value1 = New_Value+(KeySwitchScan<<6);
    367          		}
    368          	
    369          		//if (KeySwitchScan == 2)    //  15msec
    370          		{
    371          			if (Temp_Value1 == 0) 
    372          			{
    373          				Temp_Value3 = Temp_Cnt = 0;
    374          			}
    375          			else
    376          	        	{
    377          		            if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    378          		            {
    379          	                		Temp_Cnt++;                 //  계속 눌려 있는가?
    380          	                
    381          					if (Temp_Cnt ==2)          //  3번 연속 체크 되었을 때, 45msec
    382          					{
    383          						KeySwitch_Value = Temp_Value1;   
    384          
    385          						//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    386          						#ifdef STM32_BUZZER
    387          						Buzzer_Set(10);
    388          						#endif
    389          
    390          						KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    391          					}
    392          					if (Temp_Cnt == 120)         //  10번 연속 체크 되었을 때
    393          					{
    394          						//  연속 스위치 루틴..                              
    395          						KeySwitch_Value = Temp_Value1;   
    396          						Temp_Cnt -= 5;
    397          						
    398          						if(KeySwitch_Value<0x20)
    399          						{
    400          							#ifdef STM32_BUZZER
    401          								Buzzer_Set(10);
    402          							#endif
    403          							KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    404          						}
    405          					}
    406          				}
    407          				else    //  순간적으로 눌렸는가?
    408          				{
    409          					Temp_Cnt    = 0;
    410          					Temp_Value3 = Temp_Value1;
    411          				}
    412          			}
    413          		}        
    414          
    415          		if (++KeySwitchScan > 2) KeySwitchScan = 0;
    416          	}
    417          	else
    418          	{
    419          		Temp_Value1 = Temp_Value3 = Temp_Cnt =KeySwitchScan= 0;
    420          	}
    421          	//  KeySwitch Value 생성
    422          	        
    423          }
    424          #endif 
    425          
    426          #if 1
    427          
    428          
    429          void KeySwitch_Process(void)
    430          {
    431          	uint8_t i, j, k;
    432          	uint32_t New_Value;
    433          	
    434          	if (KeySwitchScan == 0) 
    435          	{
    436          		Temp_Value1 = 0;
    437          
    438          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET); //R
    439          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    440          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    441          	}
    442          	else if (KeySwitchScan == 1) 
    443          	{
    444          
    445          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    446          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET); //R
    447          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    448          	}	
    449          	else if (KeySwitchScan == 2) 
    450          	{
    451          
    452          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    453          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    454          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);//R				
    455          	}	
    456          	
    457          	New_Value = 0;
    458          	
    459          	//  KeySwitch Press Check
    460          	//Delay(100);
    461          	
    462          	for (i = 0; i < MAXSWITCH; i++)
    463          	{
    464          		k = 0;    
    465          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    466          
    467          		if (k == 0) j = 1;    
    468          		else        j = 0;
    469          
    470          		New_Value <<= 1;    //  1Bit씩 Shitf하여 총 5Bit를 만든다.
    471          		New_Value  += j;    //  0 or 1
    472          	}
    473          
    474          	
    475              if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    476              //if (New_Value != 0)
    477              {
    478                  //Temp_Value1 = New_Value+(KeySwitchScan<<6);
    479                  Temp_Value1 = New_Value << (KeySwitchScan * 8);
    480              }
    481                  
    482              if(KeySwitchSendCount < KEYSwitchSendCountMax)
    483              {
    484          		KeySwitchSendCount++;
    485          	}
    486          	if (KeySwitchScan == 2)    //  15msec
    487          	{
    488                        //  KeySwitch Value 생성
    489          		if (Temp_Value1 == 0) 
    490          		{
    491          			if(KeySwitch_Value != 0)
    492          			{
    493          				KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    494          				KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    495          			}
    496          			KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    497          
    498          			// ++, 150204 sys3215
    499          			Input_Key_Value=0;
    500          			// --, 150204 sys3215
    501          		}
    502          		else
    503                  {
    504                      if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    505                      {
    506                      	Temp_Cnt++;                 //  계속 눌려 있는가?
    507                      
    508          				if (Temp_Cnt ==3)          //  3번 연속 체크 되었을 때, 45msec
    509          				{
    510          					KeySwitch_Value = Temp_Value1;   
    511          
    512          					//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    513          					#ifdef STM32_BUZZER
    514          					Buzzer_Set(10);
    515          					#endif
    516          
    517          					if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    518          					{
    519          						KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    520          						KeySwitchSendCount = 0;
    521          					}
    522          					
    523          				}
    524          
    525          				if(Temp_Value3 == 0x00020000)
    526          				{
    527          					
    528          					if (Temp_Cnt == 100)         //  10번 연속 체크 되었을 때
    529          					{
    530          						//  연속 스위치 루틴..                              
    531          						KeySwitch_Value = Temp_Value1;   
    532          						Temp_Cnt -= 50;
    533          						
    534          						//if(KeySwitch_Value<0x20)
    535          						{
    536          							#ifdef STM32_BUZZER
    537          							Buzzer_Set(10);
    538          							#endif
    539          							if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    540          							{
    541          								KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    542          								KeySwitchSendCount = 0;
    543          							}
    544          						}
    545          					}
    546          				}
    547          				else
    548          				{
    549          					if (Temp_Cnt == 300)         //  10번 연속 체크 되었을 때
    550          					{
    551          						//  연속 스위치 루틴..                              
    552          						KeySwitch_Value = Temp_Value1;   
    553          						Temp_Cnt -= 50;
    554          						
    555          						//if(KeySwitch_Value<0x20)
    556          						{
    557          							#ifdef STM32_BUZZER
    558          								Buzzer_Set(10);
    559          							#endif
    560          							if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    561          							{
    562          								KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    563          								KeySwitchSendCount = 0;
    564          							}
    565          						}
    566          					}
    567          				}
    568          				
    569          			}
    570          			else    //  순간적으로 눌렸는가?
    571          			{
    572          				Temp_Cnt    = 0;
    573          				Temp_Value3 = Temp_Value1;
    574          			}
    575          		}
    576          	}        
    577          
    578          	if (++KeySwitchScan > 2) KeySwitchScan = 0;        
    579          }
    580          #endif
    581          
    582          
    583          void KeySwitch_Init(void)
    584          {
    585              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    586              NVIC_InitTypeDef        NVIC_InitStructure;
    587          
    588              DebugMsg_printf("++ KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize START\r\n");
    589          
    590              //  KeySwitch GPIO는 System_Init.c 에서 설정
    591              #if 0
    592          
    593              GPIO_InitTypeDef    GPIO_InitStructure;
    594              
    595          	//	KeySwitch Matrix -> GPIO Output
    596          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    597              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    598            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    599            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    600              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    601              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    602          
    603          	//	KeySwitch Matrix -> GPIO Input
    604          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    605              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    606            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    607            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    608              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    609              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    610          	
    611              #endif
    612          
    613              TIM_TimeBaseStructure.TIM_Period        = 0x9c4;   	//  (1 / 1MHz) * 5000 -> 5msec
    614          
    615          	//TIM_TimeBaseStructure.TIM_Period        = 0x4e2;   	//  (1 / 0.5MHz) * 2500 -> 5msec
    616          
    617          	//TIM_TimeBaseStructure.TIM_Period        = 0x271; 
    618          
    619          	TIM_TimeBaseStructure.TIM_Prescaler     = 0xA8;     //  84 MHz / 168 = 1MHz
    620          	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    621          	TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
    622          	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
    623          
    624          	//  TIM5 Enable counter
    625          	TIM_Cmd(TIM5, ENABLE);
    626          
    627          	//  Enable TIM5 Update Interrupt
    628          	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
    629          
    630          	//  Enable the TIM5 Interrupt, KeySwitch
    631          	NVIC_InitStructure.NVIC_IRQChannel                   = TIM5_IRQn;
    632          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    633          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    634          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    635          	NVIC_Init(&NVIC_InitStructure);
    636          
    637          	DebugMsg_printf("-- KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize END\r\n");
    638          
    639          	KeySwitch_Value = 0;	
    640          }
    641          
    642          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   KeySwitch_Init
        24   -> NVIC_Init
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   KeySwitch_Process
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
        24   -> KeySwitch_SendToEXYNOS
      24   KeySwitch_SendToEXYNOS
        24   -> Make_Key_Status
        24   -> USARTx_EXYNOS
        24   -> __aeabi_memclr4
       0   KeyTest_TEST
         0   -> CameraMode
       0   Make_Key_Status
      16   SMK_SendToExynos
        16   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
      12  KEYSWITCH_INPUT
       8  KEYSWITCH_SCAN
       8  KEYSWITCH_VALUE
      56  KeySwitchScan
          Input_Key_Value
          Key_Status
          KEYSWITCH_SCANPORT
          KEYSWITCH_INPUTPORT
          Temp_Value1
          Temp_Value3
          Temp_Cnt
          KeySwitchSendCount
      92  KeySwitch_Init
     320  KeySwitch_Process
      74  KeySwitch_SendToEXYNOS
      74  KeyTest_TEST
      82  Make_Key_Status
       4  New_Value
      48  SMK_SendToExynos
       4  Temp_Value2
       4  Temp_Value4
       1  Test1
       1  Test2
       1  rear_wiper_oper
      20  test_buf
      20  test_rx_buf

 
  55 bytes in section .bss
  56 bytes in section .data
  16 bytes in section .rodata
 718 bytes in section .text
 
 718 bytes of CODE  memory
  16 bytes of CONST memory
 111 bytes of DATA  memory

Errors: none
Warnings: 1
