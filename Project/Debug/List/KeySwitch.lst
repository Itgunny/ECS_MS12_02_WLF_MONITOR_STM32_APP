###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:33 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\KeySwitch.c                                      #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\KeySwitch.c" -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\KeySwi #
#                    tch.lst                                                  #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\KeySwit #
#                    ch.o                                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\KeySwitch.c
      1          /**
      2            ******************************************************************************
      3            * @file    KeySwitch.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   KeySwitch.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          #define STM32_BUZZER
     26          /* Private define ------------------------------------------------------------*/
     27          #define	Key_Menu			0x41
     28          #define	Key_Left			0x42
     29          #define	Key_Enter			0x44
     30          #define	Key_Right			0x48
     31          #define	Key_ESC			0x50
     32          #define	Key_Info			0x60
     33          
     34          #define	Key_CAM			0x81
     35          #define	Key_Work_Load		0x82
     36          #define	Key_EH_MODE		0x84
     37          #define	Key_Ride_Control	0x88
     38          #define	Key_Quick_Coupler	0x90
     39          #define	Key_Auto_Grease	0xa0
     40          
     41          #define	Key_Beacon			0xc1
     42          #define	Key_Mirror_Heat		0xc2
     43          #define	Key_Rear_Wiper		0xc4
     44          #define	Key_USER			0xc8
     45          #define	Key_Reserved1		0xd0
     46          #define	Key_Reserved2		0xe0
     47          
     48          /* Private macro -------------------------------------------------------------*/
     49          /* Private variables ---------------------------------------------------------*/
     50          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Port array
     51          GPIO_TypeDef*  KEYSWITCH_SCANPORT[MAXSCAN]	=   {  
     52                                                          KeySWXX_PORT, 
     53                                                          KeySWXX_PORT, 
     54                                                          KeySWXX_PORT, 
     55                                                      };
     56          
     57          GPIO_TypeDef*  KEYSWITCH_INPUTPORT[MAXINPUT]	=   {  
     58                                                          KeySWXX_PORT, 
     59                                                          KeySWXX_PORT, 
     60                                                          KeySWXX_PORT, 
     61                                                          KeySWXX_PORT, 
     62                                                          KeySWXX_PORT,
     63                                                          KeySWXX_PORT,                                                
     64                                                      };
     65          
     66          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Pin array
     67          const uint16_t KEYSWITCH_SCAN[MAXSCAN]  =   { 
     68                                                          KeySCAN0, 
     69                                                          KeySCAN1, 
     70                                                          KeySCAN2, 
     71                                                      };
     72          
     73          const uint16_t KEYSWITCH_INPUT[MAXINPUT]  =   { 
     74                                                          KeyInput0, 
     75                                                          KeyInput1, 
     76                                                          KeyInput2, 
     77                                                          KeyInput3,
     78                                                          KeyInput4,
     79                                                          KeyInput5,
     80                                                      };
     81          
     82          //  KeySwitch.h -> Press Input KeySwitch Value array
     83          const uint8_t KEYSWITCH_VALUE[MAXSWITCH]   =   {
     84                                                          KEYSWITCH_MENU,    
     85                                                          KEYSWITCH_LEFT,    
     86                                                          KEYSWITCH_ESC,    
     87                                                          KEYSWITCH_RIGHT,    
     88                                                          KEYSWITCH_ENTER,    
     89                                                      };                                                
     90          uint8_t     KeySwitchScan;
     91          uint32_t    Temp_Value1, Temp_Value2, Temp_Value3, Temp_Cnt;
     92          uint32_t	New_Value;
     93          
     94          uint8_t		Test1 = 0, Test2 = 0;	
     95          
     96          /* Private function prototypes -----------------------------------------------*/
     97          /* Private functions ---------------------------------------------------------*/
     98          
     99          void KeySwitch_SendToEXYNOS(uint8_t KeyValue, uint8_t ShortKey)
    100          {
    101          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    102          	uint8_t KeyValue_temp;
    103          
    104          	//	KeyValue에 + 0x40을 한다. 
    105          	//	윈도우에서 VK_A에서부터 순서대로 부여하기 위해서 더한다.
    106          	//	연속키 일 경우, 0x40 + 0x30을 해서 0x70의 값을 만들어 내기 위해서..
    107          	if(ShortKey)
    108          	{
    109          		if((KeyValue & 0xc0)==0x00)		KeyValue_temp = KeyValue+ 0x40;    // first line    
    110          		else if((KeyValue & 0x40)==0x40)	KeyValue_temp = KeyValue+ 0x40;    // second line
    111          		else if((KeyValue & 0x80)==0x80)	KeyValue_temp = KeyValue+ 0x40;    // third line
    112          	}
    113          	else
    114          	{
    115          		KeyValue_temp = KeyValue+ 0x40 + 0x20;    // first line    
    116          	}
    117          	KeyValueBuffer[0] = 0x02;				//	STX
    118          	KeyValueBuffer[1] = KeyCMD;				//	KeyValue Command, 0x4B
    119          	KeyValueBuffer[2] = KeyValue_temp ;	//	Key Value HexCode, 
    120          	KeyValueBuffer[3] = 0x03;				//	ETX
    121          	
    122              //  STM32에서 KeySwitch에 따른 BUZZER에 관한 명령을 MCU로 보내기 위해서 추가~
    123              
    124          	if( KeyValue_temp == KEYSWITCH_RIGHT )
    125          	{
    126          		if( WL9FM_BUZZER.Status == 1 )
    127          		{
    128          			Uart2_RxMsg_Single_160[0] |= 0x10;
    129          			Buzzer_Off();
    130          		}
    131          	}
    132          	else if(KeyValue_temp == KEYSWITCH_CAM )
    133          	{
    134          		cam_mode_change();	
    135          	}
    136          	
    137          	USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    138          
    139              DebugMsg_printf("KEYSWITCH %x\r\n", KeyValueBuffer[2]);
    140          }
    141          
    142          
    143          void RTC_SendToExynos(uint8_t Rtc_Hour, uint8_t Rtc_Min)
    144          {
    145          	uint8_t KeyValueBuffer[Serial_COM2_TxSize];
    146          
    147          	KeyValueBuffer[0] = 0x02;				//	STX
    148          	KeyValueBuffer[1] = (Rtc_Hour|0x80);				//	KeyValue Command, 0x4B
    149          	KeyValueBuffer[2] = Rtc_Min;	//	Key Value HexCode, 
    150          	KeyValueBuffer[3] = 0x03;				//	ETX
    151          	
    152          	USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    153          }
    154          
    155          void KeyTest_TEST(uint8_t value)
    156          {
    157          #if 1
    158          	switch (value)
    159          	{
    160          
    161          		case 0x01:
    162          			CameraMode(0,1);
    163          			break;
    164          		case 0x02:
    165          			CameraMode(1,1);
    166          			break;
    167          		case 0x04:
    168          			CameraMode(2,1);
    169          			break;
    170          		case 0x08:
    171          			CameraMode(3,1);
    172          			break;
    173          		case 0x10:
    174          			CameraMode(4,1);
    175          			break;
    176          		case 0x20:
    177          			CameraMode(5,1);
    178          			break;	
    179          	}
    180          #endif
    181          }
    182          
    183          /**
    184            * @brief  KeySwitch GPIO Reading & Value
    185            * @param  None
    186            * @retval None
    187            */
    188          //  5msec 마다 실행.. -> stm32f10x_it.c -> TIM5_IRQHandler
    189          void KeySwitch_Process(void)
    190          {
    191          	uint8_t i, j, k;
    192          	uint32_t New_Value;
    193              
    194          
    195          	
    196          	if (KeySwitchScan == 0) 
    197          	{
    198          		Temp_Value1 = 0;
    199          
    200          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    201          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    202          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    203          	}
    204          	else if (KeySwitchScan == 1) 
    205          	{
    206          
    207          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    208          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    209          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    210          	}	
    211          	else if (KeySwitchScan == 2) 
    212          	{
    213          
    214          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    215          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    216          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);					
    217          	}	
    218          	else
    219          	{
    220          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    221          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    222          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);		
    223          	}
    224          	
    225          	New_Value = 0;
    226          	
    227          	//  KeySwitch Press Check
    228          	for (i = 0; i < MAXSWITCH; i++)
    229          	{
    230          		k = 0;    
    231          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    232          
    233          		if (k == 0) j = 1;    
    234          		else        j = 0;
    235          
    236          		New_Value <<= 1;    //  1Bit씩 Shitf하여 총 5Bit를 만든다.
    237          		New_Value  += j;    //  0 or 1
    238          	}
    239          
    240          	//  KeySwitch Value 생성
    241          	if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    242          	{
    243          		Temp_Value1 = New_Value+(KeySwitchScan<<6);
    244          	}
    245              
    246          	if (KeySwitchScan == 5)    //  25msec
    247          	{
    248          		if (Temp_Value1 == 0) Temp_Value3 = Temp_Cnt = 0;
    249          		else
    250                  	{
    251          	            if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    252          	            {
    253                          		Temp_Cnt++;                 //  계속 눌려 있는가?
    254                          
    255          				if (Temp_Cnt == 4)          //  2번 연속 체크 되었을 때, 100msec
    256          				{
    257          					KeySwitch_Value = Temp_Value1;   
    258          
    259          					//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    260          					#ifdef STM32_BUZZER
    261          					Buzzer_Set(10);
    262          					#endif
    263          
    264          					KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    265          					//KeyTest_TEST(KeySwitch_Value);
    266          					//  디버깅할 때만 사용할 것
    267          					//DebugMsg_printf("KEYSWITCH %x\r\n", KeySwitch_Value);
    268          				}
    269          				if (Temp_Cnt == 100)         //  10번 연속 체크 되었을 때
    270          				{
    271          					//  연속 스위치 루틴..                              
    272          					KeySwitch_Value = Temp_Value1;   
    273          					Temp_Cnt -= 5;
    274          					
    275          					if(KeySwitch_Value<0x20)
    276          					{
    277          						#ifdef STM32_BUZZER
    278          							Buzzer_Set(10);
    279          						#endif
    280          						KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    281          					}
    282          				//KeyTest_TEST(KeySwitch_Value);
    283          
    284          				//  디버깅할 때만 사용할 것
    285          				//DebugMsg_printf("KEYSWITCH %x\r\n", KeySwitch_Value);
    286          				}
    287          			}
    288          			else    //  순간적으로 눌렸는가?
    289          			{
    290          				Temp_Cnt    = 0;
    291          				Temp_Value3 = Temp_Value1;
    292          			}
    293          		}
    294          	}        
    295          
    296          	if (++KeySwitchScan > 5) KeySwitchScan = 0;        
    297          }
    298          
    299          void KeySwitch_Init(void)
    300          {
    301              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    302              NVIC_InitTypeDef        NVIC_InitStructure;
    303          
    304              DebugMsg_printf("++ KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize START\r\n");
    305          
    306              //  KeySwitch GPIO는 System_Init.c 에서 설정
    307              #if 0
    308          
    309              GPIO_InitTypeDef    GPIO_InitStructure;
    310              
    311          	//	KeySwitch Matrix -> GPIO Output
    312          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    313              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    314            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    315            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    316              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    317              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    318          
    319          	//	KeySwitch Matrix -> GPIO Input
    320          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    321              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    322            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    323            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    324              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    325              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    326          	
    327              #endif
    328          
    329              TIM_TimeBaseStructure.TIM_Period        = 0x9C4;   	//  (1 / 1MHz) * 5000 -> 5msec
    330              TIM_TimeBaseStructure.TIM_Prescaler     = 0xA8;     //  168 MHz / 168 = 1MHz
    331              TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    332              TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
    333              TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
    334              
    335              //  TIM5 Enable counter
    336              TIM_Cmd(TIM5, ENABLE);
    337              
    338              //  Enable TIM5 Update Interrupt
    339              TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
    340          
    341              //  Enable the TIM5 Interrupt, KeySwitch
    342              NVIC_InitStructure.NVIC_IRQChannel                   = TIM5_IRQn;
    343              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    344              NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    345              NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    346              NVIC_Init(&NVIC_InitStructure);
    347          
    348              DebugMsg_printf("-- KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize END\r\n");
    349              
    350              KeySwitch_Value = 0;	
    351          }
    352          
    353          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   KeySwitch_Init
        24   -> NVIC_Init
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   KeySwitch_Process
        24   -> Buzzer_Set
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
        24   -> KeySwitch_SendToEXYNOS
       8   KeySwitch_SendToEXYNOS
         8   -> Buzzer_Off
         8   -> USARTx_EXYNOS
         8   -> cam_mode_change
       0   KeyTest_TEST
         0   -> CameraMode
     264   RTC_SendToExynos
       264   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
      12  KEYSWITCH_INPUT
       8  KEYSWITCH_SCAN
       8  KEYSWITCH_VALUE
      52  KeySwitchScan
          KEYSWITCH_SCANPORT
          KEYSWITCH_INPUTPORT
          Temp_Value1
          Temp_Value3
          Temp_Cnt
      92  KeySwitch_Init
     256  KeySwitch_Process
      94  KeySwitch_SendToEXYNOS
      74  KeyTest_TEST
       4  New_Value
      38  RTC_SendToExynos
       4  Temp_Value2
       1  Test1
       1  Test2

 
  10 bytes in section .bss
  52 bytes in section .data
  16 bytes in section .rodata
 586 bytes in section .text
 
 586 bytes of CODE  memory
  16 bytes of CONST memory
  62 bytes of DATA  memory

Errors: none
Warnings: none
