###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/Oct/2014  14:31:26 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\KeySwitch.c                                      #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\KeySwitch.c" -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\KeySwi #
#                    tch.lst                                                  #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\KeySwit #
#                    ch.o                                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\KeySwitch.c
      1          /**
      2            ******************************************************************************
      3            * @file    KeySwitch.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   KeySwitch.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          //#define STM32_BUZZER
     26          /* Private define ------------------------------------------------------------*/
     27          #define	Key_Menu			0x01
     28          #define	Key_Left			0x02
     29          #define	Key_Enter			0x04
     30          #define	Key_Right			0x08
     31          #define	Key_ESC				0x10
     32          #define	Key_Info			0x20
     33          
     34          #define	Key_CAM			    0x41
     35          #define	Key_Work_Load		0x42
     36          #define	Key_EH_MODE		    0x44
     37          #define	Key_Ride_Control	0x48
     38          #define	Key_Quick_Coupler	0x50
     39          #define	Key_Auto_Grease	    0x60
     40          
     41          #define	Key_Beacon			0x81
     42          #define	Key_Mirror_Heat		0x82
     43          #define	Key_Rear_Wiper		0x84
     44          #define	Key_USER			0x88
     45          #define	Key_Reserved1		0x90
     46          #define	Key_Reserved2		0xa0
     47          
     48          #define	KEYSwitchSendCountMax	50
     49          
     50          #define Bank1_SRAM1_ADDR  ((uint32_t)0x60000000) 
     51          
     52          
     53          /* Private macro -------------------------------------------------------------*/
     54          /* Private variables ---------------------------------------------------------*/
     55          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Port array
     56          GPIO_TypeDef*  KEYSWITCH_SCANPORT[MAXSCAN]	=   {  
     57                                                          KeySWXX_PORT, 
     58                                                          KeySWXX_PORT, 
     59                                                          KeySWXX_PORT, 
     60                                                      };
     61          
     62          GPIO_TypeDef*  KEYSWITCH_INPUTPORT[MAXINPUT]	=   {  
     63                                                          KeySWXX_PORT, 
     64                                                          KeySWXX_PORT, 
     65                                                          KeySWXX_PORT, 
     66                                                          KeySWXX_PORT, 
     67                                                          KeySWXX_PORT,
     68                                                          KeySWXX_PORT,                                                
     69                                                      };
     70          
     71          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Pin array
     72          const uint16_t KEYSWITCH_SCAN[MAXSCAN]  =   { 
     73                                                          KeySCAN0, 
     74                                                          KeySCAN1, 
     75                                                          KeySCAN2, 
     76                                                      };
     77          
     78          const uint16_t KEYSWITCH_INPUT[MAXINPUT]  =   { 
     79                                                          KeyInput0, 
     80                                                          KeyInput1, 
     81                                                          KeyInput2, 
     82                                                          KeyInput3,
     83                                                          KeyInput4,
     84                                                          KeyInput5,
     85                                                      };
     86          
     87          //  KeySwitch.h -> Press Input KeySwitch Value array
     88          const uint8_t KEYSWITCH_VALUE[MAXSWITCH]   =   {
     89                                                          KEYSWITCH_MENU,    
     90                                                          KEYSWITCH_LEFT,    
     91                                                          KEYSWITCH_ESC,    
     92                                                          KEYSWITCH_RIGHT,    
     93                                                          KEYSWITCH_ENTER,    
     94                                                      };                                                
     95          uint8_t     KeySwitchScan;
     96          uint32_t    Temp_Value1, Temp_Value2, Temp_Value3,Temp_Value4, Temp_Cnt;
     97          uint32_t	New_Value;
     98          uint32_t	KeySwitchSendCount = 0;
     99          
    100          uint8_t		Test1 = 0, Test2 = 0;	
    101          uint16_t		test_buf[10];
    102          uint16_t		test_rx_buf[10];
    103          
    104          unsigned char rear_wiper_oper=0;
    105          
    106          extern Realy_Control		rx_Realy_Control;
    107          /* Private function prototypes -----------------------------------------------*/
    108          /* Private functions ---------------------------------------------------------*/
    109          
    110          void KeySwitch_SendToEXYNOS(uint32_t KeyValue, uint8_t LongKey)
    111          {
    112          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    113          	uint8_t KeyValue_temp;
    114          
    115          	
    116          	memset(KeyValueBuffer, 0, Serial_COM4_TxSize * sizeof(uint8_t));
    117          
    118          	
    119          	KeyValueBuffer[0] = 0x02;				//	STX
    120          	KeyValueBuffer[1] = KeyRES;				//	KeyValue Command, 
    121          	KeyValueBuffer[2] = KeyValue & 0x000000FF;
    122          	KeyValueBuffer[3] = ((KeyValue & 0x0000FF00) >> 8);
    123          	KeyValueBuffer[4] = ((KeyValue & 0x00FF0000) >> 16);
    124          	KeyValueBuffer[5] = LongKey ;			//	Key Value Short/Long Key, 
    125          	
    126          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    127          	
    128             
    129          ////////////////////////// DPRAM TEST /////////////////////
    130          #if 0
    131          	else if( KeyValue_temp == KEYSWITCH_MENU) 
    132          	{
    133          		if(Test2==0)
    134          		{
    135          			for(Test1=0;Test1<10;Test1++)
    136          			{
    137          				test_buf[Test1]=Test1+0x30;
    138          				test_rx_buf[Test1]=0;
    139          			}
    140          		}
    141          		else if(Test2==1)
    142          		{
    143          			for(Test1=0;Test1<10;Test1++)
    144          			{
    145          				test_buf[Test1]=Test1+0x40;
    146          				test_rx_buf[Test1]=0;
    147          			}
    148          		}
    149          		else if(Test2==2)
    150          		{
    151          			for(Test1=0;Test1<10;Test1++)
    152          			{
    153          				test_buf[Test1]=Test1+0x50;
    154          				test_rx_buf[Test1]=0;
    155          			}
    156          		}
    157          		if(Test2++>2)	Test2=0;
    158          		DPRAM_WriteBuffer(&test_buf[0],0x00,10);
    159          
    160          		//memcpy(&test_buf[0], Bank1_SRAM1_ADDR,10);
    161          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0) = 0x0505;
    162                          
    163                          //test_rx_buf[0]=*(uint16_t *) (Bank1_SRAM1_ADDR + 0);
    164                          
    165                          
    166          		
    167          
    168          	}
    169          	else if( KeyValue_temp == KEYSWITCH_LEFT) 
    170          	{
    171          		DPRAM_ReadBuffer(&test_rx_buf[0],0x00,10);
    172          		for(Test1=0;Test1<10;Test1++)
    173          		{
    174          			test_buf[Test1]=0;
    175          		}
    176          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0x02) = 0x0404;
    177                          //test_rx_buf[1]=*(uint16_t *) (Bank1_SRAM1_ADDR + 2);
    178          
    179          	}
    180          #endif
    181          	if(Change_UART4_for_Download==0)
    182          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    183          
    184              DebugMsg_printf("KEYSWITCH %x\r\n", KeyValueBuffer[2]);
    185          }
    186          
    187          void SMK_SendToExynos(uint8_t SMK_Auth, uint8_t SMK_Msg, uint8_t SMK_Count)
    188          {
    189          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    190          
    191          	KeyValueBuffer[0] = 0x02;				//	STX
    192          	KeyValueBuffer[1] = SMKRES;				
    193          	KeyValueBuffer[2] = SMK_Auth;	
    194          	KeyValueBuffer[3] = SMK_Msg;	
    195          	KeyValueBuffer[4] = SMK_Count;	
    196          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    197          
    198          	if(Change_UART4_for_Download==0)
    199          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    200          }
    201          
    202          void KeyTest_TEST(uint8_t value)
    203          {
    204          #if 1
    205          	switch (value)
    206          	{
    207          
    208          		case 0x01:
    209          			CameraMode(0,1);
    210          			break;
    211          		case 0x02:
    212          			CameraMode(1,1);
    213          			break;
    214          		case 0x04:
    215          			CameraMode(2,1);
    216          			break;
    217          		case 0x08:
    218          			CameraMode(3,1);
    219          			break;
    220          		case 0x10:
    221          			CameraMode(4,1);
    222          			break;
    223          		case 0x20:
    224          			CameraMode(5,1);
    225          			break;	
    226          	}
    227          #endif
    228          }
    229          
    230          #if 0
    231          void KeySwitch_Process(void)
    232          {
    233          	uint8_t i, j, k;
    234          	uint32_t New_Value,temp_Value;
    235          
    236          	temp_Value = 0;
    237          
    238          	GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    239          	GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    240          	GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);	
    241          
    242          	for (i = 0; i < MAXSWITCH; i++)
    243          	{
    244          		k = 0;	  
    245          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    246          
    247          		if (k == 0) j = 1;	  
    248          		else		j = 0;
    249          
    250          		temp_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    251          		temp_Value  += j;	//	0 or 1
    252          	}
    253          
    254          	if( temp_Value !=0)
    255          	{
    256          		if (KeySwitchScan == 0) 
    257          		{
    258          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    259          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    260          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);	
    261          
    262          			for (i = 0; i < MAXSWITCH; i++)
    263          			{
    264          				k = 0;	  
    265          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    266          		
    267          				if (k == 0) j = 1;	  
    268          				else		j = 0;
    269          		
    270          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    271          				New_Value  += j;	//	0 or 1
    272          			}
    273          		}
    274          		else if (KeySwitchScan == 1) 
    275          		{
    276          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    277          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    278          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);		
    279          			for (i = 0; i < MAXSWITCH; i++)
    280          			{
    281          				k = 0;	  
    282          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    283          		
    284          				if (k == 0) j = 1;	  
    285          				else		j = 0;
    286          		
    287          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    288          				New_Value  += j;	//	0 or 1
    289          			}
    290          		}	
    291          		else if (KeySwitchScan == 2) 
    292          		{
    293          
    294          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    295          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    296          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);
    297          			for (i = 0; i < MAXSWITCH; i++)
    298          			{
    299          				k = 0;	  
    300          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    301          		
    302          				if (k == 0) j = 1;	  
    303          				else		j = 0;
    304          		
    305          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    306          				New_Value  += j;	//	0 or 1
    307          			}
    308          		}	
    309          		
    310          		//	KeySwitch Press Check
    311          		
    312          
    313          		if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    314          		{
    315          			Temp_Value1 = New_Value+(KeySwitchScan<<6);
    316          		}
    317          	
    318          		//if (KeySwitchScan == 2)    //  15msec
    319          		{
    320          			if (Temp_Value1 == 0) 
    321          			{
    322          				Temp_Value3 = Temp_Cnt = 0;
    323          			}
    324          			else
    325          	        	{
    326          		            if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    327          		            {
    328          	                		Temp_Cnt++;                 //  계속 눌려 있는가?
    329          	                
    330          					if (Temp_Cnt ==2)          //  3번 연속 체크 되었을 때, 45msec
    331          					{
    332          						KeySwitch_Value = Temp_Value1;   
    333          
    334          						//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    335          						#ifdef STM32_BUZZER
    336          						Buzzer_Set(10);
    337          						#endif
    338          
    339          						KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    340          					}
    341          					if (Temp_Cnt == 120)         //  10번 연속 체크 되었을 때
    342          					{
    343          						//  연속 스위치 루틴..                              
    344          						KeySwitch_Value = Temp_Value1;   
    345          						Temp_Cnt -= 5;
    346          						
    347          						if(KeySwitch_Value<0x20)
    348          						{
    349          							#ifdef STM32_BUZZER
    350          								Buzzer_Set(10);
    351          							#endif
    352          							KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    353          						}
    354          					}
    355          				}
    356          				else    //  순간적으로 눌렸는가?
    357          				{
    358          					Temp_Cnt    = 0;
    359          					Temp_Value3 = Temp_Value1;
    360          				}
    361          			}
    362          		}        
    363          
    364          		if (++KeySwitchScan > 2) KeySwitchScan = 0;
    365          	}
    366          	else
    367          	{
    368          		Temp_Value1 = Temp_Value3 = Temp_Cnt =KeySwitchScan= 0;
    369          	}
    370          	//  KeySwitch Value 생성
    371          	        
    372          }
    373          #endif 
    374          
    375          #if 1
    376          
    377          
    378          void KeySwitch_Process(void)
    379          {
    380          	uint8_t i, j, k;
    381          	uint32_t New_Value;
    382          	
    383          	if (KeySwitchScan == 0) 
    384          	{
    385          		Temp_Value1 = 0;
    386          
    387          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET); //R
    388          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    389          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    390          	}
    391          	else if (KeySwitchScan == 1) 
    392          	{
    393          
    394          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    395          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET); //R
    396          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    397          	}	
    398          	else if (KeySwitchScan == 2) 
    399          	{
    400          
    401          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    402          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    403          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);//R				
    404          	}	
    405          	
    406          	New_Value = 0;
    407          	
    408          	//  KeySwitch Press Check
    409          	//Delay(100);
    410          	
    411          	for (i = 0; i < MAXSWITCH; i++)
    412          	{
    413          		k = 0;    
    414          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    415          
    416          		if (k == 0) j = 1;    
    417          		else        j = 0;
    418          
    419          		New_Value <<= 1;    //  1Bit씩 Shitf하여 총 5Bit를 만든다.
    420          		New_Value  += j;    //  0 or 1
    421          	}
    422          
    423          	
    424              if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    425              //if (New_Value != 0)
    426              {
    427                  //Temp_Value1 = New_Value+(KeySwitchScan<<6);
    428                  Temp_Value1 = New_Value << (KeySwitchScan * 8);
    429              }
    430                  
    431              if(KeySwitchSendCount < KEYSwitchSendCountMax)
    432              {
    433          		KeySwitchSendCount++;
    434          	}
    435          	if (KeySwitchScan == 2)    //  15msec
    436          	{
    437                        //  KeySwitch Value 생성
    438          		if (Temp_Value1 == 0) 
    439          		{
    440          			if(KeySwitch_Value != 0)
    441          			{
    442          				KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    443          				KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    444          			}
    445          			KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;		
    446          		}
    447          		else
    448                  {
    449                      if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    450                      {
    451                      	Temp_Cnt++;                 //  계속 눌려 있는가?
    452                      
    453          				if (Temp_Cnt ==3)          //  3번 연속 체크 되었을 때, 45msec
    454          				{
    455          					KeySwitch_Value = Temp_Value1;   
    456          
    457          					//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    458          					#ifdef STM32_BUZZER
    459          					Buzzer_Set(10);
    460          					#endif
    461          
    462          					if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    463          					{
    464          						KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    465          						KeySwitchSendCount = 0;
    466          					}
    467          					
    468          				}
    469          				
    470          				if (Temp_Cnt == 300)         //  10번 연속 체크 되었을 때
    471          				{
    472          					//  연속 스위치 루틴..                              
    473          					KeySwitch_Value = Temp_Value1;   
    474          					Temp_Cnt -= 50;
    475          					
    476          					//if(KeySwitch_Value<0x20)
    477          					{
    478          						#ifdef STM32_BUZZER
    479          							Buzzer_Set(10);
    480          						#endif
    481          						if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    482          						{
    483          							KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    484          							KeySwitchSendCount = 0;
    485          						}
    486          					}
    487          				}
    488          			}
    489          			else    //  순간적으로 눌렸는가?
    490          			{
    491          				Temp_Cnt    = 0;
    492          				Temp_Value3 = Temp_Value1;
    493          			}
    494          		}
    495          	}        
    496          
    497          	if (++KeySwitchScan > 2) KeySwitchScan = 0;        
    498          }
    499          #endif
    500          
    501          
    502          void KeySwitch_Init(void)
    503          {
    504              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    505              NVIC_InitTypeDef        NVIC_InitStructure;
    506          
    507              DebugMsg_printf("++ KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize START\r\n");
    508          
    509              //  KeySwitch GPIO는 System_Init.c 에서 설정
    510              #if 0
    511          
    512              GPIO_InitTypeDef    GPIO_InitStructure;
    513              
    514          	//	KeySwitch Matrix -> GPIO Output
    515          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    516              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    517            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    518            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    519              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    520              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    521          
    522          	//	KeySwitch Matrix -> GPIO Input
    523          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    524              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    525            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    526            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    527              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    528              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    529          	
    530              #endif
    531          
    532              TIM_TimeBaseStructure.TIM_Period        = 0x9c4;   	//  (1 / 1MHz) * 5000 -> 5msec
    533          
    534          	//TIM_TimeBaseStructure.TIM_Period        = 0x4e2;   	//  (1 / 0.5MHz) * 2500 -> 5msec
    535          
    536          	//TIM_TimeBaseStructure.TIM_Period        = 0x271; 
    537          
    538          	TIM_TimeBaseStructure.TIM_Prescaler     = 0xA8;     //  84 MHz / 168 = 1MHz
    539          	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    540          	TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
    541          	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
    542          
    543          	//  TIM5 Enable counter
    544          	TIM_Cmd(TIM5, ENABLE);
    545          
    546          	//  Enable TIM5 Update Interrupt
    547          	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
    548          
    549          	//  Enable the TIM5 Interrupt, KeySwitch
    550          	NVIC_InitStructure.NVIC_IRQChannel                   = TIM5_IRQn;
    551          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    552          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    553          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    554          	NVIC_Init(&NVIC_InitStructure);
    555          
    556          	DebugMsg_printf("-- KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize END\r\n");
    557          
    558          	KeySwitch_Value = 0;	
    559          }
    560          
    561          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   KeySwitch_Init
        24   -> NVIC_Init
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   KeySwitch_Process
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
        24   -> KeySwitch_SendToEXYNOS
      24   KeySwitch_SendToEXYNOS
        24   -> USARTx_EXYNOS
        24   -> __aeabi_memclr4
       0   KeyTest_TEST
         0   -> CameraMode
      16   SMK_SendToExynos
        16   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      12  KEYSWITCH_INPUT
       8  KEYSWITCH_SCAN
       8  KEYSWITCH_VALUE
      56  KeySwitchScan
          KEYSWITCH_SCANPORT
          KEYSWITCH_INPUTPORT
          Temp_Value1
          Temp_Value3
          Temp_Cnt
          KeySwitchSendCount
      92  KeySwitch_Init
     304  KeySwitch_Process
      68  KeySwitch_SendToEXYNOS
      74  KeyTest_TEST
       4  New_Value
      48  SMK_SendToExynos
       4  Temp_Value2
       4  Temp_Value4
       1  Test1
       1  Test2
       1  rear_wiper_oper
      20  test_buf
      20  test_rx_buf

 
  55 bytes in section .bss
  56 bytes in section .data
  16 bytes in section .rodata
 614 bytes in section .text
 
 614 bytes of CODE  memory
  16 bytes of CONST memory
 111 bytes of DATA  memory

Errors: none
Warnings: 1
