###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      09/Jun/2015  07:54:36 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pla #
#                    tform\TaeHa - ECS\SRC\KeySwitch.c                        #
#    Command line =  "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pl #
#                    atform\TaeHa - ECS\SRC\KeySwitch.c" -D                   #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN "C:\Tools\IAR                    #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\Debug\Li #
#                    st\" -o "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monito #
#                    r_APP\Project\Debug\Obj\" --debug --endian=little        #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\IAR       #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\COMMON\INC\" -I "C:\Tools\IAR                        #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\TaeHa - ECS\INC\" -I "C:\Tools\IAR                   #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Libra #
#                    ries\CMSIS\Device\ST\STM32F4xx\Include\" -I              #
#                    "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pr #
#                    oject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -Oh  #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\List\KeySwitch.lst                            #
#    Object file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\Obj\KeySwitch.o                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\KeySwitch.c
      1          /**
      2            ******************************************************************************
      3            * @file    KeySwitch.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   KeySwitch.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          //#define STM32_BUZZER
     26          /* Private define ------------------------------------------------------------*/
     27          
     28          // ++, 150204 sys3215
     29          #if 0
     30          #define	Key_Menu			0x01
     31          #define	Key_Left			0x02
     32          #define	Key_Enter			0x04
     33          #define	Key_Right			0x08
     34          #define	Key_ESC				0x10
     35          #define	Key_Info			0x20
     36          
     37          #define	Key_CAM			    0x41
     38          #define	Key_Work_Load		0x42
     39          #define	Key_EH_MODE		    0x44
     40          #define	Key_Ride_Control	0x48
     41          #define	Key_Quick_Coupler	0x50
     42          #define	Key_Auto_Grease	    0x60
     43          
     44          #define	Key_Beacon			0x81
     45          #define	Key_Mirror_Heat		0x82
     46          #define	Key_Rear_Wiper		0x84
     47          #define	Key_USER			0x88
     48          #define	Key_Reserved1		0x90
     49          #define	Key_Reserved2		0xa0
     50          #endif
     51          
     52          #define MENU                        	0x00000001
     53          #define ESC                        	0x00000002
     54          #define LEFT                         	0x00000004
     55          #define RIGHT                        	0x00000008
     56          #define ENTER                         	0x00000010
     57          
     58          // --, 150204 sys3215
     59          
     60          #define	KEYSwitchSendCountMax	50
     61          
     62          #define Bank1_SRAM1_ADDR  ((uint32_t)0x60000000) 
     63          
     64          
     65          /* Private macro -------------------------------------------------------------*/
     66          /* Private variables ---------------------------------------------------------*/
     67          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Port array
     68          GPIO_TypeDef*  KEYSWITCH_SCANPORT[MAXSCAN]	=   {  
     69                                                          KeySWXX_PORT, 
     70                                                          KeySWXX_PORT, 
     71                                                          KeySWXX_PORT, 
     72                                                      };
     73          
     74          GPIO_TypeDef*  KEYSWITCH_INPUTPORT[MAXINPUT]	=   {  
     75                                                          KeySWXX_PORT, 
     76                                                          KeySWXX_PORT, 
     77                                                          KeySWXX_PORT, 
     78                                                          KeySWXX_PORT, 
     79                                                          KeySWXX_PORT,
     80                                                          KeySWXX_PORT,                                                
     81                                                      };
     82          
     83          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Pin array
     84          const uint16_t KEYSWITCH_SCAN[MAXSCAN]  =   { 
     85                                                          KeySCAN0, 
     86                                                          KeySCAN1, 
     87                                                          KeySCAN2, 
     88                                                      };
     89          
     90          const uint16_t KEYSWITCH_INPUT[MAXINPUT]  =   { 
     91                                                          KeyInput0, 
     92                                                          KeyInput1, 
     93                                                          KeyInput2, 
     94                                                          KeyInput3,
     95                                                          KeyInput4,
     96                                                          KeyInput5,
     97                                                      };
     98          
     99          //  KeySwitch.h -> Press Input KeySwitch Value array
    100          const uint8_t KEYSWITCH_VALUE[MAXSWITCH]   =   {
    101                                                          KEYSWITCH_MENU,    
    102                                                          KEYSWITCH_LEFT,    
    103                                                          KEYSWITCH_ESC,    
    104                                                          KEYSWITCH_RIGHT,    
    105                                                          KEYSWITCH_ENTER,    
    106                                                      };                                                
    107          uint8_t     KeySwitchScan;
    108          uint32_t    Temp_Value1, Temp_Value2, Temp_Value3,Temp_Value4, Temp_Cnt;
    109          uint32_t	New_Value;
    110          uint32_t	KeySwitchSendCount = 0;
    111          
    112          uint8_t		Test1 = 0, Test2 = 0;	
    113          uint16_t		test_buf[10];
    114          uint16_t		test_rx_buf[10];
    115          
    116          unsigned char rear_wiper_oper=0;
    117          
    118          // ++, 150204 sys3215
    119          u8 Input_Key_Value,Key_Status;
    120          // --, 150204 sys3215
    121          
    122          // ++, 150521 sys
    123          u32 Rear_wiper_Key_Status;
    124          // --, 150521 sys
    125          
    126          extern Realy_Control		rx_Realy_Control;
    127          /* Private function prototypes -----------------------------------------------*/
    128          /* Private functions ---------------------------------------------------------*/
    129          
    130          void KeySwitch_SendToEXYNOS(uint32_t KeyValue, uint8_t LongKey)
    131          {
    132          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    133          	uint8_t KeyValue_temp;
    134          
    135          	
    136          	memset(KeyValueBuffer, 0, Serial_COM4_TxSize * sizeof(uint8_t));
    137          
    138          	
    139          	KeyValueBuffer[0] = 0x02;				//	STX
    140          	KeyValueBuffer[1] = KeyRES;				//	KeyValue Command, 
    141          	KeyValueBuffer[2] = KeyValue & 0x000000FF;
    142          	KeyValueBuffer[3] = ((KeyValue & 0x0000FF00) >> 8);
    143          	KeyValueBuffer[4] = ((KeyValue & 0x00FF0000) >> 16);
    144          	KeyValueBuffer[5] = LongKey ;			//	Key Value Short/Long Key, 
    145          	
    146          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    147          	
    148             	// ++, 150204 sys3215
    149          
    150          	Make_Key_Status(KeyValue);
    151          	
    152          	// --, 150204 sys3215
    153          ////////////////////////// DPRAM TEST /////////////////////
    154          #if 0
    155          	else if( KeyValue_temp == KEYSWITCH_MENU) 
    156          	{
    157          		if(Test2==0)
    158          		{
    159          			for(Test1=0;Test1<10;Test1++)
    160          			{
    161          				test_buf[Test1]=Test1+0x30;
    162          				test_rx_buf[Test1]=0;
    163          			}
    164          		}
    165          		else if(Test2==1)
    166          		{
    167          			for(Test1=0;Test1<10;Test1++)
    168          			{
    169          				test_buf[Test1]=Test1+0x40;
    170          				test_rx_buf[Test1]=0;
    171          			}
    172          		}
    173          		else if(Test2==2)
    174          		{
    175          			for(Test1=0;Test1<10;Test1++)
    176          			{
    177          				test_buf[Test1]=Test1+0x50;
    178          				test_rx_buf[Test1]=0;
    179          			}
    180          		}
    181          		if(Test2++>2)	Test2=0;
    182          		DPRAM_WriteBuffer(&test_buf[0],0x00,10);
    183          
    184          		//memcpy(&test_buf[0], Bank1_SRAM1_ADDR,10);
    185          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0) = 0x0505;
    186                          
    187                          //test_rx_buf[0]=*(uint16_t *) (Bank1_SRAM1_ADDR + 0);
    188                          
    189                          
    190          		
    191          
    192          	}
    193          	else if( KeyValue_temp == KEYSWITCH_LEFT) 
    194          	{
    195          		DPRAM_ReadBuffer(&test_rx_buf[0],0x00,10);
    196          		for(Test1=0;Test1<10;Test1++)
    197          		{
    198          			test_buf[Test1]=0;
    199          		}
    200          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0x02) = 0x0404;
    201                          //test_rx_buf[1]=*(uint16_t *) (Bank1_SRAM1_ADDR + 2);
    202          
    203          	}
    204          #endif
    205          	if(Change_UART4_for_Download==0)
    206          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    207          
    208              DebugMsg_printf("KEYSWITCH %x\r\n", KeyValueBuffer[2]);
    209          }
    210          
    211          // ++, 150204 sys3215
    212          
    213          void Make_Key_Status(uint32_t KeyValue)
    214          {
    215          	uint32_t temp_Key_Value;
    216          	u8 i,temp_Key_Status;
    217          
    218          	Input_Key_Value=1;
    219          
    220          	temp_Key_Status=0;
    221          	
    222          	temp_Key_Value = KeyValue & 0x0000001f;
    223          
    224          	for(i=0;i<5;i++)
    225          	{
    226          		if(  ((temp_Key_Value>>i)&0x01))
    227          		{
    228          			if(i==0)	temp_Key_Status |= 0x01;
    229          			else if(i==1)	temp_Key_Status |= 0x10;
    230          			else if(i==2)	temp_Key_Status |= 0x02;
    231          			else if(i==3)	temp_Key_Status |= 0x04;
    232          			else if(i==4)	temp_Key_Status |= 0x08;	
    233          		}
    234          	}
    235          
    236          	Key_Status = temp_Key_Status;
    237          	
    238          }
    239          // --,150204 sys3215
    240          
    241          
    242          void SMK_SendToExynos(uint8_t SMK_Auth, uint8_t SMK_Msg, uint8_t SMK_Count)
    243          {
    244          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    245          
    246          	KeyValueBuffer[0] = 0x02;				//	STX
    247          	KeyValueBuffer[1] = SMKRES;				
    248          	KeyValueBuffer[2] = SMK_Auth;	
    249          	KeyValueBuffer[3] = SMK_Msg;	
    250          	KeyValueBuffer[4] = SMK_Count;	
    251          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    252          
    253          	if(Change_UART4_for_Download==0)
    254          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    255          }
    256          
    257          void KeyTest_TEST(uint8_t value)
    258          {
    259          #if 1
    260          	switch (value)
    261          	{
    262          
    263          		case 0x01:
    264          			CameraMode(0,1);
    265          			break;
    266          		case 0x02:
    267          			CameraMode(1,1);
    268          			break;
    269          		case 0x04:
    270          			CameraMode(2,1);
    271          			break;
    272          		case 0x08:
    273          			CameraMode(3,1);
    274          			break;
    275          		case 0x10:
    276          			CameraMode(4,1);
    277          			break;
    278          		case 0x20:
    279          			CameraMode(5,1);
    280          			break;	
    281          	}
    282          #endif
    283          }
    284          
    285          #if 0
    286          void KeySwitch_Process(void)
    287          {
    288          	uint8_t i, j, k;
    289          	uint32_t New_Value,temp_Value;
    290          
    291          	temp_Value = 0;
    292          
    293          	GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    294          	GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    295          	GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);	
    296          
    297          	for (i = 0; i < MAXSWITCH; i++)
    298          	{
    299          		k = 0;	  
    300          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    301          
    302          		if (k == 0) j = 1;	  
    303          		else		j = 0;
    304          
    305          		temp_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    306          		temp_Value  += j;	//	0 or 1
    307          	}
    308          
    309          	if( temp_Value !=0)
    310          	{
    311          		if (KeySwitchScan == 0) 
    312          		{
    313          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    314          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    315          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);	
    316          
    317          			for (i = 0; i < MAXSWITCH; i++)
    318          			{
    319          				k = 0;	  
    320          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    321          		
    322          				if (k == 0) j = 1;	  
    323          				else		j = 0;
    324          		
    325          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    326          				New_Value  += j;	//	0 or 1
    327          			}
    328          		}
    329          		else if (KeySwitchScan == 1) 
    330          		{
    331          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    332          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    333          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);		
    334          			for (i = 0; i < MAXSWITCH; i++)
    335          			{
    336          				k = 0;	  
    337          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    338          		
    339          				if (k == 0) j = 1;	  
    340          				else		j = 0;
    341          		
    342          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    343          				New_Value  += j;	//	0 or 1
    344          			}
    345          		}	
    346          		else if (KeySwitchScan == 2) 
    347          		{
    348          
    349          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    350          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    351          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);
    352          			for (i = 0; i < MAXSWITCH; i++)
    353          			{
    354          				k = 0;	  
    355          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    356          		
    357          				if (k == 0) j = 1;	  
    358          				else		j = 0;
    359          		
    360          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    361          				New_Value  += j;	//	0 or 1
    362          			}
    363          		}	
    364          		
    365          		//	KeySwitch Press Check
    366          		
    367          
    368          		if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    369          		{
    370          			Temp_Value1 = New_Value+(KeySwitchScan<<6);
    371          		}
    372          	
    373          		//if (KeySwitchScan == 2)    //  15msec
    374          		{
    375          			if (Temp_Value1 == 0) 
    376          			{
    377          				Temp_Value3 = Temp_Cnt = 0;
    378          			}
    379          			else
    380          	        	{
    381          		            if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    382          		            {
    383          	                		Temp_Cnt++;                 //  계속 눌려 있는가?
    384          	                
    385          					if (Temp_Cnt ==2)          //  3번 연속 체크 되었을 때, 45msec
    386          					{
    387          						KeySwitch_Value = Temp_Value1;   
    388          
    389          						//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    390          						#ifdef STM32_BUZZER
    391          						Buzzer_Set(10);
    392          						#endif
    393          
    394          						KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    395          					}
    396          					if (Temp_Cnt == 120)         //  10번 연속 체크 되었을 때
    397          					{
    398          						//  연속 스위치 루틴..                              
    399          						KeySwitch_Value = Temp_Value1;   
    400          						Temp_Cnt -= 5;
    401          						
    402          						if(KeySwitch_Value<0x20)
    403          						{
    404          							#ifdef STM32_BUZZER
    405          								Buzzer_Set(10);
    406          							#endif
    407          							KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    408          						}
    409          					}
    410          				}
    411          				else    //  순간적으로 눌렸는가?
    412          				{
    413          					Temp_Cnt    = 0;
    414          					Temp_Value3 = Temp_Value1;
    415          				}
    416          			}
    417          		}        
    418          
    419          		if (++KeySwitchScan > 2) KeySwitchScan = 0;
    420          	}
    421          	else
    422          	{
    423          		Temp_Value1 = Temp_Value3 = Temp_Cnt =KeySwitchScan= 0;
    424          	}
    425          	//  KeySwitch Value 생성
    426          	        
    427          }
    428          #endif 
    429          
    430          #if 1
    431          
    432          
    433          void KeySwitch_Process(void)
    434          {
    435          	uint8_t i, j, k;
    436          	uint32_t New_Value;
    437          	
    438          	if (KeySwitchScan == 0) 
    439          	{
    440          		Temp_Value1 = 0;
    441          
    442          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET); //R
    443          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    444          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    445          	}
    446          	else if (KeySwitchScan == 1) 
    447          	{
    448          
    449          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    450          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET); //R
    451          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    452          	}	
    453          	else if (KeySwitchScan == 2) 
    454          	{
    455          
    456          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    457          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    458          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);//R				
    459          	}	
    460          	
    461          	New_Value = 0;
    462          	
    463          	//  KeySwitch Press Check
    464          	//Delay(100);
    465          	
    466          	for (i = 0; i < MAXSWITCH; i++)
    467          	{
    468          		k = 0;    
    469          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    470          
    471          		if (k == 0) j = 1;    
    472          		else        j = 0;
    473          
    474          		New_Value <<= 1;    //  1Bit씩 Shitf하여 총 5Bit를 만든다.
    475          		New_Value  += j;    //  0 or 1
    476          	}
    477          
    478          	
    479              if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    480              //if (New_Value != 0)
    481              {
    482                  //Temp_Value1 = New_Value+(KeySwitchScan<<6);
    483                  Temp_Value1 = New_Value << (KeySwitchScan * 8);
    484              }
    485                  
    486              if(KeySwitchSendCount < KEYSwitchSendCountMax)
    487              {
    488          		KeySwitchSendCount++;
    489          	}
    490          	if (KeySwitchScan == 2)    //  15msec
    491          	{
    492                        //  KeySwitch Value 생성
    493          		if (Temp_Value1 == 0) 
    494          		{
    495          			if(KeySwitch_Value != 0)
    496          			{
    497          				//++, 150521 sys
    498          				#if 0
    499          				KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    500          				KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    501          				#endif
    502          				KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;
    503          				if(Rear_wiper_Key_Status ==0x00020000)
    504          				{
    505          					KeySwitch_SendToEXYNOS(Rear_wiper_Key_Status,0);
    506          					Rear_wiper_Key_Status=0;
    507          				}
    508          				else
    509          					KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    510          				// --,150521 sys
    511          			}
    512          			KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    513          
    514          			// ++, 150204 sys3215
    515          			Input_Key_Value=0;
    516          			// --, 150204 sys3215
    517          		}
    518          		else
    519                  {
    520                      if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    521                      {
    522                      	Temp_Cnt++;                 //  계속 눌려 있는가?
    523                      
    524          				if (Temp_Cnt ==3)          //  3번 연속 체크 되었을 때, 45msec
    525          				{
    526          					KeySwitch_Value = Temp_Value1;   
    527          
    528          					//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    529          					#ifdef STM32_BUZZER
    530          					Buzzer_Set(10);
    531          					#endif
    532          
    533          					if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    534          					{
    535          						// ++, 150521 sys
    536          						#if 0
    537          						KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    538          						KeySwitchSendCount = 0;
    539          						#endif
    540          						if(KeySwitch_Value !=0x00020000)
    541          						{
    542          							KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    543          						}
    544          						else
    545          						{
    546          							Rear_wiper_Key_Status = KeySwitch_Value;
    547          						}
    548          						KeySwitchSendCount = 0;
    549          						// --, 150521 sys
    550          					}
    551          					
    552          				}
    553          
    554          				if(Temp_Value3 == 0x00020000)
    555          				{
    556          					
    557          					if (Temp_Cnt == 100)         //  10번 연속 체크 되었을 때
    558          					{
    559          						//  연속 스위치 루틴..                              
    560          						KeySwitch_Value = Temp_Value1;   
    561          						Temp_Cnt -= 50;
    562          						
    563          						//if(KeySwitch_Value<0x20)
    564          						{
    565          							#ifdef STM32_BUZZER
    566          							Buzzer_Set(10);
    567          							#endif
    568          							if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    569          							{
    570          								KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    571          								KeySwitchSendCount = 0;
    572          								//++, 150521 sys
    573          								Rear_wiper_Key_Status=0;
    574          								//--, 150521 sys
    575          							}
    576          						}
    577          					}
    578          				}
    579          				else
    580          				{
    581          					if (Temp_Cnt == 300)         //  10번 연속 체크 되었을 때
    582          					{
    583          						//  연속 스위치 루틴..                              
    584          						KeySwitch_Value = Temp_Value1;   
    585          						Temp_Cnt -= 50;
    586          						
    587          						//if(KeySwitch_Value<0x20)
    588          						{
    589          							#ifdef STM32_BUZZER
    590          								Buzzer_Set(10);
    591          							#endif
    592          							if(KeySwitchSendCount >= KEYSwitchSendCountMax)
    593          							{
    594          								KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    595          								KeySwitchSendCount = 0;
    596          							}
    597          						}
    598          					}
    599          				}
    600          				
    601          			}
    602          			else    //  순간적으로 눌렸는가?
    603          			{
    604          				Temp_Cnt    = 0;
    605          				Temp_Value3 = Temp_Value1;
    606          			}
    607          		}
    608          	}        
    609          
    610          	if (++KeySwitchScan > 2) KeySwitchScan = 0;        
    611          }
    612          #endif
    613          
    614          
    615          void KeySwitch_Init(void)
    616          {
    617              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    618              NVIC_InitTypeDef        NVIC_InitStructure;
    619          
    620              DebugMsg_printf("++ KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize START\r\n");
    621          
    622              //  KeySwitch GPIO는 System_Init.c 에서 설정
    623              #if 0
    624          
    625              GPIO_InitTypeDef    GPIO_InitStructure;
    626              
    627          	//	KeySwitch Matrix -> GPIO Output
    628          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    629              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    630            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    631            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    632              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    633              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    634          
    635          	//	KeySwitch Matrix -> GPIO Input
    636          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    637              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    638            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    639            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    640              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    641              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    642          	
    643              #endif
    644          
    645              TIM_TimeBaseStructure.TIM_Period        = 0x9c4;   	//  (1 / 1MHz) * 5000 -> 5msec
    646          
    647          	//TIM_TimeBaseStructure.TIM_Period        = 0x4e2;   	//  (1 / 0.5MHz) * 2500 -> 5msec
    648          
    649          	//TIM_TimeBaseStructure.TIM_Period        = 0x271; 
    650          
    651          	TIM_TimeBaseStructure.TIM_Prescaler     = 0xA8;     //  84 MHz / 168 = 1MHz
    652          	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    653          	TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
    654          	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
    655          
    656          	//  TIM5 Enable counter
    657          	TIM_Cmd(TIM5, ENABLE);
    658          
    659          	//  Enable TIM5 Update Interrupt
    660          	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
    661          
    662          	//  Enable the TIM5 Interrupt, KeySwitch
    663          	NVIC_InitStructure.NVIC_IRQChannel                   = TIM5_IRQn;
    664          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    665          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    666          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    667          	NVIC_Init(&NVIC_InitStructure);
    668          
    669          	DebugMsg_printf("-- KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize END\r\n");
    670          
    671          	KeySwitch_Value = 0;	
    672          }
    673          
    674          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   KeySwitch_Init
        24   -> NVIC_Init
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   KeySwitch_Process
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
        24   -> KeySwitch_SendToEXYNOS
      24   KeySwitch_SendToEXYNOS
        24   -> Make_Key_Status
        24   -> USARTx_EXYNOS
        24   -> __aeabi_memclr4
       0   KeyTest_TEST
         0   -> CameraMode
       0   Make_Key_Status
      16   SMK_SendToExynos
        16   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
      12  KEYSWITCH_INPUT
       8  KEYSWITCH_SCAN
       8  KEYSWITCH_VALUE
      60  KeySwitchScan
          Input_Key_Value
          Key_Status
          KEYSWITCH_SCANPORT
          KEYSWITCH_INPUTPORT
          Temp_Value1
          Temp_Value3
          Temp_Cnt
          KeySwitchSendCount
          Rear_wiper_Key_Status
      92  KeySwitch_Init
     380  KeySwitch_Process
      74  KeySwitch_SendToEXYNOS
      74  KeyTest_TEST
      82  Make_Key_Status
       4  New_Value
      48  SMK_SendToExynos
       4  Temp_Value2
       4  Temp_Value4
       1  Test1
       1  Test2
       1  rear_wiper_oper
      20  test_buf
      20  test_rx_buf

 
  55 bytes in section .bss
  60 bytes in section .data
  16 bytes in section .rodata
 778 bytes in section .text
 
 778 bytes of CODE  memory
  16 bytes of CONST memory
 115 bytes of DATA  memory

Errors: none
Warnings: 1
