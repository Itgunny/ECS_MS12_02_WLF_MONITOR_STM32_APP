###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      08/Oct/2014  16:38:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa -         #
#                    ECS\SRC\KeySwitch.c                                      #
#    Command line =  "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa -         #
#                    ECS\SRC\KeySwitch.c" -D USE_STDPERIPH_DRIVER -D          #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\List\" -o  #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\Obj\"      #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\arm\INC\c\DLib_Config_Full.h" -I                 #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Platform\COMM #
#                    ON\INC\" -I "C:\Users\1\Desktop\141007 울산\CAN          #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Platform\TaeH #
#                    a - ECS\INC\" -I "C:\Users\1\Desktop\141007 울산\CAN     #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\" -I                      #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Libraries\STM #
#                    32F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I    #
#                    "C:\Tools\IAR Systems\arm\CMSIS\Include\"                #
#    List file    =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\List\KeySw #
#                    itch.lst                                                 #
#    Object file  =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\Obj\KeySwi #
#                    tch.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\1\Desktop\141007 울산\CAN Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa - ECS\SRC\KeySwitch.c
      1          /**
      2            ******************************************************************************
      3            * @file    KeySwitch.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   KeySwitch.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          //#define STM32_BUZZER
     26          /* Private define ------------------------------------------------------------*/
     27          #define	Key_Menu			0x01
     28          #define	Key_Left			0x02
     29          #define	Key_Enter			0x04
     30          #define	Key_Right			0x08
     31          #define	Key_ESC				0x10
     32          #define	Key_Info			0x20
     33          
     34          #define	Key_CAM			    0x41
     35          #define	Key_Work_Load		0x42
     36          #define	Key_EH_MODE		    0x44
     37          #define	Key_Ride_Control	0x48
     38          #define	Key_Quick_Coupler	0x50
     39          #define	Key_Auto_Grease	    0x60
     40          
     41          #define	Key_Beacon			0x81
     42          #define	Key_Mirror_Heat		0x82
     43          #define	Key_Rear_Wiper		0x84
     44          #define	Key_USER			0x88
     45          #define	Key_Reserved1		0x90
     46          #define	Key_Reserved2		0xa0
     47          
     48          
     49          #define Bank1_SRAM1_ADDR  ((uint32_t)0x60000000) 
     50          
     51          
     52          /* Private macro -------------------------------------------------------------*/
     53          /* Private variables ---------------------------------------------------------*/
     54          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Port array
     55          GPIO_TypeDef*  KEYSWITCH_SCANPORT[MAXSCAN]	=   {  
     56                                                          KeySWXX_PORT, 
     57                                                          KeySWXX_PORT, 
     58                                                          KeySWXX_PORT, 
     59                                                      };
     60          
     61          GPIO_TypeDef*  KEYSWITCH_INPUTPORT[MAXINPUT]	=   {  
     62                                                          KeySWXX_PORT, 
     63                                                          KeySWXX_PORT, 
     64                                                          KeySWXX_PORT, 
     65                                                          KeySWXX_PORT, 
     66                                                          KeySWXX_PORT,
     67                                                          KeySWXX_PORT,                                                
     68                                                      };
     69          
     70          //  KeySwitch.h -> KeySwitch Scan, Input GPIO Pin array
     71          const uint16_t KEYSWITCH_SCAN[MAXSCAN]  =   { 
     72                                                          KeySCAN0, 
     73                                                          KeySCAN1, 
     74                                                          KeySCAN2, 
     75                                                      };
     76          
     77          const uint16_t KEYSWITCH_INPUT[MAXINPUT]  =   { 
     78                                                          KeyInput0, 
     79                                                          KeyInput1, 
     80                                                          KeyInput2, 
     81                                                          KeyInput3,
     82                                                          KeyInput4,
     83                                                          KeyInput5,
     84                                                      };
     85          
     86          //  KeySwitch.h -> Press Input KeySwitch Value array
     87          const uint8_t KEYSWITCH_VALUE[MAXSWITCH]   =   {
     88                                                          KEYSWITCH_MENU,    
     89                                                          KEYSWITCH_LEFT,    
     90                                                          KEYSWITCH_ESC,    
     91                                                          KEYSWITCH_RIGHT,    
     92                                                          KEYSWITCH_ENTER,    
     93                                                      };                                                
     94          uint8_t     KeySwitchScan;
     95          uint32_t    Temp_Value1, Temp_Value2, Temp_Value3,Temp_Value4, Temp_Cnt;
     96          uint32_t	New_Value;
     97          
     98          uint8_t		Test1 = 0, Test2 = 0;	
     99          uint16_t		test_buf[10];
    100          uint16_t		test_rx_buf[10];
    101          
    102          unsigned char rear_wiper_oper=0;
    103          
    104          extern Realy_Control		rx_Realy_Control;
    105          /* Private function prototypes -----------------------------------------------*/
    106          /* Private functions ---------------------------------------------------------*/
    107          
    108          void KeySwitch_SendToEXYNOS(uint32_t KeyValue, uint8_t LongKey)
    109          {
    110          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    111          	uint8_t KeyValue_temp;
    112          
    113          	
    114          	memset(KeyValueBuffer, 0, Serial_COM4_TxSize * sizeof(uint8_t));
    115          
    116          	
    117          	KeyValueBuffer[0] = 0x02;				//	STX
    118          	KeyValueBuffer[1] = KeyRES;				//	KeyValue Command, 
    119          	KeyValueBuffer[2] = KeyValue & 0x000000FF;
    120          	KeyValueBuffer[3] = ((KeyValue & 0x0000FF00) >> 8);
    121          	KeyValueBuffer[4] = ((KeyValue & 0x00FF0000) >> 16);
    122          	KeyValueBuffer[5] = LongKey ;			//	Key Value Short/Long Key, 
    123          	
    124          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    125          	
    126             
    127          ////////////////////////// DPRAM TEST /////////////////////
    128          #if 0
    129          	else if( KeyValue_temp == KEYSWITCH_MENU) 
    130          	{
    131          		if(Test2==0)
    132          		{
    133          			for(Test1=0;Test1<10;Test1++)
    134          			{
    135          				test_buf[Test1]=Test1+0x30;
    136          				test_rx_buf[Test1]=0;
    137          			}
    138          		}
    139          		else if(Test2==1)
    140          		{
    141          			for(Test1=0;Test1<10;Test1++)
    142          			{
    143          				test_buf[Test1]=Test1+0x40;
    144          				test_rx_buf[Test1]=0;
    145          			}
    146          		}
    147          		else if(Test2==2)
    148          		{
    149          			for(Test1=0;Test1<10;Test1++)
    150          			{
    151          				test_buf[Test1]=Test1+0x50;
    152          				test_rx_buf[Test1]=0;
    153          			}
    154          		}
    155          		if(Test2++>2)	Test2=0;
    156          		DPRAM_WriteBuffer(&test_buf[0],0x00,10);
    157          
    158          		//memcpy(&test_buf[0], Bank1_SRAM1_ADDR,10);
    159          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0) = 0x0505;
    160                          
    161                          //test_rx_buf[0]=*(uint16_t *) (Bank1_SRAM1_ADDR + 0);
    162                          
    163                          
    164          		
    165          
    166          	}
    167          	else if( KeyValue_temp == KEYSWITCH_LEFT) 
    168          	{
    169          		DPRAM_ReadBuffer(&test_rx_buf[0],0x00,10);
    170          		for(Test1=0;Test1<10;Test1++)
    171          		{
    172          			test_buf[Test1]=0;
    173          		}
    174          		//*(uint16_t *) (Bank1_SRAM1_ADDR + 0x02) = 0x0404;
    175                          //test_rx_buf[1]=*(uint16_t *) (Bank1_SRAM1_ADDR + 2);
    176          
    177          	}
    178          #endif
    179          	if(Change_UART4_for_Download==0)
    180          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    181          
    182              DebugMsg_printf("KEYSWITCH %x\r\n", KeyValueBuffer[2]);
    183          }
    184          
    185          void SMK_SendToExynos(uint8_t SMK_Auth, uint8_t SMK_Msg, uint8_t SMK_Count)
    186          {
    187          	uint8_t KeyValueBuffer[Serial_COM4_TxSize];
    188          
    189          	KeyValueBuffer[0] = 0x02;				//	STX
    190          	KeyValueBuffer[1] = SMKRES;				
    191          	KeyValueBuffer[2] = SMK_Auth;	
    192          	KeyValueBuffer[3] = SMK_Msg;	
    193          	KeyValueBuffer[4] = SMK_Count;	
    194          	KeyValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    195          
    196          	if(Change_UART4_for_Download==0)
    197          		USARTx_EXYNOS(COM4, (char *)KeyValueBuffer);	
    198          }
    199          
    200          void KeyTest_TEST(uint8_t value)
    201          {
    202          #if 1
    203          	switch (value)
    204          	{
    205          
    206          		case 0x01:
    207          			CameraMode(0,1);
    208          			break;
    209          		case 0x02:
    210          			CameraMode(1,1);
    211          			break;
    212          		case 0x04:
    213          			CameraMode(2,1);
    214          			break;
    215          		case 0x08:
    216          			CameraMode(3,1);
    217          			break;
    218          		case 0x10:
    219          			CameraMode(4,1);
    220          			break;
    221          		case 0x20:
    222          			CameraMode(5,1);
    223          			break;	
    224          	}
    225          #endif
    226          }
    227          
    228          #if 0
    229          void KeySwitch_Process(void)
    230          {
    231          	uint8_t i, j, k;
    232          	uint32_t New_Value,temp_Value;
    233          
    234          	temp_Value = 0;
    235          
    236          	GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    237          	GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    238          	GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);	
    239          
    240          	for (i = 0; i < MAXSWITCH; i++)
    241          	{
    242          		k = 0;	  
    243          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    244          
    245          		if (k == 0) j = 1;	  
    246          		else		j = 0;
    247          
    248          		temp_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    249          		temp_Value  += j;	//	0 or 1
    250          	}
    251          
    252          	if( temp_Value !=0)
    253          	{
    254          		if (KeySwitchScan == 0) 
    255          		{
    256          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET);
    257          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    258          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);	
    259          
    260          			for (i = 0; i < MAXSWITCH; i++)
    261          			{
    262          				k = 0;	  
    263          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    264          		
    265          				if (k == 0) j = 1;	  
    266          				else		j = 0;
    267          		
    268          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    269          				New_Value  += j;	//	0 or 1
    270          			}
    271          		}
    272          		else if (KeySwitchScan == 1) 
    273          		{
    274          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    275          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET);
    276          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);		
    277          			for (i = 0; i < MAXSWITCH; i++)
    278          			{
    279          				k = 0;	  
    280          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    281          		
    282          				if (k == 0) j = 1;	  
    283          				else		j = 0;
    284          		
    285          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    286          				New_Value  += j;	//	0 or 1
    287          			}
    288          		}	
    289          		else if (KeySwitchScan == 2) 
    290          		{
    291          
    292          			GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    293          			GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    294          			GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);
    295          			for (i = 0; i < MAXSWITCH; i++)
    296          			{
    297          				k = 0;	  
    298          				k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    299          		
    300          				if (k == 0) j = 1;	  
    301          				else		j = 0;
    302          		
    303          				New_Value <<= 1;	//	1Bit씩 Shitf하여 총 5Bit를 만든다.
    304          				New_Value  += j;	//	0 or 1
    305          			}
    306          		}	
    307          		
    308          		//	KeySwitch Press Check
    309          		
    310          
    311          		if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    312          		{
    313          			Temp_Value1 = New_Value+(KeySwitchScan<<6);
    314          		}
    315          	
    316          		//if (KeySwitchScan == 2)    //  15msec
    317          		{
    318          			if (Temp_Value1 == 0) 
    319          			{
    320          				Temp_Value3 = Temp_Cnt = 0;
    321          			}
    322          			else
    323          	        	{
    324          		            if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    325          		            {
    326          	                		Temp_Cnt++;                 //  계속 눌려 있는가?
    327          	                
    328          					if (Temp_Cnt ==2)          //  3번 연속 체크 되었을 때, 45msec
    329          					{
    330          						KeySwitch_Value = Temp_Value1;   
    331          
    332          						//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    333          						#ifdef STM32_BUZZER
    334          						Buzzer_Set(10);
    335          						#endif
    336          
    337          						KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    338          					}
    339          					if (Temp_Cnt == 120)         //  10번 연속 체크 되었을 때
    340          					{
    341          						//  연속 스위치 루틴..                              
    342          						KeySwitch_Value = Temp_Value1;   
    343          						Temp_Cnt -= 5;
    344          						
    345          						if(KeySwitch_Value<0x20)
    346          						{
    347          							#ifdef STM32_BUZZER
    348          								Buzzer_Set(10);
    349          							#endif
    350          							KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    351          						}
    352          					}
    353          				}
    354          				else    //  순간적으로 눌렸는가?
    355          				{
    356          					Temp_Cnt    = 0;
    357          					Temp_Value3 = Temp_Value1;
    358          				}
    359          			}
    360          		}        
    361          
    362          		if (++KeySwitchScan > 2) KeySwitchScan = 0;
    363          	}
    364          	else
    365          	{
    366          		Temp_Value1 = Temp_Value3 = Temp_Cnt =KeySwitchScan= 0;
    367          	}
    368          	//  KeySwitch Value 생성
    369          	        
    370          }
    371          #endif 
    372          
    373          #if 1
    374          
    375          
    376          void KeySwitch_Process(void)
    377          {
    378          	uint8_t i, j, k;
    379          	uint32_t New_Value;
    380          	
    381          	if (KeySwitchScan == 0) 
    382          	{
    383          		Temp_Value1 = 0;
    384          
    385          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_RESET); //R
    386          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    387          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    388          	}
    389          	else if (KeySwitchScan == 1) 
    390          	{
    391          
    392          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    393          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_RESET); //R
    394          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_SET);					
    395          	}	
    396          	else if (KeySwitchScan == 2) 
    397          	{
    398          
    399          		GPIO_WriteBit(KEYSWITCH_SCANPORT[0], KEYSWITCH_SCAN[0], Bit_SET);
    400          		GPIO_WriteBit(KEYSWITCH_SCANPORT[1], KEYSWITCH_SCAN[1], Bit_SET);
    401          		GPIO_WriteBit(KEYSWITCH_SCANPORT[2], KEYSWITCH_SCAN[2], Bit_RESET);//R				
    402          	}	
    403          	
    404          	New_Value = 0;
    405          	
    406          	//  KeySwitch Press Check
    407          	//Delay(100);
    408          	
    409          	for (i = 0; i < MAXSWITCH; i++)
    410          	{
    411          		k = 0;    
    412          		k = GPIO_ReadInputDataBit(KEYSWITCH_INPUTPORT[i], KEYSWITCH_INPUT[i]); //  Read KeySwitch Input 
    413          
    414          		if (k == 0) j = 1;    
    415          		else        j = 0;
    416          
    417          		New_Value <<= 1;    //  1Bit씩 Shitf하여 총 5Bit를 만든다.
    418          		New_Value  += j;    //  0 or 1
    419          	}
    420          
    421          	
    422              if ( (Temp_Value1 == 0) && (New_Value != 0) ) 
    423              //if (New_Value != 0)
    424              {
    425                  //Temp_Value1 = New_Value+(KeySwitchScan<<6);
    426                  Temp_Value1 = New_Value << (KeySwitchScan * 8);
    427              }
    428                  
    429                  
    430          	if (KeySwitchScan == 2)    //  15msec
    431          	{
    432                        //  KeySwitch Value 생성
    433          		if (Temp_Value1 == 0) 
    434          		{
    435          			if(KeySwitch_Value != 0)
    436          			{
    437          				KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;	
    438          				KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    439          			}
    440          			KeySwitch_Value = Temp_Value3 = Temp_Cnt = 0;		
    441          		}
    442          		else
    443                  {
    444                      if (Temp_Value3 == Temp_Value1) //  눌려있던 키?
    445                      {
    446                      	Temp_Cnt++;                 //  계속 눌려 있는가?
    447                      
    448          				if (Temp_Cnt ==3)          //  3번 연속 체크 되었을 때, 45msec
    449          				{
    450          					KeySwitch_Value = Temp_Value1;   
    451          
    452          					//  STM32 BUZZER를 사용할 경우.. 버튼 클릭 
    453          					#ifdef STM32_BUZZER
    454          					Buzzer_Set(10);
    455          					#endif
    456          
    457          					KeySwitch_SendToEXYNOS(KeySwitch_Value,0);
    458          				}
    459          				
    460          				if (Temp_Cnt == 300)         //  10번 연속 체크 되었을 때
    461          				{
    462          					//  연속 스위치 루틴..                              
    463          					KeySwitch_Value = Temp_Value1;   
    464          					Temp_Cnt -= 50;
    465          					
    466          					//if(KeySwitch_Value<0x20)
    467          					{
    468          						#ifdef STM32_BUZZER
    469          							Buzzer_Set(10);
    470          						#endif
    471          						KeySwitch_SendToEXYNOS(KeySwitch_Value,1);
    472          					}
    473          				}
    474          			}
    475          			else    //  순간적으로 눌렸는가?
    476          			{
    477          				Temp_Cnt    = 0;
    478          				Temp_Value3 = Temp_Value1;
    479          			}
    480          		}
    481          	}        
    482          
    483          	if (++KeySwitchScan > 2) KeySwitchScan = 0;        
    484          }
    485          #endif
    486          
    487          
    488          void KeySwitch_Init(void)
    489          {
    490              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    491              NVIC_InitTypeDef        NVIC_InitStructure;
    492          
    493              DebugMsg_printf("++ KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize START\r\n");
    494          
    495              //  KeySwitch GPIO는 System_Init.c 에서 설정
    496              #if 0
    497          
    498              GPIO_InitTypeDef    GPIO_InitStructure;
    499              
    500          	//	KeySwitch Matrix -> GPIO Output
    501          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    502              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    503            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    504            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    505              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    506              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    507          
    508          	//	KeySwitch Matrix -> GPIO Input
    509          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    510              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    511            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    512            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    513              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    514              GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    515          	
    516              #endif
    517          
    518              TIM_TimeBaseStructure.TIM_Period        = 0x9c4;   	//  (1 / 1MHz) * 5000 -> 5msec
    519          
    520          	//TIM_TimeBaseStructure.TIM_Period        = 0x4e2;   	//  (1 / 0.5MHz) * 2500 -> 5msec
    521          
    522          	//TIM_TimeBaseStructure.TIM_Period        = 0x271; 
    523          
    524          	TIM_TimeBaseStructure.TIM_Prescaler     = 0xA8;     //  84 MHz / 168 = 1MHz
    525          	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    526          	TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
    527          	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
    528          
    529          	//  TIM5 Enable counter
    530          	TIM_Cmd(TIM5, ENABLE);
    531          
    532          	//  Enable TIM5 Update Interrupt
    533          	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
    534          
    535          	//  Enable the TIM5 Interrupt, KeySwitch
    536          	NVIC_InitStructure.NVIC_IRQChannel                   = TIM5_IRQn;
    537          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    538          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    539          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    540          	NVIC_Init(&NVIC_InitStructure);
    541          
    542          	DebugMsg_printf("-- KeySwitch (TIM5 : 5msec), TIM5_IRQn Initialize END\r\n");
    543          
    544          	KeySwitch_Value = 0;	
    545          }
    546          
    547          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   KeySwitch_Init
        24   -> NVIC_Init
        24   -> TIM_Cmd
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   KeySwitch_Process
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
        24   -> KeySwitch_SendToEXYNOS
      24   KeySwitch_SendToEXYNOS
        24   -> USARTx_EXYNOS
        24   -> __aeabi_memclr4
       0   KeyTest_TEST
         0   -> CameraMode
      16   SMK_SendToExynos
        16   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      12  KEYSWITCH_INPUT
       8  KEYSWITCH_SCAN
       8  KEYSWITCH_VALUE
      52  KeySwitchScan
          KEYSWITCH_SCANPORT
          KEYSWITCH_INPUTPORT
          Temp_Value1
          Temp_Value3
          Temp_Cnt
      92  KeySwitch_Init
     274  KeySwitch_Process
      68  KeySwitch_SendToEXYNOS
      74  KeyTest_TEST
       4  New_Value
      48  SMK_SendToExynos
       4  Temp_Value2
       4  Temp_Value4
       1  Test1
       1  Test2
       1  rear_wiper_oper
      20  test_buf
      20  test_rx_buf

 
  55 bytes in section .bss
  52 bytes in section .data
  16 bytes in section .rodata
 584 bytes in section .text
 
 584 bytes of CODE  memory
  16 bytes of CONST memory
 107 bytes of DATA  memory

Errors: none
Warnings: 1
