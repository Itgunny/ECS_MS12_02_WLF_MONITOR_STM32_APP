###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      18/Jun/2014  17:46:24 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\UART_Control.c                                   #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\UART_Control.c" -D USE_STDPERIPH_DRIVER -D       #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\UART_C #
#                    ontrol.lst                                               #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\UART_Co #
#                    ntrol.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\UART_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    UART_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   UART_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          USART_TypeDef* Serial_USART[5]     = {  0, 
     29                                                  0, 
     30                                                  Serial_COM2, 
     31                                                  0,
     32                                                  Serial_COM4, 
     33                                                  }; 
     34          
     35          GPIO_TypeDef*  Serial_PORT[5]      = {  0, 
     36                                                  0, 
     37                                                  Serial_COM2_GPIO, 
     38                                                  0,
     39          	                                    Serial_COM4_GPIO, 
     40                                                  };
     41          
     42          const uint32_t Serial_USART_CLK[5] = {  0, 
     43                                                  0, 
     44                                                  Serial_COM2_CLK, 
     45                                                  0,
     46                                                  Serial_COM4_CLK, 
     47                                                  };
     48          
     49          const uint32_t Serial_PORT_CLK[5]  = {  0, 
     50                                                  0, 
     51                                                  Serial_COM2_GPIO_CLK, 
     52                                                  0,
     53                                                  Serial_COM4_GPIO_CLK, 
     54                                                  };
     55          
     56          const uint16_t Serial_TX_PIN[5]    = {  0, 
     57                                                  0, 
     58                                                  Serial_COM2_TxPin, 
     59                                                  0,
     60                                                  Serial_COM4_TxPin,
     61                                                  };
     62          
     63          const uint16_t Serial_RX_PIN[5]    = {  0, 
     64                                                  0, 
     65                                                  Serial_COM2_RxPin,
     66                                                  0,
     67                                                  Serial_COM4_RxPin,
     68                                                  };
     69          
     70          const uint32_t Serial_BaudRate[5]  = {  0,
     71                                                  0, 
     72                                                  115200,	//  USART2
     73                                                  57600,
     74                                                  115200,  //  USART4
     75                                                  };
     76          
     77          const uint16_t Serial_IRQ_Channel[5]= { 0, 
     78                                                  0, 
     79                                                  USART2_IRQn,
     80                                                  0,
     81                                                  UART4_IRQn,
     82                                                  };
     83          
     84          /* Private function prototypes -----------------------------------------------*/
     85          /* Private functions ---------------------------------------------------------*/
     86          /**
     87            * @brief  USART2, UART4 Initialize (COM param을 받아서. Port를 초기화 한다.)
     88            * @param  COM
     89            * @retval None
     90            */
     91          void USART_COMInit(uint8_t COM)
     92          {
     93          	USART_InitTypeDef   	USART_InitStructure;
     94          	NVIC_InitTypeDef    	NVIC_InitStructure;
     95          
     96          	DebugMsg_printf("++ USART %d Initialize START\r\n", COM);
     97          
     98          #if 0
     99          	USART_ClockInitStructure.USART_Clock   = USART_Clock_Disable;
    100          	USART_ClockInitStructure.USART_CPOL    = USART_CPOL_Low;
    101          	USART_ClockInitStructure.USART_CPHA    = USART_CPHA_2Edge;
    102          	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
    103          
    104          	if (COM != 4) USART_ClockInit(Serial_USART[COM], &USART_ClockInitStructure);
    105          #endif
    106          
    107          	/* 
    108          	USARTx configuration
    109          
    110          	- BaudRate = xxxx baudrate
    111          	- Word Length = 8 Bits
    112          	- One Stop Bit
    113          	- No parity
    114          	- Hardware flow control disabled (RTS and CTS signals)
    115          	- Receive and transmit enabled/Disabled
    116          	*/
    117          
    118          	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;
    119          	USART_InitStructure.USART_StopBits            = USART_StopBits_1;
    120          	USART_InitStructure.USART_Parity              = USART_Parity_No;
    121          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    122          	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
    123          	USART_InitStructure.USART_BaudRate            = Serial_BaudRate[COM];
    124          	// USART_InitStructure.USART_BaudRate            = 57600;
    125          	
    126          	//  USART configuration
    127          	USART_Init(Serial_USART[COM], &USART_InitStructure);
    128          
    129          	//  Enable USART
    130          	USART_Cmd(Serial_USART[COM], ENABLE);
    131          
    132          	//  Enable USART2 ~ UART5 Receive interrupt
    133          	USART_ITConfig(Serial_USART[COM], USART_IT_RXNE, ENABLE);    
    134          	USART_ITConfig(Serial_USART[COM], USART_IT_TXE, DISABLE);
    135          
    136          	NVIC_InitStructure.NVIC_IRQChannel                   = Serial_IRQ_Channel[COM];
    137          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    138          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    139          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    140          	NVIC_Init(&NVIC_InitStructure);
    141          
    142          	DebugMsg_printf("-- USART %d Initialize END\r\n", COM);
    143          }
    144          
    145          /**
    146            * @brief  One Byte ASCII Sending
    147            * @param  None
    148            * @retval None
    149            */
    150          void USARTx_PutChar(uint8_t COM, uint8_t data)
    151          {
    152             USART_SendData(Serial_USART[COM], data);
    153             
    154             while (USART_GetFlagStatus(Serial_USART[COM], USART_FLAG_TXE) == RESET)
    155             {
    156             }
    157          }
    158          
    159          /**
    160            * @brief  String Data Sending
    161            * @param  None
    162            * @retval None
    163            */
    164          void USARTx_PutStr(uint8_t COM, char *pStr)
    165          {
    166          	while (*pStr != '\0') 
    167              {
    168                  USARTx_PutChar(COM, *(pStr++));
    169              }        
    170          }
    171          
    172          /**
    173            * @brief  One Byte Hex Sending
    174            * @param  None
    175            * @retval None
    176            */
    177          void USARTx_PutHex(uint8_t COM, uint8_t hex)
    178          {
    179          	USARTx_PutChar(COM, HexToAscii(hex >> 4));
    180          	USARTx_PutChar(COM, HexToAscii(hex & 0x0F));
    181          }
    182          
    183          
    184          /**
    185            * @brief  Hex code to ASCII code
    186            * @param  
    187            * @retval ASCII
    188            */
    189          char HexToAscii(uint8_t hex)
    190          {	
    191          	return hex < 10 ? hex + '0' : hex - 10 + 'A';
    192          }
    193          
    194          /**
    195            * @brief  ASCII Code to Hex Code
    196            * @param  None
    197            * @retval Hex 
    198            */
    199          uint8_t AsciiToHex(char ascii)
    200          {	
    201          	ascii = toupper(ascii);
    202          	
    203              return ascii >= 'A' ? ascii - 'A' + 10 : ascii - '0';
    204          }
    205          
    206          /**
    207            * @brief  Hex Code to Decimal
    208            * @param  None
    209            * @retval Hex 
    210            */
    211          int HexToDec(int def)
    212          {
    213              int ten, one;
    214          
    215              one = def & 0x0f;
    216              ten = 0;
    217              ten = (def & 0x70) >> 4;
    218              def =ten * 10 + one;
    219              
    220              return def;
    221          }
    222          
    223          /**
    224            * @brief  Decimal to Hex
    225            * @param  None
    226            * @retval Hex 
    227            */
    228          /*
    229          char *DecToHex(uint8_t *Hex, uint16_t Dec)
    230          {
    231              char Hex[5];
    232                  
    233              
    234              // 65535 = FFFF
    235              if (Dec > 65535) return "1";
    236              
    237              sprintf(Hex, "%4x", Dec);
    238          
    239              return Hex;
    240          }
    241          */
    242          
    243          
    244          /**
    245            * @brief  usartx printf, polling
    246            * @param  None
    247            * @retval Hex 
    248            */
    249          void USARTx_printf(uint8_t COM, char *fmt,...)
    250          {
    251              va_list ap;
    252              
    253              char string[255];
    254              
    255              va_start(ap, fmt);
    256              vsprintf(string, fmt, ap);
    257              USARTx_PutStr(COM, string);
    258              va_end(ap);
    259          }  
    260          
    261          /**
    262            * @brief  usartx printk, interrupt
    263            * @param  None
    264            * @retval None 
    265            */
    266          void USARTx_printk(uint8_t COM, char *fmt,...)
    267          {
    268              va_list ap;
    269              
    270              char string[255];
    271              
    272              va_start(ap, fmt);
    273              vsprintf(string, fmt, ap);
    274              va_end(ap);
    275              
    276              switch (COM)
    277              {
    278                  case COMPORT2 : 
    279                              strcpy((char *)WL9FM_USART_DATA.COM2_TxBuf, string);
    280                              
    281          			        WL9FM_USART_INDEX.COM2_TxCnt = 0;
    282          			        WL9FM_USART_INDEX.COM2_TxIdx = strlen((char *)WL9FM_USART_DATA.COM2_TxBuf);
    283                                      
    284                              break;
    285          
    286                  case COMPORT4 :
    287                              strcpy((char *)WL9FM_USART_DATA.COM4_TxBuf, string);
    288                              
    289          			        WL9FM_USART_INDEX.COM4_TxCnt = 0;
    290          			        WL9FM_USART_INDEX.COM4_TxIdx = strlen((char *)WL9FM_USART_DATA.COM4_TxBuf);
    291          					
    292                              break;
    293                              
    294                  default   : return;
    295              }                    
    296                  
    297              USART_ITConfig(Serial_USART[COM], USART_IT_TXE, ENABLE);
    298          }  
    299          
    300          /**
    301            * @brief  None
    302            * @param  None
    303            * @retval None
    304            */
    305          //  
    306          void USARTx_EXYNOS(uint8_t COM, char *TmpBuffer)
    307          {
    308          	memcpy((char *)WL9FM_USART_DATA.COM4_TxBuf, TmpBuffer, Serial_COM4_TxSize);
    309          						
    310          	WL9FM_USART_INDEX.COM4_TxCnt = 0;
    311          	WL9FM_USART_INDEX.COM4_TxIdx = Serial_COM4_TxSize;
    312          	    
    313          	USART_ITConfig(Serial_USART[COM], USART_IT_TXE, ENABLE);
    314          }
    315          
    316          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AsciiToHex
         8   -> toupper
       0   HexToAscii
       0   HexToDec
      32   USART_COMInit
        32   -> NVIC_Init
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
       8   USARTx_EXYNOS
         0   -> USART_ITConfig
         8   -> __aeabi_memcpy
      16   USARTx_PutChar
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
      16   USARTx_PutHex
         0   -> USARTx_PutChar
        16   -> USARTx_PutChar
      16   USARTx_PutStr
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
     272   USARTx_printf
       272   -> USARTx_PutStr
       272   -> vsprintf
     280   USARTx_printk
       280   -> USART_ITConfig
       280   -> strcpy
       280   -> strlen
       280   -> vsprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       8  ?Subroutine0
      20  AsciiToHex
      12  HexToAscii
      18  HexToDec
      20  Serial_BaudRate
      12  Serial_IRQ_Channel
      20  Serial_PORT
      20  Serial_PORT_CLK
      12  Serial_RX_PIN
      12  Serial_TX_PIN
      20  Serial_USART
      20  Serial_USART_CLK
     122  USART_COMInit
      42  USARTx_EXYNOS
      30  USARTx_PutChar
      54  USARTx_PutHex
      42  USARTx_PutStr
      32  USARTx_printf
      98  USARTx_printk

 
  40 bytes in section .data
  64 bytes in section .rodata
 526 bytes in section .text
 
 526 bytes of CODE  memory
  64 bytes of CONST memory
  40 bytes of DATA  memory

Errors: none
Warnings: none
