###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      14/Apr/2014  09:39:26 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32 #
#                    f4xx_it.c                                                #
#    Command line =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32 #
#                    f4xx_it.c -D USE_STDPERIPH_DRIVER -D STM32F4XX -D        #
#                    USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN                #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\stm32f #
#                    4xx_it.lst                                               #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\stm32f4 #
#                    xx_it.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32f4xx_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    Project/STM32F4xx_StdPeriph_Template/stm32f4xx_it.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    13-April-2012
      7            * @brief   Main Interrupt Service Routines.
      8            *          This file provides template for all exceptions handler and 
      9            *          peripherals interrupt service routine.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "stm32f4xx_it.h"
     32          #include "main.h"
     33          
     34          /** @addtogroup Template_Project
     35            * @{
     36            */
     37          
     38          /* Private typedef -----------------------------------------------------------*/
     39          
     40          //#define		DEBUG_CMD_RX
     41          //#define		DEBUG_CMD_TX
     42          //#define		DEBUG_CAN_RX
     43          //#define		DEBUG_CAN_TX
     44          #pragma pack(1)
     45          struct st_CAN_Msg
     46          {	
     47          	unsigned char Priority;
     48          	unsigned char Data_Page;
     49          	unsigned char PDU_Format;	
     50          	unsigned char PDU_Specific;		// 50
     51          	unsigned char Source_Address;	// 52
     52          };
     53          #pragma pack()
     54          
     55          CanRxMsg RxMsg;
     56          struct st_CAN_Msg Iden; 
     57          
     58          extern Realy_Control		rx_Realy_Control;
     59          extern EHCU_Status		rx_EHCU_Status;
     60          extern Auto_position_Status rx_Auto_position_Status;
     61          extern st_CANDATA_HCEPGN_65428	RX_HCEPGN_65428;
     62          /* Private define ------------------------------------------------------------*/
     63          
     64          #define RING_BUF_SIZE			768*10
     65          #define UART2_Rx_BUF_SIZE		26			// Max Multi Packet Data -> 3개
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          #define RX_MSG69		0x01
     69          #define RX_MSG69_M		0x02
     70          #define RX_MSG145		0x04
     71          #define RX_MSG161		0x08
     72          #define RX_MSG162		0x10
     73          #define RX_MSG163		0x20
     74          #define RX_MSG251		0x40
     75          #define RX_MSG252		0x80
     76          #define RX_MSG202		0x100
     77          #define RX_MSG253		0x200
     78          #define RX_MSG203		0x400
     79          #define RX_MSG239		0x800
     80          #define RX_MSG247		0x1000
     81          #define RX_MSG174		0x2000
     82          #define RX_MSG239_121	0x4000
     83          
     84          
     85          
     86          
     87          
     88          /* Private define ------------------------------------------------------------*/
     89          /* Private macro -------------------------------------------------------------*/
     90          /* Private variables ---------------------------------------------------------*/
     91          u8 ring_buf[RING_BUF_SIZE];		
     92          u16 pWriteBufPos = 0;
     93          u16 pReadBufPos = 0;
     94          u8 CanRecvCnt = 0;
     95          u16 TotPacketNum = 0;
     96          u32 pgn = 0;
     97          u16 TotMsgSize = 0;
     98          u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
     99          u8 Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE];
    100          
    101          u8 Uart2_SerialTxCnt = 0;
    102          u8 Uart2_SerialRxCnt = 0;
    103          u16 CommErrCnt = 0;
    104          
    105          u8 SendEEPROMDataCnt = 0;
    106          u8 Flag_TxE2pRomData = 0;
    107          u8 stop_send_as_phone_data = 0;
    108          u8 Stm32_Update_CMD;
    109          
    110          u8 Buz1, Buz2;
    111          
    112          extern u8 MoniInfoSendCnt;
    113          extern u16 Flag_1Sec_MoniInfo;
    114          extern u8 MoniInfoTotalPacketNum;
    115          extern u8 RecvMachInfo;
    116          extern u8 MachineBasicInformation[78];
    117          
    118          extern u8 Flag_UartTxStart;
    119          extern u32 Flag_SerialRxMsg;
    120          extern u8 eepRomReadData1[32];
    121          
    122          extern u8 Uart2_RxMsg_Save_Data1[8];
    123          extern u8 Uart2_RxMsg_Save_Data2[8];
    124          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    125          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    126          
    127          extern u8 Uart2_RxMsg_Single_46[8];
    128          extern u8 Uart2_RxMsg_Single_69[8];
    129          extern u8 Uart2_RxMsg_Multi_69[21];
    130          extern u8 Uart2_RxMsg_Single_160[8];
    131          extern u8 Uart2_RxMsg_Multi_161[16];
    132          extern u8 Uart2_RxMsg_Single_162[8];
    133          extern u8 Uart2_RxMsg_Single_163[8];
    134          extern u8 Uart2_RxMsg_Single_174[8];
    135          extern u8 Uart2_RxMsg_Single_251[8];
    136          extern u8 Uart2_RxMsg_Single_252[8];
    137          extern u8 Uart2_RxMsg_Single_253[8];
    138          extern u8 Uart2_RxMsg_Single_239[8];
    139          extern u8 Uart2_RxMsg_Single_239_121[8];
    140          extern u8 Uart2_RxMsg_Single_247[8];
    141          
    142          extern u8 SerialMsgRTC[16];
    143          extern u8 Lamp_name;
    144          extern u8 Lamp_Value;
    145          
    146          //////////////// stm32 update /////////////////////
    147          extern u8 Change_UART4_for_Download;
    148          extern u8 ST_Update;
    149          
    150          /* Private function prototypes -----------------------------------------------*/
    151          /* Private functions ---------------------------------------------------------*/
    152          void WL9F_CAN_Buffer_Init(void)
    153          {
    154          	Uart2_SerialTxMsg[0]  = 0x02;	// STX
    155          	Uart2_SerialTxMsg[1]  = 0xF5;	// ID
    156          	Uart2_SerialTxMsg[2]  = 8;		// Data Length
    157          	Uart2_SerialTxMsg[15] = 0;		// CRC
    158          	Uart2_SerialTxMsg[16] = 0x03;	// ETX
    159          
    160          	pWriteBufPos = 0;
    161          
    162          	TotPacketNum = 0;
    163          	pgn = 0;
    164          
    165          	Uart2_SerialTxCnt = 0;
    166          	CommErrCnt = 0;
    167          }
    168          
    169          uint16_t test,old_test;
    170          
    171          unsigned char test_temp[8];
    172          
    173          void OperateRingBuffer(void)
    174          {
    175          	if(pWriteBufPos >= (RING_BUF_SIZE-1))	// End of Ring Buffer
    176          		pWriteBufPos = 0;
    177          
    178          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.ExtId, 4);
    179          
    180          	pWriteBufPos += 4;
    181          
    182          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.Data, 8);
    183          	
    184          	pWriteBufPos += 8;	
    185          
    186          	if(RxMsg.ExtId==0x18fff7dd) // rcu status
    187          	{
    188          		memcpy( &rx_Realy_Control, (u8*)&RxMsg.Data, 8);
    189          	}
    190          	else if(RxMsg.ExtId==0x18ffEDE4) // ECU status
    191          	{
    192          		memcpy( &rx_EHCU_Status, (u8*)&RxMsg.Data, 8);
    193          	}
    194          	else if(RxMsg.ExtId==0x18ffEc47) // auto_position
    195          	{
    196          		memcpy( &rx_Auto_position_Status, (u8*)&RxMsg.Data, 8);
    197          	}
    198          	else if(RxMsg.ExtId==0x18ff9447) // lamp
    199          	{
    200          		memcpy( &RX_HCEPGN_65428, (u8*)&RxMsg.Data, 8);
    201          	}
    202          	
    203          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    204          	
    205          }
    206          
    207          void SendTo_E2PROM(void)
    208          {
    209          #if 1
    210          	if (SendEEPROMDataCnt < 2)	//	2번 보낸다.
    211          	{
    212          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[0], 8);
    213          		Uart2_SerialTxMsg[15] = 0xE1;
    214          	}	
    215          	else if (SendEEPROMDataCnt < 4)	//	2번 보낸다.
    216          	{
    217          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[8], 8);
    218          		Uart2_SerialTxMsg[15] = 0xE2;
    219          	}	
    220          	else
    221          	{
    222          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[16], 8);
    223          		Uart2_SerialTxMsg[15] = 0xE3;
    224          	}		
    225          
    226          	//  Enable the USART3 Transmit interrupt
    227          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    228          #endif
    229          }
    230          
    231          /******************************************************************************/
    232          /*            Cortex-M4 Processor Exceptions Handlers                         */
    233          /******************************************************************************/
    234          
    235          /**
    236            * @brief   This function handles NMI exception.
    237            * @param  None
    238            * @retval None
    239            */
    240          void NMI_Handler(void)
    241          {
    242          }
    243          
    244          /**
    245            * @brief  This function handles Hard Fault exception.
    246            * @param  None
    247            * @retval None
    248            */
    249          void HardFault_Handler(void)
    250          {
    251            /* Go to infinite loop when Hard Fault exception occurs */
    252            while (1)
    253            {
    254            }
    255          }
    256          
    257          /**
    258            * @brief  This function handles Memory Manage exception.
    259            * @param  None
    260            * @retval None
    261            */
    262          void MemManage_Handler(void)
    263          {
    264            /* Go to infinite loop when Memory Manage exception occurs */
    265            while (1)
    266            {
    267            }
    268          }
    269          
    270          /**
    271            * @brief  This function handles Bus Fault exception.
    272            * @param  None
    273            * @retval None
    274            */
    275          void BusFault_Handler(void)
    276          {
    277            /* Go to infinite loop when Bus Fault exception occurs */
    278            while (1)
    279            {
    280            }
    281          }
    282          
    283          /**
    284            * @brief  This function handles Usage Fault exception.
    285            * @param  None
    286            * @retval None
    287            */
    288          void UsageFault_Handler(void)
    289          {
    290            /* Go to infinite loop when Usage Fault exception occurs */
    291            while (1)
    292            {
    293            }
    294          }
    295          
    296          /**
    297            * @brief  This function handles SVCall exception.
    298            * @param  None
    299            * @retval None
    300            */
    301          void SVC_Handler(void)
    302          {
    303          }
    304          
    305          /**
    306            * @brief  This function handles Debug Monitor exception.
    307            * @param  None
    308            * @retval None
    309            */
    310          void DebugMon_Handler(void)
    311          {
    312          }
    313          
    314          /**
    315            * @brief  This function handles PendSVC exception.
    316            * @param  None
    317            * @retval None
    318            */
    319          void PendSV_Handler(void)
    320          {
    321          }
    322          
    323          /**
    324            * @brief  This function handles SysTick Handler.
    325            * @param  None
    326            * @retval None
    327            */
    328          void SysTick_Handler(void)
    329          {
    330            	TimeDelay_Decrement();
    331          
    332              ++WL9FM_TIME.Cnt_1mSec;
    333          
    334          	if (WL9FM_TIME.Cnt_1mSec % 1 == 0)                   //  1msec
    335          	{
    336                  WL9FM_TIME.Flag_1mSec = 1;
    337          
    338          		if (WL9FM_TIME.Cnt_1mSec % 10 == 0)              //  10msec
    339          		{
    340          			WL9FM_TIME.Flag_10mSec = 1;
    341          
    342          			if (WL9FM_TIME.Cnt_1mSec % 100 == 0)         //  100msec
    343          			{
    344          				WL9FM_TIME.Flag_100mSec = 1;
    345          
    346          				if (WL9FM_TIME.Cnt_1mSec % 1000 == 0)    //  1000 msec
    347          				{
    348          					WL9FM_TIME.Flag_1Sec = 1;
    349          					WL9FM_TIME.Cnt_1mSec = 0;
    350          				}
    351          			}
    352          		}
    353          	}    
    354          }
    355          
    356          /******************************************************************************/
    357          /*                 STM32F4xx Peripherals Interrupt Handlers                   */
    358          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    359          /*  available peripheral interrupt handler's name please refer to the startup */
    360          /*  file (startup_stm32f4xx.s).                                               */
    361          /******************************************************************************/
    362          
    363          /**
    364            * @brief  This function handles PPP interrupt request.
    365            * @param  None
    366            * @retval None
    367            */
    368          /*void PPP_IRQHandler(void)
    369          {
    370          }*/
    371          
    372          /**
    373            * @}
    374            */ 
    375          
    376          /**
    377            * @brief  This function handles CAN1 global interrupt request.
    378            * @param  None
    379            * @retval None
    380            */
    381          void CAN1_RX0_IRQHandler(void)
    382          {
    383          	u32 PF; 
    384          
    385          	CAN_Receive(CAN1,CAN_FIFO0,&RxMsg);
    386          				
    387          	Iden.Source_Address = (RxMsg.ExtId & 0x000000ff)  >> 0;
    388          	Iden.PDU_Specific = (RxMsg.ExtId  & 0x0000ff00) >> 8;
    389          	
    390          	// Iden.Source_Address == 71	 -->>	MCU
    391          	// Iden.Source_Address == 228	 -->>	EHCU	
    392          	// Iden.Source_Address == 29	 -->>	Smart Key
    393          	// Iden.Source_Address == 23	 -->>	Cluster
    394          	// Iden.Source_Address == 221	 -->>	RCU
    395          	// Iden.Source_Address == 0	 -->>	ECM
    396          	// Iden.Source_Address == 3	 -->>	TCU
    397          	
    398          	if((Iden.Source_Address == 71) || (Iden.Source_Address == 23) || (Iden.Source_Address == 29) || 
    399          		(Iden.Source_Address == 228) || (Iden.Source_Address == 221)|| (Iden.Source_Address == 0x4a)|| (Iden.Source_Address == 0xf4)
    400          		|| (Iden.Source_Address == 0x00)|| (Iden.Source_Address == 0x03))
    401          		{
    402          			if(++CanRecvCnt >= 100)
    403          			{
    404          				CanRecvCnt = 0;
    405          	
    406          				if(pWriteBufPos >= (768*10-1)) // End of Ring Buffer
    407          					pWriteBufPos = 0;
    408          	
    409          				memcpy(&ring_buf[pWriteBufPos], (u8*)&SerialMsgRTC[0], 12);
    410          			
    411          				pWriteBufPos += 12;
    412          				
    413          			}
    414          	
    415          	
    416          			PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    417          	
    418          			if((PF == 254) || (PF == 255) || (PF == 239) )
    419          			{	
    420          				if(Iden.PDU_Specific == 251)
    421          				{
    422          					MoniInfoSendCnt = 0;
    423          					Flag_1Sec_MoniInfo = 0;
    424          					MoniInfoTotalPacketNum = 0;
    425          				}
    426          				else
    427          				{
    428          					if( (Iden.PDU_Specific == 153) || (Iden.PDU_Specific == 170) ) 
    429          					{
    430          						if( Iden.PDU_Specific == 153 )
    431          							Buz1 = (RxMsg.Data[7] & 0x30 ) >> 4; 		// 1 :On 	0 : Off
    432          						else if( Iden.PDU_Specific == 170 )
    433          							Buz2 = (RxMsg.Data[0] & 0x0C) >> 2;			// 1 :On 	0 : Off
    434          					
    435          						if( (Buz1 == 1) || (Buz2 == 1) )
    436          						{
    437          							Buzzer_SendToEXYNOS(1);
    438          						}
    439          						else
    440          						{
    441          							Buzzer_SendToEXYNOS(0);
    442          						}
    443          					}
    444          					//if(Iden.PDU_Specific == 0x9b)
    445          						OperateRingBuffer();
    446          				}
    447          			}
    448          			else if((PF == 235) || (PF == 236))
    449          			{
    450          				if((Iden.PDU_Specific == 255)||(Iden.PDU_Specific == 0x28))
    451          				{
    452          					if(PF == 236)		// TP.CM_BAM
    453          					{
    454          						if(RxMsg.Data[0] == 32) 	// Control Byte
    455          						{
    456          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    457          							if(pgn == 65340)
    458          							{
    459          								TotPacketNum = RxMsg.Data[3];		// Total number of packets
    460          								TotMsgSize = (RxMsg.Data[2] << 8) | RxMsg.Data[1];
    461          							}
    462          							else
    463          							{
    464          								Uart2_SerialTxMsg[15] = 0;
    465          								OperateRingBuffer();
    466          							}
    467          							return;
    468          						}
    469          					}
    470          	
    471          					if(pgn != 0)
    472          					{
    473          						if(PF == 235)
    474          						{
    475          							if(pgn == 65340)
    476          							{
    477          								memcpy(&MachineBasicInformation[(RxMsg.Data[0]-1)*7], &RxMsg.Data[1] , 7);
    478          								if(RxMsg.Data[0] == TotPacketNum)
    479          								{
    480          									pgn = TotPacketNum = 0;
    481          									RecvMachInfo = 1;
    482          								}
    483          							}
    484          							else
    485          							{
    486          								Uart2_SerialTxMsg[15] = 0;
    487          								OperateRingBuffer();
    488          							}
    489          						}
    490          					}
    491          				}
    492          			}
    493          	
    494          			CommErrCnt = 0;
    495          		}
    496          
    497          }
    498          
    499          /**
    500            * @brief  This function handles TIM4 global interrupt request.
    501            * @param  None
    502            * @retval None
    503            */
    504          void TIM4_IRQHandler(void)  //  10msec Timer / TimeBase UP Counter
    505          {
    506              TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    507              
    508              //  BUZZER Status가 "2" 일 경우 BUZZER OnTime 만큼 BUZZER On
    509              if (WL9FM_BUZZER.Status == 2)
    510              {
    511                  if (WL9FM_BUZZER.OnCnt++ < WL9FM_BUZZER.OnTime)
    512                  {
    513                      Buzzer_On();
    514                  }
    515                  else
    516                  {
    517                      WL9FM_BUZZER.Status = 0;               
    518                  }
    519              }        
    520              //  BUZZER Status가 "1" 일 경우 UnLimit BUZZER On
    521              else if (WL9FM_BUZZER.Status == 1)
    522              {
    523                  Buzzer_On();    
    524              }    
    525              else
    526              {
    527                  Buzzer_Off();
    528                  
    529                  WL9FM_BUZZER.Status = 0;               
    530                  WL9FM_BUZZER.OnTime = 0;
    531                  WL9FM_BUZZER.OnCnt  = 0;
    532              }
    533          
    534          #if 1
    535          	CommErrCnt++;
    536          
    537          	if(CommErrCnt >= 1000)
    538          		CommErrCnt = 1001;
    539          #endif
    540          }
    541          
    542          /**
    543            * @brief  This function handles TIM5 global interrupt request.
    544            * @param  None
    545            * @retval None
    546            */
    547          void TIM5_IRQHandler(void)  //  5msec Timer / TimeBase UP Counter    
    548          {
    549              TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
    550              
    551              KeySwitch_Process();    //  KeySwitch.c Func
    552          }
    553          
    554          /**
    555            * @brief  This function handles USART3 global interrupt request.
    556            * @param  None
    557            * @retval None
    558            */
    559            // STM32F407 <-> exynos4412 can_data
    560          
    561          unsigned char temp_61184;
    562          
    563          void USART2_IRQHandler(void)
    564          {
    565          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    566          	{
    567          		Uart2_SerialRxMsg[Uart2_SerialRxCnt] = (u8)USART_ReceiveData(USART2);
    568          
    569          		  //  디버깅할 때만 사용할 것
    570          		#ifdef DEBUG_CAN_RX
    571          		DebugMsg_printf("%2x ", Uart2_SerialRxMsg[Uart2_SerialRxCnt]);
    572          		#endif
    573          		
    574          		switch(Uart2_SerialRxCnt)
    575          		{
    576          			case 0:
    577          				if(Uart2_SerialRxMsg[0] == 0x02)		// STX
    578          					Uart2_SerialRxCnt++;
    579          				break;
    580          			case 1:
    581          				if(Uart2_SerialRxMsg[1] == 0xF5)		// ID
    582          					Uart2_SerialRxCnt++;
    583          				else
    584          					Uart2_SerialRxCnt = 0;
    585          				break;
    586          			case 25:
    587          				Uart2_SerialRxCnt = 0;
    588          
    589          				if(Uart2_SerialRxMsg[25] == 0x03)		// ETX
    590          				{
    591                              			//  디버깅할 때만 사용할 것
    592          					#ifdef DEBUG_CAN_RX
    593          					DebugMsg_printf("\r\n");
    594          					#endif
    595          					
    596          					switch(Uart2_SerialRxMsg[3])		// Cmd
    597          					{
    598          						case 1 :		// UART TX Start Flag
    599          							Flag_UartTxStart = 1;
    600          							Flag_TxE2pRomData=0;
    601          							SendEEPROMDataCnt=0;
    602          							break;
    603          						case 203 :  // for EHCU setting 61184 format 131017
    604          							Flag_SerialRxMsg |= RX_MSG203;
    605          							memcpy(&Uart2_RxMsg_Single_46[0], &Uart2_SerialRxMsg[4], 8);
    606          							break;
    607          						case 69 :	// When needed
    608          							Flag_SerialRxMsg |= RX_MSG69;
    609          							memcpy(&Uart2_RxMsg_Single_69[0], &Uart2_SerialRxMsg[4], 8);
    610          							break;
    611          						case 70 :	// When needed - RX_MSG69 Multi Packet
    612          							Flag_SerialRxMsg |= RX_MSG69_M;
    613          							memcpy(&Uart2_RxMsg_Multi_69[0], &Uart2_SerialRxMsg[4], 21);
    614          							break;
    615          						case 160 :	// 100 ms
    616          							if((Uart2_RxMsg_Single_160[0] & 0xc0) == 0xc0)
    617          								memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    618          							else
    619          							{
    620          								memcpy(&Uart2_RxMsg_Single_160[1], &Uart2_SerialRxMsg[5], 7);
    621          								Uart2_RxMsg_Single_160[0] |= (Uart2_SerialRxMsg[4] & 0x3F);
    622          							}
    623          																						
    624          							if(((Uart2_SerialRxMsg[4] & 0xc0) == 0x00) || ((Uart2_SerialRxMsg[4] & 0xc0) == 0x40))
    625          							        memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    626          							break;
    627          						case 161 :	// When needed
    628          							Flag_SerialRxMsg |= RX_MSG161;
    629          							memcpy(&Uart2_RxMsg_Multi_161[0], &Uart2_SerialRxMsg[4], 14);
    630          							temp_61184=0;
    631          							break;
    632          						case 162 :	// When needed
    633          							//Flag_SerialRxMsg |= RX_MSG162;
    634          							if(Uart2_RxMsg_Single_162[4] == 0)
    635          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 8);
    636          							else
    637          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 4);
    638          							break;	
    639          						case 163 :
    640          							Flag_SerialRxMsg |= RX_MSG163;
    641          							memcpy(&Uart2_RxMsg_Single_163[0], &Uart2_SerialRxMsg[4], 8);
    642          							break;
    643          						case 174 :
    644          							Flag_SerialRxMsg |= RX_MSG174;
    645          							memcpy(&Uart2_RxMsg_Single_174[0], &Uart2_SerialRxMsg[4], 8);
    646          							break;
    647          						case 205 :	// Stop Send Cmd - A/S Phone Number
    648          							stop_send_as_phone_data = 1;
    649          							break;
    650          						case 200 :	// Save Data1
    651          							memcpy(&Uart2_RxMsg_Save_Data1[0], &Uart2_SerialRxMsg[4], 8);
    652          							break;
    653          						case 201 :	// Save Data2
    654          							memcpy(&Uart2_RxMsg_Save_Data2[0], &Uart2_SerialRxMsg[4], 8);
    655          							break;
    656          						case 202 :	// A/S Phone Number -> Save to EEPROM
    657          							Flag_SerialRxMsg |= RX_MSG202;
    658          							memcpy(&Uart2_RxMsg_AS_Phone_Data[0], &Uart2_SerialRxMsg[4], 8);
    659          							break;
    660          						case 210 :	// Smart Key Registration, Elimination
    661          							memcpy(&Uart2_RxMsg_Smk_Reg_Eli[0], &Uart2_SerialRxMsg[4], 8);
    662          							break;
    663          						case 247 :
    664          							Flag_SerialRxMsg |= RX_MSG247;
    665          							memcpy(&Uart2_RxMsg_Single_247[0], &Uart2_SerialRxMsg[4], 8);							
    666          							break;	
    667          						case 251 :
    668          							Flag_SerialRxMsg |= RX_MSG251;
    669          							memcpy(&Uart2_RxMsg_Single_251[0], &Uart2_SerialRxMsg[4], 8);							
    670          							break;
    671          						case 252 :	// Clock Set Data
    672          							Flag_SerialRxMsg |= RX_MSG252;
    673          							memcpy(&Uart2_RxMsg_Single_252[0], &Uart2_SerialRxMsg[4], 8);							
    674          							break;
    675          						case 253 :
    676          							Flag_SerialRxMsg |= RX_MSG253;
    677          							memcpy(&Uart2_RxMsg_Single_253[0], &Uart2_SerialRxMsg[4], 8);							
    678          							break;
    679          						case 101 :
    680          						case 102 :
    681          						case 109 : 
    682          						case 61 : 
    683          						case 31 : 
    684          						case 33 : 
    685          						case 34 : 
    686          						case 123 : 
    687          							Flag_SerialRxMsg |= RX_MSG239;
    688          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);		
    689          								
    690          							temp_61184++;
    691          							
    692          							break;
    693          
    694          						case 121 :
    695          							Flag_SerialRxMsg |= RX_MSG239;
    696          							Flag_SerialRxMsg |= RX_MSG239_121;
    697          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);	
    698          							memcpy(&Uart2_RxMsg_Single_239_121[0], &Uart2_SerialRxMsg[4], 8);	
    699          							temp_61184++;
    700          							break;
    701          						
    702          					}
    703          				}
    704          				else
    705          				{
    706          					//  디버깅할 때만 사용할 것
    707          					//DebugMsg_printf("Protocol Fail\r\n");
    708          				}
    709          
    710          				break;
    711          			
    712          			default :
    713          				Uart2_SerialRxCnt++;
    714          				break;
    715          		}
    716          	}
    717          
    718          	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    719          	{   
    720          		if((USART2->SR & 0x80) == RESET)
    721          			return;
    722          
    723          		if (pWriteBufPos == pReadBufPos)
    724          		{
    725          			if(Flag_TxE2pRomData == 1)
    726          			{
    727          			    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    728          			    return;
    729          		    	}
    730          		}
    731          
    732          		if(pReadBufPos >= (RING_BUF_SIZE-1))
    733          			pReadBufPos = 0;
    734          
    735          		if((Uart2_SerialTxCnt == 0) && (pWriteBufPos != pReadBufPos))
    736          		{
    737          			memcpy(&Uart2_SerialTxMsg[3] , &ring_buf[pReadBufPos], 12);
    738          		}
    739          		
    740          		USART_SendData(USART2, (u16)(Uart2_SerialTxMsg[Uart2_SerialTxCnt++]));    
    741          		
    742          		if (Uart2_SerialTxCnt >= UART2_Tx_BUF_SIZE)
    743          		{
    744          			//Uart2_SerialTxCnt = 0;
    745          			//pReadBufPos += 12;
    746          			//USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    747          
    748          			if(Flag_TxE2pRomData == 0)
    749          			{
    750                          		//  보내는 횟수 중요하다. 초기에 버그가 생실 수 있으니, 테스트 필요함!!!
    751          				//	EEPROM Data를 6번 보낸다.
    752          				if(SendEEPROMDataCnt > 5)	
    753          				{
    754          					Uart2_SerialTxCnt = 0;	
    755          					Uart2_SerialTxMsg[15] = 0;
    756          					Flag_TxE2pRomData = 1;
    757          						
    758          					//	EEPROM Data를 그만 보내고 CAN Data를 보낸다. 
    759          					Flag_UartTxStart = 0;
    760          					
    761          					//  Enable the USART2 Transmit interrupt
    762          					USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    763          					CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);			
    764          				}
    765          				else
    766          				{
    767          					SendEEPROMDataCnt++;
    768          			        	Uart2_SerialTxCnt = 0;
    769          
    770          					//  Disable the USART3 Transmit interrupt
    771          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    772          				}
    773          			}
    774          			else
    775          			{
    776          				Uart2_SerialTxCnt = 0;
    777          				pReadBufPos += 12;
    778          			}
    779          		}  
    780          	}
    781          }
    782          
    783          void UART4_IRQHandler(void)
    784          {
    785          	//  UART4 receive interrupt routine
    786          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) 
    787              	{
    788              		if(Change_UART4_for_Download==0)
    789          			UART4_Receive_CMD();
    790          		else
    791          			UART4_Receive_File();
    792          				
    793          	}
    794          	//  UART4 transmit interrupt routine
    795          	if (USART_GetITStatus(UART4, USART_IT_TXE) != RESET)
    796          	{   
    797          		UART4_transmit_CMD();
    798          	}
    799          }
    800          
    801          u8 temp_rx_buf[4];
    802          
    803          
    804          void UART4_Receive_CMD(void)
    805          {
    806          	
    807          	//  Read one byte to the receive data register
    808          	WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt] = USART_ReceiveData(UART4);
    809          
    810          	
    811              	//  디버깅할 때만 사용할 것
    812          	#ifdef DEBUG_CMD_RX
    813          	DebugMsg_printf("%2x ", WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt]);
    814          	#endif
    815          
    816          	
    817          	switch (WL9FM_USART_INDEX.COM4_RxCnt)
    818          	{
    819          		case 0:
    820          				if (WL9FM_USART_DATA.COM4_RxBuf[0] == STX)
    821          				{
    822          					WL9FM_USART_INDEX.COM4_RxCnt++;
    823          				}	
    824          				else
    825          				{
    826          					WL9FM_USART_INDEX.COM4_RxCnt=0;
    827          				}
    828          				
    829          				break;
    830          		case 1:
    831          				if (WL9FM_USART_DATA.COM4_RxBuf[1]      == KeyCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    832          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LCDBLCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    833          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == BUZZERCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    834          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LAMPCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    835          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CAMCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    836          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == DOWNCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    837          				else if ((WL9FM_USART_DATA.COM4_RxBuf[1]&0x80) == 0x80)	WL9FM_USART_INDEX.COM4_RxCnt++;
    838                                          
    839                                  else
    840                                  {
    841                                    	WL9FM_USART_INDEX.COM4_RxCnt = 0;
    842                                  }
    843          				break;
    844          
    845          		case 3: 
    846          				WL9FM_USART_INDEX.COM4_RxCnt = 0;
    847          				
    848          				//  디버깅할 때만 사용할 것
    849          				#ifdef DEBUG_CMD_RX
    850          				DebugMsg_printf("\r\n");
    851          				#endif
    852          
    853          		if (WL9FM_USART_DATA.COM4_RxBuf[Serial_COM4_RxSize-1] == ETX)
    854          		{
    855          			switch (WL9FM_USART_DATA.COM4_RxBuf[1])
    856          			{
    857          				case KeyCMD   :		//	Key Command
    858          
    859          					break;
    860          							
    861          				case LCDBLCMD :		//	LCD BackLight Command
    862          
    863          					//	LCD BackLight Level 조절.. Level0 ~ Level8
    864          					if (WL9FM_USART_DATA.COM4_RxBuf[2] < MaxBackLightLEVEL) 												
    865          					{
    866          						LCDBL_PWM_LEVEL(WL9FM_USART_DATA.COM4_RxBuf[2]);
    867          					}
    868          
    869          					break;
    870          
    871          				case BUZZERCMD :	//	Buzzer Command
    872          					break;
    873          
    874          				case LAMPCMD :	//	Buzzer Command
    875          					Lamp_name = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0xf0)>>4;
    876          					Lamp_Value = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0x0f);
    877          					
    878          					Lamp_Update_State();
    879          					break;
    880          					
    881          				case CAMCMD:
    882          					cam_mode_change(WL9FM_USART_DATA.COM4_RxBuf[2]);
    883          					break;
    884          
    885          				case DOWNCMD:
    886          					Stm32_Update_CMD = WL9FM_USART_DATA.COM4_RxBuf[2];
    887          					ST_Update=1;
    888          					break;
    889          				case  DUMMYCMD:
    890          					CMD_DUMMY_SendToExynos(0);
    891          					break;
    892          
    893          				default :
    894          					break;								
    895          			}
    896                          }						
    897          
    898          		//memset(WL9FM_USART_DATA.COM4_RxBuf, 0x0, Serial_COM4_RxSize);					
    899          				break;
    900          		
    901          		default :
    902          
    903          			WL9FM_USART_INDEX.COM4_RxCnt++;
    904          			break;
    905          	}	
    906          }
    907          
    908          void UART4_Receive_File(void)
    909          {
    910          	
    911          	//  Read one byte to the receive data register
    912          	WL9FM_USART_RX_FILE_DATA.File_RxBuf[WL9FM_USART_RX_FILE_DATA.File_RxCnt] = USART_ReceiveData(UART4);
    913          	
    914          	switch (WL9FM_USART_RX_FILE_DATA.File_RxCnt)
    915          	{
    916          		case 0:
    917          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[0] == STX)
    918          				{
    919          					WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
    920          				}						
    921          				break;
    922          		case 1029: 
    923          				WL9FM_USART_RX_FILE_DATA.File_RxCnt = 0;
    924          					
    925          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == ETX)
    926          				{
    927          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
    928          					ST_Update=1;
    929          				}
    930          				else if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == EOT)
    931          				{
    932          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
    933          					Change_UART4_for_Download =2;
    934          					ST_Update=1;
    935          				}
    936          				else
    937          				{
    938          					ACK_NACK_SendToExynos(NAK);
    939          				}
    940                                          break;
    941          		default :
    942          
    943          			WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
    944          			break;
    945          	}					
    946          }
    947          
    948          
    949          void UART4_transmit_CMD(void)
    950          {
    951          	//  Write one byte to the transmit data register
    952          	USART_SendData(UART4, WL9FM_USART_DATA.COM4_TxBuf[WL9FM_USART_INDEX.COM4_TxCnt++]);
    953          
    954          	if (WL9FM_USART_INDEX.COM4_TxIdx >= Serial_COM4_TxSize)
    955          	{
    956          		WL9FM_USART_INDEX.COM4_TxIdx = Serial_COM4_TxSize;
    957          	}    
    958          	if (WL9FM_USART_INDEX.COM4_TxCnt == WL9FM_USART_INDEX.COM4_TxIdx)
    959          	{
    960          		//  Disable the UART4 Transmit interrupt
    961          		USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
    962          
    963          		WL9FM_USART_INDEX.COM4_TxIdx = 0; //  transmit buffer Index clear
    964          		WL9FM_USART_INDEX.COM4_TxCnt = 0; //  transmit buffer Cnt   clear
    965          	}              
    966          }
    967          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BusFault_Handler
      16   CAN1_RX0_IRQHandler
        16   -> Buzzer_SendToEXYNOS
        16   -> CAN_Receive
         0   -> OperateRingBuffer
        16   -> OperateRingBuffer
        16   -> memcpy
       0   DebugMon_Handler
       0   HardFault_Handler
       0   MemManage_Handler
       0   NMI_Handler
      16   OperateRingBuffer
         0   -> USART_ITConfig
        16   -> memcpy
       0   PendSV_Handler
       0   SVC_Handler
       8   SendTo_E2PROM
         0   -> USART_ITConfig
         8   -> memcpy
       8   SysTick_Handler
         8   -> TimeDelay_Decrement
       8   TIM4_IRQHandler
         8   -> Buzzer_Off
         8   -> Buzzer_On
         8   -> TIM_ClearITPendingBit
       8   TIM5_IRQHandler
         0   -> KeySwitch_Process
         8   -> TIM_ClearITPendingBit
       8   UART4_IRQHandler
         8   -> UART4_Receive_CMD
         8   -> UART4_Receive_File
         8   -> UART4_transmit_CMD
         8   -> USART_GetITStatus
       8   UART4_Receive_CMD
         0   -> CMD_DUMMY_SendToExynos
         0   -> LCDBL_PWM_LEVEL
         0   -> Lamp_Update_State
         8   -> USART_ReceiveData
         0   -> cam_mode_change
       8   UART4_Receive_File
         0   -> ACK_NACK_SendToExynos
         8   -> USART_ReceiveData
         8   -> __aeabi_memcpy
      16   UART4_transmit_CMD
        16   -> USART_ITConfig
        16   -> USART_SendData
      24   USART2_IRQHandler
         0   -> CAN_ITConfig
        24   -> USART_GetITStatus
         0   -> USART_ITConfig
        24   -> USART_ITConfig
        24   -> USART_ReceiveData
        24   -> USART_SendData
        24   -> __aeabi_memcpy
        24   -> memcpy
       0   UsageFault_Handler
       0   WL9F_CAN_Buffer_Init
       8   memcpy
         8   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_33
       4  ??DataTable12_34
       4  ??DataTable12_35
       4  ??DataTable12_36
       4  ??DataTable12_37
       4  ??DataTable12_38
       4  ??DataTable12_39
       4  ??DataTable12_4
       4  ??DataTable12_40
       4  ??DataTable12_41
       4  ??DataTable12_42
       4  ??DataTable12_43
       4  ??DataTable12_44
       4  ??DataTable12_45
       4  ??DataTable12_46
       4  ??DataTable12_47
       4  ??DataTable12_48
       4  ??DataTable12_49
       4  ??DataTable12_5
       4  ??DataTable12_50
       4  ??DataTable12_51
       4  ??DataTable12_52
       4  ??DataTable12_53
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       8  ?Subroutine0
       2  BusFault_Handler
     364  CAN1_RX0_IRQHandler
       2  DebugMon_Handler
       2  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
     168  OperateRingBuffer
       2  PendSV_Handler
      20  RxMsg
       2  SVC_Handler
      78  SendTo_E2PROM
       1  Stm32_Update_CMD
      84  SysTick_Handler
      86  TIM4_IRQHandler
      20  TIM5_IRQHandler
      56  UART4_IRQHandler
     222  UART4_Receive_CMD
     108  UART4_Receive_File
      64  UART4_transmit_CMD
     876  USART2_IRQHandler
      34  Uart2_SerialRxMsg
          Uart2_SerialRxCnt
          Flag_TxE2pRomData
          stop_send_as_phone_data
          temp_61184
          pReadBufPos
    7728  Uart2_SerialTxMsg
          Iden
          CanRecvCnt
          Uart2_SerialTxCnt
          SendEEPROMDataCnt
          Buz1
          Buz2
          pWriteBufPos
          TotPacketNum
          TotMsgSize
          CommErrCnt
          pgn
          ring_buf
       2  UsageFault_Handler
      38  WL9F_CAN_Buffer_Init
      12  memcpy
       2  old_test
       4  temp_rx_buf
       2  test
       8  test_temp

 
 7 799 bytes in section .bss
 2 416 bytes in section .text
 
 2 404 bytes of CODE memory (+ 12 bytes shared)
 7 799 bytes of DATA memory

Errors: none
Warnings: none
