###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      02/Jul/2014  19:49:25 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32 #
#                    f4xx_it.c                                                #
#    Command line =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32 #
#                    f4xx_it.c -D USE_STDPERIPH_DRIVER -D STM32F4XX -D        #
#                    USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN                #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\stm32f #
#                    4xx_it.lst                                               #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\stm32f4 #
#                    xx_it.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\COMMON\SRC\stm32f4xx_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    Project/STM32F4xx_StdPeriph_Template/stm32f4xx_it.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    13-April-2012
      7            * @brief   Main Interrupt Service Routines.
      8            *          This file provides template for all exceptions handler and 
      9            *          peripherals interrupt service routine.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "stm32f4xx_it.h"
     32          #include "main.h"
     33          
     34          /** @addtogroup Template_Project
     35            * @{
     36            */
     37          
     38          /* Private typedef -----------------------------------------------------------*/
     39          
     40          //#define		DEBUG_CMD_RX
     41          //#define		DEBUG_CMD_TX
     42          //#define		DEBUG_CAN_RX
     43          //#define		DEBUG_CAN_TX
     44          #pragma pack(1)
     45          struct st_CAN_Msg
     46          {	
     47          	unsigned char Priority;
     48          	unsigned char Data_Page;
     49          	unsigned char PDU_Format;	
     50          	unsigned char PDU_Specific;		// 50
     51          	unsigned char Source_Address;	// 52
     52          };
     53          #pragma pack()
     54          
     55          CanRxMsg RxMsg;
     56          struct st_CAN_Msg Iden; 
     57          
     58          extern Realy_Control		rx_Realy_Control;
     59          extern EHCU_Status		rx_EHCU_Status;
     60          extern Auto_position_Status rx_Auto_position_Status;
     61          extern st_CANDATA_HCEPGN_65428	RX_HCEPGN_65428;
     62          extern WEIGHING_SYSTEM_STATUS_65450 rx_Weighing_System_Status;
     63          /* Private define ------------------------------------------------------------*/
     64          
     65          #define RING_BUF_SIZE			768*10
     66          #define UART2_Rx_BUF_SIZE		27			// Max Multi Packet Data -> 3개
     67          #define UART2_Tx_BUF_SIZE		17
     68          
     69          /*
     70          #define RX_MSG69		0x01
     71          #define RX_MSG69_M		0x02
     72          #define RX_MSG145		0x04
     73          #define RX_MSG161		0x08
     74          #define RX_MSG162		0x10
     75          #define RX_MSG163		0x20
     76          #define RX_MSG251		0x40
     77          #define RX_MSG252		0x80
     78          #define RX_MSG202		0x100
     79          #define RX_MSG253		0x200
     80          #define RX_MSG203		0x400
     81          #define RX_MSG239		0x800
     82          #define RX_MSG247		0x1000
     83          #define RX_MSG174		0x2000
     84          #define RX_MSG239_121	0x4000
     85          */
     86          #define RX_MSG11	0x01
     87          #define RX_MSG12	0x02
     88          #define RX_MSG21	0x04
     89          #define RX_MSG23	0x08
     90          #define RX_MSG61	0x10
     91          #define RX_MSG62	0x20
     92          #define RX_MSG101	0x40
     93          #define RX_MSG104	0x80
     94          #define RX_MSG105	0x100
     95          #define RX_MSG109	0x200
     96          #define RX_MSG121	0x400
     97          #define RX_MSG123	0x800
     98          #define RX_MSG201	0x1000
     99          #define RX_MSG203	0x2000
    100          		
    101          		
    102          #define RX_MSG47	0x4000
    103          		
    104          #define RX_MSG145	0x8000
    105          #define RX_MSG247	0x10000
    106          
    107          
    108          
    109          
    110          
    111          /* Private define ------------------------------------------------------------*/
    112          /* Private macro -------------------------------------------------------------*/
    113          /* Private variables ---------------------------------------------------------*/
    114          u8 ring_buf[RING_BUF_SIZE];		
    115          u16 pWriteBufPos = 0;
    116          u16 pReadBufPos = 0;
    117          u8 CanRecvCnt = 0;
    118          u16 TotPacketNum = 0;
    119          u32 pgn = 0;
    120          u32 RMCUpgn = 0;
    121          u16 TotMsgSize = 0;
    122          u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    123          u8 Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE];
    124          
    125          u8 Uart2_SerialTxCnt = 0;
    126          u8 Uart2_SerialRxCnt = 0;
    127          u16 CommErrCnt = 0;
    128          
    129          u8 SendEEPROMDataCnt = 0;
    130          u8 Flag_TxE2pRomData = 0;
    131          u8 stop_send_as_phone_data = 0;
    132          u8 Stm32_Update_CMD;
    133          
    134          u8 Buz1;
    135          
    136          extern u8 MoniInfoSendCnt;
    137          extern u16 Flag_1Sec_MoniInfo;
    138          extern u8 MoniInfoTotalPacketNum;
    139          extern u8 RecvMachInfo;
    140          extern u8 MachineBasicInformation[78];
    141          extern u8 RTSFlag_61184;
    142          extern u8 CTSFlag_61184;
    143          extern u8 RecvTotalPacket_61184;
    144          extern u8 ACK_Multi_61184[8];
    145          extern u8 RMCU_CTSFlag_61184;
    146          extern u8 RMCU_RecvTotalPacket_61184;
    147          extern u8 RMCU_ACK_Multi_61184[8];
    148          
    149          
    150          
    151          extern u8 Flag_UartTxStart;
    152          extern u32 Flag_SerialRxMsg;
    153          extern u8 eepRomReadData1[32];
    154          
    155          extern u8 Uart2_RxMsg_Save_Data1[8];
    156          extern u8 Uart2_RxMsg_Save_Data2[8];
    157          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    158          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    159          
    160          extern u8 Uart2_RxMsg_Single_46[8];
    161          extern u8 Uart2_RxMsg_Single_69[8];
    162          extern u8 Uart2_RxMsg_Multi_69[21];
    163          extern u8 Uart2_RxMsg_Single_160[8];
    164          extern u8 Uart2_RxMsg_Multi_161[16];
    165          extern u8 Uart2_RxMsg_Single_162[8];
    166          extern u8 Uart2_RxMsg_Single_163[8];
    167          extern u8 Uart2_RxMsg_Single_174[8];
    168          extern u8 Uart2_RxMsg_Single_251[8];
    169          extern u8 Uart2_RxMsg_Single_252[8];
    170          extern u8 Uart2_RxMsg_Single_253[8];
    171          extern u8 Uart2_RxMsg_Single_239[8];
    172          extern u8 Uart2_RxMsg_Single_239_121[8];
    173          extern u8 Uart2_RxMsg_Single_247[8];
    174          
    175          
    176          //61184
    177          extern u8 Uart2_RxMsg_Single_11[8];
    178          extern u8 Uart2_RxMsg_Single_12[8];
    179          extern u8 Uart2_RxMsg_Single_21[8];
    180          extern u8 Uart2_RxMsg_Multi_23[13];
    181          extern u8 Uart2_RxMsg_Single_61[8];
    182          extern u8 Uart2_RxMsg_Single_62[8];
    183          extern u8 Uart2_RxMsg_Single_101[8];
    184          extern u8 Uart2_RxMsg_Single_104[8];
    185          extern u8 Uart2_RxMsg_Single_105[8];
    186          extern u8 Uart2_RxMsg_Single_109[8];
    187          extern u8 Uart2_RxMsg_Single_121[8];
    188          extern u8 Uart2_RxMsg_Single_123[8];
    189          extern u8 Uart2_RxMsg_Single_201[8];
    190          extern u8 Uart2_RxMsg_Single_203[8];
    191          //0xFFxx
    192          extern u8 Uart2_RxMsg_Single_47[8];
    193          extern u8 Uart2_RxMsg_Multi_145[22];
    194          extern u8 Uart2_RxMsg_Single_247[8];
    195          
    196          
    197          
    198          
    199          extern u8 SerialMsgRTC[16];
    200          extern u8 Lamp_name;
    201          extern u8 Lamp_Value;
    202          
    203          //////////////// stm32 update /////////////////////
    204          extern u8 Change_UART4_for_Download;
    205          extern u8 ST_Update;
    206          
    207          
    208          // Smart Key
    209          extern WL9FM_receive_smartkey recv_smartkey;
    210          extern WL9FM_flag_data smk_flag_data;
    211          
    212          
    213          /* Private function prototypes -----------------------------------------------*/
    214          /* Private functions ---------------------------------------------------------*/
    215          void WL9F_CAN_Buffer_Init(void)
    216          {
    217          	Uart2_SerialTxMsg[0]  = 0x02;	// STX
    218          	Uart2_SerialTxMsg[1]  = 0xF5;	// ID
    219          	Uart2_SerialTxMsg[2]  = 8;		// Data Length
    220          	Uart2_SerialTxMsg[15] = 0;		// CRC
    221          	Uart2_SerialTxMsg[16] = 0x03;	// ETX
    222          
    223          	pWriteBufPos = 0;
    224          
    225          	TotPacketNum = 0;
    226          	pgn = 0;
    227          
    228          	Uart2_SerialTxCnt = 0;
    229          	CommErrCnt = 0;
    230          }
    231          
    232          uint16_t test,old_test;
    233          
    234          unsigned char test_temp[8];
    235          
    236          void OperateRingBuffer(void)
    237          {
    238          	if(pWriteBufPos >= (RING_BUF_SIZE-1))	// End of Ring Buffer
    239          		pWriteBufPos = 0;
    240          
    241          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.ExtId, 4);
    242          
    243          	pWriteBufPos += 4;
    244          
    245          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.Data, 8);
    246          	
    247          	pWriteBufPos += 8;	
    248          
    249          	if(RxMsg.ExtId==0x18fff7dd || RxMsg.ExtId==0x18fff747) // rcu status
    250          	{
    251          		memcpy( &rx_Realy_Control, (u8*)&RxMsg.Data, 8);
    252          	}
    253          
    254          	else if(RxMsg.ExtId==0x18EFFF47 || RxMsg.ExtId==0x18EF2847) // auto_position
    255          	{
    256          		if(RxMsg.Data[0] == 124)
    257          		{
    258          			memcpy( &rx_Auto_position_Status, (u8*)&RxMsg.Data, 8);
    259          		}
    260          		
    261          	}
    262          	else if(RxMsg.ExtId==0x18ff9447) // lamp
    263          	{
    264          		memcpy( &RX_HCEPGN_65428, (u8*)&RxMsg.Data, 8);
    265          	}
    266          	else if(RxMsg.ExtId == 0x18ffaa47)	// Weighing System (Work Load Lamp)
    267          	{
    268          		memcpy( &rx_Weighing_System_Status, (u8*)&RxMsg.Data, 8);
    269          	}
    270          	
    271          	else if(RxMsg.ExtId == 0x18ffede4)	// EHCU
    272          	{
    273          		memcpy( &rx_EHCU_Status, (u8*)&RxMsg.Data, 8);
    274          	}
    275          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    276          	
    277          }
    278          void RTCSend(void)
    279          {
    280          	if(pWriteBufPos >= (RING_BUF_SIZE-1)) // End of Ring Buffer
    281          		pWriteBufPos = 0;
    282          
    283          	memcpy(&ring_buf[pWriteBufPos], (u8*)&SerialMsgRTC[0], 12);
    284          
    285          	pWriteBufPos += 12;
    286          
    287          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    288          }
    289          
    290          
    291          void SendTo_E2PROM(void)
    292          {
    293          #if 1
    294          	if (SendEEPROMDataCnt < 2)	//	2번 보낸다.
    295          	{
    296          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[0], 8);
    297          		Uart2_SerialTxMsg[15] = 0xE1;
    298          	}	
    299          	else if (SendEEPROMDataCnt < 4)	//	2번 보낸다.
    300          	{
    301          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[8], 8);
    302          		Uart2_SerialTxMsg[15] = 0xE2;
    303          	}	
    304          	else
    305          	{
    306          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[16], 8);
    307          		Uart2_SerialTxMsg[15] = 0xE3;
    308          	}		
    309          
    310          	//  Enable the USART3 Transmit interrupt
    311          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    312          #endif
    313          }
    314          
    315          /******************************************************************************/
    316          /*            Cortex-M4 Processor Exceptions Handlers                         */
    317          /******************************************************************************/
    318          
    319          /**
    320            * @brief   This function handles NMI exception.
    321            * @param  None
    322            * @retval None
    323            */
    324          void NMI_Handler(void)
    325          {
    326          }
    327          
    328          /**
    329            * @brief  This function handles Hard Fault exception.
    330            * @param  None
    331            * @retval None
    332            */
    333          void HardFault_Handler(void)
    334          {
    335            /* Go to infinite loop when Hard Fault exception occurs */
    336            while (1)
    337            {
    338            }
    339          }
    340          
    341          /**
    342            * @brief  This function handles Memory Manage exception.
    343            * @param  None
    344            * @retval None
    345            */
    346          void MemManage_Handler(void)
    347          {
    348            /* Go to infinite loop when Memory Manage exception occurs */
    349            while (1)
    350            {
    351            }
    352          }
    353          
    354          /**
    355            * @brief  This function handles Bus Fault exception.
    356            * @param  None
    357            * @retval None
    358            */
    359          void BusFault_Handler(void)
    360          {
    361            /* Go to infinite loop when Bus Fault exception occurs */
    362            while (1)
    363            {
    364            }
    365          }
    366          
    367          /**
    368            * @brief  This function handles Usage Fault exception.
    369            * @param  None
    370            * @retval None
    371            */
    372          void UsageFault_Handler(void)
    373          {
    374            /* Go to infinite loop when Usage Fault exception occurs */
    375            while (1)
    376            {
    377            }
    378          }
    379          
    380          /**
    381            * @brief  This function handles SVCall exception.
    382            * @param  None
    383            * @retval None
    384            */
    385          void SVC_Handler(void)
    386          {
    387          }
    388          
    389          /**
    390            * @brief  This function handles Debug Monitor exception.
    391            * @param  None
    392            * @retval None
    393            */
    394          void DebugMon_Handler(void)
    395          {
    396          }
    397          
    398          /**
    399            * @brief  This function handles PendSVC exception.
    400            * @param  None
    401            * @retval None
    402            */
    403          void PendSV_Handler(void)
    404          {
    405          }
    406          
    407          /**
    408            * @brief  This function handles SysTick Handler.
    409            * @param  None
    410            * @retval None
    411            */
    412          void SysTick_Handler(void)
    413          {
    414            	TimeDelay_Decrement();
    415          
    416              ++WL9FM_TIME.Cnt_1mSec;
    417          
    418          	if (WL9FM_TIME.Cnt_1mSec % 1 == 0)                   //  1msec
    419          	{
    420                  WL9FM_TIME.Flag_1mSec = 1;
    421          
    422          		if (WL9FM_TIME.Cnt_1mSec % 10 == 0)              //  10msec
    423          		{
    424          			WL9FM_TIME.Flag_10mSec = 1;
    425          
    426          			if (WL9FM_TIME.Cnt_1mSec % 100 == 0)         //  100msec
    427          			{
    428          				WL9FM_TIME.Flag_100mSec = 1;
    429          
    430          				if(WL9FM_TIME.Cnt_1mSec % 500 == 0)			// 500msec
    431          				{
    432          					WL9FM_TIME.Flag_500mSec = 1;
    433          					if (WL9FM_TIME.Cnt_1mSec % 1000 == 0)    //  1000 msec
    434          					{
    435          						WL9FM_TIME.Flag_1Sec = 1;
    436          						WL9FM_TIME.Cnt_1mSec = 0;
    437          					}
    438          				}
    439          
    440          				
    441          			}
    442          		}
    443          	}    
    444          }
    445          
    446          /******************************************************************************/
    447          /*                 STM32F4xx Peripherals Interrupt Handlers                   */
    448          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    449          /*  available peripheral interrupt handler's name please refer to the startup */
    450          /*  file (startup_stm32f4xx.s).                                               */
    451          /******************************************************************************/
    452          
    453          /**
    454            * @brief  This function handles PPP interrupt request.
    455            * @param  None
    456            * @retval None
    457            */
    458          /*void PPP_IRQHandler(void)
    459          {
    460          }*/
    461          
    462          /**
    463            * @}
    464            */ 
    465          
    466          /**
    467            * @brief  This function handles CAN1 global interrupt request.
    468            * @param  None
    469            * @retval None
    470            */
    471          void CAN1_RX0_IRQHandler(void)
    472          {
    473          	u32 PF; 
    474          
    475          	CAN_Receive(CAN1,CAN_FIFO0,&RxMsg);
    476          				
    477          	Iden.Source_Address = (RxMsg.ExtId & 0x000000ff)  >> 0;
    478          	Iden.PDU_Specific = (RxMsg.ExtId  & 0x0000ff00) >> 8;
    479          	
    480          	// Iden.Source_Address == 71	 -->>	MCU
    481          	// Iden.Source_Address == 228	 -->>	EHCU	
    482          	// Iden.Source_Address == 0x29	 -->>	Smart Key
    483          	// Iden.Source_Address == 23	 -->>	Cluster
    484          	// Iden.Source_Address == 221	 -->>	RCU
    485          	// Iden.Source_Address == 0	 -->>	ECM
    486          	// Iden.Source_Address == 3	 -->>	TCU
    487          	
    488          	if((Iden.Source_Address == 71) || (Iden.Source_Address == 23) || (Iden.Source_Address == 0x29) || 
    489          		(Iden.Source_Address == 228) || (Iden.Source_Address == 221)|| (Iden.Source_Address == 0x4a)|| (Iden.Source_Address == 0xf4)
    490          		|| (Iden.Source_Address == 0x00)|| (Iden.Source_Address == 0x03))
    491          		{
    492          			if(++CanRecvCnt >= 100)
    493          			{
    494          				CanRecvCnt = 0;
    495          	
    496          				RTCSend();
    497          				
    498          			}
    499          	
    500          	
    501          			PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    502          	
    503          			if((PF == 254) || (PF == 255) || (PF == 239) )
    504          			{	
    505          				if(Iden.PDU_Specific == 251)
    506          				{
    507          					MoniInfoSendCnt = 0;
    508          					Flag_1Sec_MoniInfo = 0;
    509          					MoniInfoTotalPacketNum = 0;
    510          				}
    511          				else if(Iden.PDU_Specific == 232)	// Smart Key
    512          				{
    513          					smk_flag_data.recv_resp_packet |= RESPONSE_AUTHENTICATION;	
    514          					//smk_flag_data.recv_resp_packet |= 0x0100; 
    515          
    516          					memcpy((u8*)&recv_smartkey, (u8*)&RxMsg.Data[0], 8);
    517          				}
    518          				else
    519          				{
    520          					if( (Iden.PDU_Specific == 84)  ) 
    521          					{
    522          					
    523          						Buz1 = (RxMsg.Data[2] & 0x30 ) >> 4; 		// 1 :On 	0 : Off
    524          					
    525          						if( (Buz1 == 1))
    526          						{
    527          							Buzzer_SendToEXYNOS(1);
    528          						}
    529          						else
    530          						{
    531          							Buzzer_SendToEXYNOS(0);
    532          						}
    533          					}
    534          					//if(Iden.PDU_Specific == 0x9b)
    535          						OperateRingBuffer();
    536          				}
    537          			}
    538          			else if((PF == 235) || (PF == 236))
    539          			{
    540          				if((Iden.PDU_Specific == 255)||(Iden.PDU_Specific == 0x28))
    541          				{
    542          					if(PF == 236)		// TP.CM_BAM
    543          					{ 
    544          						if(RxMsg.Data[0] == 32) 	// Control Byte (Normal)
    545          						{
    546          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    547          							if(pgn == 65340)
    548          							{
    549          								TotPacketNum = RxMsg.Data[3];		// Total number of packets
    550          								TotMsgSize = (RxMsg.Data[2] << 8) | RxMsg.Data[1];
    551          							}
    552          							else
    553          							{
    554          								Uart2_SerialTxMsg[15] = 0;
    555          								OperateRingBuffer();
    556          							}
    557          							return;
    558          						}
    559          
    560          						else if(RxMsg.Data[0] == 17)	// Control Byte (CTS) 0x11
    561          						{
    562          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    563          							if(pgn == 61184)
    564          							{
    565          								RTSFlag_61184 = 2;
    566          							}
    567          							
    568          						}
    569          						else if(RxMsg.Data[0] == 19)	// Control Byte (ACK) 0x13 
    570          						{
    571          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    572          							if(pgn == 61184)
    573          							{
    574          								RTSFlag_61184 = 0;
    575          							}
    576          						}
    577          						else if(RxMsg.Data[0] == 16)	// Control Byte (RTS) 0x10
    578          						{
    579          							if(Iden.Source_Address == 0x4a)
    580          							{
    581          								Uart2_SerialTxMsg[15] = 0;
    582          								OperateRingBuffer();
    583          								RMCUpgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    584          								if(RMCUpgn == 61184)
    585          								{
    586          									 Send_CTS_61184(RxMsg.Data,0x4A);
    587          									 RMCU_CTSFlag_61184 = 1;
    588          									 RMCU_RecvTotalPacket_61184 = RxMsg.Data[3];
    589          									 memcpy((u8*)RMCU_ACK_Multi_61184,(u8*)RxMsg.Data,8);
    590          								}
    591          							}
    592          							else
    593          							{
    594          								Uart2_SerialTxMsg[15] = 0;
    595          								OperateRingBuffer();
    596          								pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    597          								if(pgn == 61184)
    598          								{
    599          									 Send_CTS_61184(RxMsg.Data,71);
    600          									 CTSFlag_61184 = 1;
    601          									 RecvTotalPacket_61184 = RxMsg.Data[3];
    602          									 memcpy((u8*)ACK_Multi_61184,(u8*)RxMsg.Data,8);
    603          								}
    604          							}
    605          							
    606          							
    607          							
    608          						}
    609          
    610          								
    611          					}
    612          	
    613          					if(Iden.Source_Address == 0x4a)
    614          					{
    615          						if(PF == 235)
    616          						{
    617          							Uart2_SerialTxMsg[15] = 0;
    618          							OperateRingBuffer();
    619          							if(RMCUpgn == 61184)
    620          							{
    621          								if(RMCU_RecvTotalPacket_61184 == RxMsg.Data[0])
    622          								{
    623          									RMCU_RecvTotalPacket_61184 = 0;
    624          									Send_ACK_61184(RMCU_ACK_Multi_61184,0x4a);
    625          								}
    626          							
    627          							}
    628          
    629          							
    630          						}
    631          					}else
    632          					{
    633          						if(PF == 235)
    634          						{
    635          							if(pgn == 65340)
    636          							{
    637          								memcpy(&MachineBasicInformation[(RxMsg.Data[0]-1)*7], &RxMsg.Data[1] , 7);
    638          								if(RxMsg.Data[0] == TotPacketNum)
    639          								{
    640          									pgn = TotPacketNum = 0;
    641          									RecvMachInfo = 1;
    642          								}
    643          							}
    644          							
    645          							else
    646          							{
    647          								Uart2_SerialTxMsg[15] = 0;
    648          								OperateRingBuffer();
    649          							}
    650          
    651          							if(pgn == 61184)
    652          							{
    653          								if(RecvTotalPacket_61184 == RxMsg.Data[0])
    654          								{
    655          									RecvTotalPacket_61184 = 0;
    656          									Send_ACK_61184(ACK_Multi_61184,71);
    657          								}
    658          							
    659          							}
    660          						}
    661          					}
    662          					
    663          				}
    664          			}
    665          	
    666          			CommErrCnt = 0;
    667          		}
    668          
    669          }
    670          
    671          /**
    672            * @brief  This function handles TIM4 global interrupt request.
    673            * @param  None
    674            * @retval None
    675            */
    676          void TIM4_IRQHandler(void)  //  10msec Timer / TimeBase UP Counter
    677          {
    678              TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    679              
    680              //  BUZZER Status가 "2" 일 경우 BUZZER OnTime 만큼 BUZZER On
    681              if (WL9FM_BUZZER.Status == 2)
    682              {
    683                  if (WL9FM_BUZZER.OnCnt++ < WL9FM_BUZZER.OnTime)
    684                  {
    685                      Buzzer_On();
    686                  }
    687                  else
    688                  {
    689                      WL9FM_BUZZER.Status = 0;               
    690                  }
    691              }        
    692              //  BUZZER Status가 "1" 일 경우 UnLimit BUZZER On
    693              else if (WL9FM_BUZZER.Status == 1)
    694              {
    695                  Buzzer_On();    
    696              }    
    697              else
    698              {
    699                  Buzzer_Off();
    700                  
    701                  WL9FM_BUZZER.Status = 0;               
    702                  WL9FM_BUZZER.OnTime = 0;
    703                  WL9FM_BUZZER.OnCnt  = 0;
    704              }
    705          
    706          #if 1
    707          	CommErrCnt++;
    708          
    709          	if(CommErrCnt >= 1000)
    710          		CommErrCnt = 1001;
    711          #endif
    712          }
    713          
    714          /**
    715            * @brief  This function handles TIM5 global interrupt request.
    716            * @param  None
    717            * @retval None
    718            */
    719          void TIM5_IRQHandler(void)  //  5msec Timer / TimeBase UP Counter    
    720          {
    721              TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
    722              
    723              KeySwitch_Process();    //  KeySwitch.c Func
    724          }
    725          
    726          /**
    727            * @brief  This function handles USART3 global interrupt request.
    728            * @param  None
    729            * @retval None
    730            */
    731            // STM32F407 <-> exynos4412 can_data
    732          
    733          unsigned char temp_61184;
    734          
    735          void USART2_IRQHandler(void)
    736          {
    737          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    738          	{
    739          		Uart2_SerialRxMsg[Uart2_SerialRxCnt] = (u8)USART_ReceiveData(USART2);
    740          
    741          		  //  디버깅할 때만 사용할 것
    742          		#ifdef DEBUG_CAN_RX
    743          		DebugMsg_printf("%2x ", Uart2_SerialRxMsg[Uart2_SerialRxCnt]);
    744          		#endif
    745          		
    746          		switch(Uart2_SerialRxCnt)
    747          		{
    748          			case 0:
    749          				if(Uart2_SerialRxMsg[0] == 0x02)		// STX
    750          					Uart2_SerialRxCnt++;
    751          				break;
    752          			case 1:
    753          				if(Uart2_SerialRxMsg[1] == 0xF5)		// ID
    754          					Uart2_SerialRxCnt++;
    755          				else
    756          					Uart2_SerialRxCnt = 0;
    757          				break;
    758          			case UART2_Rx_BUF_SIZE-1:
    759          				Uart2_SerialRxCnt = 0;
    760          
    761          				if(Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE-1] == 0x03)		// ETX
    762          				{
    763                              			//  디버깅할 때만 사용할 것
    764          					#ifdef DEBUG_CAN_RX
    765          					DebugMsg_printf("\r\n");
    766          					#endif
    767          					
    768          					switch(Uart2_SerialRxMsg[3])		// Cmd
    769          					{
    770          						case 1 :		// UART TX Start Flag
    771          							Flag_UartTxStart = 1;
    772          							Flag_TxE2pRomData=0;
    773          							SendEEPROMDataCnt=0;
    774          							break;
    775          						case 2 :	// Save Data1
    776          							memcpy(&Uart2_RxMsg_Save_Data1[0], &Uart2_SerialRxMsg[4], 8);
    777          							break;
    778          						case 3 :	// Save Data2
    779          							memcpy(&Uart2_RxMsg_Save_Data2[0], &Uart2_SerialRxMsg[4], 8);
    780          							break;
    781          						case 4 :	// A/S Phone Number -> Save to EEPROM
    782          							memcpy(&Uart2_RxMsg_AS_Phone_Data[0], &Uart2_SerialRxMsg[4], 8);
    783          							break;
    784          
    785          							
    786          						
    787          							case 11 : memcpy(&Uart2_RxMsg_Single_11[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_11));	Flag_SerialRxMsg |= RX_MSG11; break;
    788          							case 12 : memcpy(&Uart2_RxMsg_Single_12[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_12));	Flag_SerialRxMsg |= RX_MSG12;break;
    789          							case 21 : memcpy(&Uart2_RxMsg_Single_21[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_21));	Flag_SerialRxMsg |= RX_MSG21;break;
    790          							case 23 : memcpy(&Uart2_RxMsg_Multi_23[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Multi_23));	Flag_SerialRxMsg |= RX_MSG23; RTSFlag_61184 = 1;break;
    791          							case 61 : memcpy(&Uart2_RxMsg_Single_61[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_61));	Flag_SerialRxMsg |= RX_MSG61;break;
    792          							case 62 : memcpy(&Uart2_RxMsg_Single_62[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_62));	Flag_SerialRxMsg |= RX_MSG62;break;
    793          							case 101 : memcpy(&Uart2_RxMsg_Single_101[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_101));Flag_SerialRxMsg |= RX_MSG101;	break;
    794          							case 104 : memcpy(&Uart2_RxMsg_Single_104[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_104));	Flag_SerialRxMsg |= RX_MSG104;break;
    795          							case 105 : memcpy(&Uart2_RxMsg_Single_105[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_105));	Flag_SerialRxMsg |= RX_MSG105;break;
    796          							case 109 : memcpy(&Uart2_RxMsg_Single_109[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_109));	Flag_SerialRxMsg |= RX_MSG109;break;
    797          							case 121 : memcpy(&Uart2_RxMsg_Single_121[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_121));	Flag_SerialRxMsg |= RX_MSG121;break;
    798          							case 123 : memcpy(&Uart2_RxMsg_Single_123[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_123));	Flag_SerialRxMsg |= RX_MSG123;break;
    799          							case 201 : memcpy(&Uart2_RxMsg_Single_201[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_201));	Flag_SerialRxMsg |= RX_MSG201;break;
    800          							case 203 : memcpy(&Uart2_RxMsg_Single_203[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_203));	Flag_SerialRxMsg |= RX_MSG203;break;
    801          								
    802          								
    803          							case 47 : memcpy(&Uart2_RxMsg_Single_47[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_47));	break;
    804          								
    805          							case 145 : memcpy(&Uart2_RxMsg_Multi_145[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Multi_145));	Flag_SerialRxMsg |= RX_MSG145;break;
    806          							case 247 : memcpy(&Uart2_RxMsg_Single_247[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_247));	Flag_SerialRxMsg |= RX_MSG247;break;
    807          
    808          
    809          							// smart key
    810          							case 210 :	// Smart Key Registration, Elimination
    811          							memcpy(&Uart2_RxMsg_Smk_Reg_Eli[0], &Uart2_SerialRxMsg[4], 8);
    812          							break;
    813          
    814          						#if 0
    815          							
    816          						case 203 :  // for EHCU setting 61184 format 131017
    817          							Flag_SerialRxMsg |= RX_MSG203;
    818          							memcpy(&Uart2_RxMsg_Single_46[0], &Uart2_SerialRxMsg[4], 8);
    819          							break;
    820          						case 69 :	// When needed
    821          							Flag_SerialRxMsg |= RX_MSG69;
    822          							memcpy(&Uart2_RxMsg_Single_69[0], &Uart2_SerialRxMsg[4], 8);
    823          							break;
    824          						case 70 :	// When needed - RX_MSG69 Multi Packet
    825          							Flag_SerialRxMsg |= RX_MSG69_M;
    826          							memcpy(&Uart2_RxMsg_Multi_69[0], &Uart2_SerialRxMsg[4], 21);
    827          							break;
    828          						case 160 :	// 100 ms
    829          							if((Uart2_RxMsg_Single_160[0] & 0xc0) == 0xc0)
    830          								memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    831          							else
    832          							{
    833          								memcpy(&Uart2_RxMsg_Single_160[1], &Uart2_SerialRxMsg[5], 7);
    834          								Uart2_RxMsg_Single_160[0] |= (Uart2_SerialRxMsg[4] & 0x3F);
    835          							}
    836          																						
    837          							if(((Uart2_SerialRxMsg[4] & 0xc0) == 0x00) || ((Uart2_SerialRxMsg[4] & 0xc0) == 0x40))
    838          							        memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    839          							break;
    840          						case 161 :	// When needed
    841          							Flag_SerialRxMsg |= RX_MSG161;
    842          							memcpy(&Uart2_RxMsg_Multi_161[0], &Uart2_SerialRxMsg[4], 14);
    843          							temp_61184=0;
    844          							break;
    845          						case 162 :	// When needed
    846          							//Flag_SerialRxMsg |= RX_MSG162;
    847          							if(Uart2_RxMsg_Single_162[4] == 0)
    848          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 8);
    849          							else
    850          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 4);
    851          							break;	
    852          						case 163 :
    853          							Flag_SerialRxMsg |= RX_MSG163;
    854          							memcpy(&Uart2_RxMsg_Single_163[0], &Uart2_SerialRxMsg[4], 8);
    855          							break;
    856          						case 174 :
    857          							Flag_SerialRxMsg |= RX_MSG174;
    858          							memcpy(&Uart2_RxMsg_Single_174[0], &Uart2_SerialRxMsg[4], 8);
    859          							break;
    860          						case 205 :	// Stop Send Cmd - A/S Phone Number
    861          							stop_send_as_phone_data = 1;
    862          							break;
    863          
    864          						case 210 :	// Smart Key Registration, Elimination
    865          							memcpy(&Uart2_RxMsg_Smk_Reg_Eli[0], &Uart2_SerialRxMsg[4], 8);
    866          							break;
    867          						case 247 :
    868          							Flag_SerialRxMsg |= RX_MSG247;
    869          							memcpy(&Uart2_RxMsg_Single_247[0], &Uart2_SerialRxMsg[4], 8);							
    870          							break;	
    871          						case 251 :
    872          							Flag_SerialRxMsg |= RX_MSG251;
    873          							memcpy(&Uart2_RxMsg_Single_251[0], &Uart2_SerialRxMsg[4], 8);							
    874          							break;
    875          						case 252 :	// Clock Set Data
    876          							Flag_SerialRxMsg |= RX_MSG252;
    877          							memcpy(&Uart2_RxMsg_Single_252[0], &Uart2_SerialRxMsg[4], 8);							
    878          							break;
    879          						case 253 :
    880          							Flag_SerialRxMsg |= RX_MSG253;
    881          							memcpy(&Uart2_RxMsg_Single_253[0], &Uart2_SerialRxMsg[4], 8);							
    882          							break;
    883          						case 101 :
    884          						case 102 :
    885          						case 109 : 
    886          						case 61 : 
    887          						case 31 : 
    888          						case 33 : 
    889          						case 34 : 
    890          						case 123 : 
    891          							Flag_SerialRxMsg |= RX_MSG239;
    892          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);		
    893          								
    894          							temp_61184++;
    895          							
    896          							break;
    897          
    898          						case 121 :
    899          							Flag_SerialRxMsg |= RX_MSG239;
    900          							Flag_SerialRxMsg |= RX_MSG239_121;
    901          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);	
    902          							memcpy(&Uart2_RxMsg_Single_239_121[0], &Uart2_SerialRxMsg[4], 8);	
    903          							temp_61184++;
    904          							break;
    905          					#endif
    906          						
    907          					}
    908          				}
    909          				else
    910          				{
    911          					//  디버깅할 때만 사용할 것
    912          					//DebugMsg_printf("Protocol Fail\r\n");
    913          				}
    914          
    915          				break;
    916          			
    917          			default :
    918          				Uart2_SerialRxCnt++;
    919          				break;
    920          		}
    921          	}
    922          
    923          	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    924          	{   
    925          		if((USART2->SR & 0x80) == RESET)
    926          			return;
    927          
    928          		if (pWriteBufPos == pReadBufPos)
    929          		{
    930          			if(Flag_TxE2pRomData == 1)
    931          			{
    932          			    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    933          			    return;
    934          		    	}
    935          		}
    936          
    937          		if(pReadBufPos >= (RING_BUF_SIZE-1))
    938          			pReadBufPos = 0;
    939          
    940          		if((Uart2_SerialTxCnt == 0) && (pWriteBufPos != pReadBufPos))
    941          		{
    942          			memcpy(&Uart2_SerialTxMsg[3] , &ring_buf[pReadBufPos], 12);
    943          		}
    944          		
    945          		USART_SendData(USART2, (u16)(Uart2_SerialTxMsg[Uart2_SerialTxCnt++]));    
    946          		
    947          		if (Uart2_SerialTxCnt >= UART2_Tx_BUF_SIZE)
    948          		{
    949          			//Uart2_SerialTxCnt = 0;
    950          			//pReadBufPos += 12;
    951          			//USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    952          
    953          			if(Flag_TxE2pRomData == 0)
    954          			{
    955                          		//  보내는 횟수 중요하다. 초기에 버그가 생실 수 있으니, 테스트 필요함!!!
    956          				//	EEPROM Data를 6번 보낸다.
    957          				if(SendEEPROMDataCnt > 5)	
    958          				{
    959          					Uart2_SerialTxCnt = 0;	
    960          					Uart2_SerialTxMsg[15] = 0;
    961          					Flag_TxE2pRomData = 1;
    962          						
    963          					//	EEPROM Data를 그만 보내고 CAN Data를 보낸다. 
    964          					Flag_UartTxStart = 0;
    965          					
    966          					//  Enable the USART2 Transmit interrupt
    967          					USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    968          					CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);			
    969          				}
    970          				else
    971          				{
    972          					SendEEPROMDataCnt++;
    973          			        	Uart2_SerialTxCnt = 0;
    974          
    975          					//  Disable the USART3 Transmit interrupt
    976          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    977          				}
    978          			}
    979          			else
    980          			{
    981          				Uart2_SerialTxCnt = 0;
    982          				pReadBufPos += 12;
    983          			}
    984          		}  
    985          	}
    986          }
    987          
    988          void UART4_IRQHandler(void)
    989          {
    990          	//  UART4 receive interrupt routine
    991          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) 
    992              	{
    993              		if(Change_UART4_for_Download==0)
    994          			UART4_Receive_CMD();
    995          		else
    996          			UART4_Receive_File();
    997          				
    998          	}
    999          	//  UART4 transmit interrupt routine
   1000          	if (USART_GetITStatus(UART4, USART_IT_TXE) != RESET)
   1001          	{   
   1002          		UART4_transmit_CMD();
   1003          	}
   1004          }
   1005          
   1006          u8 temp_rx_buf[4];
   1007          
   1008          
   1009          void UART4_Receive_CMD(void)
   1010          {
   1011          	uint8_t Temp[Serial_COM4_TxSize];
   1012          	//  Read one byte to the receive data register
   1013          	WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt] = USART_ReceiveData(UART4);
   1014          
   1015          	
   1016              	//  디버깅할 때만 사용할 것
   1017          	#ifdef DEBUG_CMD_RX
   1018          	DebugMsg_printf("%2x ", WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt]);
   1019          	#endif
   1020          
   1021          	
   1022          	switch (WL9FM_USART_INDEX.COM4_RxCnt)
   1023          	{
   1024          		case 0:
   1025          				if (WL9FM_USART_DATA.COM4_RxBuf[0] == STX)
   1026          				{
   1027          					WL9FM_USART_INDEX.COM4_RxCnt++;
   1028          				}	
   1029          				else
   1030          				{
   1031          					WL9FM_USART_INDEX.COM4_RxCnt=0;
   1032          				}
   1033          				
   1034          				break;
   1035          		case 1:
   1036          				if (WL9FM_USART_DATA.COM4_RxBuf[1]      == KeyCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
   1037          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LCDBLCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
   1038          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == BUZZERCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
   1039          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LAMPCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
   1040          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CAMCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
   1041          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == DOWNCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
   1042          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionHighCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
   1043          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionLowCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
   1044          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionSubCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
   1045          				else if ((WL9FM_USART_DATA.COM4_RxBuf[1]&0x80) == 0x80)	WL9FM_USART_INDEX.COM4_RxCnt++;          
   1046                          else
   1047                          {
   1048                            	WL9FM_USART_INDEX.COM4_RxCnt = 0;
   1049                          }
   1050          				break;
   1051          
   1052          		case 3: 
   1053          				WL9FM_USART_INDEX.COM4_RxCnt = 0;
   1054          				
   1055          				//  디버깅할 때만 사용할 것
   1056          				#ifdef DEBUG_CMD_RX
   1057          				DebugMsg_printf("\r\n");
   1058          				#endif
   1059          
   1060          		if (WL9FM_USART_DATA.COM4_RxBuf[Serial_COM4_RxSize-1] == ETX)
   1061          		{
   1062          			switch (WL9FM_USART_DATA.COM4_RxBuf[1])
   1063          			{
   1064          				case KeyCMD   :		//	Key Command
   1065          
   1066          					break;
   1067          							
   1068          				case LCDBLCMD :		//	LCD BackLight Command
   1069          
   1070          					//	LCD BackLight Level 조절.. Level0 ~ Level8
   1071          					if (WL9FM_USART_DATA.COM4_RxBuf[2] < MaxBackLightLEVEL && (WL9FM_USART_DATA.COM4_RxBuf[2] > 0)) 												
   1072          					{
   1073          						LCDBL_PWM_LEVEL(WL9FM_USART_DATA.COM4_RxBuf[2]);
   1074          					}
   1075          
   1076          					break;
   1077          
   1078          				case BUZZERCMD :	//	Buzzer Command
   1079          					break;
   1080          
   1081          				case LAMPCMD :	//	Buzzer Command
   1082          					Lamp_name = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0xf0)>>4;
   1083          					Lamp_Value = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0x0f);
   1084          					
   1085          					Lamp_Update_State();
   1086          					break;
   1087          					
   1088          				case CAMCMD:
   1089          					cam_mode_change(WL9FM_USART_DATA.COM4_RxBuf[2]);
   1090          					break;
   1091          
   1092          				case DOWNCMD:
   1093          					Stm32_Update_CMD = WL9FM_USART_DATA.COM4_RxBuf[2];
   1094          					ST_Update=1;
   1095          					break;
   1096          				case  DUMMYCMD:
   1097          					CMD_DUMMY_SendToExynos(0);
   1098          					break;
   1099          				case VersionHighCMD:
   1100          					
   1101          					Temp[0] = 0x02;				
   1102          					Temp[1] = VersionHighCMD;				
   1103          					Temp[2] = VERSION_HIGH ;	
   1104          					Temp[3] = 0x03;	
   1105          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1106          					break;
   1107          				case VersionLowCMD:
   1108          					
   1109          					Temp[0] = 0x02;				
   1110          					Temp[1] = VersionLowCMD;				
   1111          					Temp[2] = VERSION_LOW ;	
   1112          					Temp[3] = 0x03;	
   1113          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1114          					break;
   1115          				case VersionSubCMD:
   1116          					
   1117          					Temp[0] = 0x02;				
   1118          					Temp[1] = VersionSubCMD;				
   1119          					Temp[2] = VERSION_SUB ;	
   1120          					Temp[3] = 0x03;	
   1121          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1122          					break;
   1123          				default :
   1124          					break;								
   1125          			}
   1126                          }						
   1127          
   1128          		//memset(WL9FM_USART_DATA.COM4_RxBuf, 0x0, Serial_COM4_RxSize);					
   1129          				break;
   1130          		
   1131          		default :
   1132          
   1133          			WL9FM_USART_INDEX.COM4_RxCnt++;
   1134          			break;
   1135          	}	
   1136          }
   1137          
   1138          void UART4_Receive_File(void)
   1139          {
   1140          	
   1141          	//  Read one byte to the receive data register
   1142          	WL9FM_USART_RX_FILE_DATA.File_RxBuf[WL9FM_USART_RX_FILE_DATA.File_RxCnt] = USART_ReceiveData(UART4);
   1143          	
   1144          	switch (WL9FM_USART_RX_FILE_DATA.File_RxCnt)
   1145          	{
   1146          		case 0:
   1147          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[0] == STX)
   1148          				{
   1149          					WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1150          				}						
   1151          				break;
   1152          		case 1029: 
   1153          				WL9FM_USART_RX_FILE_DATA.File_RxCnt = 0;
   1154          					
   1155          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == ETX)
   1156          				{
   1157          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1158          					ST_Update=1;
   1159          				}
   1160          				else if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == EOT)
   1161          				{
   1162          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1163          					Change_UART4_for_Download =2;
   1164          					ST_Update=1;
   1165          				}
   1166          				else
   1167          				{
   1168          					ACK_NACK_SendToExynos(NAK);
   1169          				}
   1170                                          break;
   1171          		default :
   1172          
   1173          			WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1174          			break;
   1175          	}					
   1176          }
   1177          
   1178          
   1179          void UART4_transmit_CMD(void)
   1180          {
   1181          	//  Write one byte to the transmit data register
   1182          	USART_SendData(UART4, WL9FM_USART_DATA.COM4_TxBuf[WL9FM_USART_INDEX.COM4_TxCnt++]);
   1183          
   1184          	if (WL9FM_USART_INDEX.COM4_TxIdx >= Serial_COM4_TxSize)
   1185          	{
   1186          		WL9FM_USART_INDEX.COM4_TxIdx = Serial_COM4_TxSize;
   1187          	}    
   1188          	if (WL9FM_USART_INDEX.COM4_TxCnt == WL9FM_USART_INDEX.COM4_TxIdx)
   1189          	{
   1190          		//  Disable the UART4 Transmit interrupt
   1191          		USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   1192          
   1193          		WL9FM_USART_INDEX.COM4_TxIdx = 0; //  transmit buffer Index clear
   1194          		WL9FM_USART_INDEX.COM4_TxCnt = 0; //  transmit buffer Cnt   clear
   1195          	}              
   1196          }
   1197          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BusFault_Handler
      16   CAN1_RX0_IRQHandler
        16   -> Buzzer_SendToEXYNOS
        16   -> CAN_Receive
         0   -> OperateRingBuffer
        16   -> OperateRingBuffer
        16   -> RTCSend
        16   -> Send_ACK_61184
        16   -> Send_CTS_61184
        16   -> __aeabi_memcpy
       0   DebugMon_Handler
       0   HardFault_Handler
       0   MemManage_Handler
       0   NMI_Handler
      16   OperateRingBuffer
         0   -> USART_ITConfig
        16   -> memcpy
       0   PendSV_Handler
       8   RTCSend
         0   -> USART_ITConfig
         8   -> memcpy
       0   SVC_Handler
       8   SendTo_E2PROM
         0   -> USART_ITConfig
         8   -> memcpy
       8   SysTick_Handler
         8   -> TimeDelay_Decrement
       8   TIM4_IRQHandler
         8   -> Buzzer_Off
         8   -> Buzzer_On
         8   -> TIM_ClearITPendingBit
       8   TIM5_IRQHandler
         0   -> KeySwitch_Process
         8   -> TIM_ClearITPendingBit
       8   UART4_IRQHandler
         8   -> UART4_Receive_CMD
         8   -> UART4_Receive_File
         8   -> UART4_transmit_CMD
         8   -> USART_GetITStatus
       8   UART4_Receive_CMD
         8   -> CMD_DUMMY_SendToExynos
         8   -> LCDBL_PWM_LEVEL
         8   -> Lamp_Update_State
         8   -> USART_ReceiveData
         8   -> USARTx_EXYNOS
         8   -> cam_mode_change
       8   UART4_Receive_File
         0   -> ACK_NACK_SendToExynos
         8   -> USART_ReceiveData
         8   -> __aeabi_memcpy
      16   UART4_transmit_CMD
        16   -> USART_ITConfig
        16   -> USART_SendData
      24   USART2_IRQHandler
         0   -> CAN_ITConfig
        24   -> USART_GetITStatus
         0   -> USART_ITConfig
        24   -> USART_ITConfig
        24   -> USART_ReceiveData
        24   -> USART_SendData
        24   -> __aeabi_memcpy
       0   UsageFault_Handler
       0   WL9F_CAN_Buffer_Init
       8   memcpy
         8   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_57
       4  ??DataTable13_58
       4  ??DataTable13_59
       4  ??DataTable13_6
       4  ??DataTable13_60
       4  ??DataTable13_61
       4  ??DataTable13_62
       4  ??DataTable13_63
       4  ??DataTable13_64
       4  ??DataTable13_65
       4  ??DataTable13_66
       4  ??DataTable13_67
       4  ??DataTable13_68
       4  ??DataTable13_69
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      18  ?Subroutine0
       8  ?Subroutine1
       2  BusFault_Handler
     620  CAN1_RX0_IRQHandler
       2  DebugMon_Handler
       2  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
     210  OperateRingBuffer
       2  PendSV_Handler
      44  RTCSend
      20  RxMsg
       2  SVC_Handler
      60  SendTo_E2PROM
       1  Stm32_Update_CMD
     106  SysTick_Handler
      86  TIM4_IRQHandler
      20  TIM5_IRQHandler
      56  UART4_IRQHandler
     312  UART4_Receive_CMD
     108  UART4_Receive_File
      64  UART4_transmit_CMD
     862  USART2_IRQHandler
      32  Uart2_SerialRxMsg
          Uart2_SerialRxCnt
          Flag_TxE2pRomData
          pReadBufPos
    7728  Uart2_SerialTxMsg
          Iden
          CanRecvCnt
          Uart2_SerialTxCnt
          SendEEPROMDataCnt
          Buz1
          pWriteBufPos
          TotPacketNum
          TotMsgSize
          CommErrCnt
          pgn
          RMCUpgn
          ring_buf
       2  UsageFault_Handler
      36  WL9F_CAN_Buffer_Init
      12  memcpy
       2  old_test
       1  stop_send_as_phone_data
       1  temp_61184
       4  temp_rx_buf
       2  test
       8  test_temp

 
 7 799 bytes in section .bss
 2 918 bytes in section .text
 
 2 906 bytes of CODE memory (+ 12 bytes shared)
 7 799 bytes of DATA memory

Errors: none
Warnings: none
