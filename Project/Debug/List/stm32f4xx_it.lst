###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      21/Dec/2017  14:06:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pla #
#                    tform\COMMON\SRC\stm32f4xx_it.c                          #
#    Command line =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pla #
#                    tform\COMMON\SRC\stm32f4xx_it.c -D USE_STDPERIPH_DRIVER  #
#                    -D STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT     #
#                    -lcN D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_AP #
#                    P\Project\Debug\List\ -o D:\GIT\WLF_MONITOR\ECS_MS12_02_ #
#                    WLF_MONITOR_STM32_APP\Project\Debug\Obj\ --debug         #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp        #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32 #
#                    _APP\Project\..\Platform\COMMON\INC\ -I                  #
#                    "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pr #
#                    oject\..\Platform\TaeHa - ECS\INC\" -I                   #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\ -I  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\ -Oh    #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\List\stm32f4xx_it.lst                         #
#    Object file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\stm32f4xx_it.o                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Platform\COMMON\SRC\stm32f4xx_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    Project/STM32F4xx_StdPeriph_Template/stm32f4xx_it.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    13-April-2012
      7            * @brief   Main Interrupt Service Routines.
      8            *          This file provides template for all exceptions handler and 
      9            *          peripherals interrupt service routine.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "stm32f4xx_it.h"
     32          #include "main.h"
     33          
     34          /** @addtogroup Template_Project
     35            * @{
     36            */
     37          
     38          /* Private typedef -----------------------------------------------------------*/
     39          
     40          //#define		DEBUG_CMD_RX
     41          //#define		DEBUG_CMD_TX
     42          //#define		DEBUG_CAN_RX
     43          //#define		DEBUG_CAN_TX
     44          #pragma pack(1)
     45          struct st_CAN_Msg
     46          {	
     47          	unsigned char Priority;
     48          	unsigned char Data_Page;
     49          	unsigned char PDU_Format;	
     50          	unsigned char PDU_Specific;		// 50
     51          	unsigned char Source_Address;	// 52
     52          };
     53          #pragma pack()
     54          
     55          CanRxMsg RxMsg;
     56          struct st_CAN_Msg Iden; 
     57          
     58          extern Realy_Control		rx_Realy_Control;
     59          extern EHCU_Status		rx_EHCU_Status;
     60          extern Auto_position_Status rx_Auto_position_Status;
     61          extern st_CANDATA_HCEPGN_65428	RX_HCEPGN_65428;
     62          extern WEIGHING_SYSTEM_STATUS_65450 rx_Weighing_System_Status;
     63          extern CMD_LAMP rx_CMD_LAMP;
     64          /* Private define ------------------------------------------------------------*/
     65          
     66          #define RING_BUF_SIZE			768
     67          #define UART2_Rx_BUF_SIZE		14			
     68          #define UART2_Tx_BUF_SIZE		17
     69          
     70          /*
     71          #define RX_MSG69		0x01
     72          #define RX_MSG69_M		0x02
     73          #define RX_MSG145		0x04
     74          #define RX_MSG161		0x08
     75          #define RX_MSG162		0x10
     76          #define RX_MSG163		0x20
     77          #define RX_MSG251		0x40
     78          #define RX_MSG252		0x80
     79          #define RX_MSG202		0x100
     80          #define RX_MSG253		0x200
     81          #define RX_MSG203		0x400
     82          #define RX_MSG239		0x800
     83          #define RX_MSG247		0x1000
     84          #define RX_MSG174		0x2000
     85          #define RX_MSG239_121	0x4000
     86          */
     87          #define RX_MSG11	0x01
     88          #define RX_MSG12	0x02
     89          #define RX_MSG21	0x04
     90          #define RX_MSG23	0x08
     91          #define RX_MSG61	0x10
     92          #define RX_MSG62	0x20
     93          #define RX_MSG101	0x40
     94          #define RX_MSG104	0x80
     95          #define RX_MSG105	0x100
     96          #define RX_MSG109	0x200
     97          #define RX_MSG121	0x400
     98          #define RX_MSG123	0x800
     99          #define RX_MSG201	0x1000
    100          #define RX_MSG203	0x2000
    101          		
    102          		
    103          #define RX_MSG47	0x4000
    104          		
    105          #define RX_MSG145	0x8000
    106          #define RX_MSG247	0x10000
    107          
    108          
    109          
    110          
    111          
    112          /* Private define ------------------------------------------------------------*/
    113          #define CPU_DIE_CTL(x)		GPIO_WriteBit(CPU_DIE_PORT,CPU_DIE,x)			// ++, --, 160511 bwk
    114          #define EXT_WATCHDOG_ENALBE(x)					GPIO_WriteBit(WD_EN_PORT, WD_EN,x)		// ++, --, 160519 bwk
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          u8 ring_buf[RING_BUF_SIZE];		
    118          u16 pWriteBufPos = 0;
    119          u16 pReadBufPos = 0;
    120          u8 CanRecvCnt = 0;
    121          u16 TotPacketNum = 0;
    122          u32 pgn = 0;
    123          u32 RMCUpgn = 0;
    124          u16 TotMsgSize = 0;
    125          u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    126          u8 Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE];
    127          
    128          u8 Uart2_SerialTxCnt = 0;
    129          u8 Uart2_SerialRxCnt = 0;
    130          u16 CommErrCnt = 0;
    131          
    132          u8 SendEEPROMDataCnt = 0;
    133          u8 Flag_TxE2pRomData = 0;
    134          u8 stop_send_as_phone_data = 0;
    135          u8 Stm32_Update_CMD;
    136          u8 FatoryInit_Flag = 0;
    137          u8 CANUpdateFlag = 0;
    138          u8 CANUpdateSA = 0;
    139          
    140          
    141          u8 Buz1;
    142          
    143          extern u8 MoniInfoSendCnt;
    144          extern u8 MoniInfoTotalPacketNum;
    145          extern u8 RecvMachInfo;
    146          extern u8 MachineBasicInformation[78];
    147          extern u8 RTSFlag_61184;
    148          extern u8 CTSFlag_61184;
    149          extern u8 RecvTotalPacket_61184;
    150          extern u8 ACK_Multi_61184[8];
    151          extern u8 RMCU_CTSFlag_61184;
    152          extern u8 RMCU_RecvTotalPacket_61184;
    153          extern u8 RMCU_ACK_Multi_61184[8];
    154          
    155          
    156          
    157          extern u8 Flag_UartTxStart;
    158          extern u32 Flag_SerialRxMsg;
    159          extern u8 eepRomReadData1[32];
    160          
    161          extern u8 Uart2_RxMsg_Save_Data1[8];
    162          extern u8 Uart2_RxMsg_Save_Data2[8];
    163          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    164          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    165          
    166          extern u8 Uart2_RxMsg_Single_46[8];
    167          extern u8 Uart2_RxMsg_Single_69[8];
    168          extern u8 Uart2_RxMsg_Multi_69[21];
    169          extern u8 Uart2_RxMsg_Single_160[8];
    170          extern u8 Uart2_RxMsg_Multi_161[16];
    171          extern u8 Uart2_RxMsg_Single_162[8];
    172          extern u8 Uart2_RxMsg_Single_163[8];
    173          extern u8 Uart2_RxMsg_Single_174[8];
    174          extern u8 Uart2_RxMsg_Single_251[8];
    175          extern u8 Uart2_RxMsg_Single_252[8];
    176          extern u8 Uart2_RxMsg_Single_253[8];
    177          extern u8 Uart2_RxMsg_Single_239[8];
    178          extern u8 Uart2_RxMsg_Single_239_121[8];
    179          extern u8 Uart2_RxMsg_Single_247[8];
    180          
    181          
    182          //61184
    183          extern u8 Uart2_RxMsg_Single_11[8];
    184          extern u8 Uart2_RxMsg_Single_12[8];
    185          extern u8 Uart2_RxMsg_Single_21[8];
    186          extern u8 Uart2_RxMsg_Multi_23[13];
    187          extern u8 Uart2_RxMsg_Single_61[8];
    188          extern u8 Uart2_RxMsg_Single_62[8];
    189          extern u8 Uart2_RxMsg_Single_101[8];
    190          extern u8 Uart2_RxMsg_Single_104[8];
    191          extern u8 Uart2_RxMsg_Single_105[8];
    192          extern u8 Uart2_RxMsg_Single_109[8];
    193          extern u8 Uart2_RxMsg_Single_121[8];
    194          extern u8 Uart2_RxMsg_Single_123[8];
    195          extern u8 Uart2_RxMsg_Single_201[8];
    196          extern u8 Uart2_RxMsg_Single_203[8];
    197          //0xFFxx
    198          extern u8 Uart2_RxMsg_Single_47[8];
    199          extern u8 Uart2_RxMsg_Multi_145[22];
    200          extern u8 Uart2_RxMsg_Single_247[8];
    201          
    202          
    203          
    204          
    205          extern u8 SerialMsgRTC[16];
    206          extern u8 Lamp_name;
    207          extern u8 Lamp_Value;
    208          
    209          //////////////// stm32 update /////////////////////
    210          extern u8 Change_UART4_for_Download;
    211          extern u8 ST_Update;
    212          extern u8 UpdateMode;
    213          
    214          
    215          // Smart Key
    216          extern WL9FM_receive_smartkey recv_smartkey;
    217          extern WL9FM_flag_data smk_flag_data;
    218          extern int SMKSuccess;
    219          
    220          
    221          unsigned long long CANRXIndex = 0;
    222          unsigned long long SerialTXIndex = 0;
    223          
    224          extern u8 LCDOffCount;
    225          extern u16 OSUpdateCount;
    226          
    227          extern u8 Flag_ESL;
    228          
    229          extern u8 SmartKeyUse;
    230          
    231          extern u8 CameraCommFlag;
    232          
    233          extern u8 AAVMCommFlag;
    234          
    235          extern u8 AAVMEquipFlag;
    236          
    237          extern uint16_t ADC3ConvertedValue;
    238          
    239          
    240          extern u16 pWriteBufPos;
    241          
    242          extern unsigned char Hardware_Revision;			// ++, --, 160511 bwk
    243          extern u8 SaveSmartKeyUse;						// ++, --, 161021 bwk
    244          
    245          /* Private function prototypes -----------------------------------------------*/
    246          /* Private functions ---------------------------------------------------------*/
    247          void WL9F_CAN_Buffer_Init(void)
    248          {
    249          	Uart2_SerialTxMsg[0]  = 0x02;	// STX
    250          	Uart2_SerialTxMsg[1]  = 0xF5;	// ID
    251          	Uart2_SerialTxMsg[2]  = 8;		// Data Length
    252          	Uart2_SerialTxMsg[15] = 0;		// CRC
    253          	Uart2_SerialTxMsg[16] = 0x03;	// ETX
    254          
    255          	pWriteBufPos = 0;
    256          
    257          	TotPacketNum = 0;
    258          	pgn = 0;
    259          
    260          	Uart2_SerialTxCnt = 0;
    261          	CommErrCnt = 0;
    262          }
    263          
    264          uint16_t test,old_test;
    265          
    266          unsigned char test_temp[8];
    267          
    268          #if 0
    269          void OperateRingBuffer(void)
    270          {
    271          	if(pWriteBufPos >= (RING_BUF_SIZE-1))	// End of Ring Buffer
    272          		pWriteBufPos = 0;
    273          
    274          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.ExtId, 4);
    275          
    276          	pWriteBufPos += 4;
    277          
    278          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.Data, 8);
    279          	
    280          	pWriteBufPos += 8;	
    281          
    282          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    283          	
    284          }
    285          #endif
    286          // ++, 160511 bwk
    287          void CPU_OK(void)
    288          {
    289          	 static unsigned char temp=0;
    290          
    291          	 CPU_DIE_CTL(((++temp%2==0) ? Bit_SET: Bit_RESET));
    292          }
    293          // --, 160511 bwk
    294          
    295          void RTCSend(void)
    296          {
    297          	if(pWriteBufPos >= (RING_BUF_SIZE-1)) // End of Ring Buffer
    298          		pWriteBufPos = 0;
    299          
    300          	memcpy(&ring_buf[pWriteBufPos], (u8*)&SerialMsgRTC[0], 12);
    301          
    302          	pWriteBufPos += 12;
    303          
    304          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    305          }
    306          
    307          
    308          void SendTo_E2PROM(void)
    309          {
    310          #if 1
    311          	if (SendEEPROMDataCnt < 2)	//	2번 보낸다.
    312          	{
    313          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[0], 8);
    314          		Uart2_SerialTxMsg[15] = 0xE1;
    315          	}	
    316          	else if (SendEEPROMDataCnt < 4)	//	2번 보낸다.
    317          	{
    318          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[8], 8);
    319          		Uart2_SerialTxMsg[15] = 0xE2;
    320          	}	
    321          	else
    322          	{
    323          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[16], 8);
    324          		Uart2_SerialTxMsg[15] = 0xE3;
    325          	}		
    326          
    327          	//  Enable the USART3 Transmit interrupt
    328          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    329          #endif
    330          }
    331          
    332          /******************************************************************************/
    333          /*            Cortex-M4 Processor Exceptions Handlers                         */
    334          /******************************************************************************/
    335          
    336          /**
    337            * @brief   This function handles NMI exception.
    338            * @param  None
    339            * @retval None
    340            */
    341          void NMI_Handler(void)
    342          {
    343          }
    344          
    345          /**
    346            * @brief  This function handles Hard Fault exception.
    347            * @param  None
    348            * @retval None
    349            */
    350          void HardFault_Handler(void)
    351          {
    352            /* Go to infinite loop when Hard Fault exception occurs */
    353            while (1)
    354            {
    355            }
    356          }
    357          
    358          /**
    359            * @brief  This function handles Memory Manage exception.
    360            * @param  None
    361            * @retval None
    362            */
    363          void MemManage_Handler(void)
    364          {
    365            /* Go to infinite loop when Memory Manage exception occurs */
    366            while (1)
    367            {
    368            }
    369          }
    370          
    371          /**
    372            * @brief  This function handles Bus Fault exception.
    373            * @param  None
    374            * @retval None
    375            */
    376          void BusFault_Handler(void)
    377          {
    378            /* Go to infinite loop when Bus Fault exception occurs */
    379            while (1)
    380            {
    381            }
    382          }
    383          
    384          /**
    385            * @brief  This function handles Usage Fault exception.
    386            * @param  None
    387            * @retval None
    388            */
    389          void UsageFault_Handler(void)
    390          {
    391            /* Go to infinite loop when Usage Fault exception occurs */
    392            while (1)
    393            {
    394            }
    395          }
    396          
    397          /**
    398            * @brief  This function handles SVCall exception.
    399            * @param  None
    400            * @retval None
    401            */
    402          void SVC_Handler(void)
    403          {
    404          }
    405          
    406          /**
    407            * @brief  This function handles Debug Monitor exception.
    408            * @param  None
    409            * @retval None
    410            */
    411          void DebugMon_Handler(void)
    412          {
    413          }
    414          
    415          /**
    416            * @brief  This function handles PendSVC exception.
    417            * @param  None
    418            * @retval None
    419            */
    420          void PendSV_Handler(void)
    421          {
    422          }
    423          
    424          /**
    425            * @brief  This function handles SysTick Handler.
    426            * @param  None
    427            * @retval None
    428            */
    429          void SysTick_Handler(void)
    430          {
    431            	TimeDelay_Decrement();
    432          
    433              ++WL9FM_TIME.Cnt_1mSec;
    434          
    435          	if (WL9FM_TIME.Cnt_1mSec % 1 == 0)                   //  1msec
    436          	{
    437                  WL9FM_TIME.Flag_1mSec = 1;
    438          
    439          		if (WL9FM_TIME.Cnt_1mSec % 10 == 0)              //  10msec
    440          		{
    441          			WL9FM_TIME.Flag_10mSec = 1;
    442          			// ++, 160511 bwk
    443          			if(Hardware_Revision >= REVH)
    444          				CPU_OK();
    445          			// --, 160511 bwk
    446          
    447          			if (WL9FM_TIME.Cnt_1mSec % 100 == 0)         //  100msec
    448          			{
    449          				WL9FM_TIME.Flag_100mSec = 1;
    450          
    451          				if(WL9FM_TIME.Cnt_1mSec % 500 == 0)			// 500msec
    452          				{
    453          					WL9FM_TIME.Flag_500mSec = 1;
    454          					if (WL9FM_TIME.Cnt_1mSec % 1000 == 0)    //  1000 msec
    455          					{
    456          						WL9FM_TIME.Flag_1Sec = 1;
    457          						WL9FM_TIME.Cnt_1mSec = 0;
    458          					}
    459          				}
    460          
    461          				
    462          			}
    463          		}
    464          	}    
    465          }
    466          
    467          /******************************************************************************/
    468          /*                 STM32F4xx Peripherals Interrupt Handlers                   */
    469          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    470          /*  available peripheral interrupt handler's name please refer to the startup */
    471          /*  file (startup_stm32f4xx.s).                                               */
    472          /******************************************************************************/
    473          
    474          /**
    475            * @brief  This function handles PPP interrupt request.
    476            * @param  None
    477            * @retval None
    478            */
    479          /*void PPP_IRQHandler(void)
    480          {
    481          }*/
    482          
    483          /**
    484            * @}
    485            */ 
    486          
    487          /**
    488            * @brief  This function handles CAN1 global interrupt request.
    489            * @param  None
    490            * @retval None
    491            */
    492          void CAN1_RX0_IRQHandler(void)
    493          {
    494          	u32 PF; 
    495          	u32 PS;
    496          	u32 PGN;
    497          
    498          	CAN_Receive(CAN1,CAN_FIFO0,&RxMsg);
    499          				
    500          	Iden.Source_Address = (RxMsg.ExtId & 0x000000ff)  >> 0;
    501          	Iden.PDU_Specific = (RxMsg.ExtId  & 0x0000ff00) >> 8;
    502          	
    503          	// Iden.Source_Address == 71	 -->>	MCU
    504          	// Iden.Source_Address == 228	 -->>	EHCU	
    505          	// Iden.Source_Address == 0x29	 -->>	Smart Key
    506          	// Iden.Source_Address == 23	 -->>	Cluster
    507          	// Iden.Source_Address == 221	 -->>	RCU
    508          	// Iden.Source_Address == 0	 -->>	ECM
    509          	// Iden.Source_Address == 3	 -->>	TCU
    510          	// Iden.Source_Address == 25	 -->>	ACU
    511          	// Iden.Source_Address == 52	 -->>	BKCU
    512                  // Iden.Source_Address == 53	 -->>	SKCU
    513                  // Iden.Source_Address == 0xDE	 -->>	AAVM
    514          	if((Iden.Source_Address == 0x47) || (Iden.Source_Address == 0x17) || (Iden.Source_Address == 0x29) || 
    515          		(Iden.Source_Address == 0xE4) || (Iden.Source_Address == 0xDD)|| (Iden.Source_Address == 0x4a)|| (Iden.Source_Address == 0xf4)
    516          		|| (Iden.Source_Address == 0x00)|| (Iden.Source_Address == 0x03) || (Iden.Source_Address == 0x02) || (Iden.Source_Address == 0x19)
    517          		|| (Iden.Source_Address == 0x34) || (Iden.Source_Address == 0xDE) || (Iden.Source_Address == 0x35))
    518          		{
    519          		#if 1
    520          			
    521          			if(CANUpdateFlag == 0)
    522          			{
    523          				PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    524          				if((PF == 254) || (PF == 255) || (PF == 239) )
    525          				{	
    526          					
    527          					if(Iden.PDU_Specific == 232)	// Smart Key
    528          					{
    529          						smk_flag_data.recv_resp_packet |= RESPONSE_AUTHENTICATION;	
    530          						//smk_flag_data.recv_resp_packet |= 0x0100; 
    531          						memcpy((u8*)&recv_smartkey, (u8*)&RxMsg.Data[0], 8);
    532          					}
    533          					else
    534          					{
    535          		
    536          						//if(Iden.PDU_Specific == 0x9b)
    537          							CAN_RX(RxMsg);
    538          					}
    539          				}
    540          				
    541          				else
    542          				{                    
    543          	                		CAN_RX(RxMsg);
    544          				}
    545          		
    546          				CommErrCnt = 0;
    547          			}
    548          			else if(CANUpdateFlag == 1)
    549          			{
    550          				if(Iden.Source_Address == CANUpdateSA)
    551          				{
    552          					PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    553          					PS = (RxMsg.ExtId  & 0x0000FF00) >> 8;
    554          					PGN = (RxMsg.ExtId  & 0x00FFFF00) >> 8;
    555          					if(PGN == 0xEFFA || PGN  == 0xECFA || PGN  == 0xEBFA)
    556          					{
    557          						CAN_RX(RxMsg);
    558          					}
    559          
    560          				}
    561          				if(Iden.Source_Address == 0x47)
    562          				{
    563          					PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    564          					PS = (RxMsg.ExtId  & 0x0000FF00) >> 8;
    565          					PGN = (RxMsg.ExtId  & 0x00FFFF00) >> 8;
    566          					
    567          					if(PGN == 0xEF28 && RxMsg.Data[0] == 122)
    568          					{
    569          						CAN_RX(RxMsg);
    570          					}
    571          				}
    572          				if(Iden.Source_Address == 0x34){
    573          					PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    574          					PS = (RxMsg.ExtId  & 0x0000FF00) >> 8;
    575          					PGN = (RxMsg.ExtId  & 0x00FFFF00) >> 8;
    576          					if(PGN == 0xFFFA || PGN == 0xFE34){
    577          						CAN_RX(RxMsg);
    578          						}
    579          				}
    580          			}
    581          		#else
    582          			if(CANUpdateFlag == 1)
    583          			{
    584          				if(Iden.Source_Address == CANUpdateSA)
    585          				{
    586          					PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    587          					PS = (RxMsg.ExtId  & 0x0000FF00) >> 8;
    588          					PGN = (RxMsg.ExtId  & 0x00FFFF00) >> 8;
    589          					if(PGN == 0xEFFA || PGN  == 0xECFA || PGN  == 0xEBFA)
    590          					{
    591          						//OperateRingBuffer();
    592          						CAN_RX(RxMsg);
    593          						CANRXIndex++;
    594          					}
    595          
    596          				}
    597          				
    598          			}
    599          		#endif
    600          			
    601          			
    602          
    603          			
    604          			
    605          		}
    606          
    607          }
    608          
    609          /**
    610            * @brief  This function handles TIM4 global interrupt request.
    611            * @param  None
    612            * @retval None
    613            */
    614          void TIM4_IRQHandler(void)  //  10msec Timer / TimeBase UP Counter
    615          {
    616              TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    617              
    618              //  BUZZER Status가 "2" 일 경우 BUZZER OnTime 만큼 BUZZER On
    619              if (WL9FM_BUZZER.Status == 2)
    620              {
    621                  if (WL9FM_BUZZER.OnCnt++ < WL9FM_BUZZER.OnTime)
    622                  {
    623                      Buzzer_On();
    624                  }
    625                  else
    626                  {
    627                      WL9FM_BUZZER.Status = 0;               
    628                  }
    629              }        
    630              //  BUZZER Status가 "1" 일 경우 UnLimit BUZZER On
    631              else if (WL9FM_BUZZER.Status == 1)
    632              {
    633                  Buzzer_On();    
    634              }    
    635              else
    636              {
    637                  Buzzer_Off();
    638                  
    639                  WL9FM_BUZZER.Status = 0;               
    640                  WL9FM_BUZZER.OnTime = 0;
    641                  WL9FM_BUZZER.OnCnt  = 0;
    642              }
    643          
    644          #if 1
    645          	CommErrCnt++;
    646          
    647          	if(CommErrCnt >= 1000)
    648          		CommErrCnt = 1001;
    649          #endif
    650          }
    651          
    652          /**
    653            * @brief  This function handles TIM5 global interrupt request.
    654            * @param  None
    655            * @retval None
    656            */
    657          void TIM5_IRQHandler(void)  //  5msec Timer / TimeBase UP Counter    
    658          {
    659              TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
    660          
    661          	KeySwitch_Process();    //  KeySwitch.c Func
    662          }
    663          
    664          /**
    665            * @brief  This function handles USART3 global interrupt request.
    666            * @param  None
    667            * @retval None
    668            */
    669            // STM32F407 <-> exynos4412 can_data
    670          
    671          unsigned char temp_61184;
    672          
    673          void USART2_IRQHandler(void)
    674          {
    675          	struct st_CAN_Message1 Send_Message;
    676          	
    677          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    678          	{
    679          		Uart2_SerialRxMsg[Uart2_SerialRxCnt] = (u8)USART_ReceiveData(USART2);
    680          
    681          		  //  디버깅할 때만 사용할 것
    682          		#ifdef DEBUG_CAN_RX
    683          		DebugMsg_printf("%2x ", Uart2_SerialRxMsg[Uart2_SerialRxCnt]);
    684          		#endif
    685          		
    686          		switch(Uart2_SerialRxCnt)
    687          		{
    688          			case 0:
    689          				if(Uart2_SerialRxMsg[0] == 0x02)		// STX
    690          					Uart2_SerialRxCnt++;
    691          				break;
    692          			case UART2_Rx_BUF_SIZE-1:
    693          				Uart2_SerialRxCnt = 0;
    694          
    695          				if(Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE-1] == 0x03)		// ETX
    696          				{
    697          					memcpy(&Send_Message,&Uart2_SerialRxMsg[1],12);	
    698          					Write_CAN_Single(Send_Message);
    699          				}
    700          				else
    701          				{
    702          					//  디버깅할 때만 사용할 것
    703          					//DebugMsg_printf("Protocol Fail\r\n");
    704          				}
    705          
    706          				break;
    707          			
    708          			default :
    709          				Uart2_SerialRxCnt++;
    710          				break;
    711          		}
    712          	}
    713          
    714          #if 0
    715          	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    716          	{   
    717          		if((USART2->SR & 0x80) == RESET)
    718          			return;
    719          
    720          		if (pWriteBufPos == pReadBufPos)
    721          		{
    722          			if(Flag_TxE2pRomData == 1)
    723          			{
    724          			    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    725          			    return;
    726          		    }
    727          		}
    728          
    729          		if(pReadBufPos >= (RING_BUF_SIZE-1))
    730          			pReadBufPos = 0;
    731          
    732          		if((Uart2_SerialTxCnt == 0) && (pWriteBufPos != pReadBufPos))
    733          		{
    734          			memcpy(&Uart2_SerialTxMsg[3] , &ring_buf[pReadBufPos], 12);
    735          			
    736          		}
    737          		
    738          		USART_SendData(USART2, (u16)(Uart2_SerialTxMsg[Uart2_SerialTxCnt++]));    
    739          		
    740          		if (Uart2_SerialTxCnt >= UART2_Tx_BUF_SIZE)
    741          		{
    742          			#if 0
    743          			//Uart2_SerialTxCnt = 0;
    744          			//pReadBufPos += 12;
    745          			//USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    746          
    747          			if(Flag_TxE2pRomData == 0)
    748          			{
    749                          //  보내는 횟수 중요하다. 초기에 버그가 생실 수 있으니, 테스트 필요함!!!
    750          				//	EEPROM Data를 6번 보낸다.
    751          				if(SendEEPROMDataCnt > 5)	
    752          				{
    753          					Uart2_SerialTxCnt = 0;	
    754          					Uart2_SerialTxMsg[15] = 0;
    755          					Flag_TxE2pRomData = 1;
    756          						
    757          					//	EEPROM Data를 그만 보내고 CAN Data를 보낸다. 
    758          					Flag_UartTxStart = 0;
    759          					
    760          					//  Enable the USART2 Transmit interrupt
    761          					USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    762          					CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);			
    763          				}
    764          				else
    765          				{
    766          					SendEEPROMDataCnt++;
    767          			        	Uart2_SerialTxCnt = 0;
    768          
    769          					//  Disable the USART3 Transmit interrupt
    770          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    771          				}
    772          			}
    773          			else
    774          			{
    775          				Uart2_SerialTxCnt = 0;
    776          				pReadBufPos += 12;
    777          			}
    778          			#else
    779          			if(Flag_TxE2pRomData == 0)
    780          			{
    781                        
    782          				Uart2_SerialTxCnt = 0;	
    783          				Uart2_SerialTxMsg[15] = 0;
    784          				Flag_TxE2pRomData = 1;
    785          					
    786          				//	EEPROM Data를 그만 보내고 CAN Data를 보낸다. 
    787          				Flag_UartTxStart = 0;
    788          				
    789          				//  Enable the USART2 Transmit interrupt
    790          				USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    791          				CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);		
    792          				
    793          				
    794          			}
    795          			else
    796          			{
    797          				Uart2_SerialTxCnt = 0;
    798          				pReadBufPos += 12;
    799          				SerialTXIndex++;
    800          			}
    801          			#endif
    802          		}  
    803          	}
    804          #else
    805          	
    806          
    807          #endif
    808          
    809          }
    810          
    811          /*
    812          void DMA1_Stream6_IRQHandler(void)
    813          {
    814          	if (DMA_GetITStatus(DMA1_Stream6, DMA_IT_TCIF6) != RESET) 
    815              	{
    816              		if(pReadBufPos >= (RING_BUF_SIZE-1))
    817          			pReadBufPos = 0;
    818          
    819          		if((Uart2_SerialTxCnt == 0) && (pWriteBufPos != pReadBufPos))
    820          		{
    821          			memcpy(&Uart2_SerialTxMsg[3] , &ring_buf[pReadBufPos], 12);	
    822          		}
    823          		USART_SendData(USART2, (u16)(Uart2_SerialTxMsg[Uart2_SerialTxCnt++]));    
    824          		
    825          		if (Uart2_SerialTxCnt >= UART2_Tx_BUF_SIZE)
    826          		{
    827          			Uart2_SerialTxCnt = 0;
    828          			pReadBufPos += 12;
    829          			SerialTXIndex++;
    830          		}  
    831          	}
    832          }*/
    833          
    834          
    835          
    836          void UART4_IRQHandler(void)
    837          {
    838          	//  UART4 receive interrupt routine
    839          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) 
    840              	{
    841              		if(Change_UART4_for_Download==0)
    842          			UART4_Receive_CMD();
    843          		else
    844          			UART4_Receive_File();
    845          				
    846          	}
    847          	//  UART4 transmit interrupt routine
    848          	if (USART_GetITStatus(UART4, USART_IT_TXE) != RESET)
    849          	{   
    850          		UART4_transmit_CMD();
    851          	}
    852          }
    853          
    854          u8 temp_rx_buf[4];
    855          
    856          void UART4_Receive_CMD(void)
    857          {
    858          	uint8_t Temp[Serial_COM4_TxSize];
    859          	//  Read one byte to the receive data register
    860          	WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt] = USART_ReceiveData(UART4);
    861          
    862          	
    863              	//  디버깅할 때만 사용할 것
    864          	#ifdef DEBUG_CMD_RX
    865          	DebugMsg_printf("%2x ", WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt]);
    866          	#endif
    867          
    868          	
    869          	switch (WL9FM_USART_INDEX.COM4_RxCnt)
    870          	{
    871          		case 0:
    872          				if (WL9FM_USART_DATA.COM4_RxBuf[0] == STX)
    873          				{
    874          					WL9FM_USART_INDEX.COM4_RxCnt++;
    875          				}	
    876          				else
    877          				{
    878          					WL9FM_USART_INDEX.COM4_RxCnt=0;
    879          				}
    880          				
    881          				break;
    882          		case 1:
    883          				if (WL9FM_USART_DATA.COM4_RxBuf[1]      == KeyCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    884          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LCDBLCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    885          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == BUZZERCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    886          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LAMPCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    887          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CAMCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    888          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == DOWNCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    889          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    890          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == StartCANCMD) WL9FM_USART_INDEX.COM4_RxCnt++;    
    891          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == RTCCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    892          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CANUPDATECMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    893          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == SMKCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    894          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == OSUPDATECMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    895          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == EEPROMTESTCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    896          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == FLASHTESTCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    897                                          else if (WL9FM_USART_DATA.COM4_RxBuf[1] == AAVMCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    898                                          else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CAMLINECMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    899          
    900                          else
    901                          {
    902                            	WL9FM_USART_INDEX.COM4_RxCnt = 0;
    903                          }
    904          				break;
    905          
    906          		case Serial_COM4_RxSize-1: 
    907          				WL9FM_USART_INDEX.COM4_RxCnt = 0;
    908          				
    909          				//  디버깅할 때만 사용할 것
    910          				#ifdef DEBUG_CMD_RX
    911          				DebugMsg_printf("\r\n");
    912          				#endif
    913          
    914          		if (WL9FM_USART_DATA.COM4_RxBuf[Serial_COM4_RxSize-1] == ETX)
    915          		{
    916          			switch (WL9FM_USART_DATA.COM4_RxBuf[1])
    917          			{
    918          				case KeyCMD   :		//	Key Command
    919          
    920          					break;
    921          							
    922          				case LCDBLCMD :		//	LCD BackLight Command
    923          
    924          					//	LCD BackLight Level 조절.. Level0 ~ Level8
    925          					if (WL9FM_USART_DATA.COM4_RxBuf[2] < MaxBackLightLEVEL && (WL9FM_USART_DATA.COM4_RxBuf[2] > 0)) 												
    926          					{
    927          						LCDBL_PWM_LEVEL(WL9FM_USART_DATA.COM4_RxBuf[2]);
    928          					}
    929          
    930          					break;
    931          
    932          				case BUZZERCMD :	//	Buzzer Command
    933          					if (WL9FM_USART_DATA.COM4_RxBuf[2] == 0)	//	Buzzer Off
    934          					{
    935          						Buzzer_UnLimitOff();
    936          					}
    937          					else if(WL9FM_USART_DATA.COM4_RxBuf[2] == 1)					//	Buzzer On
    938          					{
    939          						Buzzer_UnLimitOn();
    940          					}
    941          					break;
    942          
    943          				case LAMPCMD :	//	Buzzer Command
    944          					Lamp_name = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0xf0)>>4;
    945          					Lamp_Value = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0x0f);
    946          					memcpy(&rx_CMD_LAMP , &WL9FM_USART_DATA.COM4_RxBuf[2], 8);	
    947          					Lamp_Update_State();
    948          					//Lamp_Update_System();
    949          					break;
    950          					
    951          				case CAMCMD:
    952          					if(CameraCommFlag == 0)
    953          					{
    954          						CameraCommFlag = 1;
    955          						Camera_Mode = WL9FM_USART_DATA.COM4_RxBuf[2];
    956          					}					
    957          					break;
    958                                          case CAMLINECMD:
    959                                                  
    960                                                  Camera_Green_Line = WL9FM_USART_DATA.COM4_RxBuf[2];
    961                                                  break;
    962                                          case AAVMCMD:
    963                                            if(AAVMCommFlag == 0){
    964                                                  AAVMCommFlag = 1;
    965                                                  
    966                                                  AAVMEquipFlag = 1;
    967                                                  
    968                                                  AAVM_Mode = WL9FM_USART_DATA.COM4_RxBuf[2];
    969                                                  
    970                                                  AAVM_Icon_Index = WL9FM_USART_DATA.COM4_RxBuf[3];
    971                                                  
    972                                                  AAVM_Camera_Icon_Index = WL9FM_USART_DATA.COM4_RxBuf[4];                                        
    973                                                  
    974                                                  AAVM_Menu_Flag = WL9FM_USART_DATA.COM4_RxBuf[5];
    975                                                  
    976                                                  AAVM_Warning_Front = WL9FM_USART_DATA.COM4_RxBuf[6];
    977                                                  AAVM_Warning_Rear = WL9FM_USART_DATA.COM4_RxBuf[7];
    978                                                  AAVM_Warning_Left = WL9FM_USART_DATA.COM4_RxBuf[8];
    979                                                  AAVM_Warning_Right = WL9FM_USART_DATA.COM4_RxBuf[9];
    980                                                  
    981                                            }
    982                                                  break;
    983                                    
    984          				case DOWNCMD:
    985          					Stm32_Update_CMD = WL9FM_USART_DATA.COM4_RxBuf[2];
    986          					FatoryInit_Flag = WL9FM_USART_DATA.COM4_RxBuf[3];
    987          					ST_Update=1;
    988          					// ++, 160519 bwk
    989          					EXT_WATCHDOG_ENALBE(1);
    990          					// --, 160519 bwk
    991          					break;
    992          				case VersionCMD:
    993          					
    994          					Temp[0] = 0x02;				
    995          					Temp[1] = VersionRES;				
    996          					Temp[2] = ((VERSION_HIGH  << 4) & 0xF0 ) + (VERSION_LOW & 0x0F);	
    997          					Temp[3] = ((VERSION_SUB_HIGH  << 4) & 0xF0 )+ (VERSION_SUB_LOW & 0x0F);	
    998          					// HW Version/////
    999          					Temp[4] = (ADC3ConvertedValue & 0xFF);
   1000          					Temp[5] = (ADC3ConvertedValue & 0xFF00) >> 8;
   1001          					Temp[6] = VERSION_HIDDEN & 0x0F;
   1002          					//////////////////
   1003          					Temp[Serial_COM4_RxSize-1] = 0x03;	
   1004          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1005          					break;
   1006          				case StartCANCMD:
   1007          					//Flag_UartTxStart = 1;
   1008          					CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1009          					break;
   1010          				case RTCCMD:
   1011          					WL9FM_RTC.Year = WL9FM_USART_DATA.COM4_RxBuf[2];
   1012          					WL9FM_RTC.Month = WL9FM_USART_DATA.COM4_RxBuf[3];
   1013          					WL9FM_RTC.Date = WL9FM_USART_DATA.COM4_RxBuf[4];
   1014          					WL9FM_RTC.Day = WL9FM_USART_DATA.COM4_RxBuf[5];
   1015          					WL9FM_RTC.Hour = WL9FM_USART_DATA.COM4_RxBuf[6];
   1016          					WL9FM_RTC.Minute= WL9FM_USART_DATA.COM4_RxBuf[7];
   1017          					WL9FM_RTC.Second= WL9FM_USART_DATA.COM4_RxBuf[8];
   1018          					WRITE_RTC(WL9FM_RTC);
   1019          					break;
   1020          
   1021          				case SMKCMD:
   1022          					
   1023          					if(WL9FM_USART_DATA.COM4_RxBuf[2] == 0x00)
   1024          					{
   1025          						SendSMKAuthResult(SMKSuccess);
   1026          					}
   1027          					else if(WL9FM_USART_DATA.COM4_RxBuf[2] == 0x03)
   1028          					{
   1029          						// ++, 160511 bwk
   1030          						#if 0
   1031          						SaveSMKUseToEEPROM(WL9FM_USART_DATA.COM4_RxBuf[3]);
   1032          						#else
   1033          						if(Hardware_Revision >= REVH)
   1034          						{
   1035          							// ++, 161021 bwk
   1036          							#if 0
   1037          							SaveSMKUseToFlash(WL9FM_USART_DATA.COM4_RxBuf[3]);
   1038          							#else
   1039          							SaveSmartKeyUse = WL9FM_USART_DATA.COM4_RxBuf[3];
   1040          							#endif
   1041          							// --, 161021 bwk
   1042          						}
   1043          						else
   1044          						{
   1045          							SaveSMKUseToEEPROM(WL9FM_USART_DATA.COM4_RxBuf[3]);
   1046          						}
   1047          						#endif
   1048          						// --, 160511 bwk
   1049          					}
   1050          					// ++, 150713 bwk
   1051          					else if(WL9FM_USART_DATA.COM4_RxBuf[2] == RESPONSE_AUTHENTICATION)
   1052          					{
   1053          						SendSMKCountResult();	
   1054          					}
   1055          					// --, 150713 bwk
   1056          					else
   1057          					{
   1058          						memcpy(&Uart2_RxMsg_Smk_Reg_Eli[0], &WL9FM_USART_DATA.COM4_RxBuf[0], 8);
   1059          					}
   1060          					break;
   1061          				case CANUPDATECMD:
   1062          					CANUpdateFlag = WL9FM_USART_DATA.COM4_RxBuf[2];
   1063          					CANUpdateSA = WL9FM_USART_DATA.COM4_RxBuf[3];
   1064          					// ++, 160519 bwk
   1065          					if(CANUpdateFlag == 1)
   1066          						EXT_WATCHDOG_ENALBE(1);
   1067          					// --, 160519 bwk
   1068          					break;
   1069          				case OSUPDATECMD:
   1070          					LCDOffCount = 0;
   1071          					OSUpdateCount = 0;
   1072          					break;
   1073          				case EEPROMTESTCMD:
   1074          					if(WL9FM_USART_DATA.COM4_RxBuf[2] == 1)
   1075          					{
   1076          						InitE2PROM();
   1077          					}
   1078          					else
   1079          					{
   1080          						SaveTestToEEPROM(WL9FM_USART_DATA.COM4_RxBuf[3]);
   1081          					}
   1082          					Temp[0] = 0x02;				
   1083          					Temp[1] = EEPROMTESTRES;	
   1084          					Temp[2] = WL9FM_USART_DATA.COM4_RxBuf[2];	
   1085          					Temp[3] = LoadTestToEEPROM(); 	
   1086          					Temp[Serial_COM4_RxSize-1] = 0x03;	
   1087          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1088          					break;
   1089          				case FLASHTESTCMD:
   1090          					if(WL9FM_USART_DATA.COM4_RxBuf[2] == 1)
   1091          					{
   1092          						SPI_FLASH_BulkErase();
   1093          					}
   1094          					else
   1095          					{
   1096          						SPI_FLASH_SectorErase(0x3d0000);	//Sector60
   1097          						SPI_FLASH_PageWrite(&WL9FM_USART_DATA.COM4_RxBuf[3],0x3d0000,7);
   1098          						SPI_FLASH_BufferRead(&Temp[3],0x3d0000,7);
   1099          						Temp[0] = 0x02;
   1100          						Temp[1] = FLASHTESTRES;
   1101          						Temp[2] = WL9FM_USART_DATA.COM4_RxBuf[2];
   1102          						Temp[Serial_COM4_RxSize-1] = 0x03;	
   1103          						USARTx_EXYNOS(COM4, (char *)Temp);	
   1104          						
   1105          						SPI_FLASH_SectorErase(0x3d0000);	//Sector60
   1106          					}
   1107          
   1108          					break;
   1109          				default :
   1110          					break;								
   1111          			}
   1112                          }						
   1113          
   1114          		//memset(WL9FM_USART_DATA.COM4_RxBuf, 0x0, Serial_COM4_RxSize);					
   1115          				break;
   1116          		
   1117          		default :
   1118          
   1119          			WL9FM_USART_INDEX.COM4_RxCnt++;
   1120          			break;
   1121          	}	
   1122          }
   1123          
   1124          void UART4_Receive_File(void)
   1125          {
   1126          	
   1127          	//  Read one byte to the receive data register
   1128          	WL9FM_USART_RX_FILE_DATA.File_RxBuf[WL9FM_USART_RX_FILE_DATA.File_RxCnt] = USART_ReceiveData(UART4);
   1129          	
   1130          	switch (WL9FM_USART_RX_FILE_DATA.File_RxCnt)
   1131          	{
   1132          		case 0:
   1133          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[0] == STX)
   1134          				{
   1135          					WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1136          				}						
   1137          				break;
   1138          		case 1029: 
   1139          				WL9FM_USART_RX_FILE_DATA.File_RxCnt = 0;
   1140          					
   1141          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == ETX)
   1142          				{
   1143          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1144          					ST_Update=1;
   1145          				}
   1146          				else if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == EOT)
   1147          				{
   1148          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1149          					Change_UART4_for_Download =2;
   1150          					ST_Update=1;
   1151          				}
   1152          				else
   1153          				{
   1154          					ACK_NACK_SendToExynos(NAK);
   1155          				}
   1156                                          break;
   1157          		default :
   1158          
   1159          			WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1160          			break;
   1161          	}					
   1162          }
   1163          
   1164          
   1165          void UART4_transmit_CMD(void)
   1166          {
   1167          // ++, 150707 sys
   1168          #if 0
   1169          	//  Write one byte to the transmit data register
   1170          	USART_SendData(UART4, WL9FM_USART_DATA.COM4_TxBuf[WL9FM_USART_INDEX.COM4_TxCnt++]);
   1171          
   1172          	if (WL9FM_USART_INDEX.COM4_TxIdx >= Serial_COM4_TxSize)
   1173          	{
   1174          		WL9FM_USART_INDEX.COM4_TxIdx = Serial_COM4_TxSize;
   1175          	}    
   1176          	if (WL9FM_USART_INDEX.COM4_TxCnt == WL9FM_USART_INDEX.COM4_TxIdx)
   1177          	{
   1178          		//  Disable the UART4 Transmit interrupt
   1179          		USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   1180          
   1181          		WL9FM_USART_INDEX.COM4_TxIdx = 0; //  transmit buffer Index clear
   1182          		WL9FM_USART_INDEX.COM4_TxCnt = 0; //  transmit buffer Cnt   clear
   1183          	}      
   1184          #endif
   1185          
   1186          	if((UART4->SR & 0x80) == RESET)
   1187          		return;
   1188          
   1189          	if (pWriteBufPos == pReadBufPos)
   1190          	{
   1191          		    USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   1192          		    return;
   1193          	}
   1194          
   1195          	if(pReadBufPos >= (RING_BUF_SIZE-1))
   1196          			pReadBufPos = 0;
   1197          
   1198          
   1199          	if((pWriteBufPos != pReadBufPos) && (WL9FM_USART_INDEX.COM4_TxCnt == 0))
   1200          		memcpy(&WL9FM_USART_DATA.COM4_TxBuf[0] , &ring_buf[pReadBufPos], Serial_COM4_TxSize);
   1201          
   1202          	USART_SendData(UART4, WL9FM_USART_DATA.COM4_TxBuf[WL9FM_USART_INDEX.COM4_TxCnt++]);
   1203          
   1204          	if (WL9FM_USART_INDEX.COM4_TxCnt >= Serial_COM4_TxSize)
   1205          	{
   1206          		WL9FM_USART_INDEX.COM4_TxCnt = 0;
   1207          		pReadBufPos += Serial_COM4_TxSize;
   1208          	}
   1209          // --, 150707 sys
   1210          }
   1211          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BusFault_Handler
      32   CAN1_RX0_IRQHandler
        16   -> CAN_RX
        16   -> CAN_Receive
        16   -> __aeabi_memcpy
        32   -> __aeabi_memcpy4
       0   CPU_OK
         0   -> GPIO_WriteBit
       0   DebugMon_Handler
       0   HardFault_Handler
       0   MemManage_Handler
       0   NMI_Handler
       0   PendSV_Handler
       8   RTCSend
         0   -> USART_ITConfig
         8   -> __aeabi_memcpy
       0   SVC_Handler
       8   SendTo_E2PROM
         0   -> USART_ITConfig
         8   -> __aeabi_memcpy
       8   SysTick_Handler
         8   -> GPIO_WriteBit
         8   -> TimeDelay_Decrement
       8   TIM4_IRQHandler
         8   -> Buzzer_Off
         8   -> Buzzer_On
         8   -> TIM_ClearITPendingBit
       8   TIM5_IRQHandler
         0   -> KeySwitch_Process
         8   -> TIM_ClearITPendingBit
       8   UART4_IRQHandler
         8   -> UART4_Receive_CMD
         8   -> UART4_Receive_File
         8   -> UART4_transmit_CMD
         8   -> USART_GetITStatus
      32   UART4_Receive_CMD
        32   -> Buzzer_UnLimitOff
        32   -> Buzzer_UnLimitOn
        32   -> CAN_ITConfig
        32   -> GPIO_WriteBit
        32   -> InitE2PROM
        32   -> LCDBL_PWM_LEVEL
        32   -> Lamp_Update_State
        32   -> LoadTestToEEPROM
        32   -> SPI_FLASH_BufferRead
        32   -> SPI_FLASH_BulkErase
        32   -> SPI_FLASH_PageWrite
        32   -> SPI_FLASH_SectorErase
        32   -> SaveSMKUseToEEPROM
        32   -> SaveTestToEEPROM
        32   -> SendSMKAuthResult
        32   -> USART_ReceiveData
        32   -> USARTx_EXYNOS
        32   -> WRITE_RTC
        32   -> __aeabi_memcpy
       8   UART4_Receive_File
         0   -> ACK_NACK_SendToExynos
         8   -> USART_ReceiveData
         8   -> __aeabi_memcpy
      16   UART4_transmit_CMD
         0   -> USART_ITConfig
        16   -> USART_SendData
        16   -> __aeabi_memcpy
      24   USART2_IRQHandler
        24   -> USART_GetITStatus
        24   -> USART_ReceiveData
        24   -> Write_CAN_Single
        24   -> __aeabi_memcpy
       0   UsageFault_Handler
       0   WL9F_CAN_Buffer_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_33
       4  ??DataTable12_34
       4  ??DataTable12_35
       4  ??DataTable12_36
       4  ??DataTable12_37
       4  ??DataTable12_38
       4  ??DataTable12_39
       4  ??DataTable12_4
       4  ??DataTable12_40
       4  ??DataTable12_41
       4  ??DataTable12_42
       4  ??DataTable12_43
       4  ??DataTable12_44
       4  ??DataTable12_45
       4  ??DataTable12_46
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      18  ?Subroutine0
       2  BusFault_Handler
       1  Buz1
     314  CAN1_RX0_IRQHandler
       8  CANRXIndex
      28  CPU_OK
       1  CanRecvCnt
       2  DebugMon_Handler
       1  Flag_TxE2pRomData
       2  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
       2  PendSV_Handler
       4  RMCUpgn
      44  RTCSend
     816  RxMsg
          Iden
          Uart2_SerialTxCnt
          Stm32_Update_CMD
          FatoryInit_Flag
          CANUpdateFlag
          CANUpdateSA
          pWriteBufPos
          pReadBufPos
          TotPacketNum
          CommErrCnt
          pgn
          ring_buf
       2  SVC_Handler
      60  SendTo_E2PROM
       8  SerialTXIndex
     148  SysTick_Handler
      86  TIM4_IRQHandler
      20  TIM5_IRQHandler
       2  TotMsgSize
      60  UART4_IRQHandler
     828  UART4_Receive_CMD
     114  UART4_Receive_File
     110  UART4_transmit_CMD
      94  USART2_IRQHandler
      17  Uart2_SerialRxMsg
          Uart2_SerialRxCnt
      21  Uart2_SerialTxMsg
          SendEEPROMDataCnt
       2  UsageFault_Handler
      42  WL9F_CAN_Buffer_Init
       2  old_test
       1  stop_send_as_phone_data
       1  temp
       1  temp_61184
       4  temp_rx_buf
       2  test
       8  test_temp

 
   898 bytes in section .bss
 2 170 bytes in section .text
 
 2 170 bytes of CODE memory
   898 bytes of DATA memory

Errors: none
Warnings: 4
