###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      13/May/2014  13:35:38 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\COMM #
#                    ON\SRC\stm32f4xx_it.c                                    #
#    Command line =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\COMM #
#                    ON\SRC\stm32f4xx_it.c -D USE_STDPERIPH_DRIVER -D         #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \List\ -o C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Pro #
#                    ject\Debug\Obj\ --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR            #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Proje #
#                    ct\..\Platform\COMMON\INC\ -I                            #
#                    "C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\P #
#                    latform\TaeHa - ECS\INC\" -I                             #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\Li #
#                    braries\CMSIS\Device\ST\STM32F4xx\Include\ -I            #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\Li #
#                    braries\STM32F4xx_StdPeriph_Driver\inc\ -Oh              #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \List\stm32f4xx_it.lst                                   #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \Obj\stm32f4xx_it.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\COMMON\SRC\stm32f4xx_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    Project/STM32F4xx_StdPeriph_Template/stm32f4xx_it.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    13-April-2012
      7            * @brief   Main Interrupt Service Routines.
      8            *          This file provides template for all exceptions handler and 
      9            *          peripherals interrupt service routine.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "stm32f4xx_it.h"
     32          #include "main.h"
     33          
     34          /** @addtogroup Template_Project
     35            * @{
     36            */
     37          
     38          /* Private typedef -----------------------------------------------------------*/
     39          
     40          //#define		DEBUG_CMD_RX
     41          //#define		DEBUG_CMD_TX
     42          //#define		DEBUG_CAN_RX
     43          //#define		DEBUG_CAN_TX
     44          #pragma pack(1)
     45          struct st_CAN_Msg
     46          {	
     47          	unsigned char Priority;
     48          	unsigned char Data_Page;
     49          	unsigned char PDU_Format;	
     50          	unsigned char PDU_Specific;		// 50
     51          	unsigned char Source_Address;	// 52
     52          };
     53          #pragma pack()
     54          
     55          CanRxMsg RxMsg;
     56          struct st_CAN_Msg Iden; 
     57          
     58          extern Realy_Control		rx_Realy_Control;
     59          extern EHCU_Status		rx_EHCU_Status;
     60          extern Auto_position_Status rx_Auto_position_Status;
     61          extern st_CANDATA_HCEPGN_65428	RX_HCEPGN_65428;
     62          extern WEIGHING_SYSTEM_STATUS_65450 rx_Weighing_System_Status;
     63          /* Private define ------------------------------------------------------------*/
     64          
     65          #define RING_BUF_SIZE			768*10
     66          #define UART2_Rx_BUF_SIZE		26			// Max Multi Packet Data -> 3개
     67          #define UART2_Tx_BUF_SIZE		17
     68          
     69          /*
     70          #define RX_MSG69		0x01
     71          #define RX_MSG69_M		0x02
     72          #define RX_MSG145		0x04
     73          #define RX_MSG161		0x08
     74          #define RX_MSG162		0x10
     75          #define RX_MSG163		0x20
     76          #define RX_MSG251		0x40
     77          #define RX_MSG252		0x80
     78          #define RX_MSG202		0x100
     79          #define RX_MSG253		0x200
     80          #define RX_MSG203		0x400
     81          #define RX_MSG239		0x800
     82          #define RX_MSG247		0x1000
     83          #define RX_MSG174		0x2000
     84          #define RX_MSG239_121	0x4000
     85          */
     86          #define RX_MSG11	0x01
     87          #define RX_MSG12	0x02
     88          #define RX_MSG21	0x04
     89          #define RX_MSG23	0x08
     90          #define RX_MSG61	0x10
     91          #define RX_MSG62	0x20
     92          #define RX_MSG101	0x40
     93          #define RX_MSG104	0x80
     94          #define RX_MSG105	0x100
     95          #define RX_MSG109	0x200
     96          #define RX_MSG121	0x400
     97          #define RX_MSG123	0x800
     98          #define RX_MSG201	0x1000
     99          #define RX_MSG203	0x2000
    100          		
    101          		
    102          #define RX_MSG47	0x4000
    103          		
    104          #define RX_MSG145	0x8000
    105          #define RX_MSG247	0x10000
    106          
    107          
    108          
    109          
    110          
    111          /* Private define ------------------------------------------------------------*/
    112          /* Private macro -------------------------------------------------------------*/
    113          /* Private variables ---------------------------------------------------------*/
    114          u8 ring_buf[RING_BUF_SIZE];		
    115          u16 pWriteBufPos = 0;
    116          u16 pReadBufPos = 0;
    117          u8 CanRecvCnt = 0;
    118          u16 TotPacketNum = 0;
    119          u32 pgn = 0;
    120          u16 TotMsgSize = 0;
    121          u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    122          u8 Uart2_SerialRxMsg[UART2_Rx_BUF_SIZE];
    123          
    124          u8 Uart2_SerialTxCnt = 0;
    125          u8 Uart2_SerialRxCnt = 0;
    126          u16 CommErrCnt = 0;
    127          
    128          u8 SendEEPROMDataCnt = 0;
    129          u8 Flag_TxE2pRomData = 0;
    130          u8 stop_send_as_phone_data = 0;
    131          u8 Stm32_Update_CMD;
    132          
    133          u8 Buz1;
    134          
    135          extern u8 MoniInfoSendCnt;
    136          extern u16 Flag_1Sec_MoniInfo;
    137          extern u8 MoniInfoTotalPacketNum;
    138          extern u8 RecvMachInfo;
    139          extern u8 MachineBasicInformation[78];
    140          extern u8 RTSFlag_61184;
    141          extern u8 CTSFlag_61184;
    142          extern u8 RecvTotalPacket_61184;
    143          extern u8 ACK_Multi_61184[8];
    144          
    145          
    146          extern u8 Flag_UartTxStart;
    147          extern u32 Flag_SerialRxMsg;
    148          extern u8 eepRomReadData1[32];
    149          
    150          extern u8 Uart2_RxMsg_Save_Data1[8];
    151          extern u8 Uart2_RxMsg_Save_Data2[8];
    152          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    153          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    154          
    155          extern u8 Uart2_RxMsg_Single_46[8];
    156          extern u8 Uart2_RxMsg_Single_69[8];
    157          extern u8 Uart2_RxMsg_Multi_69[21];
    158          extern u8 Uart2_RxMsg_Single_160[8];
    159          extern u8 Uart2_RxMsg_Multi_161[16];
    160          extern u8 Uart2_RxMsg_Single_162[8];
    161          extern u8 Uart2_RxMsg_Single_163[8];
    162          extern u8 Uart2_RxMsg_Single_174[8];
    163          extern u8 Uart2_RxMsg_Single_251[8];
    164          extern u8 Uart2_RxMsg_Single_252[8];
    165          extern u8 Uart2_RxMsg_Single_253[8];
    166          extern u8 Uart2_RxMsg_Single_239[8];
    167          extern u8 Uart2_RxMsg_Single_239_121[8];
    168          extern u8 Uart2_RxMsg_Single_247[8];
    169          
    170          
    171          //61184
    172          extern u8 Uart2_RxMsg_Single_11[8];
    173          extern u8 Uart2_RxMsg_Single_12[8];
    174          extern u8 Uart2_RxMsg_Single_21[8];
    175          extern u8 Uart2_RxMsg_Multi_23[13];
    176          extern u8 Uart2_RxMsg_Single_61[8];
    177          extern u8 Uart2_RxMsg_Single_62[8];
    178          extern u8 Uart2_RxMsg_Single_101[8];
    179          extern u8 Uart2_RxMsg_Single_104[8];
    180          extern u8 Uart2_RxMsg_Single_105[8];
    181          extern u8 Uart2_RxMsg_Single_109[8];
    182          extern u8 Uart2_RxMsg_Single_121[8];
    183          extern u8 Uart2_RxMsg_Single_123[8];
    184          extern u8 Uart2_RxMsg_Single_201[8];
    185          extern u8 Uart2_RxMsg_Single_203[8];
    186          //0xFFxx
    187          extern u8 Uart2_RxMsg_Single_47[8];
    188          extern u8 Uart2_RxMsg_Multi_145[13];
    189          extern u8 Uart2_RxMsg_Single_247[8];
    190          
    191          
    192          
    193          
    194          extern u8 SerialMsgRTC[16];
    195          extern u8 Lamp_name;
    196          extern u8 Lamp_Value;
    197          
    198          //////////////// stm32 update /////////////////////
    199          extern u8 Change_UART4_for_Download;
    200          extern u8 ST_Update;
    201          
    202          /* Private function prototypes -----------------------------------------------*/
    203          /* Private functions ---------------------------------------------------------*/
    204          void WL9F_CAN_Buffer_Init(void)
    205          {
    206          	Uart2_SerialTxMsg[0]  = 0x02;	// STX
    207          	Uart2_SerialTxMsg[1]  = 0xF5;	// ID
    208          	Uart2_SerialTxMsg[2]  = 8;		// Data Length
    209          	Uart2_SerialTxMsg[15] = 0;		// CRC
    210          	Uart2_SerialTxMsg[16] = 0x03;	// ETX
    211          
    212          	pWriteBufPos = 0;
    213          
    214          	TotPacketNum = 0;
    215          	pgn = 0;
    216          
    217          	Uart2_SerialTxCnt = 0;
    218          	CommErrCnt = 0;
    219          }
    220          
    221          uint16_t test,old_test;
    222          
    223          unsigned char test_temp[8];
    224          
    225          void OperateRingBuffer(void)
    226          {
    227          	if(pWriteBufPos >= (RING_BUF_SIZE-1))	// End of Ring Buffer
    228          		pWriteBufPos = 0;
    229          
    230          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.ExtId, 4);
    231          
    232          	pWriteBufPos += 4;
    233          
    234          	memcpy(&ring_buf[pWriteBufPos], (u8*)&RxMsg.Data, 8);
    235          	
    236          	pWriteBufPos += 8;	
    237          
    238          	if(RxMsg.ExtId==0x18fff7dd || RxMsg.ExtId==0x18fff747) // rcu status
    239          	{
    240          		memcpy( &rx_Realy_Control, (u8*)&RxMsg.Data, 8);
    241          	}
    242          
    243          	else if(RxMsg.ExtId==0x18EFFF47 || RxMsg.ExtId==0x18EF2847) // auto_position
    244          	{
    245          		if(RxMsg.Data[0] == 124)
    246          		{
    247          			memcpy( &rx_Auto_position_Status, (u8*)&RxMsg.Data, 8);
    248          		}
    249          		else if(RxMsg.Data[0] == 203)
    250          		{
    251          			memcpy( &rx_EHCU_Status, (u8*)&RxMsg.Data, 8);
    252          		}
    253          		
    254          	}
    255          	else if(RxMsg.ExtId==0x18ff9447) // lamp
    256          	{
    257          		memcpy( &RX_HCEPGN_65428, (u8*)&RxMsg.Data, 8);
    258          	}
    259          	else if(RxMsg.ExtId == 0x18ffaa47)	// Weighing System (Work Load Lamp)
    260          	{
    261          		memcpy( &rx_Weighing_System_Status, (u8*)&RxMsg.Data, 8);
    262          	}
    263          	
    264          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    265          	
    266          }
    267          
    268          void SendTo_E2PROM(void)
    269          {
    270          #if 1
    271          	if (SendEEPROMDataCnt < 2)	//	2번 보낸다.
    272          	{
    273          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[0], 8);
    274          		Uart2_SerialTxMsg[15] = 0xE1;
    275          	}	
    276          	else if (SendEEPROMDataCnt < 4)	//	2번 보낸다.
    277          	{
    278          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[8], 8);
    279          		Uart2_SerialTxMsg[15] = 0xE2;
    280          	}	
    281          	else
    282          	{
    283          		memcpy(&Uart2_SerialTxMsg[7], &eepRomReadData1[16], 8);
    284          		Uart2_SerialTxMsg[15] = 0xE3;
    285          	}		
    286          
    287          	//  Enable the USART3 Transmit interrupt
    288          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    289          #endif
    290          }
    291          
    292          /******************************************************************************/
    293          /*            Cortex-M4 Processor Exceptions Handlers                         */
    294          /******************************************************************************/
    295          
    296          /**
    297            * @brief   This function handles NMI exception.
    298            * @param  None
    299            * @retval None
    300            */
    301          void NMI_Handler(void)
    302          {
    303          }
    304          
    305          /**
    306            * @brief  This function handles Hard Fault exception.
    307            * @param  None
    308            * @retval None
    309            */
    310          void HardFault_Handler(void)
    311          {
    312            /* Go to infinite loop when Hard Fault exception occurs */
    313            while (1)
    314            {
    315            }
    316          }
    317          
    318          /**
    319            * @brief  This function handles Memory Manage exception.
    320            * @param  None
    321            * @retval None
    322            */
    323          void MemManage_Handler(void)
    324          {
    325            /* Go to infinite loop when Memory Manage exception occurs */
    326            while (1)
    327            {
    328            }
    329          }
    330          
    331          /**
    332            * @brief  This function handles Bus Fault exception.
    333            * @param  None
    334            * @retval None
    335            */
    336          void BusFault_Handler(void)
    337          {
    338            /* Go to infinite loop when Bus Fault exception occurs */
    339            while (1)
    340            {
    341            }
    342          }
    343          
    344          /**
    345            * @brief  This function handles Usage Fault exception.
    346            * @param  None
    347            * @retval None
    348            */
    349          void UsageFault_Handler(void)
    350          {
    351            /* Go to infinite loop when Usage Fault exception occurs */
    352            while (1)
    353            {
    354            }
    355          }
    356          
    357          /**
    358            * @brief  This function handles SVCall exception.
    359            * @param  None
    360            * @retval None
    361            */
    362          void SVC_Handler(void)
    363          {
    364          }
    365          
    366          /**
    367            * @brief  This function handles Debug Monitor exception.
    368            * @param  None
    369            * @retval None
    370            */
    371          void DebugMon_Handler(void)
    372          {
    373          }
    374          
    375          /**
    376            * @brief  This function handles PendSVC exception.
    377            * @param  None
    378            * @retval None
    379            */
    380          void PendSV_Handler(void)
    381          {
    382          }
    383          
    384          /**
    385            * @brief  This function handles SysTick Handler.
    386            * @param  None
    387            * @retval None
    388            */
    389          void SysTick_Handler(void)
    390          {
    391            	TimeDelay_Decrement();
    392          
    393              ++WL9FM_TIME.Cnt_1mSec;
    394          
    395          	if (WL9FM_TIME.Cnt_1mSec % 1 == 0)                   //  1msec
    396          	{
    397                  WL9FM_TIME.Flag_1mSec = 1;
    398          
    399          		if (WL9FM_TIME.Cnt_1mSec % 10 == 0)              //  10msec
    400          		{
    401          			WL9FM_TIME.Flag_10mSec = 1;
    402          
    403          			if (WL9FM_TIME.Cnt_1mSec % 100 == 0)         //  100msec
    404          			{
    405          				WL9FM_TIME.Flag_100mSec = 1;
    406          
    407          				if(WL9FM_TIME.Cnt_1mSec % 500 == 0)			// 500msec
    408          				{
    409          					WL9FM_TIME.Flag_500mSec = 1;
    410          					if (WL9FM_TIME.Cnt_1mSec % 1000 == 0)    //  1000 msec
    411          					{
    412          						WL9FM_TIME.Flag_1Sec = 1;
    413          						WL9FM_TIME.Cnt_1mSec = 0;
    414          					}
    415          				}
    416          
    417          				
    418          			}
    419          		}
    420          	}    
    421          }
    422          
    423          /******************************************************************************/
    424          /*                 STM32F4xx Peripherals Interrupt Handlers                   */
    425          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    426          /*  available peripheral interrupt handler's name please refer to the startup */
    427          /*  file (startup_stm32f4xx.s).                                               */
    428          /******************************************************************************/
    429          
    430          /**
    431            * @brief  This function handles PPP interrupt request.
    432            * @param  None
    433            * @retval None
    434            */
    435          /*void PPP_IRQHandler(void)
    436          {
    437          }*/
    438          
    439          /**
    440            * @}
    441            */ 
    442          
    443          /**
    444            * @brief  This function handles CAN1 global interrupt request.
    445            * @param  None
    446            * @retval None
    447            */
    448          void CAN1_RX0_IRQHandler(void)
    449          {
    450          	u32 PF; 
    451          
    452          	CAN_Receive(CAN1,CAN_FIFO0,&RxMsg);
    453          				
    454          	Iden.Source_Address = (RxMsg.ExtId & 0x000000ff)  >> 0;
    455          	Iden.PDU_Specific = (RxMsg.ExtId  & 0x0000ff00) >> 8;
    456          	
    457          	// Iden.Source_Address == 71	 -->>	MCU
    458          	// Iden.Source_Address == 228	 -->>	EHCU	
    459          	// Iden.Source_Address == 29	 -->>	Smart Key
    460          	// Iden.Source_Address == 23	 -->>	Cluster
    461          	// Iden.Source_Address == 221	 -->>	RCU
    462          	// Iden.Source_Address == 0	 -->>	ECM
    463          	// Iden.Source_Address == 3	 -->>	TCU
    464          	
    465          	if((Iden.Source_Address == 71) || (Iden.Source_Address == 23) || (Iden.Source_Address == 29) || 
    466          		(Iden.Source_Address == 228) || (Iden.Source_Address == 221)|| (Iden.Source_Address == 0x4a)|| (Iden.Source_Address == 0xf4)
    467          		|| (Iden.Source_Address == 0x00)|| (Iden.Source_Address == 0x03))
    468          		{
    469          			if(++CanRecvCnt >= 100)
    470          			{
    471          				CanRecvCnt = 0;
    472          	
    473          				if(pWriteBufPos >= (768*10-1)) // End of Ring Buffer
    474          					pWriteBufPos = 0;
    475          	
    476          				memcpy(&ring_buf[pWriteBufPos], (u8*)&SerialMsgRTC[0], 12);
    477          			
    478          				pWriteBufPos += 12;
    479          				
    480          			}
    481          	
    482          	
    483          			PF = (RxMsg.ExtId  & 0x00ff0000) >> 16;
    484          	
    485          			if((PF == 254) || (PF == 255) || (PF == 239) )
    486          			{	
    487          				if(Iden.PDU_Specific == 251)
    488          				{
    489          					MoniInfoSendCnt = 0;
    490          					Flag_1Sec_MoniInfo = 0;
    491          					MoniInfoTotalPacketNum = 0;
    492          				}
    493          				else
    494          				{
    495          					if( (Iden.PDU_Specific == 84)  ) 
    496          					{
    497          					
    498          						Buz1 = (RxMsg.Data[2] & 0x30 ) >> 4; 		// 1 :On 	0 : Off
    499          					
    500          						if( (Buz1 == 1))
    501          						{
    502          							Buzzer_SendToEXYNOS(1);
    503          						}
    504          						else
    505          						{
    506          							Buzzer_SendToEXYNOS(0);
    507          						}
    508          					}
    509          					//if(Iden.PDU_Specific == 0x9b)
    510          						OperateRingBuffer();
    511          				}
    512          			}
    513          			else if((PF == 235) || (PF == 236))
    514          			{
    515          				if((Iden.PDU_Specific == 255)||(Iden.PDU_Specific == 0x28))
    516          				{
    517          					if(PF == 236)		// TP.CM_BAM
    518          					{
    519          						if(RxMsg.Data[0] == 32) 	// Control Byte (Normal)
    520          						{
    521          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    522          							if(pgn == 65340)
    523          							{
    524          								TotPacketNum = RxMsg.Data[3];		// Total number of packets
    525          								TotMsgSize = (RxMsg.Data[2] << 8) | RxMsg.Data[1];
    526          							}
    527          							else
    528          							{
    529          								Uart2_SerialTxMsg[15] = 0;
    530          								OperateRingBuffer();
    531          							}
    532          							return;
    533          						}
    534          
    535          						else if(RxMsg.Data[0] == 17)	// Control Byte (CTS) 0x11
    536          						{
    537          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    538          							if(pgn == 61184)
    539          							{
    540          								RTSFlag_61184 = 2;
    541          							}
    542          							
    543          						}
    544          						else if(RxMsg.Data[0] == 19)	// Control Byte (ACK) 0x13 
    545          						{
    546          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    547          							if(pgn == 61184)
    548          							{
    549          								RTSFlag_61184 = 0;
    550          							}
    551          						}
    552          						else if(RxMsg.Data[0] == 16)	// Control Byte (RTS) 0x10
    553          						{
    554          							Uart2_SerialTxMsg[15] = 0;
    555          							OperateRingBuffer();
    556          							pgn = (RxMsg.Data[6] << 8) | (RxMsg.Data[5]);
    557          							if(pgn == 61184)
    558          							{
    559          								 Send_CTS_61184(RxMsg.Data);
    560          								 CTSFlag_61184 = 1;
    561          								 RecvTotalPacket_61184 = RxMsg.Data[3];
    562          								 memcpy((u8*)ACK_Multi_61184,(u8*)RxMsg.Data,8);
    563          							}
    564          							
    565          						}
    566          
    567          								
    568          					}
    569          	
    570          					if(pgn != 0)
    571          					{
    572          						if(PF == 235)
    573          						{
    574          							if(pgn == 65340)
    575          							{
    576          								memcpy(&MachineBasicInformation[(RxMsg.Data[0]-1)*7], &RxMsg.Data[1] , 7);
    577          								if(RxMsg.Data[0] == TotPacketNum)
    578          								{
    579          									pgn = TotPacketNum = 0;
    580          									RecvMachInfo = 1;
    581          								}
    582          							}
    583          							
    584          							else
    585          							{
    586          								Uart2_SerialTxMsg[15] = 0;
    587          								OperateRingBuffer();
    588          							}
    589          
    590          							if(pgn == 61184)
    591          							{
    592          								if(RecvTotalPacket_61184 == RxMsg.Data[0])
    593          								{
    594          									RecvTotalPacket_61184 = 0;
    595          									Send_ACK_61184(ACK_Multi_61184);
    596          								}
    597          							
    598          							}
    599          						}
    600          					}
    601          				}
    602          			}
    603          	
    604          			CommErrCnt = 0;
    605          		}
    606          
    607          }
    608          
    609          /**
    610            * @brief  This function handles TIM4 global interrupt request.
    611            * @param  None
    612            * @retval None
    613            */
    614          void TIM4_IRQHandler(void)  //  10msec Timer / TimeBase UP Counter
    615          {
    616              TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    617              
    618              //  BUZZER Status가 "2" 일 경우 BUZZER OnTime 만큼 BUZZER On
    619              if (WL9FM_BUZZER.Status == 2)
    620              {
    621                  if (WL9FM_BUZZER.OnCnt++ < WL9FM_BUZZER.OnTime)
    622                  {
    623                      Buzzer_On();
    624                  }
    625                  else
    626                  {
    627                      WL9FM_BUZZER.Status = 0;               
    628                  }
    629              }        
    630              //  BUZZER Status가 "1" 일 경우 UnLimit BUZZER On
    631              else if (WL9FM_BUZZER.Status == 1)
    632              {
    633                  Buzzer_On();    
    634              }    
    635              else
    636              {
    637                  Buzzer_Off();
    638                  
    639                  WL9FM_BUZZER.Status = 0;               
    640                  WL9FM_BUZZER.OnTime = 0;
    641                  WL9FM_BUZZER.OnCnt  = 0;
    642              }
    643          
    644          #if 1
    645          	CommErrCnt++;
    646          
    647          	if(CommErrCnt >= 1000)
    648          		CommErrCnt = 1001;
    649          #endif
    650          }
    651          
    652          /**
    653            * @brief  This function handles TIM5 global interrupt request.
    654            * @param  None
    655            * @retval None
    656            */
    657          void TIM5_IRQHandler(void)  //  5msec Timer / TimeBase UP Counter    
    658          {
    659              TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
    660              
    661              KeySwitch_Process();    //  KeySwitch.c Func
    662          }
    663          
    664          /**
    665            * @brief  This function handles USART3 global interrupt request.
    666            * @param  None
    667            * @retval None
    668            */
    669            // STM32F407 <-> exynos4412 can_data
    670          
    671          unsigned char temp_61184;
    672          
    673          void USART2_IRQHandler(void)
    674          {
    675          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    676          	{
    677          		Uart2_SerialRxMsg[Uart2_SerialRxCnt] = (u8)USART_ReceiveData(USART2);
    678          
    679          		  //  디버깅할 때만 사용할 것
    680          		#ifdef DEBUG_CAN_RX
    681          		DebugMsg_printf("%2x ", Uart2_SerialRxMsg[Uart2_SerialRxCnt]);
    682          		#endif
    683          		
    684          		switch(Uart2_SerialRxCnt)
    685          		{
    686          			case 0:
    687          				if(Uart2_SerialRxMsg[0] == 0x02)		// STX
    688          					Uart2_SerialRxCnt++;
    689          				break;
    690          			case 1:
    691          				if(Uart2_SerialRxMsg[1] == 0xF5)		// ID
    692          					Uart2_SerialRxCnt++;
    693          				else
    694          					Uart2_SerialRxCnt = 0;
    695          				break;
    696          			case 25:
    697          				Uart2_SerialRxCnt = 0;
    698          
    699          				if(Uart2_SerialRxMsg[25] == 0x03)		// ETX
    700          				{
    701                              			//  디버깅할 때만 사용할 것
    702          					#ifdef DEBUG_CAN_RX
    703          					DebugMsg_printf("\r\n");
    704          					#endif
    705          					
    706          					switch(Uart2_SerialRxMsg[3])		// Cmd
    707          					{
    708          						case 1 :		// UART TX Start Flag
    709          							Flag_UartTxStart = 1;
    710          							Flag_TxE2pRomData=0;
    711          							SendEEPROMDataCnt=0;
    712          							break;
    713          						case 2 :	// Save Data1
    714          							memcpy(&Uart2_RxMsg_Save_Data1[0], &Uart2_SerialRxMsg[4], 8);
    715          							break;
    716          						case 3 :	// Save Data2
    717          							memcpy(&Uart2_RxMsg_Save_Data2[0], &Uart2_SerialRxMsg[4], 8);
    718          							break;
    719          						case 4 :	// A/S Phone Number -> Save to EEPROM
    720          							memcpy(&Uart2_RxMsg_AS_Phone_Data[0], &Uart2_SerialRxMsg[4], 8);
    721          							break;
    722          
    723          							
    724          						
    725          							case 11 : memcpy(&Uart2_RxMsg_Single_11[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_11));	Flag_SerialRxMsg |= RX_MSG11; break;
    726          							case 12 : memcpy(&Uart2_RxMsg_Single_12[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_12));	Flag_SerialRxMsg |= RX_MSG12;break;
    727          							case 21 : memcpy(&Uart2_RxMsg_Single_21[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_21));	Flag_SerialRxMsg |= RX_MSG21;break;
    728          							case 23 : memcpy(&Uart2_RxMsg_Multi_23[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Multi_23));	Flag_SerialRxMsg |= RX_MSG23; RTSFlag_61184 = 1;break;
    729          							case 61 : memcpy(&Uart2_RxMsg_Single_61[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_61));	Flag_SerialRxMsg |= RX_MSG61;break;
    730          							case 62 : memcpy(&Uart2_RxMsg_Single_62[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_62));	Flag_SerialRxMsg |= RX_MSG62;break;
    731          							case 101 : memcpy(&Uart2_RxMsg_Single_101[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_101));Flag_SerialRxMsg |= RX_MSG101;	break;
    732          							case 104 : memcpy(&Uart2_RxMsg_Single_104[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_104));	Flag_SerialRxMsg |= RX_MSG104;break;
    733          							case 105 : memcpy(&Uart2_RxMsg_Single_105[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_105));	Flag_SerialRxMsg |= RX_MSG105;break;
    734          							case 109 : memcpy(&Uart2_RxMsg_Single_109[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_109));	Flag_SerialRxMsg |= RX_MSG109;break;
    735          							case 121 : memcpy(&Uart2_RxMsg_Single_121[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_121));	Flag_SerialRxMsg |= RX_MSG121;break;
    736          							case 123 : memcpy(&Uart2_RxMsg_Single_123[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_123));	Flag_SerialRxMsg |= RX_MSG123;break;
    737          							case 201 : memcpy(&Uart2_RxMsg_Single_201[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_201));	Flag_SerialRxMsg |= RX_MSG201;break;
    738          							case 203 : memcpy(&Uart2_RxMsg_Single_203[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_203));	Flag_SerialRxMsg |= RX_MSG203;break;
    739          								
    740          								
    741          							case 47 : memcpy(&Uart2_RxMsg_Single_47[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_47));	break;
    742          								
    743          							case 145 : memcpy(&Uart2_RxMsg_Multi_145[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Multi_145));	Flag_SerialRxMsg |= RX_MSG145;break;
    744          							case 247 : memcpy(&Uart2_RxMsg_Single_247[0], &Uart2_SerialRxMsg[4], sizeof(Uart2_RxMsg_Single_247));	Flag_SerialRxMsg |= RX_MSG247;break;
    745          						
    746          
    747          						#if 0
    748          							
    749          						case 203 :  // for EHCU setting 61184 format 131017
    750          							Flag_SerialRxMsg |= RX_MSG203;
    751          							memcpy(&Uart2_RxMsg_Single_46[0], &Uart2_SerialRxMsg[4], 8);
    752          							break;
    753          						case 69 :	// When needed
    754          							Flag_SerialRxMsg |= RX_MSG69;
    755          							memcpy(&Uart2_RxMsg_Single_69[0], &Uart2_SerialRxMsg[4], 8);
    756          							break;
    757          						case 70 :	// When needed - RX_MSG69 Multi Packet
    758          							Flag_SerialRxMsg |= RX_MSG69_M;
    759          							memcpy(&Uart2_RxMsg_Multi_69[0], &Uart2_SerialRxMsg[4], 21);
    760          							break;
    761          						case 160 :	// 100 ms
    762          							if((Uart2_RxMsg_Single_160[0] & 0xc0) == 0xc0)
    763          								memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    764          							else
    765          							{
    766          								memcpy(&Uart2_RxMsg_Single_160[1], &Uart2_SerialRxMsg[5], 7);
    767          								Uart2_RxMsg_Single_160[0] |= (Uart2_SerialRxMsg[4] & 0x3F);
    768          							}
    769          																						
    770          							if(((Uart2_SerialRxMsg[4] & 0xc0) == 0x00) || ((Uart2_SerialRxMsg[4] & 0xc0) == 0x40))
    771          							        memcpy(&Uart2_RxMsg_Single_160[0], &Uart2_SerialRxMsg[4], 8);
    772          							break;
    773          						case 161 :	// When needed
    774          							Flag_SerialRxMsg |= RX_MSG161;
    775          							memcpy(&Uart2_RxMsg_Multi_161[0], &Uart2_SerialRxMsg[4], 14);
    776          							temp_61184=0;
    777          							break;
    778          						case 162 :	// When needed
    779          							//Flag_SerialRxMsg |= RX_MSG162;
    780          							if(Uart2_RxMsg_Single_162[4] == 0)
    781          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 8);
    782          							else
    783          								memcpy(&Uart2_RxMsg_Single_162[0], &Uart2_SerialRxMsg[4], 4);
    784          							break;	
    785          						case 163 :
    786          							Flag_SerialRxMsg |= RX_MSG163;
    787          							memcpy(&Uart2_RxMsg_Single_163[0], &Uart2_SerialRxMsg[4], 8);
    788          							break;
    789          						case 174 :
    790          							Flag_SerialRxMsg |= RX_MSG174;
    791          							memcpy(&Uart2_RxMsg_Single_174[0], &Uart2_SerialRxMsg[4], 8);
    792          							break;
    793          						case 205 :	// Stop Send Cmd - A/S Phone Number
    794          							stop_send_as_phone_data = 1;
    795          							break;
    796          
    797          						case 210 :	// Smart Key Registration, Elimination
    798          							memcpy(&Uart2_RxMsg_Smk_Reg_Eli[0], &Uart2_SerialRxMsg[4], 8);
    799          							break;
    800          						case 247 :
    801          							Flag_SerialRxMsg |= RX_MSG247;
    802          							memcpy(&Uart2_RxMsg_Single_247[0], &Uart2_SerialRxMsg[4], 8);							
    803          							break;	
    804          						case 251 :
    805          							Flag_SerialRxMsg |= RX_MSG251;
    806          							memcpy(&Uart2_RxMsg_Single_251[0], &Uart2_SerialRxMsg[4], 8);							
    807          							break;
    808          						case 252 :	// Clock Set Data
    809          							Flag_SerialRxMsg |= RX_MSG252;
    810          							memcpy(&Uart2_RxMsg_Single_252[0], &Uart2_SerialRxMsg[4], 8);							
    811          							break;
    812          						case 253 :
    813          							Flag_SerialRxMsg |= RX_MSG253;
    814          							memcpy(&Uart2_RxMsg_Single_253[0], &Uart2_SerialRxMsg[4], 8);							
    815          							break;
    816          						case 101 :
    817          						case 102 :
    818          						case 109 : 
    819          						case 61 : 
    820          						case 31 : 
    821          						case 33 : 
    822          						case 34 : 
    823          						case 123 : 
    824          							Flag_SerialRxMsg |= RX_MSG239;
    825          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);		
    826          								
    827          							temp_61184++;
    828          							
    829          							break;
    830          
    831          						case 121 :
    832          							Flag_SerialRxMsg |= RX_MSG239;
    833          							Flag_SerialRxMsg |= RX_MSG239_121;
    834          							memcpy(&Uart2_RxMsg_Single_239[0], &Uart2_SerialRxMsg[4], 8);	
    835          							memcpy(&Uart2_RxMsg_Single_239_121[0], &Uart2_SerialRxMsg[4], 8);	
    836          							temp_61184++;
    837          							break;
    838          					#endif
    839          						
    840          					}
    841          				}
    842          				else
    843          				{
    844          					//  디버깅할 때만 사용할 것
    845          					//DebugMsg_printf("Protocol Fail\r\n");
    846          				}
    847          
    848          				break;
    849          			
    850          			default :
    851          				Uart2_SerialRxCnt++;
    852          				break;
    853          		}
    854          	}
    855          
    856          	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    857          	{   
    858          		if((USART2->SR & 0x80) == RESET)
    859          			return;
    860          
    861          		if (pWriteBufPos == pReadBufPos)
    862          		{
    863          			if(Flag_TxE2pRomData == 1)
    864          			{
    865          			    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    866          			    return;
    867          		    	}
    868          		}
    869          
    870          		if(pReadBufPos >= (RING_BUF_SIZE-1))
    871          			pReadBufPos = 0;
    872          
    873          		if((Uart2_SerialTxCnt == 0) && (pWriteBufPos != pReadBufPos))
    874          		{
    875          			memcpy(&Uart2_SerialTxMsg[3] , &ring_buf[pReadBufPos], 12);
    876          		}
    877          		
    878          		USART_SendData(USART2, (u16)(Uart2_SerialTxMsg[Uart2_SerialTxCnt++]));    
    879          		
    880          		if (Uart2_SerialTxCnt >= UART2_Tx_BUF_SIZE)
    881          		{
    882          			//Uart2_SerialTxCnt = 0;
    883          			//pReadBufPos += 12;
    884          			//USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    885          
    886          			if(Flag_TxE2pRomData == 0)
    887          			{
    888                          		//  보내는 횟수 중요하다. 초기에 버그가 생실 수 있으니, 테스트 필요함!!!
    889          				//	EEPROM Data를 6번 보낸다.
    890          				if(SendEEPROMDataCnt > 5)	
    891          				{
    892          					Uart2_SerialTxCnt = 0;	
    893          					Uart2_SerialTxMsg[15] = 0;
    894          					Flag_TxE2pRomData = 1;
    895          						
    896          					//	EEPROM Data를 그만 보내고 CAN Data를 보낸다. 
    897          					Flag_UartTxStart = 0;
    898          					
    899          					//  Enable the USART2 Transmit interrupt
    900          					USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    901          					CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);			
    902          				}
    903          				else
    904          				{
    905          					SendEEPROMDataCnt++;
    906          			        	Uart2_SerialTxCnt = 0;
    907          
    908          					//  Disable the USART3 Transmit interrupt
    909          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    910          				}
    911          			}
    912          			else
    913          			{
    914          				Uart2_SerialTxCnt = 0;
    915          				pReadBufPos += 12;
    916          			}
    917          		}  
    918          	}
    919          }
    920          
    921          void UART4_IRQHandler(void)
    922          {
    923          	//  UART4 receive interrupt routine
    924          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) 
    925              	{
    926              		if(Change_UART4_for_Download==0)
    927          			UART4_Receive_CMD();
    928          		else
    929          			UART4_Receive_File();
    930          				
    931          	}
    932          	//  UART4 transmit interrupt routine
    933          	if (USART_GetITStatus(UART4, USART_IT_TXE) != RESET)
    934          	{   
    935          		UART4_transmit_CMD();
    936          	}
    937          }
    938          
    939          u8 temp_rx_buf[4];
    940          
    941          
    942          void UART4_Receive_CMD(void)
    943          {
    944          	uint8_t Temp[Serial_COM4_TxSize];
    945          	//  Read one byte to the receive data register
    946          	WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt] = USART_ReceiveData(UART4);
    947          
    948          	
    949              	//  디버깅할 때만 사용할 것
    950          	#ifdef DEBUG_CMD_RX
    951          	DebugMsg_printf("%2x ", WL9FM_USART_DATA.COM4_RxBuf[WL9FM_USART_INDEX.COM4_RxCnt]);
    952          	#endif
    953          
    954          	
    955          	switch (WL9FM_USART_INDEX.COM4_RxCnt)
    956          	{
    957          		case 0:
    958          				if (WL9FM_USART_DATA.COM4_RxBuf[0] == STX)
    959          				{
    960          					WL9FM_USART_INDEX.COM4_RxCnt++;
    961          				}	
    962          				else
    963          				{
    964          					WL9FM_USART_INDEX.COM4_RxCnt=0;
    965          				}
    966          				
    967          				break;
    968          		case 1:
    969          				if (WL9FM_USART_DATA.COM4_RxBuf[1]      == KeyCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    970          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LCDBLCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    971          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == BUZZERCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    972          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == LAMPCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    973          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == CAMCMD)		WL9FM_USART_INDEX.COM4_RxCnt++;
    974          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == DOWNCMD)	WL9FM_USART_INDEX.COM4_RxCnt++;
    975          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionHighCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    976          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionLowCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    977          				else if (WL9FM_USART_DATA.COM4_RxBuf[1] == VersionSubCMD) WL9FM_USART_INDEX.COM4_RxCnt++;
    978          				else if ((WL9FM_USART_DATA.COM4_RxBuf[1]&0x80) == 0x80)	WL9FM_USART_INDEX.COM4_RxCnt++;          
    979                          else
    980                          {
    981                            	WL9FM_USART_INDEX.COM4_RxCnt = 0;
    982                          }
    983          				break;
    984          
    985          		case 3: 
    986          				WL9FM_USART_INDEX.COM4_RxCnt = 0;
    987          				
    988          				//  디버깅할 때만 사용할 것
    989          				#ifdef DEBUG_CMD_RX
    990          				DebugMsg_printf("\r\n");
    991          				#endif
    992          
    993          		if (WL9FM_USART_DATA.COM4_RxBuf[Serial_COM4_RxSize-1] == ETX)
    994          		{
    995          			switch (WL9FM_USART_DATA.COM4_RxBuf[1])
    996          			{
    997          				case KeyCMD   :		//	Key Command
    998          
    999          					break;
   1000          							
   1001          				case LCDBLCMD :		//	LCD BackLight Command
   1002          
   1003          					//	LCD BackLight Level 조절.. Level0 ~ Level8
   1004          					if (WL9FM_USART_DATA.COM4_RxBuf[2] < MaxBackLightLEVEL) 												
   1005          					{
   1006          						LCDBL_PWM_LEVEL(WL9FM_USART_DATA.COM4_RxBuf[2]);
   1007          					}
   1008          
   1009          					break;
   1010          
   1011          				case BUZZERCMD :	//	Buzzer Command
   1012          					break;
   1013          
   1014          				case LAMPCMD :	//	Buzzer Command
   1015          					Lamp_name = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0xf0)>>4;
   1016          					Lamp_Value = (WL9FM_USART_DATA.COM4_RxBuf[2] & 0x0f);
   1017          					
   1018          					Lamp_Update_State();
   1019          					break;
   1020          					
   1021          				case CAMCMD:
   1022          					cam_mode_change(WL9FM_USART_DATA.COM4_RxBuf[2]);
   1023          					break;
   1024          
   1025          				case DOWNCMD:
   1026          					Stm32_Update_CMD = WL9FM_USART_DATA.COM4_RxBuf[2];
   1027          					ST_Update=1;
   1028          					break;
   1029          				case  DUMMYCMD:
   1030          					CMD_DUMMY_SendToExynos(0);
   1031          					break;
   1032          				case VersionHighCMD:
   1033          					
   1034          					Temp[0] = 0x02;				
   1035          					Temp[1] = VersionHighCMD;				
   1036          					Temp[2] = VERSION_HIGH ;	
   1037          					Temp[3] = 0x03;	
   1038          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1039          					break;
   1040          				case VersionLowCMD:
   1041          					
   1042          					Temp[0] = 0x02;				
   1043          					Temp[1] = VersionLowCMD;				
   1044          					Temp[2] = VERSION_LOW ;	
   1045          					Temp[3] = 0x03;	
   1046          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1047          					break;
   1048          				case VersionSubCMD:
   1049          					
   1050          					Temp[0] = 0x02;				
   1051          					Temp[1] = VersionSubCMD;				
   1052          					Temp[2] = VERSION_SUB ;	
   1053          					Temp[3] = 0x03;	
   1054          					USARTx_EXYNOS(COM4, (char *)Temp);	
   1055          					break;
   1056          				default :
   1057          					break;								
   1058          			}
   1059                          }						
   1060          
   1061          		//memset(WL9FM_USART_DATA.COM4_RxBuf, 0x0, Serial_COM4_RxSize);					
   1062          				break;
   1063          		
   1064          		default :
   1065          
   1066          			WL9FM_USART_INDEX.COM4_RxCnt++;
   1067          			break;
   1068          	}	
   1069          }
   1070          
   1071          void UART4_Receive_File(void)
   1072          {
   1073          	
   1074          	//  Read one byte to the receive data register
   1075          	WL9FM_USART_RX_FILE_DATA.File_RxBuf[WL9FM_USART_RX_FILE_DATA.File_RxCnt] = USART_ReceiveData(UART4);
   1076          	
   1077          	switch (WL9FM_USART_RX_FILE_DATA.File_RxCnt)
   1078          	{
   1079          		case 0:
   1080          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[0] == STX)
   1081          				{
   1082          					WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1083          				}						
   1084          				break;
   1085          		case 1029: 
   1086          				WL9FM_USART_RX_FILE_DATA.File_RxCnt = 0;
   1087          					
   1088          				if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == ETX)
   1089          				{
   1090          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1091          					ST_Update=1;
   1092          				}
   1093          				else if (WL9FM_USART_RX_FILE_DATA.File_RxBuf[1029] == EOT)
   1094          				{
   1095          					memcpy(&WL9FM_USART_FILE_DATA , &WL9FM_USART_RX_FILE_DATA, Serial_file_RxSize);	
   1096          					Change_UART4_for_Download =2;
   1097          					ST_Update=1;
   1098          				}
   1099          				else
   1100          				{
   1101          					ACK_NACK_SendToExynos(NAK);
   1102          				}
   1103                                          break;
   1104          		default :
   1105          
   1106          			WL9FM_USART_RX_FILE_DATA.File_RxCnt++;
   1107          			break;
   1108          	}					
   1109          }
   1110          
   1111          
   1112          void UART4_transmit_CMD(void)
   1113          {
   1114          	//  Write one byte to the transmit data register
   1115          	USART_SendData(UART4, WL9FM_USART_DATA.COM4_TxBuf[WL9FM_USART_INDEX.COM4_TxCnt++]);
   1116          
   1117          	if (WL9FM_USART_INDEX.COM4_TxIdx >= Serial_COM4_TxSize)
   1118          	{
   1119          		WL9FM_USART_INDEX.COM4_TxIdx = Serial_COM4_TxSize;
   1120          	}    
   1121          	if (WL9FM_USART_INDEX.COM4_TxCnt == WL9FM_USART_INDEX.COM4_TxIdx)
   1122          	{
   1123          		//  Disable the UART4 Transmit interrupt
   1124          		USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   1125          
   1126          		WL9FM_USART_INDEX.COM4_TxIdx = 0; //  transmit buffer Index clear
   1127          		WL9FM_USART_INDEX.COM4_TxCnt = 0; //  transmit buffer Cnt   clear
   1128          	}              
   1129          }
   1130          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BusFault_Handler
      16   CAN1_RX0_IRQHandler
        16   -> Buzzer_SendToEXYNOS
        16   -> CAN_Receive
         0   -> OperateRingBuffer
        16   -> OperateRingBuffer
        16   -> Send_ACK_61184
        16   -> Send_CTS_61184
        16   -> __aeabi_memcpy
       0   DebugMon_Handler
       0   HardFault_Handler
       0   MemManage_Handler
       0   NMI_Handler
      16   OperateRingBuffer
         0   -> USART_ITConfig
        16   -> memcpy
       0   PendSV_Handler
       0   SVC_Handler
       8   SendTo_E2PROM
         0   -> USART_ITConfig
         8   -> memcpy
       8   SysTick_Handler
         8   -> TimeDelay_Decrement
       8   TIM4_IRQHandler
         8   -> Buzzer_Off
         8   -> Buzzer_On
         8   -> TIM_ClearITPendingBit
       8   TIM5_IRQHandler
         0   -> KeySwitch_Process
         8   -> TIM_ClearITPendingBit
       8   UART4_IRQHandler
         8   -> UART4_Receive_CMD
         8   -> UART4_Receive_File
         8   -> UART4_transmit_CMD
         8   -> USART_GetITStatus
       8   UART4_Receive_CMD
         8   -> CMD_DUMMY_SendToExynos
         8   -> LCDBL_PWM_LEVEL
         8   -> Lamp_Update_State
         8   -> USART_ReceiveData
         8   -> USARTx_EXYNOS
         8   -> cam_mode_change
       8   UART4_Receive_File
         0   -> ACK_NACK_SendToExynos
         8   -> USART_ReceiveData
         8   -> __aeabi_memcpy
      16   UART4_transmit_CMD
        16   -> USART_ITConfig
        16   -> USART_SendData
      24   USART2_IRQHandler
         0   -> CAN_ITConfig
        24   -> USART_GetITStatus
         0   -> USART_ITConfig
        24   -> USART_ITConfig
        24   -> USART_ReceiveData
        24   -> USART_SendData
        24   -> __aeabi_memcpy
       0   UsageFault_Handler
       0   WL9F_CAN_Buffer_Init
       8   memcpy
         8   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_33
       4  ??DataTable12_34
       4  ??DataTable12_35
       4  ??DataTable12_36
       4  ??DataTable12_37
       4  ??DataTable12_38
       4  ??DataTable12_39
       4  ??DataTable12_4
       4  ??DataTable12_40
       4  ??DataTable12_41
       4  ??DataTable12_42
       4  ??DataTable12_43
       4  ??DataTable12_44
       4  ??DataTable12_45
       4  ??DataTable12_46
       4  ??DataTable12_47
       4  ??DataTable12_48
       4  ??DataTable12_49
       4  ??DataTable12_5
       4  ??DataTable12_50
       4  ??DataTable12_51
       4  ??DataTable12_52
       4  ??DataTable12_53
       4  ??DataTable12_54
       4  ??DataTable12_55
       4  ??DataTable12_56
       4  ??DataTable12_57
       4  ??DataTable12_58
       4  ??DataTable12_59
       4  ??DataTable12_6
       4  ??DataTable12_60
       4  ??DataTable12_61
       4  ??DataTable12_62
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       8  ?Subroutine0
       2  BusFault_Handler
     500  CAN1_RX0_IRQHandler
       2  DebugMon_Handler
       2  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
     206  OperateRingBuffer
       2  PendSV_Handler
      20  RxMsg
       2  SVC_Handler
      78  SendTo_E2PROM
       1  Stm32_Update_CMD
     106  SysTick_Handler
      86  TIM4_IRQHandler
      20  TIM5_IRQHandler
      56  UART4_IRQHandler
     292  UART4_Receive_CMD
     108  UART4_Receive_File
      64  UART4_transmit_CMD
     844  USART2_IRQHandler
      32  Uart2_SerialRxMsg
          Uart2_SerialRxCnt
          Flag_TxE2pRomData
          pReadBufPos
    7724  Uart2_SerialTxMsg
          Iden
          CanRecvCnt
          Uart2_SerialTxCnt
          SendEEPROMDataCnt
          Buz1
          pWriteBufPos
          TotPacketNum
          TotMsgSize
          CommErrCnt
          pgn
          ring_buf
       2  UsageFault_Handler
      36  WL9F_CAN_Buffer_Init
      12  memcpy
       2  old_test
       1  stop_send_as_phone_data
       1  temp_61184
       4  temp_rx_buf
       2  test
       8  test_temp

 
 7 795 bytes in section .bss
 2 684 bytes in section .text
 
 2 672 bytes of CODE memory (+ 12 bytes shared)
 7 795 bytes of DATA memory

Errors: none
Warnings: none
