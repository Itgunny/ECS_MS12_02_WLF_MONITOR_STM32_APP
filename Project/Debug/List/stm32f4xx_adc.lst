###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      04/Mar/2013  20:26:44 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\src\stm32f4xx_adc.c                          #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\src\stm32f4xx_adc.c" -D                      #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN "C:\Tools\IAR Systems\Embedded   #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\L #
#                    ist\" -o "C:\Tools\IAR Systems\Embedded Workbench        #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\stm32f #
#                    4xx_adc.lst                                              #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\stm32f4 #
#                    xx_adc.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           - Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           - Analog Watchdog configuration
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           - Regular Channels Configuration
     15            *           - Regular Channels DMA Configuration
     16            *           - Injected channels Configuration
     17            *           - Interrupts and flags management
     18            *         
     19            *  @verbatim
     20            *
     21            *          ===================================================================
     22            *                                   How to use this driver
     23            *          ===================================================================
     24          
     25            *          1.  Enable the ADC interface clock using 
     26            *                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     27            *     
     28            *          2. ADC pins configuration
     29            *               - Enable the clock for the ADC GPIOs using the following function:
     30            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     31            *                - Configure these ADC pins in analog mode using GPIO_Init();  
     32            *
     33            *          3. Configure the ADC Prescaler, conversion resolution and data 
     34            *              alignment using the ADC_Init() function.
     35            *          4. Activate the ADC peripheral using ADC_Cmd() function.
     36            *
     37            *          Regular channels group configuration
     38            *          ====================================    
     39            *            - To configure the ADC regular channels group features, use 
     40            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     41            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     42            *              function.
     43            *            - To configurate and activate the Discontinuous mode, use the 
     44            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     46            *              function.
     47            *
     48            *          Multi mode ADCs Regular channels configuration
     49            *          ===============================================
     50            *            - Refer to "Regular channels group configuration" description to
     51            *              configure the ADC1, ADC2 and ADC3 regular channels.        
     52            *            - Select the Multi mode ADC regular channels features (dual or 
     53            *              triple mode) using ADC_CommonInit() function and configure 
     54            *              the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     55            *              functions.        
     56            *            - Read the ADCs converted values using the 
     57            *              ADC_GetMultiModeConversionValue() function.
     58            *
     59            *          DMA for Regular channels group features configuration
     60            *          ====================================================== 
     61            *           - To enable the DMA mode for regular channels group, use the 
     62            *             ADC_DMACmd() function.
     63            *           - To enable the generation of DMA requests continuously at the end
     64            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     65            *             function.
     66            *
     67            *          Injected channels group configuration
     68            *          =====================================    
     69            *            - To configure the ADC Injected channels group features, use 
     70            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     71            *              functions.
     72            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     73            *              function.
     74            *            - To activate the Injected Discontinuous mode, use the 
     75            *              ADC_InjectedDiscModeCmd() function.  
     76            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     77            *              function.        
     78            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     79            *              function.
     80            *
     81            *  @endverbatim
     82            *
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     87            *
     88            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     89            * You may not use this file except in compliance with the License.
     90            * You may obtain a copy of the License at:
     91            *
     92            *        http://www.st.com/software_license_agreement_liberty_v2
     93            *
     94            * Unless required by applicable law or agreed to in writing, software 
     95            * distributed under the License is distributed on an "AS IS" BASIS, 
     96            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     97            * See the License for the specific language governing permissions and
     98            * limitations under the License.
     99            *
    100            ******************************************************************************
    101            */ 
    102          
    103          /* Includes ------------------------------------------------------------------*/
    104          #include "stm32f4xx_adc.h"
    105          #include "stm32f4xx_rcc.h"
    106          
    107          /** @addtogroup STM32F4xx_StdPeriph_Driver
    108            * @{
    109            */
    110          
    111          /** @defgroup ADC 
    112            * @brief ADC driver modules
    113            * @{
    114            */ 
    115          
    116          /* Private typedef -----------------------------------------------------------*/
    117          /* Private define ------------------------------------------------------------*/ 
    118          
    119          /* ADC DISCNUM mask */
    120          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    121          
    122          /* ADC AWDCH mask */
    123          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    124          
    125          /* ADC Analog watchdog enable mode mask */
    126          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    127          
    128          /* CR1 register Mask */
    129          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    130          
    131          /* ADC EXTEN mask */
    132          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    133          
    134          /* ADC JEXTEN mask */
    135          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    136          
    137          /* ADC JEXTSEL mask */
    138          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    139          
    140          /* CR2 register Mask */
    141          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    142          
    143          /* ADC SQx mask */
    144          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    145          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    146          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    147          
    148          /* ADC L Mask */
    149          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    150          
    151          /* ADC JSQx mask */
    152          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    153          
    154          /* ADC JL mask */
    155          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    156          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    157          
    158          /* ADC SMPx mask */
    159          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    160          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    161          
    162          /* ADC JDRx registers offset */
    163          #define JDR_OFFSET                ((uint8_t)0x28) 
    164          
    165          /* ADC CDR register base address */
    166          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    167          
    168          /* ADC CCR register Mask */
    169          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    170          
    171          /* Private macro -------------------------------------------------------------*/
    172          /* Private variables ---------------------------------------------------------*/
    173          /* Private function prototypes -----------------------------------------------*/
    174          /* Private functions ---------------------------------------------------------*/
    175          
    176          /** @defgroup ADC_Private_Functions
    177            * @{
    178            */ 
    179          
    180          /** @defgroup ADC_Group1 Initialization and Configuration functions
    181           *  @brief    Initialization and Configuration functions 
    182           *
    183          @verbatim    
    184           ===============================================================================
    185                                Initialization and Configuration functions
    186           ===============================================================================  
    187            This section provides functions allowing to:
    188             - Initialize and configure the ADC Prescaler
    189             - ADC Conversion Resolution (12bit..6bit)
    190             - Scan Conversion Mode (multichannels or one channel) for regular group
    191             - ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    192               regular group
    193             - External trigger Edge and source of regular group, 
    194             - Converted data alignment (left or right)
    195             - The number of ADC conversions that will be done using the sequencer for 
    196               regular channel group
    197             - Multi ADC mode selection
    198             - Direct memory access mode selection for multi ADC mode  
    199             - Delay between 2 sampling phases (used in dual or triple interleaved modes)
    200             - Enable or disable the ADC peripheral
    201             
    202          @endverbatim
    203            * @{
    204            */
    205          
    206          /**
    207            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    208            *         values.
    209            * @param  None
    210            * @retval None
    211            */
    212          void ADC_DeInit(void)
    213          {
    214            /* Enable all ADCs reset state */
    215            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
    216            
    217            /* Release all ADCs from reset state */
    218            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
    219          }
    220          
    221          /**
    222            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    223            *         in the ADC_InitStruct.
    224            * @note   This function is used to configure the global features of the ADC ( 
    225            *         Resolution and Data Alignment), however, the rest of the configuration
    226            *         parameters are specific to the regular channels group (scan mode 
    227            *         activation, continuous mode activation, External trigger source and 
    228            *         edge, number of conversion in the regular channels group sequencer).  
    229            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    230            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    231            *         the configuration information for the specified ADC peripheral.
    232            * @retval None
    233            */
    234          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    235          {
    236            uint32_t tmpreg1 = 0;
    237            uint8_t tmpreg2 = 0;
    238            /* Check the parameters */
    239            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    240            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    241            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    242            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
    243            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
    244            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
    245            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    246            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
    247            
    248            /*---------------------------- ADCx CR1 Configuration -----------------*/
    249            /* Get the ADCx CR1 value */
    250            tmpreg1 = ADCx->CR1;
    251            
    252            /* Clear RES and SCAN bits */
    253            tmpreg1 &= CR1_CLEAR_MASK;
    254            
    255            /* Configure ADCx: scan conversion mode and resolution */
    256            /* Set SCAN bit according to ADC_ScanConvMode value */
    257            /* Set RES bit according to ADC_Resolution value */ 
    258            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    259                                             ADC_InitStruct->ADC_Resolution);
    260            /* Write to ADCx CR1 */
    261            ADCx->CR1 = tmpreg1;
    262            /*---------------------------- ADCx CR2 Configuration -----------------*/
    263            /* Get the ADCx CR2 value */
    264            tmpreg1 = ADCx->CR2;
    265            
    266            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    267            tmpreg1 &= CR2_CLEAR_MASK;
    268            
    269            /* Configure ADCx: external trigger event and edge, data alignment and 
    270               continuous conversion mode */
    271            /* Set ALIGN bit according to ADC_DataAlign value */
    272            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    273            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    274            /* Set CONT bit according to ADC_ContinuousConvMode value */
    275            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    276                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    277                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    278                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    279                                  
    280            /* Write to ADCx CR2 */
    281            ADCx->CR2 = tmpreg1;
    282            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    283            /* Get the ADCx SQR1 value */
    284            tmpreg1 = ADCx->SQR1;
    285            
    286            /* Clear L bits */
    287            tmpreg1 &= SQR1_L_RESET;
    288            
    289            /* Configure ADCx: regular channel sequence length */
    290            /* Set L bits according to ADC_NbrOfConversion value */
    291            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
    292            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
    293            
    294            /* Write to ADCx SQR1 */
    295            ADCx->SQR1 = tmpreg1;
    296          }
    297          
    298          /**
    299            * @brief  Fills each ADC_InitStruct member with its default value.
    300            * @note   This function is used to initialize the global features of the ADC ( 
    301            *         Resolution and Data Alignment), however, the rest of the configuration
    302            *         parameters are specific to the regular channels group (scan mode 
    303            *         activation, continuous mode activation, External trigger source and 
    304            *         edge, number of conversion in the regular channels group sequencer).  
    305            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    306            *         be initialized.
    307            * @retval None
    308            */
    309          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    310          {
    311            /* Initialize the ADC_Mode member */
    312            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
    313          
    314            /* initialize the ADC_ScanConvMode member */
    315            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    316          
    317            /* Initialize the ADC_ContinuousConvMode member */
    318            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    319          
    320            /* Initialize the ADC_ExternalTrigConvEdge member */
    321            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
    322          
    323            /* Initialize the ADC_ExternalTrigConv member */
    324            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    325          
    326            /* Initialize the ADC_DataAlign member */
    327            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    328          
    329            /* Initialize the ADC_NbrOfConversion member */
    330            ADC_InitStruct->ADC_NbrOfConversion = 1;
    331          }
    332          
    333          /**
    334            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    335            *         in the ADC_CommonInitStruct.
    336            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    337            *         that contains the configuration information for  All ADCs peripherals.
    338            * @retval None
    339            */
    340          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    341          {
    342            uint32_t tmpreg1 = 0;
    343            /* Check the parameters */
    344            assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
    345            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
    346            assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
    347            assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
    348            /*---------------------------- ADC CCR Configuration -----------------*/
    349            /* Get the ADC CCR value */
    350            tmpreg1 = ADC->CCR;
    351            
    352            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    353            tmpreg1 &= CR_CLEAR_MASK;
    354            
    355            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    356               and DMA access mode for multimode */
    357            /* Set MULTI bits according to ADC_Mode value */
    358            /* Set ADCPRE bits according to ADC_Prescaler value */
    359            /* Set DMA bits according to ADC_DMAAccessMode value */
    360            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    361            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    362                                  ADC_CommonInitStruct->ADC_Prescaler | 
    363                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    364                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
    365                                  
    366            /* Write to ADC CCR */
    367            ADC->CCR = tmpreg1;
    368          }
    369          
    370          /**
    371            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    372            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    373            *         which will be initialized.
    374            * @retval None
    375            */
    376          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    377          {
    378            /* Initialize the ADC_Mode member */
    379            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
    380          
    381            /* initialize the ADC_Prescaler member */
    382            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
    383          
    384            /* Initialize the ADC_DMAAccessMode member */
    385            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
    386          
    387            /* Initialize the ADC_TwoSamplingDelay member */
    388            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
    389          }
    390          
    391          /**
    392            * @brief  Enables or disables the specified ADC peripheral.
    393            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    394            * @param  NewState: new state of the ADCx peripheral. 
    395            *          This parameter can be: ENABLE or DISABLE.
    396            * @retval None
    397            */
    398          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    399          {
    400            /* Check the parameters */
    401            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    402            assert_param(IS_FUNCTIONAL_STATE(NewState));
    403            if (NewState != DISABLE)
    404            {
    405              /* Set the ADON bit to wake up the ADC from power down mode */
    406              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
    407            }
    408            else
    409            {
    410              /* Disable the selected ADC peripheral */
    411              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
    412            }
    413          }
    414          /**
    415            * @}
    416            */
    417          
    418          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    419           *  @brief    Analog Watchdog configuration functions 
    420           *
    421          @verbatim   
    422           ===============================================================================
    423                              Analog Watchdog configuration functions
    424           ===============================================================================  
    425          
    426            This section provides functions allowing to configure the Analog Watchdog
    427            (AWD) feature in the ADC.
    428            
    429            A typical configuration Analog Watchdog is done following these steps :
    430             1. the ADC guarded channel(s) is (are) selected using the 
    431                ADC_AnalogWatchdogSingleChannelConfig() function.
    432             2. The Analog watchdog lower and higher threshold are configured using the  
    433               ADC_AnalogWatchdogThresholdsConfig() function.
    434             3. The Analog watchdog is enabled and configured to enable the check, on one
    435                or more channels, using the  ADC_AnalogWatchdogCmd() function.
    436          
    437          @endverbatim
    438            * @{
    439            */
    440            
    441          /**
    442            * @brief  Enables or disables the analog watchdog on single/all regular or 
    443            *         injected channels
    444            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    445            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    446            *         This parameter can be one of the following values:
    447            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    448            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    449            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    450            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    451            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    452            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    453            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    454            * @retval None	  
    455            */
    456          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    457          {
    458            uint32_t tmpreg = 0;
    459            /* Check the parameters */
    460            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    461            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
    462            
    463            /* Get the old register value */
    464            tmpreg = ADCx->CR1;
    465            
    466            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    467            tmpreg &= CR1_AWDMode_RESET;
    468            
    469            /* Set the analog watchdog enable mode */
    470            tmpreg |= ADC_AnalogWatchdog;
    471            
    472            /* Store the new register value */
    473            ADCx->CR1 = tmpreg;
    474          }
    475          
    476          /**
    477            * @brief  Configures the high and low thresholds of the analog watchdog.
    478            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    479            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    480            *          This parameter must be a 12-bit value.
    481            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    482            *          This parameter must be a 12-bit value.
    483            * @retval None
    484            */
    485          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    486                                                  uint16_t LowThreshold)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    490            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    491            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    492            
    493            /* Set the ADCx high threshold */
    494            ADCx->HTR = HighThreshold;
    495            
    496            /* Set the ADCx low threshold */
    497            ADCx->LTR = LowThreshold;
    498          }
    499          
    500          /**
    501            * @brief  Configures the analog watchdog guarded single channel
    502            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    503            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    504            *          This parameter can be one of the following values:
    505            *            @arg ADC_Channel_0: ADC Channel0 selected
    506            *            @arg ADC_Channel_1: ADC Channel1 selected
    507            *            @arg ADC_Channel_2: ADC Channel2 selected
    508            *            @arg ADC_Channel_3: ADC Channel3 selected
    509            *            @arg ADC_Channel_4: ADC Channel4 selected
    510            *            @arg ADC_Channel_5: ADC Channel5 selected
    511            *            @arg ADC_Channel_6: ADC Channel6 selected
    512            *            @arg ADC_Channel_7: ADC Channel7 selected
    513            *            @arg ADC_Channel_8: ADC Channel8 selected
    514            *            @arg ADC_Channel_9: ADC Channel9 selected
    515            *            @arg ADC_Channel_10: ADC Channel10 selected
    516            *            @arg ADC_Channel_11: ADC Channel11 selected
    517            *            @arg ADC_Channel_12: ADC Channel12 selected
    518            *            @arg ADC_Channel_13: ADC Channel13 selected
    519            *            @arg ADC_Channel_14: ADC Channel14 selected
    520            *            @arg ADC_Channel_15: ADC Channel15 selected
    521            *            @arg ADC_Channel_16: ADC Channel16 selected
    522            *            @arg ADC_Channel_17: ADC Channel17 selected
    523            *            @arg ADC_Channel_18: ADC Channel18 selected
    524            * @retval None
    525            */
    526          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    527          {
    528            uint32_t tmpreg = 0;
    529            /* Check the parameters */
    530            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    531            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    532            
    533            /* Get the old register value */
    534            tmpreg = ADCx->CR1;
    535            
    536            /* Clear the Analog watchdog channel select bits */
    537            tmpreg &= CR1_AWDCH_RESET;
    538            
    539            /* Set the Analog watchdog channel */
    540            tmpreg |= ADC_Channel;
    541            
    542            /* Store the new register value */
    543            ADCx->CR1 = tmpreg;
    544          }
    545          /**
    546            * @}
    547            */
    548          
    549          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    550           *            and VBAT (Voltage BATtery) management functions
    551           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    552           *
    553          @verbatim   
    554           ===============================================================================
    555                         Temperature Sensor, Vrefint and VBAT management functions
    556           ===============================================================================  
    557          
    558            This section provides functions allowing to enable/ disable the internal 
    559            connections between the ADC and the Temperature Sensor, the Vrefint and the
    560            Vbat sources.
    561               
    562            A typical configuration to get the Temperature sensor and Vrefint channels 
    563            voltages is done following these steps :
    564             1. Enable the internal connection of Temperature sensor and Vrefint sources 
    565                with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    566             2. Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    567                ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    568             3. Get the voltage values, using ADC_GetConversionValue() or  
    569                ADC_GetInjectedConversionValue().
    570          
    571            A typical configuration to get the VBAT channel voltage is done following 
    572            these steps :
    573             1. Enable the internal connection of VBAT source with the ADC channel using 
    574                ADC_VBATCmd() function. 
    575             2. Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    576                ADC_InjectedChannelConfig() functions 
    577             3. Get the voltage value, using ADC_GetConversionValue() or  
    578                ADC_GetInjectedConversionValue().
    579           
    580          @endverbatim
    581            * @{
    582            */
    583            
    584            
    585          /**
    586            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    587            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    588            *          This parameter can be: ENABLE or DISABLE.
    589            * @retval None
    590            */
    591          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    592          {
    593            /* Check the parameters */
    594            assert_param(IS_FUNCTIONAL_STATE(NewState));
    595            if (NewState != DISABLE)
    596            {
    597              /* Enable the temperature sensor and Vrefint channel*/
    598              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
    599            }
    600            else
    601            {
    602              /* Disable the temperature sensor and Vrefint channel*/
    603              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
    604            }
    605          }
    606          
    607          /**
    608            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    609            * @param  NewState: new state of the VBAT channel.
    610            *          This parameter can be: ENABLE or DISABLE.
    611            * @retval None
    612            */
    613          void ADC_VBATCmd(FunctionalState NewState)                             
    614          {
    615            /* Check the parameters */
    616            assert_param(IS_FUNCTIONAL_STATE(NewState));
    617            if (NewState != DISABLE)
    618            {
    619              /* Enable the VBAT channel*/
    620              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
    621            }
    622            else
    623            {
    624              /* Disable the VBAT channel*/
    625              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
    626            }
    627          }
    628          
    629          /**
    630            * @}
    631            */
    632          
    633          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    634           *  @brief   Regular Channels Configuration functions 
    635           *
    636          @verbatim   
    637           ===============================================================================
    638                            Regular Channels Configuration functions
    639           ===============================================================================  
    640          
    641            This section provides functions allowing to manage the ADC's regular channels,
    642            it is composed of 2 sub sections : 
    643            
    644            1. Configuration and management functions for regular channels: This subsection 
    645               provides functions allowing to configure the ADC regular channels :    
    646                    - Configure the rank in the regular group sequencer for each channel
    647                    - Configure the sampling time for each channel
    648                    - select the conversion Trigger for regular channels
    649                    - select the desired EOC event behavior configuration
    650                    - Activate the continuous Mode  (*)
    651                    - Activate the Discontinuous Mode 
    652               Please Note that the following features for regular channels are configurated
    653               using the ADC_Init() function : 
    654                    - scan mode activation 
    655                    - continuous mode activation (**) 
    656                    - External trigger source  
    657                    - External trigger edge 
    658                    - number of conversion in the regular channels group sequencer.
    659               
    660               @note (*) and (**) are performing the same configuration
    661               
    662            2. Get the conversion data: This subsection provides an important function in 
    663               the ADC peripheral since it returns the converted data of the current 
    664               regular channel. When the Conversion value is read, the EOC Flag is 
    665               automatically cleared.
    666               
    667               @note For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    668                     results data (in the selected multi mode) can be returned in the same 
    669                     time using ADC_GetMultiModeConversionValue() function. 
    670                 
    671            
    672          @endverbatim
    673            * @{
    674            */
    675          /**
    676            * @brief  Configures for the selected ADC regular channel its corresponding
    677            *         rank in the sequencer and its sample time.
    678            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    679            * @param  ADC_Channel: the ADC channel to configure. 
    680            *          This parameter can be one of the following values:
    681            *            @arg ADC_Channel_0: ADC Channel0 selected
    682            *            @arg ADC_Channel_1: ADC Channel1 selected
    683            *            @arg ADC_Channel_2: ADC Channel2 selected
    684            *            @arg ADC_Channel_3: ADC Channel3 selected
    685            *            @arg ADC_Channel_4: ADC Channel4 selected
    686            *            @arg ADC_Channel_5: ADC Channel5 selected
    687            *            @arg ADC_Channel_6: ADC Channel6 selected
    688            *            @arg ADC_Channel_7: ADC Channel7 selected
    689            *            @arg ADC_Channel_8: ADC Channel8 selected
    690            *            @arg ADC_Channel_9: ADC Channel9 selected
    691            *            @arg ADC_Channel_10: ADC Channel10 selected
    692            *            @arg ADC_Channel_11: ADC Channel11 selected
    693            *            @arg ADC_Channel_12: ADC Channel12 selected
    694            *            @arg ADC_Channel_13: ADC Channel13 selected
    695            *            @arg ADC_Channel_14: ADC Channel14 selected
    696            *            @arg ADC_Channel_15: ADC Channel15 selected
    697            *            @arg ADC_Channel_16: ADC Channel16 selected
    698            *            @arg ADC_Channel_17: ADC Channel17 selected
    699            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    700            * @param  Rank: The rank in the regular group sequencer.
    701            *          This parameter must be between 1 to 16.
    702            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    703            *          This parameter can be one of the following values:
    704            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    705            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    706            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    707            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    708            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    709            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    710            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    711            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    712            * @retval None
    713            */
    714          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    715          {
    716            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    717            /* Check the parameters */
    718            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    719            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    720            assert_param(IS_ADC_REGULAR_RANK(Rank));
    721            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    722            
    723            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    724            if (ADC_Channel > ADC_Channel_9)
    725            {
    726              /* Get the old register value */
    727              tmpreg1 = ADCx->SMPR1;
    728              
    729              /* Calculate the mask to clear */
    730              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    731              
    732              /* Clear the old sample time */
    733              tmpreg1 &= ~tmpreg2;
    734              
    735              /* Calculate the mask to set */
    736              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    737              
    738              /* Set the new sample time */
    739              tmpreg1 |= tmpreg2;
    740              
    741              /* Store the new register value */
    742              ADCx->SMPR1 = tmpreg1;
    743            }
    744            else /* ADC_Channel include in ADC_Channel_[0..9] */
    745            {
    746              /* Get the old register value */
    747              tmpreg1 = ADCx->SMPR2;
    748              
    749              /* Calculate the mask to clear */
    750              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    751              
    752              /* Clear the old sample time */
    753              tmpreg1 &= ~tmpreg2;
    754              
    755              /* Calculate the mask to set */
    756              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    757              
    758              /* Set the new sample time */
    759              tmpreg1 |= tmpreg2;
    760              
    761              /* Store the new register value */
    762              ADCx->SMPR2 = tmpreg1;
    763            }
    764            /* For Rank 1 to 6 */
    765            if (Rank < 7)
    766            {
    767              /* Get the old register value */
    768              tmpreg1 = ADCx->SQR3;
    769              
    770              /* Calculate the mask to clear */
    771              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    772              
    773              /* Clear the old SQx bits for the selected rank */
    774              tmpreg1 &= ~tmpreg2;
    775              
    776              /* Calculate the mask to set */
    777              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    778              
    779              /* Set the SQx bits for the selected rank */
    780              tmpreg1 |= tmpreg2;
    781              
    782              /* Store the new register value */
    783              ADCx->SQR3 = tmpreg1;
    784            }
    785            /* For Rank 7 to 12 */
    786            else if (Rank < 13)
    787            {
    788              /* Get the old register value */
    789              tmpreg1 = ADCx->SQR2;
    790              
    791              /* Calculate the mask to clear */
    792              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    793              
    794              /* Clear the old SQx bits for the selected rank */
    795              tmpreg1 &= ~tmpreg2;
    796              
    797              /* Calculate the mask to set */
    798              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    799              
    800              /* Set the SQx bits for the selected rank */
    801              tmpreg1 |= tmpreg2;
    802              
    803              /* Store the new register value */
    804              ADCx->SQR2 = tmpreg1;
    805            }
    806            /* For Rank 13 to 16 */
    807            else
    808            {
    809              /* Get the old register value */
    810              tmpreg1 = ADCx->SQR1;
    811              
    812              /* Calculate the mask to clear */
    813              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    814              
    815              /* Clear the old SQx bits for the selected rank */
    816              tmpreg1 &= ~tmpreg2;
    817              
    818              /* Calculate the mask to set */
    819              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    820              
    821              /* Set the SQx bits for the selected rank */
    822              tmpreg1 |= tmpreg2;
    823              
    824              /* Store the new register value */
    825              ADCx->SQR1 = tmpreg1;
    826            }
    827          }
    828          
    829          /**
    830            * @brief  Enables the selected ADC software start conversion of the regular channels.
    831            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    832            * @retval None
    833            */
    834          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    835          {
    836            /* Check the parameters */
    837            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    838            
    839            /* Enable the selected ADC conversion for regular group */
    840            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    841          }
    842          
    843          /**
    844            * @brief  Gets the selected ADC Software start regular conversion Status.
    845            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    846            * @retval The new state of ADC software start conversion (SET or RESET).
    847            */
    848          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    849          {
    850            FlagStatus bitstatus = RESET;
    851            /* Check the parameters */
    852            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    853            
    854            /* Check the status of SWSTART bit */
    855            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
    856            {
    857              /* SWSTART bit is set */
    858              bitstatus = SET;
    859            }
    860            else
    861            {
    862              /* SWSTART bit is reset */
    863              bitstatus = RESET;
    864            }
    865            
    866            /* Return the SWSTART bit status */
    867            return  bitstatus;
    868          }
    869          
    870          
    871          /**
    872            * @brief  Enables or disables the EOC on each regular channel conversion
    873            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    874            * @param  NewState: new state of the selected ADC EOC flag rising
    875            *          This parameter can be: ENABLE or DISABLE.
    876            * @retval None
    877            */
    878          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    879          {
    880            /* Check the parameters */
    881            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    882            assert_param(IS_FUNCTIONAL_STATE(NewState));
    883            
    884            if (NewState != DISABLE)
    885            {
    886              /* Enable the selected ADC EOC rising on each regular channel conversion */
    887              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
    888            }
    889            else
    890            {
    891              /* Disable the selected ADC EOC rising on each regular channel conversion */
    892              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
    893            }
    894          }
    895          
    896          /**
    897            * @brief  Enables or disables the ADC continuous conversion mode 
    898            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    899            * @param  NewState: new state of the selected ADC continuous conversion mode
    900            *          This parameter can be: ENABLE or DISABLE.
    901            * @retval None
    902            */
    903          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    904          {
    905            /* Check the parameters */
    906            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    907            assert_param(IS_FUNCTIONAL_STATE(NewState));
    908            
    909            if (NewState != DISABLE)
    910            {
    911              /* Enable the selected ADC continuous conversion mode */
    912              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
    913            }
    914            else
    915            {
    916              /* Disable the selected ADC continuous conversion mode */
    917              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
    918            }
    919          }
    920          
    921          /**
    922            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    923            *         channel.
    924            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    925            * @param  Number: specifies the discontinuous mode regular channel count value.
    926            *          This number must be between 1 and 8.
    927            * @retval None
    928            */
    929          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    930          {
    931            uint32_t tmpreg1 = 0;
    932            uint32_t tmpreg2 = 0;
    933            
    934            /* Check the parameters */
    935            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    936            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    937            
    938            /* Get the old register value */
    939            tmpreg1 = ADCx->CR1;
    940            
    941            /* Clear the old discontinuous mode channel count */
    942            tmpreg1 &= CR1_DISCNUM_RESET;
    943            
    944            /* Set the discontinuous mode channel count */
    945            tmpreg2 = Number - 1;
    946            tmpreg1 |= tmpreg2 << 13;
    947            
    948            /* Store the new register value */
    949            ADCx->CR1 = tmpreg1;
    950          }
    951          
    952          /**
    953            * @brief  Enables or disables the discontinuous mode on regular group channel 
    954            *         for the specified ADC
    955            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    956            * @param  NewState: new state of the selected ADC discontinuous mode on 
    957            *         regular group channel.
    958            *          This parameter can be: ENABLE or DISABLE.
    959            * @retval None
    960            */
    961          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    962          {
    963            /* Check the parameters */
    964            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    965            assert_param(IS_FUNCTIONAL_STATE(NewState));
    966            
    967            if (NewState != DISABLE)
    968            {
    969              /* Enable the selected ADC regular discontinuous mode */
    970              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
    971            }
    972            else
    973            {
    974              /* Disable the selected ADC regular discontinuous mode */
    975              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
    976            }
    977          }
    978          
    979          /**
    980            * @brief  Returns the last ADCx conversion result data for regular channel.
    981            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    982            * @retval The Data conversion value.
    983            */
    984          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    985          {
    986            /* Check the parameters */
    987            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    988            
    989            /* Return the selected ADC conversion value */
    990            return (uint16_t) ADCx->DR;
    991          }
    992          
    993          /**
    994            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    995            *         data in the selected multi mode.
    996            * @param  None  
    997            * @retval The Data conversion value.
    998            * @note   In dual mode, the value returned by this function is as following
    999            *           Data[15:0] : these bits contain the regular data of ADC1.
   1000            *           Data[31:16]: these bits contain the regular data of ADC2.
   1001            * @note   In triple mode, the value returned by this function is as following
   1002            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
   1003            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
   1004            */
   1005          uint32_t ADC_GetMultiModeConversionValue(void)
   1006          {
   1007            /* Return the multi mode conversion value */
   1008            return (*(__IO uint32_t *) CDR_ADDRESS);
   1009          }
   1010          /**
   1011            * @}
   1012            */
   1013          
   1014          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1015           *  @brief   Regular Channels DMA Configuration functions 
   1016           *
   1017          @verbatim   
   1018           ===============================================================================
   1019                             Regular Channels DMA Configuration functions
   1020           ===============================================================================  
   1021          
   1022            This section provides functions allowing to configure the DMA for ADC regular 
   1023            channels.
   1024            Since converted regular channel values are stored into a unique data register, 
   1025            it is useful to use DMA for conversion of more than one regular channel. This 
   1026            avoids the loss of the data already stored in the ADC Data register. 
   1027            
   1028            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1029            conversion of a regular channel, a DMA request is generated.
   1030            
   1031            Depending on the "DMA disable selection for Independent ADC mode" 
   1032            configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1033            at the end of the last DMA transfer, two possibilities are allowed:
   1034            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1035            - Requests can continue to be generated (feature ENABLED).
   1036            
   1037            Depending on the "DMA disable selection for multi ADC mode" configuration 
   1038            (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1039            at the end of the last DMA transfer, two possibilities are allowed:
   1040            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1041            - Requests can continue to be generated (feature ENABLED).
   1042          
   1043          @endverbatim
   1044            * @{
   1045            */
   1046            
   1047           /**
   1048            * @brief  Enables or disables the specified ADC DMA request.
   1049            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1050            * @param  NewState: new state of the selected ADC DMA transfer.
   1051            *          This parameter can be: ENABLE or DISABLE.
   1052            * @retval None
   1053            */
   1054          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1055          {
   1056            /* Check the parameters */
   1057            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1058            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1059            if (NewState != DISABLE)
   1060            {
   1061              /* Enable the selected ADC DMA request */
   1062              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   1063            }
   1064            else
   1065            {
   1066              /* Disable the selected ADC DMA request */
   1067              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   1068            }
   1069          }
   1070          
   1071          /**
   1072            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1073            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1074            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1075            *          This parameter can be: ENABLE or DISABLE.
   1076            * @retval None
   1077            */
   1078          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1079          {
   1080            /* Check the parameters */
   1081            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1082            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1083            if (NewState != DISABLE)
   1084            {
   1085              /* Enable the selected ADC DMA request after last transfer */
   1086              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   1087            }
   1088            else
   1089            {
   1090              /* Disable the selected ADC DMA request after last transfer */
   1091              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   1092            }
   1093          }
   1094          
   1095          /**
   1096            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1097            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1098            *          This parameter can be: ENABLE or DISABLE.
   1099            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1100            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1101            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1102            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1103            * @retval None
   1104            */
   1105          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1106          {
   1107            /* Check the parameters */
   1108            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1109            if (NewState != DISABLE)
   1110            {
   1111              /* Enable the selected ADC DMA request after last transfer */
   1112              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   1113            }
   1114            else
   1115            {
   1116              /* Disable the selected ADC DMA request after last transfer */
   1117              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   1118            }
   1119          }
   1120          /**
   1121            * @}
   1122            */
   1123          
   1124          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1125           *  @brief   Injected channels Configuration functions 
   1126           *
   1127          @verbatim   
   1128           ===============================================================================
   1129                               Injected channels Configuration functions
   1130           ===============================================================================  
   1131          
   1132            This section provide functions allowing to configure the ADC Injected channels,
   1133            it is composed of 2 sub sections : 
   1134              
   1135            1. Configuration functions for Injected channels: This subsection provides 
   1136               functions allowing to configure the ADC injected channels :    
   1137              - Configure the rank in the injected group sequencer for each channel
   1138              - Configure the sampling time for each channel    
   1139              - Activate the Auto injected Mode  
   1140              - Activate the Discontinuous Mode 
   1141              - scan mode activation  
   1142              - External/software trigger source   
   1143              - External trigger edge 
   1144              - injected channels sequencer.
   1145              
   1146             2. Get the Specified Injected channel conversion data: This subsection 
   1147                provides an important function in the ADC peripheral since it returns the 
   1148                converted data of the specific injected channel.
   1149          
   1150          @endverbatim
   1151            * @{
   1152            */ 
   1153          /**
   1154            * @brief  Configures for the selected ADC injected channel its corresponding
   1155            *         rank in the sequencer and its sample time.
   1156            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1157            * @param  ADC_Channel: the ADC channel to configure. 
   1158            *          This parameter can be one of the following values:
   1159            *            @arg ADC_Channel_0: ADC Channel0 selected
   1160            *            @arg ADC_Channel_1: ADC Channel1 selected
   1161            *            @arg ADC_Channel_2: ADC Channel2 selected
   1162            *            @arg ADC_Channel_3: ADC Channel3 selected
   1163            *            @arg ADC_Channel_4: ADC Channel4 selected
   1164            *            @arg ADC_Channel_5: ADC Channel5 selected
   1165            *            @arg ADC_Channel_6: ADC Channel6 selected
   1166            *            @arg ADC_Channel_7: ADC Channel7 selected
   1167            *            @arg ADC_Channel_8: ADC Channel8 selected
   1168            *            @arg ADC_Channel_9: ADC Channel9 selected
   1169            *            @arg ADC_Channel_10: ADC Channel10 selected
   1170            *            @arg ADC_Channel_11: ADC Channel11 selected
   1171            *            @arg ADC_Channel_12: ADC Channel12 selected
   1172            *            @arg ADC_Channel_13: ADC Channel13 selected
   1173            *            @arg ADC_Channel_14: ADC Channel14 selected
   1174            *            @arg ADC_Channel_15: ADC Channel15 selected
   1175            *            @arg ADC_Channel_16: ADC Channel16 selected
   1176            *            @arg ADC_Channel_17: ADC Channel17 selected
   1177            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1178            * @param  Rank: The rank in the injected group sequencer. 
   1179            *          This parameter must be between 1 to 4.
   1180            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1181            *          This parameter can be one of the following values:
   1182            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1183            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1184            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1185            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1186            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1187            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1188            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1189            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1190            * @retval None
   1191            */
   1192          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1193          {
   1194            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1195            /* Check the parameters */
   1196            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1197            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1198            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1199            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1200            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1201            if (ADC_Channel > ADC_Channel_9)
   1202            {
   1203              /* Get the old register value */
   1204              tmpreg1 = ADCx->SMPR1;
   1205              /* Calculate the mask to clear */
   1206              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   1207              /* Clear the old sample time */
   1208              tmpreg1 &= ~tmpreg2;
   1209              /* Calculate the mask to set */
   1210              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   1211              /* Set the new sample time */
   1212              tmpreg1 |= tmpreg2;
   1213              /* Store the new register value */
   1214              ADCx->SMPR1 = tmpreg1;
   1215            }
   1216            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1217            {
   1218              /* Get the old register value */
   1219              tmpreg1 = ADCx->SMPR2;
   1220              /* Calculate the mask to clear */
   1221              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   1222              /* Clear the old sample time */
   1223              tmpreg1 &= ~tmpreg2;
   1224              /* Calculate the mask to set */
   1225              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1226              /* Set the new sample time */
   1227              tmpreg1 |= tmpreg2;
   1228              /* Store the new register value */
   1229              ADCx->SMPR2 = tmpreg1;
   1230            }
   1231            /* Rank configuration */
   1232            /* Get the old register value */
   1233            tmpreg1 = ADCx->JSQR;
   1234            /* Get JL value: Number = JL+1 */
   1235            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   1236            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1237            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1238            /* Clear the old JSQx bits for the selected rank */
   1239            tmpreg1 &= ~tmpreg2;
   1240            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1241            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1242            /* Set the JSQx bits for the selected rank */
   1243            tmpreg1 |= tmpreg2;
   1244            /* Store the new register value */
   1245            ADCx->JSQR = tmpreg1;
   1246          }
   1247          
   1248          /**
   1249            * @brief  Configures the sequencer length for injected channels
   1250            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1251            * @param  Length: The sequencer length. 
   1252            *          This parameter must be a number between 1 to 4.
   1253            * @retval None
   1254            */
   1255          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1256          {
   1257            uint32_t tmpreg1 = 0;
   1258            uint32_t tmpreg2 = 0;
   1259            /* Check the parameters */
   1260            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1261            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1262            
   1263            /* Get the old register value */
   1264            tmpreg1 = ADCx->JSQR;
   1265            
   1266            /* Clear the old injected sequence length JL bits */
   1267            tmpreg1 &= JSQR_JL_RESET;
   1268            
   1269            /* Set the injected sequence length JL bits */
   1270            tmpreg2 = Length - 1; 
   1271            tmpreg1 |= tmpreg2 << 20;
   1272            
   1273            /* Store the new register value */
   1274            ADCx->JSQR = tmpreg1;
   1275          }
   1276          
   1277          /**
   1278            * @brief  Set the injected channels conversion value offset
   1279            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1280            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1281            *          This parameter can be one of the following values:
   1282            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1283            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1284            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1285            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1286            * @param  Offset: the offset value for the selected ADC injected channel
   1287            *          This parameter must be a 12bit value.
   1288            * @retval None
   1289            */
   1290          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1291          {
   1292              __IO uint32_t tmp = 0;
   1293            /* Check the parameters */
   1294            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1295            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1296            assert_param(IS_ADC_OFFSET(Offset));
   1297            
   1298            tmp = (uint32_t)ADCx;
   1299            tmp += ADC_InjectedChannel;
   1300            
   1301            /* Set the selected injected channel data offset */
   1302           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1303          }
   1304          
   1305           /**
   1306            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1307            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1308            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1309            *          This parameter can be one of the following values:                    
   1310            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1311            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1312            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1313            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1314            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1315            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1316            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1317            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1318            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1319            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1320            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1321            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1322            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1323            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1324            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1325            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1326            * @retval None
   1327            */
   1328          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1329          {
   1330            uint32_t tmpreg = 0;
   1331            /* Check the parameters */
   1332            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1333            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1334            
   1335            /* Get the old register value */
   1336            tmpreg = ADCx->CR2;
   1337            
   1338            /* Clear the old external event selection for injected group */
   1339            tmpreg &= CR2_JEXTSEL_RESET;
   1340            
   1341            /* Set the external event selection for injected group */
   1342            tmpreg |= ADC_ExternalTrigInjecConv;
   1343            
   1344            /* Store the new register value */
   1345            ADCx->CR2 = tmpreg;
   1346          }
   1347          
   1348          /**
   1349            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1350            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1351            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1352            *         to start injected conversion. 
   1353            *          This parameter can be one of the following values:
   1354            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1355            *                                                     injected conversion
   1356            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1357            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1358            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1359            *                                                               and falling edge
   1360            * @retval None
   1361            */
   1362          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1363          {
   1364            uint32_t tmpreg = 0;
   1365            /* Check the parameters */
   1366            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1367            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   1368            /* Get the old register value */
   1369            tmpreg = ADCx->CR2;
   1370            /* Clear the old external trigger edge for injected group */
   1371            tmpreg &= CR2_JEXTEN_RESET;
   1372            /* Set the new external trigger edge for injected group */
   1373            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   1374            /* Store the new register value */
   1375            ADCx->CR2 = tmpreg;
   1376          }
   1377          
   1378          /**
   1379            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1380            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1381            * @retval None
   1382            */
   1383          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1384          {
   1385            /* Check the parameters */
   1386            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1387            /* Enable the selected ADC conversion for injected group */
   1388            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   1389          }
   1390          
   1391          /**
   1392            * @brief  Gets the selected ADC Software start injected conversion Status.
   1393            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1394            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1395            */
   1396          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1397          {
   1398            FlagStatus bitstatus = RESET;
   1399            /* Check the parameters */
   1400            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1401            
   1402            /* Check the status of JSWSTART bit */
   1403            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   1404            {
   1405              /* JSWSTART bit is set */
   1406              bitstatus = SET;
   1407            }
   1408            else
   1409            {
   1410              /* JSWSTART bit is reset */
   1411              bitstatus = RESET;
   1412            }
   1413            /* Return the JSWSTART bit status */
   1414            return  bitstatus;
   1415          }
   1416          
   1417          /**
   1418            * @brief  Enables or disables the selected ADC automatic injected group 
   1419            *         conversion after regular one.
   1420            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1421            * @param  NewState: new state of the selected ADC auto injected conversion
   1422            *          This parameter can be: ENABLE or DISABLE.
   1423            * @retval None
   1424            */
   1425          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1426          {
   1427            /* Check the parameters */
   1428            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1429            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1430            if (NewState != DISABLE)
   1431            {
   1432              /* Enable the selected ADC automatic injected group conversion */
   1433              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   1434            }
   1435            else
   1436            {
   1437              /* Disable the selected ADC automatic injected group conversion */
   1438              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   1439            }
   1440          }
   1441          
   1442          /**
   1443            * @brief  Enables or disables the discontinuous mode for injected group 
   1444            *         channel for the specified ADC
   1445            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1446            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1447            *         group channel.
   1448            *          This parameter can be: ENABLE or DISABLE.
   1449            * @retval None
   1450            */
   1451          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1452          {
   1453            /* Check the parameters */
   1454            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1455            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1456            if (NewState != DISABLE)
   1457            {
   1458              /* Enable the selected ADC injected discontinuous mode */
   1459              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   1460            }
   1461            else
   1462            {
   1463              /* Disable the selected ADC injected discontinuous mode */
   1464              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   1465            }
   1466          }
   1467          
   1468          /**
   1469            * @brief  Returns the ADC injected channel conversion result
   1470            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1471            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1472            *          This parameter can be one of the following values:
   1473            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1474            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1475            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1476            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1477            * @retval The Data conversion value.
   1478            */
   1479          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1480          {
   1481            __IO uint32_t tmp = 0;
   1482            
   1483            /* Check the parameters */
   1484            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1485            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1486          
   1487            tmp = (uint32_t)ADCx;
   1488            tmp += ADC_InjectedChannel + JDR_OFFSET;
   1489            
   1490            /* Returns the selected injected channel conversion data value */
   1491            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   1492          }
   1493          /**
   1494            * @}
   1495            */
   1496          
   1497          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1498           *  @brief   Interrupts and flags management functions
   1499           *
   1500          @verbatim   
   1501           ===============================================================================
   1502                             Interrupts and flags management functions
   1503           ===============================================================================  
   1504          
   1505            This section provides functions allowing to configure the ADC Interrupts and 
   1506            to get the status and clear flags and Interrupts pending bits.
   1507            
   1508            Each ADC provides 4 Interrupts sources and 6 Flags which can be divided into 
   1509            3 groups:
   1510            
   1511            I. Flags and Interrupts for ADC regular channels
   1512            =================================================
   1513            Flags :
   1514            ---------- 
   1515               1. ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1516          
   1517               2. ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate (depending 
   1518                        on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() ) the end of:
   1519                         ==> a regular CHANNEL conversion 
   1520                         ==> sequence of regular GROUP conversions .
   1521          
   1522               3. ADC_FLAG_STRT: Regular channel start ==> to indicate when regular CHANNEL 
   1523                        conversion starts.
   1524          
   1525            Interrupts :
   1526            ------------
   1527               1. ADC_IT_OVR : specifies the interrupt source for Overrun detection event.  
   1528               2. ADC_IT_EOC : specifies the interrupt source for Regular channel end of 
   1529                               conversion event.
   1530            
   1531            
   1532            II. Flags and Interrupts for ADC Injected channels
   1533            =================================================
   1534            Flags :
   1535            ---------- 
   1536               1. ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate at 
   1537                         the end of injected GROUP conversion  
   1538                        
   1539               2. ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1540                         injected GROUP conversion starts.
   1541          
   1542            Interrupts :
   1543            ------------
   1544               1. ADC_IT_JEOC : specifies the interrupt source for Injected channel end of 
   1545                                conversion event.     
   1546          
   1547            III. General Flags and Interrupts for the ADC
   1548            ================================================= 
   1549            Flags :
   1550            ---------- 
   1551               1. ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1552                        crosses the programmed thresholds values.
   1553                        
   1554            Interrupts :
   1555            ------------
   1556               1. ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1557          
   1558            
   1559            The user should identify which mode will be used in his application to manage 
   1560            the ADC controller events: Polling mode or Interrupt mode.
   1561            
   1562            In the Polling Mode it is advised to use the following functions:
   1563                - ADC_GetFlagStatus() : to check if flags events occur. 
   1564                - ADC_ClearFlag()     : to clear the flags events.
   1565                
   1566            In the Interrupt Mode it is advised to use the following functions:
   1567               - ADC_ITConfig()          : to enable or disable the interrupt source.
   1568               - ADC_GetITStatus()       : to check if Interrupt occurs.
   1569               - ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1570                                           (corresponding Flag). 
   1571          @endverbatim
   1572            * @{
   1573            */ 
   1574          /**
   1575            * @brief  Enables or disables the specified ADC interrupts.
   1576            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1577            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1578            *          This parameter can be one of the following values:
   1579            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1580            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1581            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1582            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1583            * @param  NewState: new state of the specified ADC interrupts.
   1584            *          This parameter can be: ENABLE or DISABLE.
   1585            * @retval None
   1586            */
   1587          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1588          {
   1589            uint32_t itmask = 0;
   1590            /* Check the parameters */
   1591            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1592            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1593            assert_param(IS_ADC_IT(ADC_IT)); 
   1594          
   1595            /* Get the ADC IT index */
   1596            itmask = (uint8_t)ADC_IT;
   1597            itmask = (uint32_t)0x01 << itmask;    
   1598          
   1599            if (NewState != DISABLE)
   1600            {
   1601              /* Enable the selected ADC interrupts */
   1602              ADCx->CR1 |= itmask;
   1603            }
   1604            else
   1605            {
   1606              /* Disable the selected ADC interrupts */
   1607              ADCx->CR1 &= (~(uint32_t)itmask);
   1608            }
   1609          }
   1610          
   1611          /**
   1612            * @brief  Checks whether the specified ADC flag is set or not.
   1613            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1614            * @param  ADC_FLAG: specifies the flag to check. 
   1615            *          This parameter can be one of the following values:
   1616            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1617            *            @arg ADC_FLAG_EOC: End of conversion flag
   1618            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1619            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1620            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1621            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1622            * @retval The new state of ADC_FLAG (SET or RESET).
   1623            */
   1624          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1625          {
   1626            FlagStatus bitstatus = RESET;
   1627            /* Check the parameters */
   1628            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1629            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1630          
   1631            /* Check the status of the specified ADC flag */
   1632            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1633            {
   1634              /* ADC_FLAG is set */
   1635              bitstatus = SET;
   1636            }
   1637            else
   1638            {
   1639              /* ADC_FLAG is reset */
   1640              bitstatus = RESET;
   1641            }
   1642            /* Return the ADC_FLAG status */
   1643            return  bitstatus;
   1644          }
   1645          
   1646          /**
   1647            * @brief  Clears the ADCx's pending flags.
   1648            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1649            * @param  ADC_FLAG: specifies the flag to clear. 
   1650            *          This parameter can be any combination of the following values:
   1651            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1652            *            @arg ADC_FLAG_EOC: End of conversion flag
   1653            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1654            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1655            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1656            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1657            * @retval None
   1658            */
   1659          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1660          {
   1661            /* Check the parameters */
   1662            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1663            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1664          
   1665            /* Clear the selected ADC flags */
   1666            ADCx->SR = ~(uint32_t)ADC_FLAG;
   1667          }
   1668          
   1669          /**
   1670            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1671            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1672            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1673            *          This parameter can be one of the following values:
   1674            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1675            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1676            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1677            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1678            * @retval The new state of ADC_IT (SET or RESET).
   1679            */
   1680          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1681          {
   1682            ITStatus bitstatus = RESET;
   1683            uint32_t itmask = 0, enablestatus = 0;
   1684          
   1685            /* Check the parameters */
   1686            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1687            assert_param(IS_ADC_IT(ADC_IT));
   1688          
   1689            /* Get the ADC IT index */
   1690            itmask = ADC_IT >> 8;
   1691          
   1692            /* Get the ADC_IT enable bit status */
   1693            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   1694          
   1695            /* Check the status of the specified ADC interrupt */
   1696            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   1697            {
   1698              /* ADC_IT is set */
   1699              bitstatus = SET;
   1700            }
   1701            else
   1702            {
   1703              /* ADC_IT is reset */
   1704              bitstatus = RESET;
   1705            }
   1706            /* Return the ADC_IT status */
   1707            return  bitstatus;
   1708          }
   1709          
   1710          /**
   1711            * @brief  Clears the ADCx's interrupt pending bits.
   1712            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1713            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1714            *          This parameter can be one of the following values:
   1715            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1716            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1717            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1718            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1719            * @retval None
   1720            */
   1721          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1722          {
   1723            uint8_t itmask = 0;
   1724            /* Check the parameters */
   1725            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1726            assert_param(IS_ADC_IT(ADC_IT)); 
   1727            /* Get the ADC IT index */
   1728            itmask = (uint8_t)(ADC_IT >> 8);
   1729            /* Clear the selected ADC interrupt pending bits */
   1730            ADCx->SR = ~(uint32_t)itmask;
   1731          }                    
   1732          /**
   1733            * @}
   1734            */ 
   1735          
   1736          /**
   1737            * @}
   1738            */
   1739          
   1740          /**
   1741            * @}
   1742            */ 
   1743          
   1744          /**
   1745            * @}
   1746            */ 
   1747          
   1748          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_AnalogWatchdogCmd
        16   -> assert_failed
      16   ADC_AnalogWatchdogSingleChannelConfig
        16   -> assert_failed
      16   ADC_AnalogWatchdogThresholdsConfig
        16   -> assert_failed
      16   ADC_AutoInjectedConvCmd
        16   -> assert_failed
      16   ADC_ClearFlag
        16   -> assert_failed
      16   ADC_ClearITPendingBit
        16   -> assert_failed
      16   ADC_Cmd
        16   -> assert_failed
       8   ADC_CommonInit
         8   -> assert_failed
       0   ADC_CommonStructInit
      16   ADC_ContinuousModeCmd
        16   -> assert_failed
      16   ADC_DMACmd
        16   -> assert_failed
      16   ADC_DMARequestAfterLastTransferCmd
        16   -> assert_failed
       8   ADC_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
      16   ADC_DiscModeChannelCountConfig
        16   -> assert_failed
      16   ADC_DiscModeCmd
        16   -> assert_failed
      16   ADC_EOCOnEachRegularChannelCmd
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvConfig
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvEdgeConfig
        16   -> assert_failed
       8   ADC_GetConversionValue
         8   -> assert_failed
      16   ADC_GetFlagStatus
        16   -> assert_failed
      16   ADC_GetITStatus
        16   -> assert_failed
      16   ADC_GetInjectedConversionValue
        16   -> assert_failed
       0   ADC_GetMultiModeConversionValue
       8   ADC_GetSoftwareStartConvStatus
         8   -> assert_failed
       8   ADC_GetSoftwareStartInjectedConvCmdStatus
         8   -> assert_failed
      16   ADC_ITConfig
        16   -> assert_failed
      16   ADC_Init
        16   -> assert_failed
      24   ADC_InjectedChannelConfig
        24   -> assert_failed
      16   ADC_InjectedDiscModeCmd
        16   -> assert_failed
      16   ADC_InjectedSequencerLengthConfig
        16   -> assert_failed
       8   ADC_MultiModeDMARequestAfterLastTransferCmd
         8   -> assert_failed
      24   ADC_RegularChannelConfig
        24   -> assert_failed
      24   ADC_SetInjectedOffset
        24   -> assert_failed
       8   ADC_SoftwareStartConv
         8   -> assert_failed
       8   ADC_SoftwareStartInjectedConv
         8   -> assert_failed
       0   ADC_StructInit
       8   ADC_TempSensorVrefintCmd
         8   -> assert_failed
       8   ADC_VBATCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     128  ?<Constant "C:\\Tools\\IAR Systems\\...">
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable28
       4  ??DataTable31
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable33_8
       4  ??DataTable33_9
       6  ?Subroutine0
      10  ?Subroutine1
     110  ADC_AnalogWatchdogCmd
     138  ADC_AnalogWatchdogSingleChannelConfig
      84  ADC_AnalogWatchdogThresholdsConfig
      70  ADC_AutoInjectedConvCmd
      60  ADC_ClearFlag
      84  ADC_ClearITPendingBit
      76  ADC_Cmd
     280  ADC_CommonInit
      12  ADC_CommonStructInit
      76  ADC_ContinuousModeCmd
      76  ADC_DMACmd
      72  ADC_DMARequestAfterLastTransferCmd
      26  ADC_DeInit
      74  ADC_DiscModeChannelCountConfig
      76  ADC_DiscModeCmd
      76  ADC_EOCOnEachRegularChannelCmd
     150  ADC_ExternalTrigInjectedConvConfig
      74  ADC_ExternalTrigInjectedConvEdgeConfig
      44  ADC_GetConversionValue
      84  ADC_GetFlagStatus
     102  ADC_GetITStatus
      86  ADC_GetInjectedConversionValue
       8  ADC_GetMultiModeConversionValue
      40  ADC_GetSoftwareStartConvStatus
      32  ADC_GetSoftwareStartInjectedConvCmdStatus
     118  ADC_ITConfig
     360  ADC_Init
     272  ADC_InjectedChannelConfig
      70  ADC_InjectedDiscModeCmd
      70  ADC_InjectedSequencerLengthConfig
      46  ADC_MultiModeDMARequestAfterLastTransferCmd
     328  ADC_RegularChannelConfig
     106  ADC_SetInjectedOffset
      48  ADC_SoftwareStartConv
      42  ADC_SoftwareStartInjectedConv
      20  ADC_StructInit
      46  ADC_TempSensorVrefintCmd
      46  ADC_VBATCmd

 
 3 790 bytes in section .text
 
 3 790 bytes of CODE memory

Errors: none
Warnings: none
