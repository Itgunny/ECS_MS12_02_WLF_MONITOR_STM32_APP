###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:37 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW2835_OSD.c                                     #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW2835_OSD.c" -D USE_STDPERIPH_DRIVER -D         #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\TW2835 #
#                    _OSD.lst                                                 #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\TW2835_ #
#                    OSD.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\TW2835_OSD.c
      1          /**
      2            ******************************************************************************
      3            * @file    TW2835_OSD.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   TW2835_OSD.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          u8 osd_bmp_pos_y;
     29          
     30          
     31          unsigned char ct_CHANNEL[]={
     32          3,	// used color
     33          //	Y,	Cb,	Cr,	addr
     34          0xeb,	0x80,	0x80,	0x80,
     35          0x10,	0x80,	0x80,	0x81,
     36          0x95,	0x46,	0xbe,	0x82
     37          };
     38          
     39          
     40          unsigned char gt_CHANNEL_CH1_O[]={
     41          0,	//... bit[15:8] of vertical size
     42          20,	//... bit[7:0] of vertical size
     43          0,	//... bit[15:8] of horizontal size
     44          44,	//... bit[7:0] of horizontal size
     45          1,		//... column number of table in each bitmap unit
     46          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     47          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     48          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,
     49          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     50          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,
     51          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
     52          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
     53          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
     54          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x01,0xff,0xff,
     55          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     56          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     57          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     58          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     59          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     60          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     61          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     62          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
     63          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,
     64          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     65          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
     66          };
     67          
     68          unsigned char gt_CHANNEL_CH2_O[]={
     69          0,	//... bit[15:8] of vertical size
     70          20,	//... bit[7:0] of vertical size
     71          0,	//... bit[15:8] of horizontal size
     72          44,	//... bit[7:0] of horizontal size
     73          1,		//... column number of table in each bitmap unit
     74          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     75          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     76          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xff,0xff,
     77          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x01,0x01,0xff,
     78          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,
     79          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x02,0x02,0x02,0x01,
     80          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0x01,0x02,0x02,0x02,0x01,
     81          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0x01,0x02,0x02,0x02,0x01,
     82          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,
     83          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0x01,0x02,0x02,0x02,0x01,0xff,
     84          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0xff,
     85          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
     86          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,
     87          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,
     88          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
     89          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,
     90          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,
     91          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
     92          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
     93          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
     94          };
     95          
     96          unsigned char gt_CHANNEL_CH3_O[]={
     97          0,	//... bit[15:8] of vertical size
     98          20,	//... bit[7:0] of vertical size
     99          0,	//... bit[15:8] of horizontal size
    100          44,	//... bit[7:0] of horizontal size
    101          1,		//... column number of table in each bitmap unit
    102          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    103          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    104          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,
    105          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
    106          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,
    107          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x02,0x02,0x02,0x01,0x01,
    108          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0x01,0x02,0x02,0x02,0x01,
    109          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0x01,0x01,0x02,0x02,0x02,0x01,
    110          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,
    111          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,
    112          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x01,0xff,
    113          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,
    114          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,
    115          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,
    116          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x02,0x02,0x02,0x01,
    117          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
    118          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,
    119          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,
    120          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,
    121          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
    122          };
    123          
    124          unsigned char gt_CHANNEL_CH4_O[]={
    125          0,	//... bit[15:8] of vertical size
    126          20,	//... bit[7:0] of vertical size
    127          0,	//... bit[15:8] of horizontal size
    128          44,	//... bit[7:0] of horizontal size
    129          1,		//... column number of table in each bitmap unit
    130          
    131          
    132          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    133          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    134          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,
    135          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,
    136          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,
    137          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
    138          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0xff,0xff,
    139          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0xff,0xff,
    140          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x02,0x02,0x01,0xff,0xff,
    141          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x01,0x01,0x02,0x02,0x01,0xff,0xff,
    142          0xff,0x01,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0x01,0x01,0x02,0x02,0x01,0xff,0xff,
    143          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x02,0x02,0x01,0x01,0x01,
    144          0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,
    145          0xff,0x01,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,
    146          0xff,0xff,0x01,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x01,0x01,0x01,
    147          0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
    148          0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0x01,0x02,0x02,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02,0x02,0x01,0xff,0xff,
    149          0xff,0xff,0xff,0xff,0x01,0x01,0x02,0x02,0x02,0x02,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,
    150          0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    151          0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
    152          
    153          };
    154          
    155          
    156          
    157          
    158          /* Private function prototypes -----------------------------------------------*/
    159          /* Private functions ---------------------------------------------------------*/
    160          //==================================================================================
    161          //						OSD function description
    162          //==================================================================================
    163          void WriteOSDBmpX(u8 _dvc, u8 _pos_x, u16 _pos_y, u8 _prp_pg, u8 _indx, u8 *_bmp_ptr)
    164          //... _pos_x: ~ 180(4 pixel/_pos_x), _pos_y: ~ 240/288 domain
    165          {
    166          //	u8 _wdat_;
    167          	u8 _t1_;
    168          	u8 _pg_;//, _bf_sz_;
    169          	u8 _bf_dt_[5];
    170          	u16 _num_h_, _num_v_;
    171          	u16 _wdth_, _hght_;
    172          	u16 _wt1_, _wt2_;
    173          	u16 _ofst_indx_, _ofst_v_od_, _ofst_v_evn_;
    174          	
    175          	_pg_ = _prp_pg & 0x07;
    176          	_prp_pg &= 0xc0;
    177          
    178          	_hght_ = ((_bmp_ptr[OSD_TBL_V_SZ_MSB])<<8) + _bmp_ptr[OSD_TBL_V_SZ_LSB];
    179          	_wdth_ = ((_bmp_ptr[OSD_TBL_H_SZ_MSB])<<8) + _bmp_ptr[OSD_TBL_H_SZ_LSB];
    180          	//_wdth_ >>= 1;
    181          	_ofst_indx_ = (_wdth_*_hght_)*_bmp_ptr[OSD_TBL_CLMN];
    182          	_ofst_indx_ = _ofst_indx_*(_indx/_bmp_ptr[OSD_TBL_CLMN]);			//... data size of one index row (= (one bitmap icon size)*column)
    183          	_ofst_indx_ = _ofst_indx_+((_indx%_bmp_ptr[OSD_TBL_CLMN])*_wdth_);	//... add array_index to offset for 1 index column
    184          
    185          	//_wdth_ = _bmp_ptr[OSD_TBL_H_SZ_LSB]>>2;							//... horizontal size / 4(pixels)
    186          
    187          	WriteAsicByteOSD(_dvc,0x06,0x00);
    188          	WriteAsicByteOSD(_dvc,0x08,0x00);
    189          
    190          	_wt1_ = _wdth_*_bmp_ptr[OSD_TBL_CLMN];
    191          
    192          	for(_num_v_=0;_num_v_<_hght_;_num_v_+=2)
    193          
    194          	{//(1<<_bmp_ptr[OSD_TBL_RSLTN])){	//... if(_bmp_ptr[OSD_TBL_RSLTN]==0)	field resolution, else	frame resolution
    195          		_ofst_v_od_ = _num_v_*_wt1_;
    196          		_ofst_v_evn_ = _ofst_v_od_+_wt1_;//(_num_v_+1)*_wt1_;
    197          
    198          		WriteAsicByteOSD(_dvc, 0x07, (_pos_y+(_num_v_>>1))&0xff);
    199          
    200          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    201          			_t1_ = (_num_h_>>2)&0x0f;								//... define max buffer size
    202          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_od_+_num_h_;		//
    203          			_bf_dt_[0] = _prp_pg|_bmp_ptr[_wt2_+0];
    204          			_bf_dt_[1] = _prp_pg|_bmp_ptr[_wt2_+1];
    205          			_bf_dt_[2] = _prp_pg|_bmp_ptr[_wt2_+2];
    206          			_bf_dt_[3] = _prp_pg|_bmp_ptr[_wt2_+3];
    207          			_bf_dt_[4] = 0x80+_t1_;
    208          			WriteAsicTableOSD(_dvc, 0x00, _bf_dt_);
    209          
    210          			if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    211          				WriteAsicByteOSD(_dvc, 0x05, _pos_x+(_num_h_>>2)-_t1_);
    212          				WriteAsicByteOSD(_dvc, 0x09, (_t1_<<4)|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    213          				while(ReadAsicOSDMemWr(_dvc) & BIT7);								//... wait finishing write for odd field
    214          				WriteAsicByteOSD(_dvc, 0x0a, 0x80 + (_pg_<<2));					//... x path
    215          			}
    216          		}
    217          
    218          
    219          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    220          			_t1_ = (_num_h_>>2)&0x0f;
    221          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_evn_+_num_h_;
    222          			_bf_dt_[0] = _prp_pg|_bmp_ptr[_wt2_+0];
    223          			_bf_dt_[1] = _prp_pg|_bmp_ptr[_wt2_+1];
    224          			_bf_dt_[2] = _prp_pg|_bmp_ptr[_wt2_+2];
    225          			_bf_dt_[3] = _prp_pg|_bmp_ptr[_wt2_+3];
    226          			_bf_dt_[4] = 0x80+_t1_;
    227          			WriteAsicTableOSD(_dvc,0x00,_bf_dt_);
    228          
    229          			if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    230          				WriteAsicByteOSD(_dvc, 0x05, _pos_x+(_num_h_>>2)-_t1_);
    231          				WriteAsicByteOSD(_dvc, 0x09,(_t1_<<4)|0x0a|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    232          				while(ReadAsicOSDMemWr(_dvc) & BIT7);							//... wait finishing write for odd field
    233          				WriteAsicByteOSD(_dvc, 0x0a, 0x80 + (_pg_<<2));					//... x path
    234          			}
    235          		}
    236          	}
    237          }
    238          //	*/
    239          
    240          //==================================================================================
    241          //*
    242          void WriteOSDBmp_DP(u8 _dvc, u8 _pos_x, u16 _pos_y, u8 _prp_pg, u8 _indx, u8 *_bmp_ptr)
    243          //... _pos_x: ~ 180(4 pixel/_pos_x), _pos_y: ~ 240/288 domain
    244          {
    245          //	u8 _wdat_;
    246          	u8 _t1_;
    247          	u8 _pg_;//, _bf_sz_;
    248          	u8 _bf_dt_[5];
    249          	u16 _num_h_, _num_v_;
    250          	u16 _wdth_, _hght_;
    251          	u16 _wt1_, _wt2_;
    252          	u16 _ofst_indx_, _ofst_v_od_, _ofst_v_evn_;
    253          
    254          	_pg_ = _prp_pg & 0x07;
    255          	_prp_pg &= 0xc0;
    256          
    257          	_hght_ = ((_bmp_ptr[OSD_TBL_V_SZ_MSB])<<8)+_bmp_ptr[OSD_TBL_V_SZ_LSB];
    258          	_wdth_ = ((_bmp_ptr[OSD_TBL_H_SZ_MSB])<<8)+_bmp_ptr[OSD_TBL_H_SZ_LSB];
    259          	
    260          	_ofst_indx_ = (_wdth_*_hght_)*_bmp_ptr[OSD_TBL_CLMN];
    261          	_ofst_indx_ = _ofst_indx_*(_indx/_bmp_ptr[OSD_TBL_CLMN]);		    //... data size of one index row (= (one bitmap icon size)*column)
    262          	_ofst_indx_ = _ofst_indx_+((_indx%_bmp_ptr[OSD_TBL_CLMN])*_wdth_);	//... add array_index to offset for 1 index column
    263          
    264          	//_wdth_ = _bmp_ptr[OSD_TBL_H_SZ_LSB]>>2;							//... horizontal size / 4(pixels)
    265          
    266          	WriteAsicByteOSD(_dvc,0x06,0x00);
    267          	WriteAsicByteOSD(_dvc,0x08,0x00);
    268          
    269          	_wt1_ = _wdth_*_bmp_ptr[OSD_TBL_CLMN];
    270          
    271          	for(_num_v_=0;_num_v_<_hght_;_num_v_+=2)
    272          
    273          	{//(1<<_bmp_ptr[OSD_TBL_RSLTN])){	//... if(_bmp_ptr[OSD_TBL_RSLTN]==0)	field resolution, else	frame resolution
    274          		_ofst_v_od_ = _num_v_*_wt1_;
    275          		_ofst_v_evn_ = _ofst_v_od_+_wt1_;//(_num_v_+1)*_wt1_;
    276                  
    277          		WriteAsicByteOSD(_dvc,0x07,(_pos_y+(_num_v_>>1))&0xff);
    278          
    279          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    280          			_t1_ = (_num_h_>>2)&0x0f;								//... define max buffer size
    281          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_od_+_num_h_;	//
    282          			_bf_dt_[0] = _prp_pg|_bmp_ptr[_wt2_+0];
    283          			_bf_dt_[1] = _prp_pg|_bmp_ptr[_wt2_+1];
    284          			_bf_dt_[2] = _prp_pg|_bmp_ptr[_wt2_+2];
    285          			_bf_dt_[3] = _prp_pg|_bmp_ptr[_wt2_+3];
    286          			_bf_dt_[4] = 0x80+_t1_;
    287          			WriteAsicTableOSD(_dvc,0x00,_bf_dt_);
    288          
    289          			if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    290          				WriteAsicByteOSD(_dvc,0x05,_pos_x+(_num_h_>>2)-_t1_);
    291          				WriteAsicByteOSD(_dvc,0x09,(_t1_<<4)|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    292          
    293          				while(ReadAsicOSDMemWr(_dvc)&BIT7);					//... wait finishing write for odd field
    294          				WriteAsicByteOSD(_dvc,0x0a,0x80+(_pg_<<2));			//... x path
    295          			}
    296          		}
    297          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    298          			_t1_ = (_num_h_>>2)&0x0f;
    299          
    300          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_evn_+_num_h_;
    301          			_bf_dt_[0] = _prp_pg|_bmp_ptr[_wt2_+0];
    302          			_bf_dt_[1] = _prp_pg|_bmp_ptr[_wt2_+1];
    303          			_bf_dt_[2] = _prp_pg|_bmp_ptr[_wt2_+2];
    304          			_bf_dt_[3] = _prp_pg|_bmp_ptr[_wt2_+3];
    305          			_bf_dt_[4] = 0x80+_t1_;
    306          			WriteAsicTableOSD(_dvc,0x00,_bf_dt_);
    307          
    308          			if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    309          				WriteAsicByteOSD(_dvc,0x05,_pos_x+(_num_h_>>2)-_t1_);
    310          				WriteAsicByteOSD(_dvc,0x09,(_t1_<<4)|0x0a|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    311          				while(ReadAsicOSDMemWr(_dvc)&BIT7);					//... wait finishing write for odd field
    312          				WriteAsicByteOSD(_dvc,0x0a,0x80+(_pg_<<2));			//... x path
    313          			}
    314          		}
    315          	}
    316          }
    317          //	*/
    318          //==================================================================================
    319          
    320          //==================================================================================
    321          //*
    322          void WriteOSDBmpY(u8 _dvc, u8 _pos_x, u16 _pos_y, u8 _prp, u8 _indx, u8 *_bmp_ptr)
    323          //... _pos_x: ~ 180(4 pixel/_pos_x), _pos_y: ~ 240/288 domain
    324          {
    325          //	u8 _wdat_;
    326          	u8 _t1_;
    327          //	u8 _pg_;//, _bf_sz_;
    328          	u8 _bf_dt_[5];
    329          	u16 _num_h_, _num_v_;
    330          	u16 _wdth_, _hght_;
    331          	u16 _wt1_, _wt2_;
    332          	u16 _ofst_indx_, _ofst_v_od_, _ofst_v_evn_;
    333          	
    334          #if	defined(__EN_ISR__)
    335          //	EA = 0;
    336          #endif
    337          
    338              _prp |= _prp>>4;    //  y path
    339          
    340          	_hght_ = ((_bmp_ptr[OSD_TBL_V_SZ_MSB])<<8)+_bmp_ptr[OSD_TBL_V_SZ_LSB];
    341          	_wdth_ = ((_bmp_ptr[OSD_TBL_H_SZ_MSB])<<8)+_bmp_ptr[OSD_TBL_H_SZ_LSB];
    342          	_wdth_ >>= 1;
    343          	
    344          	_ofst_indx_ = (_wdth_*_hght_)*_bmp_ptr[OSD_TBL_CLMN];
    345          	_ofst_indx_ = _ofst_indx_*(_indx/_bmp_ptr[OSD_TBL_CLMN]);		//... data size of one index row (= (one bitmap icon size)*column)
    346          	_ofst_indx_ = _ofst_indx_+((_indx%_bmp_ptr[OSD_TBL_CLMN])*_wdth_);	//... add array_index to offset for 1 index column
    347          
    348          	WriteAsicByteOSD(_dvc,0x06,0x00);
    349          	WriteAsicByteOSD(_dvc,0x08,0x00);
    350          
    351          	_wt1_ = _wdth_*_bmp_ptr[OSD_TBL_CLMN];
    352          
    353          	for(_num_v_=0;_num_v_<_hght_;_num_v_+=2){//(1<<_bmp_ptr[OSD_TBL_RSLTN])){	//... if(_bmp_ptr[OSD_TBL_RSLTN]==0)	field resolution, else	frame resolution
    354          		_ofst_v_od_ = _num_v_*_wt1_;
    355          		_ofst_v_evn_ = _ofst_v_od_+_wt1_;//(_num_v_+1)*_wt1_;
    356          
    357          		WriteAsicByteOSD(_dvc,0x07,(_pos_y+(_num_v_>>1))&0xff);
    358          
    359          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    360          			_t1_ = (_num_h_>>2)&0x0f;								//... define max buffer size
    361          
    362          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_od_+_num_h_;		//
    363          			_bf_dt_[0] = _prp|_bmp_ptr[_wt2_+0];
    364          			_bf_dt_[1] = _prp|_bmp_ptr[_wt2_+1];
    365          			_bf_dt_[2] = _prp|_bmp_ptr[_wt2_+2];
    366          			_bf_dt_[3] = _prp|_bmp_ptr[_wt2_+3];
    367          			_bf_dt_[4] = 0x80+_t1_;
    368          			WriteAsicTableOSD(_dvc,0x00,_bf_dt_);
    369          
    370          			if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    371          				WriteAsicByteOSD(_dvc,0x05,_pos_x+(_num_h_>>2)-_t1_);
    372          				WriteAsicByteOSD(_dvc,0x09,(_t1_<<4)|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    373          
    374          				while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for odd field
    375          				WriteAsicByteOSD(_dvc,0x0a,0xa0);					//... y path
    376          				//WriteAsicByteOSD(_dvc,0x0a,0x80);					//... X path
    377          			}
    378          		}
    379          
    380          		//if(_bmp_ptr[OSD_TBL_RSLTN]){
    381          		for(_num_h_=0;_num_h_<_wdth_;_num_h_+=4){
    382          			_t1_ = (_num_h_>>2)&0x0f;
    383          			_wt2_ = OSD_TBL_DAT+_ofst_indx_+_ofst_v_evn_+_num_h_;
    384          			_bf_dt_[0] = _prp|_bmp_ptr[_wt2_+0];
    385          			_bf_dt_[1] = _prp|_bmp_ptr[_wt2_+1];
    386          			_bf_dt_[2] = _prp|_bmp_ptr[_wt2_+2];
    387          			_bf_dt_[3] = _prp|_bmp_ptr[_wt2_+3];
    388          			_bf_dt_[4] = 0x80+_t1_;
    389          			WriteAsicTableOSD(_dvc,0x00,_bf_dt_);
    390          				if((_t1_==0x0f)||((_num_h_+4)>=_wdth_)){
    391          				WriteAsicByteOSD(_dvc,0x05,_pos_x+(_num_h_>>2)-_t1_);
    392          				WriteAsicByteOSD(_dvc,0x09,(_t1_<<4)|0x0a|(((_pos_y+(_num_v_>>1))>>8)<<2));		
    393          					while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for odd field
    394          				WriteAsicByteOSD(_dvc,0x0a,0xa0);					//... y path
    395          				//WriteAsicByteOSD(_dvc,0x0a,0x80);					//... X path
    396          			}
    397          		}
    398          	//}
    399          }
    400          
    401          #if	defined(__EN_ISR__)
    402          //	EA = 1;
    403          #endif
    404          }
    405          //	*/
    406          //==================================================================================
    407          void WriteOSDClrX(u8 _dvc, u8 _osd_pg, u8 _pos_x, u16 _pos_y, u8 _wdth, u16 _hght)	//... only one _pth at once
    408          {
    409          //	u8 _t1_;
    410          	u8 _t2_, _t3_;
    411          	
    412          #if	defined(__EN_ISR__)
    413          //	EA = 0;
    414          #endif
    415          //	u8 _t1_;
    416          
    417          	WriteAsicByteOSD(_dvc,0x00,0xff);					//... 1st pixel
    418          	WriteAsicByteOSD(_dvc,0x01,0xff);					//... 2nd pixel
    419          	WriteAsicByteOSD(_dvc,0x02,0xff);					//... 3rd pixel
    420          	WriteAsicByteOSD(_dvc,0x03,0xff);					//... 4th pixel
    421          	//... acceleration 을 사용할 경우 buffer write 과정 생략가능.
    422          //	WriteAsicByteOSD(_dvc,0x04,0x80);					//... write to buffer
    423          
    424          //... start position
    425          //	_pos_x <<= 2;														//... (_pos_x)*4 -> 4 pixel * 4 -> 16 pixel char
    426          	_pos_y = (_pos_y<<1)+(_pos_y<<3);							//... (_pos_y)*(2+8)
    427          
    428          //	WriteAsicByteOSD(_dvc,0x05,_pos_x);
    429          	WriteAsicByteOSD(_dvc,0x07,_pos_y&0xff);
    430          
    431          //... end position
    432          //	_pos_x += _wdth<<2;
    433          	_hght = _pos_y+((_hght<<1)+(_hght<<3));
    434          
    435          //	WriteAsicByteOSD(_dvc,0x06,--_pos_x);
    436          	WriteAsicByteOSD(_dvc,0x08,(--_hght)&0xff);
    437          
    438          //	WriteAsicByteOSD(_dvc,0x09,((_pos_y>>8)<<2)+(_hght>>8));		//... odd field
    439          //	WriteAsicByteOSD(_dvc,0x0a,0xc0);										//... acceleration|x path
    440          //
    441          //	while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for odd field
    442          ////Delay(1);
    443          
    444          	WriteAsicByteOSD(_dvc,0x09,0x02|((_pos_y>>8)<<2)+(_hght>>8));	//... ~ even field
    445          //	WriteAsicByteOSD(_dvc,0x0a,0xc0);										//... acceleration|x path
    446          //
    447          //	while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for even field
    448          ////Delay(1);
    449          	_pos_x <<= 2;
    450          	_wdth <<= 2;
    451          	
    452          	_t2_ = _wdth>>4;
    453          	_t3_ = _wdth&0x0f;
    454          	
    455          	if (_t2_ != 0) {
    456          			WriteAsicByteOSD(0,0x05,_pos_x);
    457          			WriteAsicByteOSD(0,0x06,_pos_x+(_t2_<<4));//79);
    458          		WriteAsicByteOSD(0,0x0a,0xc0+(_osd_pg<<2));										//... acceleration|x path
    459          		//  read_data[0] = ReadAsicOSDMemWr(_dvc);
    460          		while(ReadAsicOSDMemWr(_dvc)&BIT7){}								//... wait finishing write for even field
    461          	}
    462          	if (_t3_ != 0){
    463          			WriteAsicByteOSD(0,0x05,_pos_x+(_t2_<<4));//_t1_);
    464          			WriteAsicByteOSD(0,0x06,_pos_x+((_t2_<<4)+_t3_-1));//79);
    465          		WriteAsicByteOSD(0,0x0a,0xc0+(_osd_pg<<2));										//... acceleration|x path
    466          		while(ReadAsicOSDMemWr(_dvc)&BIT7){}								//... wait finishing write for even field
    467          	}
    468          	
    469          
    470          #if	defined(__EN_ISR__)
    471          //	EA = 1;
    472          #endif
    473          }
    474          //==================================================================================
    475          void WriteOSDClrY(u8 _dvc, u8 _pos_x, u16 _pos_y, u8 _wdth, u16 _hght)	//... only one _pth at once
    476          {
    477          //	u8 _t1_;
    478          	u8 _t2_, _t3_;
    479          	
    480          #if	defined(__EN_ISR__)
    481          //	EA = 0;
    482          #endif
    483          //	u8 _t1_;
    484          
    485          	WriteAsicByteOSD(_dvc,0x00,0xff);					//... 1st pixel
    486          	WriteAsicByteOSD(_dvc,0x01,0xff);					//... 2nd pixel
    487          	WriteAsicByteOSD(_dvc,0x02,0xff);					//... 3rd pixel
    488          	WriteAsicByteOSD(_dvc,0x03,0xff);					//... 4th pixel
    489          	//... acceleration 을 사용할 경우 buffer write 과정 생략가능.
    490          //	WriteAsicByteOSD(_dvc,0x04,0x80);					//... write to buffer
    491          
    492          //... start position
    493          //	_pos_x <<= 1;														//... (_pos_x)*2 -> 8 pixel * 2 -> 16 pixel char
    494          	_pos_y = (_pos_y<<1)+(_pos_y<<3);							//... (_pos_y)*(2+8)
    495          
    496          //	WriteAsicByteOSD(_dvc,0x05,_pos_x);
    497          	WriteAsicByteOSD(_dvc,0x07,_pos_y&0xff);
    498          
    499          //... end position
    500          //	_pos_x += _wdth<<1;
    501          	_hght = _pos_y+((_hght<<1)+(_hght<<3));
    502          
    503          //	WriteAsicByteOSD(_dvc,0x06,--_pos_x);
    504          	WriteAsicByteOSD(_dvc,0x08,(--_hght)&0xff);
    505          
    506          //	WriteAsicByteOSD(_dvc,0x09,((_pos_y>>8)<<2)+(_hght>>8));		//... odd field
    507          //	WriteAsicByteOSD(_dvc,0x0a,0xe0);										//... acceleration|y path
    508          //
    509          //	while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for odd field
    510          ////Delay(1);
    511          
    512          	WriteAsicByteOSD(_dvc,0x09,0x02|((_pos_y>>8)<<2)+(_hght>>8));	//... ~ even field
    513          //	WriteAsicByteOSD(_dvc,0x0a,0xe0);										//... acceleration|y path
    514          //
    515          //	while(ReadAsicOSDMemWr(_dvc)&BIT7);								//... wait finishing write for even field
    516          ////Delay(1);
    517          	_pos_x <<= 1;														//... (_pos_x)*2 -> 8 pixel * 2 -> 16 pixel char
    518          	_wdth <<= 1;
    519          	
    520          	_t2_ = _wdth>>4;
    521          	_t3_ = _wdth&0x0f;
    522          	
    523          	if (_t2_ != 0) {
    524          			WriteAsicByteOSD(0,0x05,_pos_x);
    525          			WriteAsicByteOSD(0,0x06,_pos_x+(_t2_<<4));//79);
    526          		WriteAsicByteOSD(0,0x0a,0xe0);										//... acceleration|y path
    527          		while(ReadAsicOSDMemWr(_dvc)&BIT7){}								//... wait finishing write for even field
    528          	}
    529          	if (_t3_ != 0){
    530          			WriteAsicByteOSD(0,0x05,_pos_x+(_t2_<<4));//_t1_);
    531          			WriteAsicByteOSD(0,0x06,_pos_x+((_t2_<<4)+_t3_-1));//79);
    532          		WriteAsicByteOSD(0,0x0a,0xe0);										//... acceleration|y path
    533          		while(ReadAsicOSDMemWr(_dvc)&BIT7){}								//... wait finishing write for even field
    534          	}
    535          
    536          #if	defined(__EN_ISR__)
    537          //	EA = 1;
    538          #endif
    539          }
    540          //==================================================================================
    541          //void WriteOSDClr(u8 _pth, u8 _dvc, u8 _pos_x, u16 _pos_y, u8 _wdth, u16 _hght)	//... 16x20 font 기준.
    542          //{
    543          //	if(BitSet(_pth,PTH_X))	WriteOSDClrX(_dvc,_pos_x,_pos_y,_wdth,_hght);
    544          //	if(BitSet(_pth,PTH_Y))	WriteOSDClrY(_dvc,_pos_x,_pos_y,_wdth,_hght);
    545          //}
    546          //==================================================================================
    547          void	SetOSDCol(u8 *_tbl_osd_clr)//u8 _col_num, u8 _y, u8 _cb, u8 _cr)
    548          {
    549          	u8 _t1_, _t2_;//, _t3_;
    550          	
    551          	_t1_ = _tbl_osd_clr[0];
    552          	for(_t2_=0;_t2_<_t1_;_t2_++){
    553          		WriteAsicByte(MASTER,DVC_PG2,0x0b,_tbl_osd_clr[1+(_t2_<<2)]);
    554          		WriteAsicByte(MASTER,DVC_PG2,0x0c,_tbl_osd_clr[1+(_t2_<<2)+1]);
    555          		WriteAsicByte(MASTER,DVC_PG2,0x0d,_tbl_osd_clr[1+(_t2_<<2)+2]);
    556          		WriteAsicByte(MASTER,DVC_PG2,0x0e,_tbl_osd_clr[1+(_t2_<<2)+3]);
    557          
    558          //		while(ReadAsicByte(MASTER,DVC_PG2,0x0e)&BIT7);
    559          	}
    560          }
    561          //==================================================================================
    562          void	InitOSDCol(void)
    563          {
    564          
    565          	//SetOSDCol(ct_tst_24bit);
    566          	//SetOSDCol(ct_tst_fnt_16x20);
    567              //SetOSDCol(ct_ALPHA_NUM_32x40_4c);
    568              SetOSDCol(ct_CHANNEL);
    569          }
    570          //==================================================================================
    571          
    572          u8	GetCodeLength(unsigned char *_str)
    573          {
    574          	 u8 _cnt_=0;
    575          
    576            while((*_str++)!='\0')++_cnt_;
    577            return (_cnt_);
    578          }
    579          
    580          void WriteOSDStrX(u8 _dvc, u8 _pos_x, u8 _pos_y, u8 _prp, unsigned char *_str_ptr)
    581          {
    582          	u8 _lngth_ = GetCodeLength(_str_ptr);
    583          	u8 _indx_;
    584          	u8 _t1_, _t2_ = 0;
    585          
    586              
    587          	for(_t1_=0 ;_t1_< 3 ;_t1_++){
    588                  if(_str_ptr[_t1_] <0x40)
    589          		    _indx_ = _str_ptr[_t1_]-0x15;	
    590                  else if(_str_ptr[_t1_] >= 0x40)
    591                      _indx_ = _str_ptr[_t1_]-0x40;	
    592                  
    593                  WriteOSDBmpX(_dvc,_pos_x+_t2_,_pos_y,_prp,_indx_,gt_ALPHA_NUM_32x40_4c_Alpha_Num_32x40);
    594                  _t2_ += 4;
    595              }
    596              /*
    597              for(_t1_=0;_t1_<_lngth_;_t1_++){
    598                  if(_str_ptr[_t1_] <0x40)
    599          		    _indx_ = _str_ptr[_t1_]-0x20;
    600                  
    601                  
    602                  //WriteOSDBmp_DP(_dvc,_pos_x+_t2_,_pos_y,_prp,_indx_,gt_tst_fnt_16x20_tst_fnt_16x20);
    603          		WriteOSDBmpX(_dvc,_pos_x+_t2_,_pos_y,_prp,_indx_,gt_tst_fnt_16x20_tst_fnt_16x20);
    604                  //WriteOSDBmpY(_dvc,_pos_x+_t1_,_pos_y,_prp,_indx_,gt_tst_fnt_16x20_tst_fnt_16x20);
    605                  _t2_ += 2;
    606          	}
    607          	*/
    608          }
    609          
    610          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetCodeLength
       0   InitOSDCol
         0   -> SetOSDCol
      16   SetOSDCol
        16   -> WriteAsicByte
       0   WriteOSDBmpX
        88   -> ReadAsicOSDMemWr
        88   -> WriteAsicByteOSD
        88   -> WriteAsicTableOSD
      88   WriteOSDBmpY
        88   -> ReadAsicOSDMemWr
        88   -> WriteAsicByteOSD
        88   -> WriteAsicTableOSD
       0   WriteOSDBmp_DP
        88   -> ReadAsicOSDMemWr
        88   -> WriteAsicByteOSD
        88   -> WriteAsicTableOSD
      32   WriteOSDClrX
        32   -> ReadAsicOSDMemWr
        32   -> WriteAsicByteOSD
      24   WriteOSDClrY
        24   -> ReadAsicOSDMemWr
        24   -> WriteAsicByteOSD
      40   WriteOSDStrX
        40   -> WriteOSDBmpX


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
     546  ?Subroutine0
      18  GetCodeLength
       4  InitOSDCol
      72  SetOSDCol
       2  WriteOSDBmpX
     526  WriteOSDBmpY
       2  WriteOSDBmp_DP
     254  WriteOSDClrX
     238  WriteOSDClrY
      68  WriteOSDStrX
      16  ct_CHANNEL
     888  gt_CHANNEL_CH1_O
     888  gt_CHANNEL_CH2_O
     888  gt_CHANNEL_CH3_O
     888  gt_CHANNEL_CH4_O
       1  osd_bmp_pos_y

 
     1 byte  in section .bss
 3 568 bytes in section .data
 1 738 bytes in section .text
 
 1 738 bytes of CODE memory
 3 569 bytes of DATA memory

Errors: none
Warnings: none
