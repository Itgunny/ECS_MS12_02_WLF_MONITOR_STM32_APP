###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      21/Dec/2017  14:06:14 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pla #
#                    tform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c                 #
#    Command line =  "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pl #
#                    atform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c" -D            #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN D:\GIT\WLF_MONITOR\ECS_MS12_02_W #
#                    LF_MONITOR_STM32_APP\Project\Debug\List\ -o              #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\ --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Platform\COMMON\INC\ -I                          #
#                    "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pr #
#                    oject\..\Platform\TaeHa - ECS\INC\" -I                   #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\ -I  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\ -Oh    #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\List\WL9F_Monitor_APP.lst                     #
#    Object file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\WL9F_Monitor_APP.o                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          #include "flash_if.h"
     27          /* Private typedef -----------------------------------------------------------*/
     28          /*
     29          #define RX_MSG69		0x01
     30          #define RX_MSG69_M		0x02
     31          #define RX_MSG145		0x04
     32          #define RX_MSG161		0x08
     33          #define RX_MSG162		0x10
     34          #define RX_MSG163		0x20
     35          #define RX_MSG251		0x40
     36          #define RX_MSG252		0x80
     37          #define RX_MSG202		0x100
     38          #define RX_MSG253		0x200
     39          #define RX_MSG203		0x400
     40          #define RX_MSG239		0x800
     41          #define RX_MSG247		0x1000
     42          #define RX_MSG174		0x2000
     43          #define RX_MSG239_121	0x4000
     44          */
     45          #define RX_MSG11	0x01
     46          #define RX_MSG12	0x02
     47          #define RX_MSG21	0x04
     48          #define RX_MSG23	0x08
     49          #define RX_MSG61	0x10
     50          #define RX_MSG62	0x20
     51          #define RX_MSG101	0x40
     52          #define RX_MSG104	0x80
     53          #define RX_MSG105	0x100
     54          #define RX_MSG109	0x200
     55          #define RX_MSG121	0x400
     56          #define RX_MSG123	0x800
     57          #define RX_MSG201	0x1000
     58          #define RX_MSG203	0x2000
     59          		
     60          		
     61          #define RX_MSG47	0x4000
     62          		
     63          #define RX_MSG145	0x8000
     64          #define RX_MSG247	0x10000
     65          
     66          
     67          #define UART2_Tx_BUF_SIZE		17
     68          
     69          
     70          /* Private define ------------------------------------------------------------*/
     71          #define EXT_WATCHDOG_ENALBE(x)					GPIO_WriteBit(WD_EN_PORT, WD_EN,x)		// ++, --, 160511 bwk
     72          /* Private macro -------------------------------------------------------------*/
     73          WL9FM_send_smartkey send_smartkey;
     74          WL9FM_receive_smartkey recv_smartkey;
     75          WL9FM_save_rand_value rand_value;
     76          WL9FM_flag_data smk_flag_data;	
     77          
     78          /* Private variables ---------------------------------------------------------*/
     79          u8 gAuthentication_Cnt = 0;
     80          u8 gRetryCheck=0;		// ++, --, 161021 bwk
     81          
     82          // ++ , 141118 sys3215
     83          u8 Flag_ESL;
     84          u8 Seed_request;
     85          u8 Seed_received;
     86          u8 ESL_CTS_received;
     87          u8 ESL_ACK_received;
     88          u8 Password_Certification_Result;
     89          // -- , 141118 sys3215
     90          
     91          u8 AuthResult;
     92          u8 SMKSuccess;
     93          u8 SMK_Msg_Send;
     94          u8 SMK_Tag_Count;
     95          u8 MultiPacketSendOrder = 0;
     96          u8 TotalPacketNum = 0;
     97          u8 DiffMachInfo = 0;
     98          u8 MachInfoSendCnt = 0;
     99          u8 MoniInfoSendCnt = 0;
    100          
    101          u8 RTSFlag_61184 = 0;
    102          u8 CTSFlag_61184 = 0;
    103          u8 RMCU_CTSFlag_61184 = 0;
    104          u8 RecvTotalPacket_61184 = 0;
    105          u8 RMCU_RecvTotalPacket_61184 = 0;
    106          u8 ACK_Multi_61184[8];
    107          u8 RMCU_ACK_Multi_61184[8];
    108          
    109          u8 Flag_UartTxStart = 0;
    110          u8  SendTime_E2PROM = 0;
    111          
    112          u16 Flag_1Sec_MachInfo = 0;
    113          u16 Flag_1Min = 0;
    114          
    115          u8 MachInfoTotalPacketNum = 0;
    116          u8 MoniInfoTotalPacketNum = 0;
    117          u8 Flag_200mSec = 0;
    118          u8 SendRTCnt = 0;
    119          u16 adc_value = 0;
    120          
    121          u8 SerialMsgRTC[16];
    122          u8 eepRomReadData1[32];
    123          u8 MoniInfoData[21];
    124          u8 McuInfoData2[4];
    125          u8 McuInfoData3[4];
    126          u8 McuInfoData4[4];
    127          
    128          u8 SystemReset = 0;
    129          u8 E2PROM_Save = 0;
    130          u8 PwrOffCnt = 0;
    131          u8 gRebootCmd = 0;
    132          
    133          
    134          u8 send_mcu_data=0;
    135          u8 send_bkcu_data=0;
    136          
    137          u8 ST_Update=0;
    138          u8 UpdateMode = 0;
    139          
    140          extern u8 Uart2_RxMsg_Single_252[8];
    141          extern u8 Uart2_RxMsg_Single_253[8];
    142          extern u8 Uart2_RxMsg_Single_239[8];
    143          extern u8 Uart2_RxMsg_Single_239_121[8];
    144          extern u8 Uart2_RxMsg_Single_247[8];
    145          extern u8 Uart2_RxMsg_Save_Data1[8];
    146          extern u8 Uart2_RxMsg_Save_Data2[8];
    147          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    148          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    149          extern u8 McuInfoData1[79];
    150          extern u8 tmpMcuInfoData[78];
    151          extern u8 FatoryInit_Flag;
    152          
    153          extern u8 stop_send_as_phone_data;
    154          extern u8 Flag_TxE2pRomData;
    155          
    156          extern u8 Buz1;
    157          
    158          extern u8 Stm32_Update_CMD;
    159          extern u8 CANUpdateFlag;
    160          
    161          extern u16 pWriteBufPos;
    162          extern u16 pReadBufPos;
    163          
    164          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    165          extern char Illumination_Sig;
    166          
    167          // ++, 141006 fort22
    168          u8 LCDOffCount;
    169          u16 OSUpdateCount;
    170          // --, 141006 fort22
    171          
    172          u8 SmartKeyUse;
    173          u8 SaveSmartKeyUse;		// ++, --, 161021 bwk
    174          
    175          u8 CameraCommFlag;
    176          
    177          u8 AAVMCommFlag;
    178          u8 AAVMEquipFlag;
    179          // ++, sys3215, 141211
    180          extern u8 Hardware_Revision;
    181          // --, sys3215, 141211
    182          
    183          extern u8 Flag_St_Update;
    184          extern u8 Old_CAMSig_1;
    185          
    186          
    187          //	++, kutelf, 150810
    188          //	Software_Reset
    189          #define ApplicationAddress      0x8004000
    190          #define BootLoaderAddress       0x8000000
    191          
    192          typedef  void (*pFunction)(void);
    193          
    194          pFunction Jump_To_Application_Cluster_App;
    195          uint32_t JumpAddress_Cluster_App;
    196          
    197          pFunction Jump_To_Application_Cluster_Iap;
    198          uint32_t JumpAddress_Cluster_Iap;
    199          
    200          void Software_Reset_BootLoader(void);
    201          void Software_Reset_Application(void);
    202          
    203          
    204          void Software_Reset_Application(void)
    205          { 	/* Jump to user application */
    206          		JumpAddress_Cluster_App = *(__IO uint32_t*) (ApplicationAddress + 4);
    207          		Jump_To_Application_Cluster_App = (pFunction) JumpAddress_Cluster_App;
    208          		/* Initialize user application's Stack Pointer */
    209          		__set_MSP(*(__IO uint32_t*) ApplicationAddress);
    210          		Jump_To_Application_Cluster_App();
    211          }	
    212          
    213          void Software_Reset_BootLoader(void)
    214          { 	/* Jump to user application */
    215          		JumpAddress_Cluster_Iap = *(__IO uint32_t*) (BootLoaderAddress + 4);
    216          		Jump_To_Application_Cluster_Iap = (pFunction) JumpAddress_Cluster_Iap;
    217          		/* Initialize user application's Stack Pointer */
    218          		__set_MSP(*(__IO uint32_t*) BootLoaderAddress);
    219          		Jump_To_Application_Cluster_Iap();
    220          }	
    221          //	--, kutelf, 150810
    222          
    223          /* Private function prototypes -----------------------------------------------*/
    224          /* Private functions ---------------------------------------------------------*/
    225          
    226          void Init_RTC(void)
    227          {
    228          	WL9FM_RTC.Year   = 0;
    229          	WL9FM_RTC.Month  = 1;
    230          	WL9FM_RTC.Date   = 1;
    231          	WL9FM_RTC.Day    = 1;
    232          	WL9FM_RTC.Hour   = 12;
    233          	WL9FM_RTC.Minute = 0;
    234          	WL9FM_RTC.Second = 0;
    235          
    236          	WRITE_RTC(WL9FM_RTC);
    237          }
    238          void InitE2PROM(void)
    239          {
    240          	u8 i;
    241          	u8 tmpBuf1[8];
    242          	u8 tmpBuf2[8];
    243          	u8 tmpBuf3[8];
    244          	u8 tmpBuf4[21];
    245          	
    246          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    247          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    248          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    249          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    250          
    251          	SaveE2PROM1->WorkLoad 				= 0;
    252          	SaveE2PROM1->testWorkLoad 			= 0;
    253          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    254          	SaveE2PROM1->DispType	 			= 0;
    255          	SaveE2PROM1->InfoViewPriority 		= 0;
    256          	SaveE2PROM1->UnitPressure 			= 0;
    257          	SaveE2PROM1->Reserved0 				= 0;
    258          	SaveE2PROM1->Lang 					= 0;
    259          	SaveE2PROM1->ManualBackLight 		= 7;
    260          	SaveE2PROM1->AutoBackLight 			= 0;
    261          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    262          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    263          	SaveE2PROM1->InfoViewCnt 			= 2;
    264          	SaveE2PROM1->HR_Start 				= 0;
    265          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    266          	SaveE2PROM1->ActiveCamNum 			= 1;
    267          	SaveE2PROM1->FirstCam 				= 0;
    268          	SaveE2PROM1->SecondCam 				= 1;
    269          	SaveE2PROM1->ThirdCam 				= 2;
    270          	SaveE2PROM1->Reserved1 				= 0;
    271          
    272          	SaveE2PROM2->LightMode 				= 0;
    273          	SaveE2PROM2->JobTimeView 			= 0;
    274          	SaveE2PROM2->OdoMeterView 			= 0;
    275          	SaveE2PROM2->JobOdoSelect 			= 0;
    276          	SaveE2PROM2->LightLowTime 			= 8;
    277          	SaveE2PROM2->LightUpperTime 		= 16;
    278          	SaveE2PROM2->AutoLightDay 			= 0;
    279          	SaveE2PROM2->AutoLightNight 		= 0;
    280          	SaveE2PROM2->Reserved1 				= 0;
    281          
    282          	SaveE2PROM3->Phone_1  				= 0;
    283          	SaveE2PROM3->Phone_2  				= 8;
    284          	SaveE2PROM3->Phone_3  				= 0;
    285          	SaveE2PROM3->Phone_4  				= 5;
    286          	SaveE2PROM3->Phone_5  				= 5;
    287          	SaveE2PROM3->Phone_6  				= 5;
    288          	SaveE2PROM3->Phone_7  				= 8;
    289          	SaveE2PROM3->Phone_8  				= 2;
    290          	SaveE2PROM3->Phone_9  				= 7;
    291          	SaveE2PROM3->Phone_10 				= 2;
    292          	SaveE2PROM3->Phone_11 				= 0xf;
    293          	SaveE2PROM3->Phone_12 				= 0xf;
    294          
    295          #if 1	// Monitor Change History - temp
    296          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    297          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    298          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    299          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    300          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    301          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    302          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    303          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    304          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    305          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    306          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    307          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    308          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    309          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    310          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    311          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    312          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    313          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    314          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    315          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    316          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    317          #endif
    318          
    319          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    320          
    321          	EEPROM_Write(0, 0);	// tmp
    322          	EEPROM_Write(0, 0);	// tmp
    323          	EEPROM_Write(0, 0);	// tmp
    324          
    325          	for(i = 0 ; i < 8 ; i++)
    326          	{
    327          		EEPROM_Write(i+8, tmpBuf1[i]);
    328          		TimeDelay_msec(5);
    329          		EEPROM_Write(i+16, tmpBuf2[i]);
    330          		TimeDelay_msec(5);
    331          		EEPROM_Write(i+24, tmpBuf3[i]);
    332          		TimeDelay_msec(5);
    333          	}
    334          
    335          	SerialPutString("Initialize : 30 %%\n\r");
    336          	
    337          #if 1	// Monitor Change History - temp
    338          	for(i = 0 ; i < 21 ; i++)
    339          	{
    340          		EEPROM_Write(i+50, tmpBuf4[i]);
    341          		TimeDelay_msec(5);
    342          	}
    343          #endif
    344          
    345          	for(i = 0 ; i < 79 ; i++)
    346          	{
    347          		EEPROM_Write(i+100, 0xff);
    348          		TimeDelay_msec(5);
    349          	}
    350          
    351          	SerialPutString("Initialize : 60 %%\n\r");
    352          
    353          	for(i = 0 ; i < 30 ; i++)
    354          	{
    355          		EEPROM_Write(i+200, 0xff);
    356          		TimeDelay_msec(5);
    357          	}
    358          
    359          	for(i = 0 ; i < 29 ; i++)
    360          	{
    361          		EEPROM_Write(i+230, 0xff);
    362          		TimeDelay_msec(5);
    363          	}
    364          
    365          	SerialPutString("Initialize : 95 %%\n\r");
    366          	Init_RTC();
    367          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    368          }
    369          
    370          void ReadE2PROM_ToSend()
    371          {
    372          #if 1
    373          	u8 i;
    374          
    375          	adc_value = (ADC1->DR & 0x0000FFFF);
    376          
    377          	i = EEPROM_Read(0);	
    378          	i = EEPROM_Read(0);
    379          	i = EEPROM_Read(0);
    380          	i = 0;
    381              
    382          	adc_value = (ADC1->DR & 0x0000FFFF);
    383          
    384          	for(i = 0 ; i < 24 ; i++)
    385          		eepRomReadData1[i] = EEPROM_Read(i+8);
    386          
    387          	for(i = 0 ; i < 8 ; i++)
    388          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    389          
    390          	for(i = 0 ; i < 8 ; i++)
    391          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    392          
    393          	for(i = 0 ; i < 8 ; i++)
    394          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    395          
    396          	for(i = 0 ; i < 21 ; i++)
    397          		MoniInfoData[i] = EEPROM_Read(i+50);
    398          	
    399          	for(i = 0 ; i < 79 ; i++)
    400          		McuInfoData1[i] = EEPROM_Read(i+100);
    401          
    402          	for(i = 0 ; i < 4 ; i++)
    403          		McuInfoData2[i] = EEPROM_Read(i+200);
    404          
    405          	for(i = 0 ; i < 4 ; i++)
    406          		McuInfoData3[i] = EEPROM_Read(i+210);
    407          
    408          	for(i = 0 ; i < 4 ; i++)
    409          		McuInfoData4[i] = EEPROM_Read(i+220);
    410          
    411          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    412          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    413          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    414          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    415          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    416          
    417          
    418          	adc_value = (ADC1->DR & 0x0000FFFF);
    419          	
    420          	eepRomReadData1[12] = (adc_value & 0xff);
    421          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    422          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    423          
    424          #endif
    425          }
    426          
    427          
    428          void Init_Smart_Key_valuable(void)
    429          {
    430          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    431          	AuthResult = 0xff;
    432          	SMK_Msg_Send = 0;
    433          	SMK_Tag_Count = 0;
    434          	SMKSuccess = 0;
    435          
    436          // ++, 141118 sys3215
    437          	Flag_ESL=0;
    438          	Seed_request=0;
    439          	Seed_received=0;
    440          	ESL_CTS_received=0;
    441          	ESL_ACK_received=0;
    442          	Password_Certification_Result=0;
    443          // --, 141118 sys3215
    444          
    445          	gAuthentication_Cnt = 0;						// ++, --, 161021 bwk
    446          	rand_value.rand_cpk = (rand() % 0xfaffffff);	// ++, --, 161021 bwk
    447          
    448          }
    449          
    450          
    451          void read_clock(void)
    452          {
    453          	uint8_t Temp[Serial_COM4_TxSize];
    454          	
    455          	READ_RTC(&WL9FM_RTC);
    456          
    457          	Temp[0] = 0x02;				
    458          	Temp[1] = RTCRES;				
    459          	Temp[2] = WL9FM_RTC.Year;	
    460          	Temp[3] = WL9FM_RTC.Month;	
    461          	Temp[4] = WL9FM_RTC.Date;	
    462          	Temp[5] = WL9FM_RTC.Day;	
    463          	Temp[6] = WL9FM_RTC.Hour;	
    464          	Temp[7] = WL9FM_RTC.Minute;	
    465          	Temp[8] = WL9FM_RTC.Second;	
    466          	Temp[9] = 0xFF;	
    467          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    468          	USARTx_EXYNOS(COM4, (char *)Temp);	
    469          
    470          }
    471          
    472          void SaveDataToEEPROM(void)
    473          {
    474          	u8 i;
    475          	
    476          	for(i = 0 ; i < 8 ; i++)
    477          	{
    478          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    479          		TimeDelay_msec(1);
    480          	}
    481          
    482          	for(i = 0 ; i < 8 ; i++)
    483          	{
    484          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    485          		TimeDelay_msec(1);
    486          	}
    487          
    488          	for(i = 0 ; i < 8 ; i++)
    489          	{
    490          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    491          		TimeDelay_msec(1);
    492          	}
    493          
    494          	for(i = 0 ; i < 21 ; i++)
    495          	{
    496          		EEPROM_Write(i+50, MoniInfoData[i]);
    497          		TimeDelay_msec(1);
    498          	}
    499          	
    500          	for(i = 0 ; i < 79 ; i++)
    501          	{
    502          		EEPROM_Write(i+100, McuInfoData1[i]);
    503          		TimeDelay_msec(1);
    504          	}
    505          
    506          
    507          	if(DiffMachInfo == 1)
    508          	{
    509          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    510          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    511          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    512          	}
    513          
    514          	for(i = 0 ; i < 4 ; i++)
    515          	{
    516          		EEPROM_Write(i+200, McuInfoData2[i]);
    517          		TimeDelay_msec(1);
    518          	}
    519          
    520          	for(i = 0 ; i < 4 ; i++)
    521          	{
    522          		EEPROM_Write(i+210, McuInfoData3[i]);
    523          		TimeDelay_msec(1);
    524          	}
    525          
    526          	for(i = 0 ; i < 4 ; i++)
    527          	{
    528          		EEPROM_Write(i+220, McuInfoData4[i]);
    529          		TimeDelay_msec(1);
    530          	}
    531          }
    532          void SaveSMKUseToEEPROM(u8 Use)
    533          {
    534          	EEPROM_Write(0,Use);
    535          }
    536          u8 LoadSMKUseToEEPROM(void)
    537          {
    538          	return EEPROM_Read(0);
    539          }
    540          
    541          // ++, 160511 bwk
    542          void SaveSMKUseToFlash(u8 Use)
    543          {
    544          	// ++, 161021 bwk
    545          	#if 0
    546          	u8 SaveSMKUse[1];
    547          	SaveSMKUse[0] = Use;
    548          	SPI_FLASH_SectorErase(0);		// 0 : Sector_0
    549          	SPI_FLASH_PageWrite(SaveSMKUse,0,1);		// 0 : Sector_0
    550          	#else
    551          	FLASH_If_Init();	
    552          	u32 SmkAddress = ADDR_FLASH_SECTOR_11;
    553          	FLASH_If_SMK_Erase(SmkAddress);
    554          	FLASH_ProgramByte(SmkAddress, Use);
    555          	FLASH_Lock();
    556          	#endif
    557          	// --, 161021 bwk
    558          }
    559          u8 LoadSMKUseToFlash(void)
    560          {
    561          	// ++, 161021 bwk
    562          	#if 0
    563          	u8 SaveSMKUse[1];
    564          	SPI_FLASH_BufferRead(SaveSMKUse,0,1);		// 0 : Sector_0
    565          	return SaveSMKUse[0];
    566          	#else
    567          	u8 loadSMKUse;
    568          	u32 SmkAddress = ADDR_FLASH_SECTOR_11;
    569          	loadSMKUse =  *(unsigned char*)SmkAddress++;
    570          	if(loadSMKUse == 0xff)
    571          		loadSMKUse = 0;
    572          	return loadSMKUse;
    573          	#endif
    574          	// --, 161021 bwk
    575                  /*
    576                  */
    577          }
    578          // --, 160511 bwk
    579          
    580          void SaveTestToEEPROM(u8 Use)
    581          {
    582          	EEPROM_Write(1,Use);
    583          }
    584          
    585          u8 LoadTestToEEPROM(void)
    586          {
    587          	return EEPROM_Read(1);
    588          }
    589          
    590          
    591          void System_CheckPowerIG()
    592          {
    593          	// Check POWER IG
    594          	if(!WL9FM_GetPowerIG())
    595          	{
    596          		WL9FM_PowerIG(PowerIG_ON);
    597          		SystemReset = 0;
    598          	}
    599          	else
    600          	{
    601          		if(E2PROM_Save == 0)
    602          		{
    603          			//SaveDataToEEPROM();
    604          
    605          			PwrOffCnt = 0;
    606          			
    607          			while(1)
    608          			{
    609          				//	100msec 마다 15번 체크 -> 1.5초..
    610          				//	PowerIG Off 상태일 경우
    611          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    612          				//	PowerIG On  상태일 경우 
    613          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    614          				
    615          				if(!WL9FM_GetPowerIG())
    616          				{
    617          					
    618          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    619          					
    620          					
    621          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    622          					SystemReset = 0;
    623          					return;
    624          				}
    625          			
    626          				TimeDelay_msec(100);
    627          
    628          				PwrOffCnt++;
    629          				if(PwrOffCnt >= 15)	
    630          					break;
    631          			}
    632          
    633          			// ++, 161021 bwk
    634          			if(SaveSmartKeyUse != SmartKeyUse)
    635          			{
    636          				SaveSMKUseToFlash(SaveSmartKeyUse);
    637          			}
    638          			// --, 161021 bwk
    639          			Buzzer_Off();
    640          
    641          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    642          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(100);
    643          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	//TimeDelay_msec(3);
    644          
    645          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    646          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    647          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    648          
    649          
    650          			Buzzer_UnLimitOff();
    651          			
    652          			//	POWER OFF 일 때, LAMP Clear
    653          			LAMP_Update_Data = LAMP_ALL_OFF;
    654          
    655          			//Old_LAMP_Update_Data = LAMP_ALL_OFF;
    656          
    657          			Illumination_Sig = 0;
    658          			Lamp_Update_System();
    659          			
    660          			//	엔딩화면 딜레이 시간
    661          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    662          			TimeDelay_msec(1200);
    663          
    664          			//	LCDBL, LCD, LED Off
    665          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    666          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    667          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    668          			//LED_POWER_ONOFF(LED_OFF);       //  LED Off
    669          
    670          		//	++, kutelf, 140801
    671          		//	RevD.01.01 
    672          		//	Power, PMIC On/Off 방법 변경 
    673          		#if 0
    674          
    675          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_PMIC_OFF);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
    676          			WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
    677          			WL9FM_EXYNOS_PMIC_nRESET();
    678          		#else
    679          			WL9FM_EXYNOS_PMIC_PWROFF();
    680          			
    681          			//	Exynos VDD5V0_4412 Off
    682          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    683          			
    684          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    685          
    686          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    687          			if(!WL9FM_GetPowerIG())
    688          			{
    689          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    690          
    691          				//	++, kutelf, 150810
    692          				#if 1
    693          				if (Flag_St_Update==1)
    694          				{
    695          					gRebootCmd=1;
    696          					Flag_St_Update=0;
    697          
    698          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    699          					CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    700          
    701          					Software_Reset_BootLoader();
    702          				}
    703          				else
    704          				{
    705          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    706          					CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    707          
    708          					Software_Reset_Application();
    709          				}	
    710          				#else
    711          				if(Flag_St_Update==1)
    712          				{
    713          					gRebootCmd=1;
    714          					Flag_St_Update=0;
    715          				}
    716          				else
    717          					SystemReset = 1;			//	Software RESET
    718          
    719          				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    720          				CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    721          				return;
    722          				#endif
    723          				//	--, kutelf, 150810
    724          			}
    725          
    726          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	 
    727          			WL9FM_PowerIG(PowerIG_OFF);		
    728          			WL9FM_PowerIG(PowerIG_OFF);		
    729          		#endif
    730          		//	--, kutelf, 140801
    731          		}
    732          	}
    733          }
    734          
    735          
    736          void JumpIAP(void)
    737          {
    738          	//#ifdef USE_WATCH_DOG
    739          	/* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
    740          	dispersion) -------------------------------------------------------------*/
    741          	/* Enable write access to IWDG_PR and IWDG_RLR registers */
    742          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
    743          
    744          	/* IWDG counter clock: 40KHz(LSI) / 32 = 156.25 Hz */
    745          	IWDG_SetPrescaler(IWDG_Prescaler_256);
    746          
    747          	/* Set counter reload value to 150   about 1sec */
    748          	IWDG_SetReload(1);
    749          
    750          	/* Reload IWDG counter */
    751          	IWDG_ReloadCounter();
    752          
    753          	IWDG_Enable();
    754          		
    755          	while(1);
    756          	//#endif		
    757          }
    758          
    759          /*******************************************************************************
    760          *
    761          *	Smart Key Test Function
    762          *
    763          *******************************************************************************/
    764          #if 1
    765          void SendSMKAuthResult(u8 result)
    766          {
    767          	// ++, 150707 bwk
    768          	#if 0
    769          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    770          	#else
    771          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count , 0xff, 0xff);
    772          	#endif
    773          	// --, 150707 bwk
    774          }
    775          
    776          // ++, 150710 bwk
    777          void SendSMKCountResult()
    778          {
    779          	SMK_SendToExynos( 0xFF,SMK_RESPONSE_FLAG_DUPLICATION_REG, SMK_Tag_Count , 0xff, 0xff);
    780          }
    781          // --, 150710 bwk
    782          
    783          void SendSMKMsgResult(u8 result)
    784          {
    785          	// ++, 150707 bwk
    786          	#if 0
    787          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    788          	#else
    789          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count, recv_smartkey.Smk_Response_Code, recv_smartkey.Smk_Response_Flag);
    790          	#endif
    791          	// --, 150707 bwk
    792          }
    793          
    794          void SetTagLevel(u8 level)
    795          {
    796          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    797          		send_smartkey.TagLevel = level;
    798          	else
    799          		send_smartkey.TagLevel = 3;
    800          }
    801          
    802          void SetTagCmd(u8 cmd)
    803          {
    804          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    805          		send_smartkey.TagCommand = cmd;
    806          	else
    807          		send_smartkey.TagCommand = 0xf;
    808          }
    809          
    810          void SetVMC(void)
    811          {
    812          	if(rand_value.rand_vmc <= 64255)
    813          		send_smartkey.VMC = rand_value.rand_vmc;
    814          	else
    815          		send_smartkey.VMC = 0xffff;
    816          }
    817          
    818          void SetCPK(void)
    819          {
    820          #if 1
    821          	if(rand_value.rand_cpk <= 0xfaffffff)
    822          		send_smartkey.CPK = rand_value.rand_cpk;
    823          	else
    824          		send_smartkey.CPK = 0xffffffff;
    825          #else
    826          	send_smartkey.CPK = 0x11223344;
    827          #endif
    828          }
    829          
    830          void Srand()
    831          {
    832          	READ_RTC(&WL9FM_RTC);
    833          	srand((u32)WL9FM_RTC.Second);
    834          }
    835          
    836          void GetRandValue(u8 random)
    837          {
    838          	// ++, 161021 bwk
    839          	#if 0
    840          	if(random == GET_VMC)	
    841          	{
    842          		// ++, 150710 bwk
    843          #if 0
    844          		rand_value.rand_vmc = (rand() % 64255);
    845          #else
    846          		return;
    847          #endif
    848          		// --, 150710 bwk 
    849          	}
    850          	else if(random == GET_CPK)	
    851          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    852          	else if(random == GET_VMC_CPK)		
    853          	{
    854          		rand_value.rand_vmc = (rand() % 64255);
    855          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    856          	}	
    857          	#else
    858          	if((random == GET_VMC) || (random == GET_VMC_CPK))
    859          		rand_value.rand_vmc = (rand() % 64255);	
    860          	#endif
    861          	// --, 161021 bwk
    862          }
    863          
    864          void RequestFirstAuthentication(void)
    865          {
    866          	unsigned int temp;
    867          	
    868          	gRetryCheck = 0;				// ++, --, 161021 bwk
    869          	
    870          	SetTagLevel(TAG_LEVEL_NORMAL);
    871          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    872          	GetRandValue(GET_VMC_CPK);
    873          	SetVMC();
    874          	SetCPK();
    875          
    876          	setCipherParam(0x8085, 0x8087);
    877          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    878          	
    879          	send_smartkey.CPK = temp;
    880          
    881          	// CPK 암호화 Function 추가 필요
    882          	TimeDelay_msec(10);
    883          
    884          	struct st_CAN_Message1 Send_Message;
    885          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    886          	Send_Message.Priority= 0x18;
    887          	Send_Message.PDU_Format= 0xFF;
    888          	Send_Message.PDU_Specific= 0xE7;
    889          	Send_Message.Source_Address= 0x28;
    890          	Write_CAN_Single(Send_Message);
    891          }
    892          
    893          void RequestSecondAuthentication(void)
    894          {
    895          	unsigned short upper_cpk, lower_cpk;
    896          	unsigned int temp;
    897          
    898          	gRetryCheck = 0;				// ++, --, 161021 bwk
    899          
    900          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    901          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    902          	
    903          	SetTagLevel(TAG_LEVEL_NORMAL);
    904          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    905          	GetRandValue(GET_VMC);
    906          	SetVMC();
    907          
    908          	setCipherParam(upper_cpk, lower_cpk);
    909          	//setCipherParam(0x1122, 0x3344);
    910          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    911          
    912          	send_smartkey.CPK = temp;
    913          	
    914          	TimeDelay_msec(10);
    915          
    916          	struct st_CAN_Message1 Send_Message;
    917          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    918          	Send_Message.Priority= 0x18;
    919          	Send_Message.PDU_Format= 0xFF;
    920          	Send_Message.PDU_Specific= 0xE7;
    921          	Send_Message.Source_Address= 0x28;
    922          	Write_CAN_Single(Send_Message);
    923          
    924          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    925          }
    926          
    927          void RequestSMKRegistration(void)
    928          {
    929          	unsigned short upper_cpk, lower_cpk;
    930          	unsigned int temp;
    931          
    932          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    933          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    934          	
    935          	SetTagLevel(TAG_LEVEL_NORMAL);
    936          	SetTagCmd(TAG_CMD_REGISTRATION);
    937          	GetRandValue(GET_VMC);
    938          	SetVMC();
    939          
    940          	setCipherParam(upper_cpk, lower_cpk);
    941          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    942          
    943          	send_smartkey.CPK = temp;
    944          
    945          
    946          	struct st_CAN_Message1 Send_Message;
    947          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    948          	Send_Message.Priority= 0x18;
    949          	Send_Message.PDU_Format= 0xFF;
    950          	Send_Message.PDU_Specific= 0xE7;
    951          	Send_Message.Source_Address= 0x28;
    952          	Write_CAN_Single(Send_Message);
    953          
    954          
    955          
    956          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    957          }
    958          
    959          void RequestSMKElimination(void)
    960          {
    961          	unsigned short upper_cpk, lower_cpk;
    962          	unsigned int temp;
    963          
    964          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    965          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    966          	
    967          	SetTagLevel(TAG_LEVEL_NORMAL);
    968          	SetTagCmd(TAG_CMD_ELIMINATION);
    969          	GetRandValue(GET_VMC);
    970          	SetVMC();
    971          
    972          	setCipherParam(upper_cpk, lower_cpk);
    973          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    974          
    975          	send_smartkey.CPK = temp;
    976          
    977          	struct st_CAN_Message1 Send_Message;
    978          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    979          	Send_Message.Priority= 0x18;
    980          	Send_Message.PDU_Format= 0xFF;
    981          	Send_Message.PDU_Specific= 0xE7;
    982          	Send_Message.Source_Address= 0x28;
    983          	Write_CAN_Single(Send_Message);
    984          
    985          
    986          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    987          }
    988          
    989          void RequestSMKMessage(u8 Msg)
    990          {
    991          	if(Msg == 1)
    992          		RequestSMKRegistration();
    993          	else if(Msg == 2)
    994          		RequestSMKElimination();
    995          }
    996          
    997          void RequestSMKComm(void)
    998          {
    999          	SetTagLevel(TAG_LEVEL_NORMAL);
   1000          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
   1001          	GetRandValue(GET_VMC);
   1002          	SetVMC();
   1003          
   1004          	struct st_CAN_Message1 Send_Message;
   1005          	memcpy(&Send_Message.Data,&send_smartkey,8);	
   1006          	Send_Message.Priority= 0x18;
   1007          	Send_Message.PDU_Format= 0xFF;
   1008          	Send_Message.PDU_Specific= 0xE7;
   1009          	Send_Message.Source_Address= 0x28;
   1010          	Write_CAN_Single(Send_Message);
   1011          
   1012          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1013          }
   1014          
   1015          u8 CheckResponseVMC(void)
   1016          {
   1017          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
   1018          		return RETURN_VMC_OK;
   1019          	else
   1020          		return RETURN_VMC_NOT_OK;
   1021          }
   1022          
   1023          u8 CheckResponseAuthentication(u8 Auth)
   1024          {
   1025          	u8 output_buf[8];
   1026          	u16 upper_cpk, lower_cpk;
   1027          
   1028          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
   1029          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
   1030          	
   1031          	setCipherParam(upper_cpk, lower_cpk);
   1032          	//setCipherParam(0x1122, 0x3344);	// 임시
   1033          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
   1034          
   1035          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
   1036          
   1037          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
   1038          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
   1039          	{
   1040          		if((recv_smartkey.Smk_Response_Code == Auth) && 
   1041          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
   1042          		{
   1043          			return SMK_RESPONSE_FLAG_SUCCESS;
   1044          		}
   1045          		else
   1046          			return recv_smartkey.Smk_Response_Flag;
   1047          	}
   1048          	else
   1049          		return SMK_RESPONSE_CODE_NOT_MATCH;
   1050          }
   1051          
   1052          void CheckResponseMsgComm(void)
   1053          {
   1054          	u8 output_buf[8];
   1055          	u16 upper_cpk, lower_cpk;
   1056          
   1057          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
   1058          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
   1059          	
   1060          	setCipherParam(upper_cpk, lower_cpk);
   1061          	//setCipherParam(0x1122, 0x3344);	// 임시
   1062          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
   1063          
   1064          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
   1065          
   1066          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
   1067          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
   1068          	{
   1069          		if(recv_smartkey.Smk_Response_Code == 1)
   1070          		{
   1071          			switch(recv_smartkey.Smk_Response_Flag)
   1072          			{
   1073          				
   1074          				case 2 :
   1075          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
   1076          					break;
   1077          				
   1078          				case 1:
   1079          				case 3 :
   1080          					SendSMKMsgResult(SMK_MSG_FAIL);
   1081          					break;
   1082          				case 4 :
   1083          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
   1084          					break;
   1085          				default :
   1086          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
   1087          					{
   1088          						if(recv_smartkey.Registered_Tag_Count == 1)
   1089          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
   1090          						else if(recv_smartkey.Registered_Tag_Count == 2)
   1091          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
   1092          						else if(recv_smartkey.Registered_Tag_Count == 3)
   1093          							SendSMKMsgResult(SMK_MSG_TAG_THIRD_REG_SUCCESS);
   1094          						else if(recv_smartkey.Registered_Tag_Count == 4)
   1095          							SendSMKMsgResult(SMK_MSG_TAG_FOURTH_REG_SUCCESS);
   1096          						else if(recv_smartkey.Registered_Tag_Count == 5)
   1097          							SendSMKMsgResult(SMK_MSG_TAG_FIFTH_REG_SUCCESS);
   1098          						else
   1099          							SendSMKMsgResult(SMK_MSG_FAIL);
   1100          					}
   1101          					else
   1102          					{
   1103          						// ++, 150707 sys
   1104          						#if 0
   1105          						if(SMK_Tag_Count != 0)
   1106          							SMK_Tag_Count--;
   1107          						#endif
   1108          						// --, 150707 sys
   1109          						
   1110          						SendSMKMsgResult(SMK_MSG_FAIL);
   1111          					}
   1112          					break;
   1113          			}
   1114          		}
   1115          		else if(recv_smartkey.Smk_Response_Code == 2)
   1116          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
   1117          		else
   1118          			SendSMKMsgResult(SMK_MSG_FAIL);
   1119          	}
   1120          	else
   1121          		SendSMKMsgResult(SMK_MSG_FAIL);
   1122          }
   1123          
   1124          
   1125          void SmartKeyAuthentication(void)
   1126          {
   1127          	u8  Auth = 0;
   1128          	u8 returnvalue;
   1129          
   1130          	if(AuthResult != 1)
   1131          	{
   1132          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
   1133          		{
   1134          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
   1135          			{
   1136          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
   1137          				RequestFirstAuthentication();
   1138          			}
   1139          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
   1140          			{
   1141          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
   1142          				RequestSecondAuthentication();
   1143          			}
   1144          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
   1145          			{
   1146          
   1147          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
   1148          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
   1149          
   1150          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1151          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
   1152          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1153          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
   1154          					
   1155          				returnvalue = CheckResponseAuthentication(Auth);
   1156          					
   1157          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
   1158          				{
   1159          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1160          					{
   1161          						gAuthentication_Cnt = 0;
   1162          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1163                                                          // ++, 150713 bwk
   1164          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;		// ++, --, 150709 bwk
   1165          						SendSMKCountResult();
   1166                                                          // --, 150713 bwk
   1167          					}
   1168          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1169          					{
   1170          						gAuthentication_Cnt = 0;
   1171          						AuthResult = 1;
   1172          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
   1173          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
   1174          						SMKSuccess = SMK_SUCCESS;
   1175          						SendSMKAuthResult(SMK_SUCCESS);
   1176          
   1177          						// ++ , 141118 sys3215
   1178          						Flag_ESL=1;
   1179          						// -- , 141118 sys3215
   1180          						
   1181          					}
   1182          				}
   1183          				else
   1184          				{
   1185          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
   1186          					{
   1187          						gAuthentication_Cnt = 0;
   1188          						//AuthResult = 2;
   1189          						AuthResult = 1;
   1190          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
   1191          						SMKSuccess = SMK_FAIL;
   1192          						SendSMKAuthResult(SMK_FAIL);
   1193          						return;
   1194          					}
   1195          
   1196          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1197          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
   1198          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1199          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1200          				}
   1201          			}
   1202          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
   1203          			{
   1204          				// ++, 161021 bwk
   1205          				#if 0
   1206          				//RequestFirstAuthentication();
   1207          				#else
   1208          				if(gRetryCheck < 5)
   1209          				{
   1210          					if(++gAuthentication_Cnt >= 2)
   1211          					{
   1212          						gAuthentication_Cnt = 0;
   1213          						struct st_CAN_Message1 Send_Message;
   1214          						memcpy(&Send_Message.Data,&send_smartkey,8);	
   1215          						Send_Message.Priority= 0x18;
   1216          						Send_Message.PDU_Format= 0xFF;
   1217          						Send_Message.PDU_Specific= 0xE7;
   1218          						Send_Message.Source_Address= 0x28;
   1219          						Write_CAN_Single(Send_Message);
   1220          
   1221          						gRetryCheck++;
   1222          					}
   1223          				}
   1224          				#endif
   1225          				// --, 161021 bwk
   1226          			}
   1227          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
   1228          			{
   1229          				// ++, 161021 bwk
   1230          				#if 0
   1231          				//RequestSecondAuthentication();
   1232          				#else
   1233          				if(gRetryCheck < 5)
   1234          				{
   1235          					if(++gAuthentication_Cnt >= 2)
   1236          					{
   1237          						gAuthentication_Cnt = 0;
   1238          						struct st_CAN_Message1 Send_Message;
   1239          						memcpy(&Send_Message.Data,&send_smartkey,8);	
   1240          						Send_Message.Priority= 0x18;
   1241          						Send_Message.PDU_Format= 0xFF;
   1242          						Send_Message.PDU_Specific= 0xE7;
   1243          						Send_Message.Source_Address= 0x28;
   1244          						Write_CAN_Single(Send_Message);
   1245          
   1246          						gRetryCheck++;
   1247          					}
   1248          				}
   1249          				#endif
   1250          				// --, 161021 bwk
   1251          			}
   1252          		}
   1253          	}
   1254          	//else if(AuthResult == 1)
   1255          	{
   1256          	
   1257          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
   1258          		{
   1259          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
   1260          			SMK_Msg_Send = 1;
   1261          			smk_flag_data.recv_resp_packet = 0;
   1262          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
   1263          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
   1264          		}
   1265          		
   1266          		if(SMK_Msg_Send == 1)
   1267          		{
   1268          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
   1269          			{
   1270          				SMK_Msg_Send = 0;
   1271          				CheckResponseMsgComm();
   1272          			}
   1273          		}
   1274          	}
   1275          }
   1276          #endif
   1277          
   1278          // ++, 141118 sys3215
   1279          void ESL_System(void)
   1280          {
   1281          	if(Seed_request==0)
   1282          	{
   1283          		Seed_request=0xff;
   1284          		Seed_Request_CAN_TX();
   1285          	}
   1286          	if(Seed_received==1)
   1287          	{
   1288          		Seed_received=0xff;
   1289          		SendMultiPacketRTS_ESL();
   1290          	}
   1291          	if(ESL_CTS_received==1)
   1292          	{
   1293          		ESL_CTS_received=0xff;
   1294          		SendMultiPacketData_ESL();
   1295                          Flag_ESL = 0;
   1296          	}
   1297          	if(ESL_ACK_received==1)
   1298          	{
   1299          		Init_Smart_Key_valuable();
   1300          	}
   1301          }
   1302          
   1303          // --, 141118 sys3215
   1304          
   1305          
   1306          
   1307          /**
   1308            * @brief  1msec OperationFunc
   1309            * @param  None
   1310            * @retval None
   1311            */
   1312          void WL9FM_1mSecOperationFunc(void)
   1313          {
   1314          #if 1
   1315          	if( Flag_UartTxStart == 1 )
   1316          	{
   1317          		if (SendTime_E2PROM++ > 3) //	25msec
   1318          		{
   1319          			SendTime_E2PROM = 0;
   1320          			SendTo_E2PROM();
   1321          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
   1322          		}			
   1323          	}
   1324          	// CAN_TX Routine
   1325          	CAN_TX();
   1326          	Write_UART_Single();
   1327          #endif
   1328          }
   1329          
   1330          /**
   1331            * @brief  10msec OperationFunc
   1332            * @param  None
   1333            * @retval None
   1334            */
   1335          
   1336          u8 flag_reset=0;
   1337          
   1338          void WL9FM_10mSecOperationFunc(void)
   1339          {
   1340          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
   1341            if(Old_Camera_Green_Line != Camera_Green_Line) {
   1342                Old_Camera_Green_Line = Camera_Green_Line;
   1343                Old_CAMSig_1 = 0xf;
   1344                CheckCamera_Input(Camera_Mode);	
   1345            }
   1346          	
   1347          }
   1348          
   1349          /**
   1350            * @brief  100msec OperationFunc
   1351            * @param  None
   1352            * @retval None
   1353            */
   1354          void WL9FM_100mSecOperationFunc(void)
   1355          {
   1356          	
   1357          	
   1358          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1359          
   1360          #if 1
   1361          	if(SmartKeyUse == 1)
   1362          		SmartKeyAuthentication();
   1363          #endif
   1364          
   1365          // ++ , 141118 sys3215
   1366          	if(Flag_ESL==1)
   1367          	{
   1368          		ESL_System();
   1369          	}
   1370          // -- , 141118 sys3215
   1371          	
   1372          	if(LCDOffCount < 30)
   1373          	{
   1374          		LCDOffCount++;
   1375          		LCDBL_ONOFF(LCDBL_OFF);
   1376          	}
   1377          	else if(LCDOffCount == 30)
   1378          	{
   1379          		LCDOffCount++;
   1380          		LCDBL_ONOFF(LCDBL_ON);
   1381          	}
   1382          	else
   1383          	{
   1384          		LCDBL_ONOFF(LCDBL_ON);
   1385          	}
   1386          	
   1387          	if(CommErrCnt > 1000)
   1388             	{
   1389             		if( Flag_TxE2pRomData == 1 )
   1390          	   	{
   1391          	   		CAN_COMInit();
   1392             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1393          
   1394          			Buz1 = 0;
   1395                      //RTCSend();
   1396          			if(++SendRTCnt >= 10)
   1397          			{
   1398          				SendRTCnt = 0;
   1399          				
   1400          			}
   1401          	   	}
   1402          	}	
   1403          	if(OSUpdateCount < 200)
   1404          	{
   1405          		OSUpdateCount++;
   1406          	}
   1407          	else if(OSUpdateCount == 200)
   1408          	{
   1409          		OSUpdateCount++;
   1410          		System_CheckPowerIG();
   1411          	}
   1412          	else
   1413          	{
   1414          		System_CheckPowerIG();
   1415          	}
   1416          	
   1417          
   1418          	if(ST_Update)
   1419          	{
   1420          		if(UpdateMode < 10)
   1421          			UpdateMode++;
   1422          
   1423          		if(UpdateMode >= 10)
   1424          		{
   1425          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1426          			ST_Update=0;
   1427          		}
   1428          	}
   1429          		
   1430          	//	WL9A Monitor RESET Code
   1431          	if((SystemReset == 1) || (gRebootCmd == 1))
   1432          	{
   1433          		if(gRebootCmd == 1)
   1434          			//SaveDataToEEPROM();
   1435          				
   1436          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1437          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1438          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1439          		return;
   1440          	}
   1441          
   1442          	if(CameraCommFlag == 1)
   1443          	{
   1444                          // ++, 150715 bwk
   1445          #if 0
   1446          		cam_mode_change(Camera_Mode);
   1447          		CameraCommFlag = 0;
   1448          #else
   1449          		CameraCommFlag = 0;
   1450          		cam_mode_change(Camera_Mode);
   1451                          cam_mode_check();
   1452          #endif
   1453                          // --, 150715 bwk
   1454          
   1455          	}
   1456                  
   1457                  if(AAVMCommFlag == 1)
   1458                  {
   1459                          AAVMCommFlag = 0;
   1460                          aavm_mode_change(AAVM_Mode);
   1461                          aavm_mode_check();
   1462          	}
   1463          
   1464          
   1465          	// ++, 150204 sys3215
   1466          	CAN_TX_Key_Status();
   1467          	// --, 150204 sys3215
   1468          }
   1469          
   1470          void WL9FM_500mSecOperationFunc(void)
   1471          {
   1472          	if(CANUpdateFlag != 1)
   1473          		MonitorStatus_CAN_TX();
   1474          
   1475          }
   1476          
   1477          
   1478          
   1479          /**
   1480            * @brief  1sec OperationFunc
   1481            * @param  None
   1482            * @retval None
   1483            */
   1484          void WL9FM_1SecOperationFunc(void)
   1485          {
   1486          	if(UpdateMode < 10)
   1487          		read_clock();
   1488          
   1489          
   1490          	//  ++, kutelf, 131007
   1491          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1492          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1493          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1494          	{
   1495          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1496          			
   1497          		if ((Camera_CheckCnt % 3) == 0)
   1498          		{
   1499          			cam_mode_check();
   1500          		}
   1501          	}
   1502          	else
   1503          	{
   1504          		Camera_CheckCnt = 0;
   1505          	}
   1506          	//  --, kutelf, 131007
   1507          	if (AAVM_CheckFlag == 1 && AAVM_Mode != 0xFF)
   1508          	{
   1509          		if (++AAVM_CheckCnt == 6) AAVM_CheckCnt = 0;
   1510          
   1511          		if ((AAVM_CheckCnt % 3) == 0)
   1512          		{
   1513          			aavm_mode_check();
   1514          		}
   1515          	}
   1516          	else
   1517          	{
   1518          		AAVM_CheckCnt = 0;
   1519          	}
   1520          }
   1521          //	++, kutelf, 140801
   1522          //	RevD.01.01
   1523          //	RevD 보드와 호환성을 위하여 함수 추가 및 이름 변경
   1524          void CameraMode(u8 Mode, u8 OSD)
   1525          {
   1526          // ++, sys3215, 141211
   1527          #if 0
   1528          	#ifdef BoardVersion_RevD
   1529          		TW8816_CameraMode(Mode, OSD);
   1530          	#else
   1531          		TW2835_CameraMode(Mode, OSD);
   1532          	#endif
   1533          #endif
   1534          
   1535          	if(Hardware_Revision==REVB)
   1536          	{
   1537          		TW2835_CameraMode(Mode, OSD);
   1538          	}
   1539          	else
   1540          	{
   1541          		TW8816_CameraMode(Mode, OSD);
   1542          	}
   1543          // --, sys3215, 141211
   1544          }
   1545          
   1546          void CheckCamera_Input(u8 Mode)
   1547          {
   1548          // ++, sys3215, 141211
   1549          #if 0
   1550          	#ifdef BoardVersion_RevD
   1551          		TW8816_CheckCamera_Input(Mode);
   1552          	#else
   1553          		TW2835_CheckCamera_Input(Mode);
   1554          	#endif
   1555          #endif
   1556          
   1557          	if(Hardware_Revision==REVB)
   1558          	{
   1559          		TW2835_CheckCamera_Input(Mode);
   1560          	}
   1561          	else
   1562          	{
   1563          		TW8816_CheckCamera_Input(Mode);
   1564          	}
   1565          // --, sys3215, 14121
   1566          }
   1567          
   1568          void AAVMMode(u8 Mode, u8 OSD)
   1569          {
   1570          // ++, sys3215, 141211
   1571          #if 0
   1572          	#ifdef BoardVersion_RevD
   1573          		TW8816_AAVMMode(Mode, OSD);
   1574          	#else
   1575          		TW2835_CameraMode(Mode, OSD);
   1576          	#endif
   1577          #endif
   1578          
   1579          	if(Hardware_Revision==REVB)
   1580          	{
   1581          		TW2835_CameraMode(Mode, OSD);
   1582          	}
   1583          	else
   1584          	{
   1585          		TW8816_AAVMMode(Mode, OSD);
   1586          	}
   1587          // --, sys3215, 141211
   1588          }
   1589          
   1590          void CheckAAVM_Input(u8 Mode)
   1591          {
   1592          // ++, sys3215, 141211
   1593          #if 0
   1594          	#ifdef BoardVersion_RevD
   1595          		TW8816_CheckAAVM_Input(Mode);
   1596          	#else
   1597          		TW2835_CheckCamera_Input(Mode);
   1598          	#endif
   1599          #endif
   1600          
   1601          	if(Hardware_Revision==REVB)
   1602          	{
   1603          		TW2835_CheckCamera_Input(Mode);
   1604          	}
   1605          	else
   1606          	{
   1607          		TW8816_CheckAAVM_Input(Mode);
   1608          	}
   1609          // --, sys3215, 14121
   1610          }
   1611          //	--, kutelf, 140801
   1612          
   1613          
   1614          void WL9FM_System_Init_Start(void)
   1615          {
   1616          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1617          	if (SystemReset != 1)
   1618          	{
   1619          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1620          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1621          	}				
   1622          
   1623          //	++, kutelf, 140801
   1624          //	RevD.01.01
   1625          //	Power, PMIC On/Off 방법 변경 
   1626          #if 0
   1627          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1628          	WL9FM_EXYNOS_PMIC_nRESET();
   1629          	WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
   1630          
   1631          #else
   1632          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1633          	WL9FM_EXYNOS_PMIC_PWRON();
   1634          #endif
   1635          //	--, kutelf, 140801
   1636          
   1637          	//++,  sys3215 ,141211
   1638          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1639          	Camera_IO_Init();
   1640          
   1641          	WL9FM_CAMERA_nRESET();	
   1642          	WL9F_CAMERA_Init();
   1643          #if 0	
   1644          //	++, kutelf, 140801
   1645          //	RevD.01.01 
   1646          //	Camera Input, LCD Controller 변경
   1647          //		=> TW2835 + TW8832 -> TW8816
   1648          //	DPRAM 삭제 - FSMC 사용 안함.
   1649          #ifdef BoardVersion_RevD
   1650          	WL9FM_CAMERA_nRESET();						//	-> 	TW8816 Power On..
   1651          	TW8816_Control_Init();
   1652          #else
   1653          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1654          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1655          	TW2835_Control_Init();	
   1656          	//DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1657          #endif
   1658          //	--, kutelf, 140801	
   1659          #endif 
   1660          	//--, sys3215, 141211
   1661          	
   1662          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1663          	// ++, 160511 bwk
   1664          	#if 0
   1665          	FM3164_Watchdog_Init(0x00);
   1666          	#else
   1667          	if(Hardware_Revision < REVH)			// ++, --, 160511 bwk
   1668          		FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1669          	else
   1670          		EXT_WATCHDOG_ENALBE(0);
   1671          	#endif
   1672          	// --, 160511 bwk
   1673          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1674          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1675          												//		LAMP ALL ON
   1676          	LED_POWER_ONOFF(LED_OFF);					//	->	LCD_Control.c (LED On/Off)
   1677          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1678          
   1679          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1680          
   1681          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1682          
   1683          	//USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1684          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);   //      COM2 : CAN
   1685          	USART_COMInit(COMPORT4);       					//      COM4 : CMDData
   1686          
   1687          												
   1688          	CAN_COMInit();								//	-> 	CAN_Control.c
   1689          	//InitE2PROM();
   1690          	//ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1691          	// ++, 160511 bwk
   1692          	#if 0
   1693          	SmartKeyUse = LoadSMKUseToEEPROM();
   1694          	#else
   1695          	if(Hardware_Revision >= REVH)
   1696          		SaveSmartKeyUse = SmartKeyUse = LoadSMKUseToFlash();		// ++, --, 161021 bwk SaveSmartKeyUse 추가 
   1697          	else
   1698          		SaveSmartKeyUse = SmartKeyUse = LoadSMKUseToEEPROM();	// ++, --, 161021 bwk SaveSmartKeyUse 추가 
   1699          	#endif
   1700          	// --, 160511 bwk
   1701          	M25P32_Init();
   1702          
   1703          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1704          	//Old_LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1705          
   1706          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1707          
   1708          	SetFontOSDWindow();
   1709          }
   1710          
   1711          /**
   1712            * @brief  Application Program Start Point.
   1713            * @param  None
   1714            * @retval None
   1715            */
   1716          void WL9FM_Monitor_APP(void)
   1717          {
   1718          	DebugUART_Init();			//	->	Main.c
   1719          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1720          
   1721          //	++, kutelf, 140925
   1722          //	KeyIG Off에서 무한 RESET 되는 현상 수정 => SYSTEM_RESET 위치 변경
   1723          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1724          SYSTEM_RESET :
   1725          //	--, kutelf, 140925
   1726          	System_Configuration();		//  ->  System_Init.c
   1727          	                    		//      RCC, NVIC, GPIO Initialize
   1728          
   1729          	System_Initialize();		//	-> 	System_Init.c
   1730          
   1731          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1732          	System_Variable_Init();
   1733          	WL9FM_System_Init_Start();
   1734          
   1735          	//RCC_ClearFlag();
   1736          	
   1737          	/* Infinite loop */
   1738          	while (1)
   1739          	{  
   1740          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1741          		{
   1742          			WL9FM_TIME.Flag_1mSec = 0;
   1743          
   1744          			//  WL9F_1mSecOperationState -> Func 실행..
   1745          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1746          			WL9FM_1mSecOperationFunc();
   1747          		}            
   1748          		
   1749          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1750          		{
   1751          			WL9FM_TIME.Flag_10mSec = 0;
   1752          
   1753          			//  WL9F_10mSecOperationState -> Func 실행..
   1754          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1755          			WL9FM_10mSecOperationFunc();
   1756          		}
   1757          		
   1758          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1759          		{
   1760          			WL9FM_TIME.Flag_100mSec = 0;
   1761          
   1762          			//  WL9F_100mSecOperationState -> Func 실행..
   1763          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1764          			WL9FM_100mSecOperationFunc();
   1765          
   1766          			#if 1
   1767          			//	WL9F Monitor RESET Code
   1768          			if((SystemReset == 1) || (gRebootCmd == 1))
   1769          			{
   1770          				//	++, kutelf, 150810
   1771          				#if 1
   1772          				if (gRebootCmd)	
   1773          				{	
   1774          					Software_Reset_BootLoader();
   1775          				}	
   1776          				else
   1777          				{
   1778          					goto SYSTEM_RESET;
   1779          				}	
   1780          
   1781          				#else
   1782          				if(gRebootCmd)	JumpIAP();
   1783          				else
   1784          					goto SYSTEM_RESET;
   1785          				#endif
   1786          				//	--, kutelf, 150810
   1787          			}
   1788          			#endif
   1789          		}
   1790          
   1791          		if(WL9FM_TIME.Flag_500mSec == 1)
   1792          		{
   1793          			WL9FM_TIME.Flag_500mSec = 0;
   1794          			WL9FM_500mSecOperationFunc();
   1795          		}
   1796          		
   1797          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1798          		{
   1799          			WL9FM_TIME.Flag_1Sec = 0;
   1800          
   1801          			//  WL9F_1SecOperationState -> Func 실행..
   1802          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1803          			WL9FM_1SecOperationFunc();
   1804                                  
   1805          		}
   1806          	}
   1807          }
   1808          
   1809          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
   1810          
   1811          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AAVMMode
         0   -> TW2835_CameraMode
         0   -> TW8816_AAVMMode
       0   CameraMode
         0   -> TW2835_CameraMode
         0   -> TW8816_CameraMode
       0   CheckAAVM_Input
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckAAVM_Input
       0   CheckCamera_Input
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckCamera_Input
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SendSMKMsgResult
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   ESL_System
         8   -> Init_Smart_Key_valuable
         8   -> Seed_Request_CAN_TX
         8   -> SendMultiPacketData_ESL
         8   -> SendMultiPacketRTS_ESL
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       8   Init_Smart_Key_valuable
         8   -> rand
       8   JumpIAP
         8   -> IWDG_Enable
         8   -> IWDG_ReloadCounter
         8   -> IWDG_SetPrescaler
         8   -> IWDG_SetReload
         8   -> IWDG_WriteAccessCmd
       0   LoadSMKUseToEEPROM
         0   -> EEPROM_Read
       0   LoadSMKUseToFlash
       0   LoadTestToEEPROM
         0   -> EEPROM_Read
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      16   RequestSMKComm
        16   -> GetRandValue
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SaveSMKUseToEEPROM
         0   -> EEPROM_Write
      16   SaveSMKUseToFlash
        16   -> FLASH_If_Init
        16   -> FLASH_If_SMK_Erase
         0   -> FLASH_Lock
        16   -> FLASH_ProgramByte
       0   SaveTestToEEPROM
         0   -> EEPROM_Write
       8   SendSMKAuthResult
         8   -> SMK_SendToExynos
       8   SendSMKCountResult
         8   -> SMK_SendToExynos
       8   SendSMKMsgResult
         8   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      24   SmartKeyAuthentication
        24   -> CheckResponseAuthentication
        24   -> CheckResponseMsgComm
        24   -> RequestFirstAuthentication
        24   -> RequestSMKElimination
        24   -> RequestSMKRegistration
        24   -> RequestSecondAuthentication
        24   -> SMK_SendToExynos
        24   -> Write_CAN_Single
       0   Software_Reset_Application
         0   -- Indirect call
       0   Software_Reset_BootLoader
         0   -- Indirect call
       8   Srand
         8   -> READ_RTC
         0   -> srand
      24   System_CheckPowerIG
        24   -> Buzzer_Off
        24   -> Buzzer_UnLimitOff
        24   -> CAN_ITConfig
        24   -> FLASH_If_Init
        24   -> FLASH_If_SMK_Erase
        24   -> FLASH_Lock
        24   -> FLASH_ProgramByte
        24   -> KeySwitch_SendToEXYNOS
        24   -> LCDBL_ONOFF
        24   -> LCDBL_PWM_LEVEL
        24   -> LCD_POWER_ONOFF
        24   -> Lamp_Update_System
        24   -> Software_Reset_Application
        24   -> Software_Reset_BootLoader
        24   -> TimeDelay_msec
        24   -> USART_ITConfig
        24   -> WL9FM_EXYNOS_PMIC_PWROFF
        24   -> WL9FM_EXYNOS_POWER_ONOFF
        24   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
        24   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         0   -> CAN_TX_Key_Status
         8   -> ESL_System
         8   -> LCDBL_ONOFF
         8   -> Lamp_Update_System
         8   -> STM32_Update
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
         8   -> aavm_mode_change
         8   -> aavm_mode_check
         8   -> cam_mode_change
         8   -> cam_mode_check
       0   WL9FM_10mSecOperationFunc
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckCamera_Input
       8   WL9FM_1SecOperationFunc
         0   -> aavm_mode_check
         8   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      32   WL9FM_Monitor_APP
        32   -- Indirect call
        32   -> CAN_TX
        32   -> DebugUART_Init
        32   -> KeySwitch_SendToEXYNOS
        32   -> MonitorStatus_CAN_TX
        32   -> SendTo_E2PROM
        32   -> System_Configuration
        32   -> System_Initialize
        32   -> System_Variable_Init
        32   -> TW2835_CheckCamera_Input
        32   -> TW8816_CheckCamera_Input
        32   -> WL9FM_100mSecOperationFunc
        32   -> WL9FM_1SecOperationFunc
        32   -> WL9FM_System_Init_Start
        32   -> Write_UART_Single
      16   WL9FM_System_Init_Start
        16   -> Buzzer_Init
        16   -> CAN_COMInit
        16   -> CAN_ITConfig
        16   -> Camera_IO_Init
        16   -> EEPROM_Read
        16   -> FM3164_Watchdog_Init
        16   -> GPIO_WriteBit
        16   -> Hardware_Version_Init
        16   -> KeySwitch_Init
        16   -> LAMP_Control_Init
        16   -> LCDBL_ONOFF
        16   -> LCD_Control_Init
        16   -> LCD_POWER_ONOFF
        16   -> LED_POWER_ONOFF
        16   -> M25P32_Init
         0   -> SetFontOSDWindow
        16   -> USART_COMInit
        16   -> USART_COMInit_DMA
        16   -> WL9FM_CAMERA_nRESET
        16   -> WL9FM_EXYNOS_PMIC_PWRON
        16   -> WL9FM_EXYNOS_POWER_ONOFF
        16   -> WL9FM_PowerIG
        16   -> WL9F_CAMERA_Init
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_17
       4  ??DataTable37_18
       4  ??DataTable37_19
       4  ??DataTable37_2
       4  ??DataTable37_20
       4  ??DataTable37_21
       4  ??DataTable37_22
       4  ??DataTable37_23
       4  ??DataTable37_24
       4  ??DataTable37_25
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
      34  ??Subroutine5_0
      10  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
      40  ?Subroutine4
       1  AAVMEquipFlag
      16  AAVMMode
       8  ACK_Multi_61184
       1  CTSFlag_61184
      16  CameraMode
      16  CheckAAVM_Input
      16  CheckCamera_Input
      90  CheckResponseAuthentication
     170  CheckResponseMsgComm
      20  CheckResponseVMC
      66  ESL_System
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
      24  Flag_UartTxStart
          SendTime_E2PROM
          WL9FM_TIME
      38  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      50  Init_Smart_Key_valuable
      32  JumpIAP
       8  Jump_To_Application_Cluster_App
          JumpAddress_Cluster_App
       4  KeySwitch_Value
       6  LoadSMKUseToEEPROM
      14  LoadSMKUseToFlash
       6  LoadTestToEEPROM
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       4  Old_LAMP_Update_Data
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     138  RequestFirstAuthentication
      84  RequestSMKComm
      38  RequestSMKElimination
      18  RequestSMKMessage
      42  RequestSMKRegistration
      90  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
       8  SaveSMKUseToEEPROM
      34  SaveSMKUseToFlash
       8  SaveTestToEEPROM
      18  SendSMKAuthResult
      18  SendSMKCountResult
      28  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     400  SmartKeyAuthentication
      16  Software_Reset_Application
      14  Software_Reset_BootLoader
      22  Srand
     316  System_CheckPowerIG
       1  TotalPacketNum
     230  WL9FM_100mSecOperationFunc
      52  WL9FM_10mSecOperationFunc
     138  WL9FM_1SecOperationFunc
      50  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     230  WL9FM_Monitor_APP
       8  WL9FM_RTC
     174  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
       1  flag_reset
      82  read_clock
      68  recv_smartkey
          gAuthentication_Cnt
          gRetryCheck
          Flag_ESL
          Seed_request
          Seed_received
          ESL_CTS_received
          ESL_ACK_received
          Password_Certification_Result
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          LCDOffCount
          SmartKeyUse
          SaveSmartKeyUse
          CameraCommFlag
          AAVMCommFlag
          send_smartkey
          rand_value
          OSUpdateCount
          LAMP_Update_Data
          smk_flag_data
          Jump_To_Application_Cluster_Iap
          JumpAddress_Cluster_Iap
       1  send_bkcu_data
       1  send_mcu_data

 
 2 871 bytes in section .bss
 4 650 bytes in section .text
 
 4 650 bytes of CODE memory
 2 871 bytes of DATA memory

Errors: none
Warnings: 5
