###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      30/Jun/2015  18:08:56 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\WL9F_M #
#                    onitor_APP.lst                                           #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\WL9F_Mo #
#                    nitor_APP.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          // ++ , 141118 sys3215
     80          u8 Flag_ESL;
     81          u8 Seed_request;
     82          u8 Seed_received;
     83          u8 ESL_CTS_received;
     84          u8 ESL_ACK_received;
     85          u8 Password_Certification_Result;
     86          // -- , 141118 sys3215
     87          
     88          u8 AuthResult;
     89          u8 SMKSuccess;
     90          u8 SMK_Msg_Send;
     91          u8 SMK_Tag_Count;
     92          u8 MultiPacketSendOrder = 0;
     93          u8 TotalPacketNum = 0;
     94          u8 DiffMachInfo = 0;
     95          u8 MachInfoSendCnt = 0;
     96          u8 MoniInfoSendCnt = 0;
     97          
     98          u8 RTSFlag_61184 = 0;
     99          u8 CTSFlag_61184 = 0;
    100          u8 RMCU_CTSFlag_61184 = 0;
    101          u8 RecvTotalPacket_61184 = 0;
    102          u8 RMCU_RecvTotalPacket_61184 = 0;
    103          u8 ACK_Multi_61184[8];
    104          u8 RMCU_ACK_Multi_61184[8];
    105          
    106          u8 Flag_UartTxStart = 0;
    107          u8  SendTime_E2PROM = 0;
    108          
    109          u16 Flag_1Sec_MachInfo = 0;
    110          u16 Flag_1Min = 0;
    111          
    112          u8 MachInfoTotalPacketNum = 0;
    113          u8 MoniInfoTotalPacketNum = 0;
    114          u8 Flag_200mSec = 0;
    115          u8 SendRTCnt = 0;
    116          u16 adc_value = 0;
    117          
    118          u8 SerialMsgRTC[16];
    119          u8 eepRomReadData1[32];
    120          u8 MoniInfoData[21];
    121          u8 McuInfoData2[4];
    122          u8 McuInfoData3[4];
    123          u8 McuInfoData4[4];
    124          
    125          u8 SystemReset = 0;
    126          u8 E2PROM_Save = 0;
    127          u8 PwrOffCnt = 0;
    128          u8 gRebootCmd = 0;
    129          
    130          
    131          u8 send_mcu_data=0;
    132          u8 send_bkcu_data=0;
    133          
    134          u8 ST_Update=0;
    135          u8 UpdateMode = 0;
    136          
    137          extern u8 Uart2_RxMsg_Single_252[8];
    138          extern u8 Uart2_RxMsg_Single_253[8];
    139          extern u8 Uart2_RxMsg_Single_239[8];
    140          extern u8 Uart2_RxMsg_Single_239_121[8];
    141          extern u8 Uart2_RxMsg_Single_247[8];
    142          extern u8 Uart2_RxMsg_Save_Data1[8];
    143          extern u8 Uart2_RxMsg_Save_Data2[8];
    144          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    145          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    146          extern u8 McuInfoData1[79];
    147          extern u8 tmpMcuInfoData[78];
    148          extern u8 FatoryInit_Flag;
    149          
    150          extern u8 stop_send_as_phone_data;
    151          extern u8 Flag_TxE2pRomData;
    152          
    153          extern u8 Buz1;
    154          
    155          extern u8 Stm32_Update_CMD;
    156          extern u8 CANUpdateFlag;
    157          
    158          extern u16 pWriteBufPos;
    159          extern u16 pReadBufPos;
    160          
    161          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    162          extern char Illumination_Sig;
    163          
    164          // ++, 141006 fort22
    165          u8 LCDOffCount;
    166          u16 OSUpdateCount;
    167          // --, 141006 fort22
    168          
    169          u8 SmartKeyUse;
    170          
    171          u8 CameraCommFlag;
    172          
    173          // ++, sys3215, 141211
    174          extern u8 Hardware_Revision;
    175          // --, sys3215, 141211
    176          
    177          extern u8 Flag_St_Update;
    178          
    179          /* Private function prototypes -----------------------------------------------*/
    180          /* Private functions ---------------------------------------------------------*/
    181          
    182          void Init_RTC(void)
    183          {
    184          	WL9FM_RTC.Year   = 0;
    185          	WL9FM_RTC.Month  = 1;
    186          	WL9FM_RTC.Date   = 1;
    187          	WL9FM_RTC.Day    = 1;
    188          	WL9FM_RTC.Hour   = 12;
    189          	WL9FM_RTC.Minute = 0;
    190          	WL9FM_RTC.Second = 0;
    191          
    192          	WRITE_RTC(WL9FM_RTC);
    193          }
    194          void InitE2PROM(void)
    195          {
    196          	u8 i;
    197          	u8 tmpBuf1[8];
    198          	u8 tmpBuf2[8];
    199          	u8 tmpBuf3[8];
    200          	u8 tmpBuf4[21];
    201          	
    202          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    203          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    204          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    205          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    206          
    207          	SaveE2PROM1->WorkLoad 				= 0;
    208          	SaveE2PROM1->testWorkLoad 			= 0;
    209          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    210          	SaveE2PROM1->DispType	 			= 0;
    211          	SaveE2PROM1->InfoViewPriority 		= 0;
    212          	SaveE2PROM1->UnitPressure 			= 0;
    213          	SaveE2PROM1->Reserved0 				= 0;
    214          	SaveE2PROM1->Lang 					= 0;
    215          	SaveE2PROM1->ManualBackLight 		= 7;
    216          	SaveE2PROM1->AutoBackLight 			= 0;
    217          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    218          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    219          	SaveE2PROM1->InfoViewCnt 			= 2;
    220          	SaveE2PROM1->HR_Start 				= 0;
    221          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    222          	SaveE2PROM1->ActiveCamNum 			= 1;
    223          	SaveE2PROM1->FirstCam 				= 0;
    224          	SaveE2PROM1->SecondCam 				= 1;
    225          	SaveE2PROM1->ThirdCam 				= 2;
    226          	SaveE2PROM1->Reserved1 				= 0;
    227          
    228          	SaveE2PROM2->LightMode 				= 0;
    229          	SaveE2PROM2->JobTimeView 			= 0;
    230          	SaveE2PROM2->OdoMeterView 			= 0;
    231          	SaveE2PROM2->JobOdoSelect 			= 0;
    232          	SaveE2PROM2->LightLowTime 			= 8;
    233          	SaveE2PROM2->LightUpperTime 		= 16;
    234          	SaveE2PROM2->AutoLightDay 			= 0;
    235          	SaveE2PROM2->AutoLightNight 		= 0;
    236          	SaveE2PROM2->Reserved1 				= 0;
    237          
    238          	SaveE2PROM3->Phone_1  				= 0;
    239          	SaveE2PROM3->Phone_2  				= 8;
    240          	SaveE2PROM3->Phone_3  				= 0;
    241          	SaveE2PROM3->Phone_4  				= 5;
    242          	SaveE2PROM3->Phone_5  				= 5;
    243          	SaveE2PROM3->Phone_6  				= 5;
    244          	SaveE2PROM3->Phone_7  				= 8;
    245          	SaveE2PROM3->Phone_8  				= 2;
    246          	SaveE2PROM3->Phone_9  				= 7;
    247          	SaveE2PROM3->Phone_10 				= 2;
    248          	SaveE2PROM3->Phone_11 				= 0xf;
    249          	SaveE2PROM3->Phone_12 				= 0xf;
    250          
    251          #if 1	// Monitor Change History - temp
    252          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    253          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    254          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    255          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    256          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    257          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    258          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    259          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    260          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    261          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    262          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    263          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    264          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    265          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    266          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    267          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    268          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    269          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    270          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    271          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    272          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    273          #endif
    274          
    275          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    276          
    277          	EEPROM_Write(0, 0);	// tmp
    278          	EEPROM_Write(0, 0);	// tmp
    279          	EEPROM_Write(0, 0);	// tmp
    280          
    281          	for(i = 0 ; i < 8 ; i++)
    282          	{
    283          		EEPROM_Write(i+8, tmpBuf1[i]);
    284          		TimeDelay_msec(5);
    285          		EEPROM_Write(i+16, tmpBuf2[i]);
    286          		TimeDelay_msec(5);
    287          		EEPROM_Write(i+24, tmpBuf3[i]);
    288          		TimeDelay_msec(5);
    289          	}
    290          
    291          	SerialPutString("Initialize : 30 %%\n\r");
    292          	
    293          #if 1	// Monitor Change History - temp
    294          	for(i = 0 ; i < 21 ; i++)
    295          	{
    296          		EEPROM_Write(i+50, tmpBuf4[i]);
    297          		TimeDelay_msec(5);
    298          	}
    299          #endif
    300          
    301          	for(i = 0 ; i < 79 ; i++)
    302          	{
    303          		EEPROM_Write(i+100, 0xff);
    304          		TimeDelay_msec(5);
    305          	}
    306          
    307          	SerialPutString("Initialize : 60 %%\n\r");
    308          
    309          	for(i = 0 ; i < 30 ; i++)
    310          	{
    311          		EEPROM_Write(i+200, 0xff);
    312          		TimeDelay_msec(5);
    313          	}
    314          
    315          	for(i = 0 ; i < 29 ; i++)
    316          	{
    317          		EEPROM_Write(i+230, 0xff);
    318          		TimeDelay_msec(5);
    319          	}
    320          
    321          	SerialPutString("Initialize : 95 %%\n\r");
    322          	Init_RTC();
    323          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    324          }
    325          
    326          void ReadE2PROM_ToSend()
    327          {
    328          #if 1
    329          	u8 i;
    330          
    331          	adc_value = (ADC1->DR & 0x0000FFFF);
    332          
    333          	i = EEPROM_Read(0);	
    334          	i = EEPROM_Read(0);
    335          	i = EEPROM_Read(0);
    336          	i = 0;
    337              
    338          	adc_value = (ADC1->DR & 0x0000FFFF);
    339          
    340          	for(i = 0 ; i < 24 ; i++)
    341          		eepRomReadData1[i] = EEPROM_Read(i+8);
    342          
    343          	for(i = 0 ; i < 8 ; i++)
    344          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    345          
    346          	for(i = 0 ; i < 8 ; i++)
    347          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    348          
    349          	for(i = 0 ; i < 8 ; i++)
    350          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    351          
    352          	for(i = 0 ; i < 21 ; i++)
    353          		MoniInfoData[i] = EEPROM_Read(i+50);
    354          	
    355          	for(i = 0 ; i < 79 ; i++)
    356          		McuInfoData1[i] = EEPROM_Read(i+100);
    357          
    358          	for(i = 0 ; i < 4 ; i++)
    359          		McuInfoData2[i] = EEPROM_Read(i+200);
    360          
    361          	for(i = 0 ; i < 4 ; i++)
    362          		McuInfoData3[i] = EEPROM_Read(i+210);
    363          
    364          	for(i = 0 ; i < 4 ; i++)
    365          		McuInfoData4[i] = EEPROM_Read(i+220);
    366          
    367          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    368          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    369          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    370          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    371          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    372          
    373          
    374          	adc_value = (ADC1->DR & 0x0000FFFF);
    375          	
    376          	eepRomReadData1[12] = (adc_value & 0xff);
    377          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    378          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    379          
    380          #endif
    381          }
    382          
    383          
    384          void Init_Smart_Key_valuable(void)
    385          {
    386          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    387          	AuthResult = 0xff;
    388          	SMK_Msg_Send = 0;
    389          	SMK_Tag_Count = 0;
    390          	SMKSuccess = 0;
    391          
    392          // ++, 141118 sys3215
    393          	Flag_ESL=0;
    394          	Seed_request=0;
    395          	Seed_received=0;
    396          	ESL_CTS_received=0;
    397          	ESL_ACK_received=0;
    398          	Password_Certification_Result=0;
    399          // --, 141118 sys3215
    400          
    401          }
    402          
    403          
    404          void read_clock(void)
    405          {
    406          	uint8_t Temp[Serial_COM4_TxSize];
    407          	
    408          	READ_RTC(&WL9FM_RTC);
    409          
    410          	Temp[0] = 0x02;				
    411          	Temp[1] = RTCRES;				
    412          	Temp[2] = WL9FM_RTC.Year;	
    413          	Temp[3] = WL9FM_RTC.Month;	
    414          	Temp[4] = WL9FM_RTC.Date;	
    415          	Temp[5] = WL9FM_RTC.Day;	
    416          	Temp[6] = WL9FM_RTC.Hour;	
    417          	Temp[7] = WL9FM_RTC.Minute;	
    418          	Temp[8] = WL9FM_RTC.Second;	
    419          	Temp[9] = 0xFF;	
    420          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    421          	USARTx_EXYNOS(COM4, (char *)Temp);	
    422          
    423          }
    424          
    425          void SaveDataToEEPROM(void)
    426          {
    427          	u8 i;
    428          	
    429          	for(i = 0 ; i < 8 ; i++)
    430          	{
    431          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    432          		TimeDelay_msec(1);
    433          	}
    434          
    435          	for(i = 0 ; i < 8 ; i++)
    436          	{
    437          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    438          		TimeDelay_msec(1);
    439          	}
    440          
    441          	for(i = 0 ; i < 8 ; i++)
    442          	{
    443          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    444          		TimeDelay_msec(1);
    445          	}
    446          
    447          	for(i = 0 ; i < 21 ; i++)
    448          	{
    449          		EEPROM_Write(i+50, MoniInfoData[i]);
    450          		TimeDelay_msec(1);
    451          	}
    452          	
    453          	for(i = 0 ; i < 79 ; i++)
    454          	{
    455          		EEPROM_Write(i+100, McuInfoData1[i]);
    456          		TimeDelay_msec(1);
    457          	}
    458          
    459          
    460          	if(DiffMachInfo == 1)
    461          	{
    462          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    463          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    464          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    465          	}
    466          
    467          	for(i = 0 ; i < 4 ; i++)
    468          	{
    469          		EEPROM_Write(i+200, McuInfoData2[i]);
    470          		TimeDelay_msec(1);
    471          	}
    472          
    473          	for(i = 0 ; i < 4 ; i++)
    474          	{
    475          		EEPROM_Write(i+210, McuInfoData3[i]);
    476          		TimeDelay_msec(1);
    477          	}
    478          
    479          	for(i = 0 ; i < 4 ; i++)
    480          	{
    481          		EEPROM_Write(i+220, McuInfoData4[i]);
    482          		TimeDelay_msec(1);
    483          	}
    484          }
    485          void SaveSMKUseToEEPROM(u8 Use)
    486          {
    487          	EEPROM_Write(0,Use);
    488          }
    489          u8 LoadSMKUseToEEPROM(void)
    490          {
    491          	return EEPROM_Read(0);
    492          }
    493          
    494          void SaveTestToEEPROM(u8 Use)
    495          {
    496          	EEPROM_Write(1,Use);
    497          }
    498          
    499          u8 LoadTestToEEPROM(void)
    500          {
    501          	return EEPROM_Read(1);
    502          }
    503          
    504          
    505          void System_CheckPowerIG()
    506          {
    507          	// Check POWER IG
    508          	if(!WL9FM_GetPowerIG())
    509          	{
    510          		WL9FM_PowerIG(PowerIG_ON);
    511          		SystemReset = 0;
    512          	}
    513          	else
    514          	{
    515          		if(E2PROM_Save == 0)
    516          		{
    517          			//SaveDataToEEPROM();
    518          
    519          			PwrOffCnt = 0;
    520          			
    521          			while(1)
    522          			{
    523          				//	100msec 마다 15번 체크 -> 1.5초..
    524          				//	PowerIG Off 상태일 경우
    525          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    526          				//	PowerIG On  상태일 경우 
    527          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    528          				
    529          				if(!WL9FM_GetPowerIG())
    530          				{
    531          					
    532          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    533          					
    534          					
    535          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    536          					SystemReset = 0;
    537          					return;
    538          				}
    539          			
    540          				TimeDelay_msec(100);
    541          
    542          				PwrOffCnt++;
    543          				if(PwrOffCnt >= 15)	
    544          					break;
    545          			}
    546          
    547          			Buzzer_Off();
    548          
    549          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    550          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(100);
    551          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	//TimeDelay_msec(3);
    552          
    553          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    554          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    555          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    556          
    557          
    558          			Buzzer_UnLimitOff();
    559          			
    560          			//	POWER OFF 일 때, LAMP Clear
    561          			LAMP_Update_Data = LAMP_ALL_OFF;
    562          
    563          			//Old_LAMP_Update_Data = LAMP_ALL_OFF;
    564          
    565          			Illumination_Sig = 0;
    566          			Lamp_Update_System();
    567          			
    568          			//	엔딩화면 딜레이 시간
    569          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    570          			TimeDelay_msec(1200);
    571          
    572          			//	LCDBL, LCD, LED Off
    573          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    574          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    575          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    576          			//LED_POWER_ONOFF(LED_OFF);       //  LED Off
    577          
    578          		//	++, kutelf, 140801
    579          		//	RevD.01.01 
    580          		//	Power, PMIC On/Off 방법 변경 
    581          		#if 0
    582          
    583          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_PMIC_OFF);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
    584          			WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
    585          			WL9FM_EXYNOS_PMIC_nRESET();
    586          		#else
    587          			WL9FM_EXYNOS_PMIC_PWROFF();
    588          			
    589          			//	Exynos VDD5V0_4412 Off
    590          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    591          			
    592          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    593          
    594          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    595          			if(!WL9FM_GetPowerIG())
    596          			{
    597          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    598          
    599          				if(Flag_St_Update==1)
    600          				{
    601          					gRebootCmd=1;
    602          					Flag_St_Update=0;
    603          				}
    604          				else
    605          					SystemReset = 1;			//	Software RESET
    606          
    607          				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    608          				CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    609          				return;
    610          			}
    611          
    612          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	    
    613          		#endif
    614          		//	--, kutelf, 140801
    615          		}
    616          	}
    617          }
    618          
    619          
    620          void JumpIAP(void)
    621          {
    622          	//#ifdef USE_WATCH_DOG
    623          	/* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
    624          	dispersion) -------------------------------------------------------------*/
    625          	/* Enable write access to IWDG_PR and IWDG_RLR registers */
    626          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
    627          
    628          	/* IWDG counter clock: 40KHz(LSI) / 32 = 156.25 Hz */
    629          	IWDG_SetPrescaler(IWDG_Prescaler_256);
    630          
    631          	/* Set counter reload value to 150   about 1sec */
    632          	IWDG_SetReload(1);
    633          
    634          	/* Reload IWDG counter */
    635          	IWDG_ReloadCounter();
    636          
    637          	IWDG_Enable();
    638          		
    639          	while(1);
    640          	//#endif		
    641          }
    642          
    643          /*******************************************************************************
    644          *
    645          *	Smart Key Test Function
    646          *
    647          *******************************************************************************/
    648          #if 1
    649          void SendSMKAuthResult(u8 result)
    650          {
    651          	// ++, 150630 bwk
    652          	recv_smartkey.Reserved0 = result;
    653          	// --, 150630 bwk
    654          
    655          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    656          }
    657          
    658          void SendSMKMsgResult(u8 result)
    659          {
    660          	// ++, 150630 bwk
    661          	recv_smartkey.Reserved0 = result;
    662          	// --, 150630 bwk
    663          	
    664          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    665          }
    666          
    667          void SetTagLevel(u8 level)
    668          {
    669          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    670          		send_smartkey.TagLevel = level;
    671          	else
    672          		send_smartkey.TagLevel = 3;
    673          }
    674          
    675          void SetTagCmd(u8 cmd)
    676          {
    677          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    678          		send_smartkey.TagCommand = cmd;
    679          	else
    680          		send_smartkey.TagCommand = 0xf;
    681          }
    682          
    683          void SetVMC(void)
    684          {
    685          	if(rand_value.rand_vmc <= 64255)
    686          		send_smartkey.VMC = rand_value.rand_vmc;
    687          	else
    688          		send_smartkey.VMC = 0xffff;
    689          }
    690          
    691          void SetCPK(void)
    692          {
    693          #if 1
    694          	if(rand_value.rand_cpk <= 0xfaffffff)
    695          		send_smartkey.CPK = rand_value.rand_cpk;
    696          	else
    697          		send_smartkey.CPK = 0xffffffff;
    698          #else
    699          	send_smartkey.CPK = 0x11223344;
    700          #endif
    701          }
    702          
    703          void Srand()
    704          {
    705          	READ_RTC(&WL9FM_RTC);
    706          	srand((u32)WL9FM_RTC.Second);
    707          }
    708          
    709          void GetRandValue(u8 random)
    710          {
    711          	if(random == GET_VMC)	
    712          		rand_value.rand_vmc = (rand() % 64255);
    713          	else if(random == GET_CPK)	
    714          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    715          	else if(random == GET_VMC_CPK)		
    716          	{
    717          		rand_value.rand_vmc = (rand() % 64255);
    718          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    719          	}	
    720          }
    721          
    722          void RequestFirstAuthentication(void)
    723          {
    724          	unsigned int temp;
    725          	
    726          	SetTagLevel(TAG_LEVEL_NORMAL);
    727          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    728          	GetRandValue(GET_VMC_CPK);
    729          	SetVMC();
    730          	SetCPK();
    731          
    732          	setCipherParam(0x8085, 0x8087);
    733          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    734          	
    735          	send_smartkey.CPK = temp;
    736          
    737          	// CPK 암호화 Function 추가 필요
    738          	TimeDelay_msec(10);
    739          
    740          	struct st_CAN_Message1 Send_Message;
    741          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    742          	Send_Message.Priority= 0x18;
    743          	Send_Message.PDU_Format= 0xFF;
    744          	Send_Message.PDU_Specific= 0xE7;
    745          	Send_Message.Source_Address= 0x28;
    746          	Write_CAN_Single(Send_Message);
    747          }
    748          
    749          void RequestSecondAuthentication(void)
    750          {
    751          	unsigned short upper_cpk, lower_cpk;
    752          	unsigned int temp;
    753          
    754          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    755          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    756          	
    757          	SetTagLevel(TAG_LEVEL_NORMAL);
    758          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    759          	GetRandValue(GET_VMC);
    760          	SetVMC();
    761          
    762          	setCipherParam(upper_cpk, lower_cpk);
    763          	//setCipherParam(0x1122, 0x3344);
    764          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    765          
    766          	send_smartkey.CPK = temp;
    767          	
    768          	TimeDelay_msec(10);
    769          
    770          	struct st_CAN_Message1 Send_Message;
    771          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    772          	Send_Message.Priority= 0x18;
    773          	Send_Message.PDU_Format= 0xFF;
    774          	Send_Message.PDU_Specific= 0xE7;
    775          	Send_Message.Source_Address= 0x28;
    776          	Write_CAN_Single(Send_Message);
    777          
    778          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    779          }
    780          
    781          void RequestSMKRegistration(void)
    782          {
    783          	unsigned short upper_cpk, lower_cpk;
    784          	unsigned int temp;
    785          
    786          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    787          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    788          	
    789          	SetTagLevel(TAG_LEVEL_NORMAL);
    790          	SetTagCmd(TAG_CMD_REGISTRATION);
    791          	GetRandValue(GET_VMC);
    792          	SetVMC();
    793          
    794          	setCipherParam(upper_cpk, lower_cpk);
    795          	//setCipherParam(0x1122, 0x3344);
    796          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    797          
    798          	send_smartkey.CPK = temp;
    799          
    800          	struct st_CAN_Message1 Send_Message;
    801          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    802          	Send_Message.Priority= 0x18;
    803          	Send_Message.PDU_Format= 0xFF;
    804          	Send_Message.PDU_Specific= 0xE7;
    805          	Send_Message.Source_Address= 0x28;
    806          	Write_CAN_Single(Send_Message);
    807          
    808          
    809          
    810          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    811          }
    812          
    813          void RequestSMKElimination(void)
    814          {
    815          	unsigned short upper_cpk, lower_cpk;
    816          	unsigned int temp;
    817          
    818          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    819          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    820          	
    821          	SetTagLevel(TAG_LEVEL_NORMAL);
    822          	SetTagCmd(TAG_CMD_ELIMINATION);
    823          	GetRandValue(GET_VMC);
    824          	SetVMC();
    825          
    826          	setCipherParam(upper_cpk, lower_cpk);
    827          	//setCipherParam(0x1122, 0x3344);
    828          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    829          
    830          	send_smartkey.CPK = temp;
    831          
    832          	struct st_CAN_Message1 Send_Message;
    833          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    834          	Send_Message.Priority= 0x18;
    835          	Send_Message.PDU_Format= 0xFF;
    836          	Send_Message.PDU_Specific= 0xE7;
    837          	Send_Message.Source_Address= 0x28;
    838          	Write_CAN_Single(Send_Message);
    839          
    840          
    841          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    842          }
    843          
    844          void RequestSMKMessage(u8 Msg)
    845          {
    846          	if(Msg == 1)
    847          		RequestSMKRegistration();
    848          	else if(Msg == 2)
    849          		RequestSMKElimination();
    850          }
    851          
    852          void RequestSMKComm(void)
    853          {
    854          	SetTagLevel(TAG_LEVEL_NORMAL);
    855          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    856          	GetRandValue(GET_VMC);
    857          	SetVMC();
    858          
    859          	struct st_CAN_Message1 Send_Message;
    860          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    861          	Send_Message.Priority= 0x18;
    862          	Send_Message.PDU_Format= 0xFF;
    863          	Send_Message.PDU_Specific= 0xE7;
    864          	Send_Message.Source_Address= 0x28;
    865          	Write_CAN_Single(Send_Message);
    866          
    867          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    868          }
    869          
    870          u8 CheckResponseVMC(void)
    871          {
    872          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    873          		return RETURN_VMC_OK;
    874          	else
    875          		return RETURN_VMC_NOT_OK;
    876          }
    877          
    878          u8 CheckResponseAuthentication(u8 Auth)
    879          {
    880          	u8 output_buf[8];
    881          	u16 upper_cpk, lower_cpk;
    882          
    883          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    884          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    885          	
    886          	setCipherParam(upper_cpk, lower_cpk);
    887          	//setCipherParam(0x1122, 0x3344);	// 임시
    888          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    889          
    890          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    891          
    892          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    893          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    894          	{
    895          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    896          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    897          		{
    898          			return SMK_RESPONSE_FLAG_SUCCESS;
    899          		}
    900          		else
    901          			return recv_smartkey.Smk_Response_Flag;
    902          	}
    903          	else
    904          		return SMK_RESPONSE_CODE_NOT_MATCH;
    905          }
    906          
    907          void CheckResponseMsgComm(void)
    908          {
    909          	u8 output_buf[8];
    910          	u16 upper_cpk, lower_cpk;
    911          
    912          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    913          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    914          	
    915          	setCipherParam(upper_cpk, lower_cpk);
    916          	//setCipherParam(0x1122, 0x3344);	// 임시
    917          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    918          
    919          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    920          
    921          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    922          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    923          	{
    924          		if(recv_smartkey.Smk_Response_Code == 1)
    925          		{
    926          			switch(recv_smartkey.Smk_Response_Flag)
    927          			{
    928          				
    929          				case 2 :
    930          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    931          					break;
    932          				case 1:
    933          				case 3 :
    934          					SendSMKMsgResult(SMK_MSG_FAIL);
    935          					break;
    936          				case 4 :
    937          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    938          					break;
    939          				default :
    940          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    941          					{
    942          						if(recv_smartkey.Registered_Tag_Count == 1)
    943          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    944          						else if(recv_smartkey.Registered_Tag_Count == 2)
    945          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    946          						else if(recv_smartkey.Registered_Tag_Count == 3)
    947          							SendSMKMsgResult(SMK_MSG_TAG_THIRD_REG_SUCCESS);
    948          						else if(recv_smartkey.Registered_Tag_Count == 4)
    949          							SendSMKMsgResult(SMK_MSG_TAG_FOURTH_REG_SUCCESS);
    950          						else if(recv_smartkey.Registered_Tag_Count == 5)
    951          							SendSMKMsgResult(SMK_MSG_TAG_FIFTH_REG_SUCCESS);
    952          						else
    953          							SendSMKMsgResult(SMK_MSG_FAIL);
    954          					}
    955          					else
    956          					{
    957          						if(SMK_Tag_Count != 0)
    958          							SMK_Tag_Count--;
    959          
    960          						SendSMKMsgResult(SMK_MSG_FAIL);
    961          					}
    962          					break;
    963          			}
    964          		}
    965          		else if(recv_smartkey.Smk_Response_Code == 2)
    966          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    967          		else
    968          			SendSMKMsgResult(SMK_MSG_FAIL);
    969          	}
    970          	else
    971          		SendSMKMsgResult(SMK_MSG_FAIL);
    972          }
    973          
    974          
    975          void SmartKeyAuthentication(void)
    976          {
    977          	u8  Auth = 0;
    978          	u8 returnvalue;
    979          
    980          	if(AuthResult != 1)
    981          	{
    982          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    983          		{
    984          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    985          			{
    986          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    987          				RequestFirstAuthentication();
    988          			}
    989          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    990          			{
    991          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    992          				RequestSecondAuthentication();
    993          			}
    994          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    995          			{
    996          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    997          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    998          
    999          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1000          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
   1001          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1002          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
   1003          					
   1004          				returnvalue = CheckResponseAuthentication(Auth);
   1005          					
   1006          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
   1007          				{
   1008          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1009          					{
   1010          						gAuthentication_Cnt = 0;
   1011          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1012          					}
   1013          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1014          					{
   1015          						gAuthentication_Cnt = 0;
   1016          						AuthResult = 1;
   1017          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
   1018          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
   1019          						SMKSuccess = SMK_SUCCESS;
   1020          						SendSMKAuthResult(SMK_SUCCESS);
   1021          
   1022          						// ++ , 141118 sys3215
   1023          						Flag_ESL=1;
   1024          						// -- , 141118 sys3215
   1025          						
   1026          					}
   1027          				}
   1028          				else
   1029          				{
   1030          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
   1031          					{
   1032          						//AuthResult = 2;
   1033          						AuthResult = 1;
   1034          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
   1035          						SMKSuccess = SMK_FAIL;
   1036          						SendSMKAuthResult(SMK_FAIL);
   1037          						return;
   1038          					}
   1039          
   1040          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1041          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
   1042          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1043          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1044          				}
   1045          			}
   1046          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
   1047          			{
   1048          				//RequestFirstAuthentication();
   1049          			}
   1050          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
   1051          			{
   1052          				//RequestSecondAuthentication();
   1053          			}
   1054          		}
   1055          	}
   1056          	//else if(AuthResult == 1)
   1057          	{
   1058          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
   1059          		{
   1060          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
   1061          			SMK_Msg_Send = 1;
   1062          			smk_flag_data.recv_resp_packet = 0;
   1063          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
   1064          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
   1065          		}
   1066          
   1067          		if(SMK_Msg_Send == 1)
   1068          		{
   1069          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
   1070          			{
   1071          				SMK_Msg_Send = 0;
   1072          				CheckResponseMsgComm();
   1073          			}
   1074          		}
   1075          	}
   1076          }
   1077          #endif
   1078          
   1079          // ++, 141118 sys3215
   1080          void ESL_System(void)
   1081          {
   1082          	if(Seed_request==0)
   1083          	{
   1084          		Seed_request=0xff;
   1085          		Seed_Request_CAN_TX();
   1086          	}
   1087          	if(Seed_received==1)
   1088          	{
   1089          		Seed_received=0xff;
   1090          		SendMultiPacketRTS_ESL();
   1091          	}
   1092          	if(ESL_CTS_received==1)
   1093          	{
   1094          		ESL_CTS_received=0xff;
   1095          		SendMultiPacketData_ESL();
   1096                          Flag_ESL = 0;
   1097          	}
   1098          	if(ESL_ACK_received==1)
   1099          	{
   1100          		Init_Smart_Key_valuable();
   1101          	}
   1102          }
   1103          
   1104          // --, 141118 sys3215
   1105          
   1106          
   1107          
   1108          /**
   1109            * @brief  1msec OperationFunc
   1110            * @param  None
   1111            * @retval None
   1112            */
   1113          void WL9FM_1mSecOperationFunc(void)
   1114          {
   1115          #if 1
   1116          	if( Flag_UartTxStart == 1 )
   1117          	{
   1118          		if (SendTime_E2PROM++ > 3) //	25msec
   1119          		{
   1120          			SendTime_E2PROM = 0;
   1121          			SendTo_E2PROM();
   1122          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
   1123          		}			
   1124          	}
   1125          	// CAN_TX Routine
   1126          	CAN_TX();
   1127          	Write_UART_Single();
   1128          #endif
   1129          }
   1130          
   1131          /**
   1132            * @brief  10msec OperationFunc
   1133            * @param  None
   1134            * @retval None
   1135            */
   1136          
   1137          u8 flag_reset=0;
   1138          
   1139          void WL9FM_10mSecOperationFunc(void)
   1140          {
   1141          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
   1142          	
   1143          }
   1144          
   1145          /**
   1146            * @brief  100msec OperationFunc
   1147            * @param  None
   1148            * @retval None
   1149            */
   1150          void WL9FM_100mSecOperationFunc(void)
   1151          {
   1152          	
   1153          	
   1154          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1155          
   1156          #if 1
   1157          	if(SmartKeyUse == 1)
   1158          		SmartKeyAuthentication();
   1159          #endif
   1160          
   1161          // ++ , 141118 sys3215
   1162          	if(Flag_ESL==1)
   1163          	{
   1164          		ESL_System();
   1165          	}
   1166          // -- , 141118 sys3215
   1167          	
   1168          	if(LCDOffCount < 30)
   1169          	{
   1170          		LCDOffCount++;
   1171          		LCDBL_ONOFF(LCDBL_OFF);
   1172          	}
   1173          	else if(LCDOffCount == 30)
   1174          	{
   1175          		LCDOffCount++;
   1176          		LCDBL_ONOFF(LCDBL_ON);
   1177          	}
   1178          	else
   1179          	{
   1180          		LCDBL_ONOFF(LCDBL_ON);
   1181          	}
   1182          	
   1183          	if(CommErrCnt > 1000)
   1184             	{
   1185             		if( Flag_TxE2pRomData == 1 )
   1186          	   	{
   1187          	   		CAN_COMInit();
   1188             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1189          
   1190          			Buz1 = 0;
   1191                      //RTCSend();
   1192          			if(++SendRTCnt >= 10)
   1193          			{
   1194          				SendRTCnt = 0;
   1195          				
   1196          			}
   1197          	   	}
   1198          	}	
   1199          	if(OSUpdateCount < 200)
   1200          	{
   1201          		OSUpdateCount++;
   1202          	}
   1203          	else if(OSUpdateCount == 200)
   1204          	{
   1205          		OSUpdateCount++;
   1206          		System_CheckPowerIG();
   1207          	}
   1208          	else
   1209          	{
   1210          		System_CheckPowerIG();
   1211          	}
   1212          	
   1213          
   1214          	if(ST_Update)
   1215          	{
   1216          		if(UpdateMode < 10)
   1217          			UpdateMode++;
   1218          
   1219          		if(UpdateMode >= 10)
   1220          		{
   1221          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1222          			ST_Update=0;
   1223          		}
   1224          	}
   1225          		
   1226          	//	WL9A Monitor RESET Code
   1227          	if((SystemReset == 1) || (gRebootCmd == 1))
   1228          	{
   1229          		if(gRebootCmd == 1)
   1230          			//SaveDataToEEPROM();
   1231          				
   1232          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1233          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1234          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1235          		return;
   1236          	}
   1237          
   1238          	if(CameraCommFlag == 1)
   1239          	{
   1240          		cam_mode_change(Camera_Mode);
   1241          		CameraCommFlag = 0;
   1242          	}
   1243          
   1244          	// ++, 150204 sys3215
   1245          	CAN_TX_Key_Status();
   1246          	// --, 150204 sys3215
   1247          }
   1248          
   1249          void WL9FM_500mSecOperationFunc(void)
   1250          {
   1251          	if(CANUpdateFlag != 1)
   1252          		MonitorStatus_CAN_TX();
   1253          
   1254          }
   1255          
   1256          
   1257          
   1258          /**
   1259            * @brief  1sec OperationFunc
   1260            * @param  None
   1261            * @retval None
   1262            */
   1263          void WL9FM_1SecOperationFunc(void)
   1264          {
   1265          	if(UpdateMode < 10)
   1266          		read_clock();
   1267          
   1268          
   1269          	//  ++, kutelf, 131007
   1270          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1271          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1272          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1273          	{
   1274          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1275          			
   1276          		if ((Camera_CheckCnt % 3) == 0)
   1277          		{
   1278          			cam_mode_check();
   1279          		}
   1280          	}
   1281          	else
   1282          	{
   1283          		Camera_CheckCnt = 0;
   1284          	}
   1285          	//  --, kutelf, 131007
   1286          }
   1287          
   1288          //	++, kutelf, 140801
   1289          //	RevD.01.01
   1290          //	RevD 보드와 호환성을 위하여 함수 추가 및 이름 변경
   1291          void CameraMode(u8 Mode, u8 OSD)
   1292          {
   1293          // ++, sys3215, 141211
   1294          #if 0
   1295          	#ifdef BoardVersion_RevD
   1296          		TW8816_CameraMode(Mode, OSD);
   1297          	#else
   1298          		TW2835_CameraMode(Mode, OSD);
   1299          	#endif
   1300          #endif
   1301          
   1302          	if(Hardware_Revision==REVB)
   1303          	{
   1304          		TW2835_CameraMode(Mode, OSD);
   1305          	}
   1306          	else
   1307          	{
   1308          		TW8816_CameraMode(Mode, OSD);
   1309          	}
   1310          // --, sys3215, 141211
   1311          }
   1312          
   1313          void CheckCamera_Input(u8 Mode)
   1314          {
   1315          // ++, sys3215, 141211
   1316          #if 0
   1317          	#ifdef BoardVersion_RevD
   1318          		TW8816_CheckCamera_Input(Mode);
   1319          	#else
   1320          		TW2835_CheckCamera_Input(Mode);
   1321          	#endif
   1322          #endif
   1323          
   1324          	if(Hardware_Revision==REVB)
   1325          	{
   1326          		TW2835_CheckCamera_Input(Mode);
   1327          	}
   1328          	else
   1329          	{
   1330          		TW8816_CheckCamera_Input(Mode);
   1331          	}
   1332          // --, sys3215, 14121
   1333          }
   1334          //	--, kutelf, 140801
   1335          
   1336          void WL9FM_System_Init_Start(void)
   1337          {
   1338          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1339          	if (SystemReset != 1)
   1340          	{
   1341          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1342          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1343          	}				
   1344          
   1345          //	++, kutelf, 140801
   1346          //	RevD.01.01
   1347          //	Power, PMIC On/Off 방법 변경 
   1348          #if 0
   1349          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1350          	WL9FM_EXYNOS_PMIC_nRESET();
   1351          	WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
   1352          
   1353          #else
   1354          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1355          	WL9FM_EXYNOS_PMIC_PWRON();
   1356          #endif
   1357          //	--, kutelf, 140801
   1358          
   1359          	//++,  sys3215 ,141211
   1360          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1361          	Camera_IO_Init();
   1362          
   1363          	WL9FM_CAMERA_nRESET();	
   1364          	WL9F_CAMERA_Init();
   1365          #if 0	
   1366          //	++, kutelf, 140801
   1367          //	RevD.01.01 
   1368          //	Camera Input, LCD Controller 변경
   1369          //		=> TW2835 + TW8832 -> TW8816
   1370          //	DPRAM 삭제 - FSMC 사용 안함.
   1371          #ifdef BoardVersion_RevD
   1372          	WL9FM_CAMERA_nRESET();						//	-> 	TW8816 Power On..
   1373          	TW8816_Control_Init();
   1374          #else
   1375          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1376          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1377          	TW2835_Control_Init();	
   1378          	//DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1379          #endif
   1380          //	--, kutelf, 140801	
   1381          #endif 
   1382          	//--, sys3215, 141211
   1383          	
   1384          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1385          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1386          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1387          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1388          												//		LAMP ALL ON
   1389          	LED_POWER_ONOFF(LED_OFF);					//	->	LCD_Control.c (LED On/Off)
   1390          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1391          
   1392          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1393          
   1394          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1395          
   1396          	//USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1397          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);   //      COM2 : CAN
   1398          	USART_COMInit(COMPORT4);       					//      COM4 : CMDData
   1399          
   1400          												
   1401          	CAN_COMInit();								//	-> 	CAN_Control.c
   1402          	//InitE2PROM();
   1403          	//ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1404          	SmartKeyUse = LoadSMKUseToEEPROM();
   1405          	M25P32_Init();
   1406          
   1407          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1408          	//Old_LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1409          
   1410          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1411          
   1412          	SetFontOSDWindow();
   1413          }
   1414          
   1415          /**
   1416            * @brief  Application Program Start Point.
   1417            * @param  None
   1418            * @retval None
   1419            */
   1420          void WL9FM_Monitor_APP(void)
   1421          {
   1422          	DebugUART_Init();			//	->	Main.c
   1423          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1424          
   1425          //	++, kutelf, 140925
   1426          //	KeyIG Off에서 무한 RESET 되는 현상 수정 => SYSTEM_RESET 위치 변경
   1427          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1428          SYSTEM_RESET :
   1429          //	--, kutelf, 140925
   1430          	System_Configuration();		//  ->  System_Init.c
   1431          	                    		//      RCC, NVIC, GPIO Initialize
   1432          
   1433          	System_Initialize();		//	-> 	System_Init.c
   1434          
   1435          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1436          	System_Variable_Init();
   1437          	WL9FM_System_Init_Start();
   1438          
   1439          	//RCC_ClearFlag();
   1440          	
   1441          	/* Infinite loop */
   1442          	while (1)
   1443          	{  
   1444          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1445          		{
   1446          			WL9FM_TIME.Flag_1mSec = 0;
   1447          
   1448          			//  WL9F_1mSecOperationState -> Func 실행..
   1449          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1450          			WL9FM_1mSecOperationFunc();
   1451          		}            
   1452          		
   1453          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1454          		{
   1455          			WL9FM_TIME.Flag_10mSec = 0;
   1456          
   1457          			//  WL9F_10mSecOperationState -> Func 실행..
   1458          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1459          			WL9FM_10mSecOperationFunc();
   1460          		}
   1461          		
   1462          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1463          		{
   1464          			WL9FM_TIME.Flag_100mSec = 0;
   1465          
   1466          			//  WL9F_100mSecOperationState -> Func 실행..
   1467          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1468          			WL9FM_100mSecOperationFunc();
   1469          
   1470          			#if 1
   1471          			//	WL9F Monitor RESET Code
   1472          			if((SystemReset == 1) || (gRebootCmd == 1))
   1473          			{
   1474          				if(gRebootCmd)		JumpIAP();
   1475          				else
   1476          					goto SYSTEM_RESET;
   1477          			}
   1478          			#endif
   1479          		}
   1480          
   1481          		if(WL9FM_TIME.Flag_500mSec == 1)
   1482          		{
   1483          			WL9FM_TIME.Flag_500mSec = 0;
   1484          			WL9FM_500mSecOperationFunc();
   1485          		}
   1486          		
   1487          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1488          		{
   1489          			WL9FM_TIME.Flag_1Sec = 0;
   1490          
   1491          			//  WL9F_1SecOperationState -> Func 실행..
   1492          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1493          			WL9FM_1SecOperationFunc();
   1494                                  
   1495          		}
   1496          	}
   1497          }
   1498          
   1499          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
   1500          
   1501          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CameraMode
         0   -> TW2835_CameraMode
         0   -> TW8816_CameraMode
       0   CheckCamera_Input
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckCamera_Input
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SendSMKMsgResult
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   ESL_System
         8   -> Init_Smart_Key_valuable
         8   -> Seed_Request_CAN_TX
         8   -> SendMultiPacketData_ESL
         8   -> SendMultiPacketRTS_ESL
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
       8   JumpIAP
         8   -> IWDG_Enable
         8   -> IWDG_ReloadCounter
         8   -> IWDG_SetPrescaler
         8   -> IWDG_SetReload
         8   -> IWDG_WriteAccessCmd
       0   LoadSMKUseToEEPROM
         0   -> EEPROM_Read
       0   LoadTestToEEPROM
         0   -> EEPROM_Read
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      24   RequestSMKComm
        24   -> GetRandValue
        24   -> SetTagLevel
        24   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SaveSMKUseToEEPROM
         0   -> EEPROM_Write
       0   SaveTestToEEPROM
         0   -> EEPROM_Write
       0   SendSMKAuthResult
         0   -> SMK_SendToExynos
       0   SendSMKMsgResult
         0   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
         0   -> SendSMKAuthResult
        16   -> SendSMKAuthResult
       8   Srand
         8   -> READ_RTC
         0   -> srand
      24   System_CheckPowerIG
        24   -> Buzzer_Off
        24   -> Buzzer_UnLimitOff
         0   -> CAN_ITConfig
        24   -> CAN_ITConfig
        24   -> KeySwitch_SendToEXYNOS
        24   -> LCDBL_ONOFF
        24   -> LCDBL_PWM_LEVEL
        24   -> LCD_POWER_ONOFF
        24   -> Lamp_Update_System
        24   -> TimeDelay_msec
        24   -> USART_ITConfig
        24   -> WL9FM_EXYNOS_PMIC_PWROFF
        24   -> WL9FM_EXYNOS_POWER_ONOFF
        24   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
        24   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         0   -> CAN_TX_Key_Status
         8   -> ESL_System
         8   -> LCDBL_ONOFF
         8   -> Lamp_Update_System
         8   -> STM32_Update
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
         8   -> cam_mode_change
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         0   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      32   WL9FM_Monitor_APP
        32   -> CAN_TX
        32   -> DebugUART_Init
        32   -> IWDG_Enable
        32   -> IWDG_ReloadCounter
        32   -> IWDG_SetPrescaler
        32   -> IWDG_SetReload
        32   -> IWDG_WriteAccessCmd
        32   -> KeySwitch_SendToEXYNOS
        32   -> MonitorStatus_CAN_TX
        32   -> SendTo_E2PROM
        32   -> System_Configuration
        32   -> System_Initialize
        32   -> System_Variable_Init
        32   -> WL9FM_100mSecOperationFunc
        32   -> WL9FM_System_Init_Start
        32   -> Write_UART_Single
        32   -> cam_mode_check
        32   -> read_clock
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         8   -> Camera_IO_Init
         8   -> EEPROM_Read
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         0   -> SetFontOSDWindow
         8   -> USART_COMInit
         8   -> USART_COMInit_DMA
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
         8   -> WL9F_CAMERA_Init
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      34  ??Subroutine4_0
       6  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
      40  ?Subroutine3
       8  ACK_Multi_61184
       1  CTSFlag_61184
      16  CameraMode
      16  CheckCamera_Input
      90  CheckResponseAuthentication
     180  CheckResponseMsgComm
      20  CheckResponseVMC
      64  ESL_System
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
     118  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      28  Init_Smart_Key_valuable
      32  JumpIAP
       4  KeySwitch_Value
       6  LoadSMKUseToEEPROM
       6  LoadTestToEEPROM
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       4  Old_LAMP_Update_Data
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     128  RequestFirstAuthentication
      86  RequestSMKComm
      40  RequestSMKElimination
      18  RequestSMKMessage
      42  RequestSMKRegistration
      88  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
       8  SaveSMKUseToEEPROM
       8  SaveTestToEEPROM
      20  SendSMKAuthResult
      24  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     254  SmartKeyAuthentication
      22  Srand
     248  System_CheckPowerIG
       1  TotalPacketNum
     198  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
      78  WL9FM_1SecOperationFunc
      48  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     258  WL9FM_Monitor_APP
       8  WL9FM_RTC
     134  WL9FM_System_Init_Start
      20  WL9FM_TIME
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
       1  flag_reset
      82  read_clock
      60  recv_smartkey
          gAuthentication_Cnt
          Flag_ESL
          Seed_request
          Seed_received
          ESL_CTS_received
          ESL_ACK_received
          Password_Certification_Result
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          LCDOffCount
          SmartKeyUse
          CameraCommFlag
          send_smartkey
          rand_value
          OSUpdateCount
          LAMP_Update_Data
          smk_flag_data
       1  send_bkcu_data
       1  send_mcu_data

 
 2 850 bytes in section .bss
 4 158 bytes in section .text
 
 4 158 bytes of CODE memory
 2 850 bytes of DATA memory

Errors: none
Warnings: 4
