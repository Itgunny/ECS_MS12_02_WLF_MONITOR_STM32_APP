###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      01/Sep/2014  20:45:28 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -      #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -     #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\   #
#                    -o C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\ #
#                     --debug --endian=little --cpu=Cortex-M4 -e              #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Pl #
#                    atform\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP_DM #
#                    A\Project\..\Platform\TaeHa - ECS\INC\" -I               #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    CMSIS\Device\ST\STM32F4xx\Include\ -I                    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    STM32F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I  #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\WL #
#                    9F_Monitor_APP.lst                                       #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\WL9 #
#                    F_Monitor_APP.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          u8 AuthResult;
     80          u8 SMK_Msg_Send;
     81          u8 SMK_Tag_Count;
     82          u8 MultiPacketSendOrder = 0;
     83          u8 TotalPacketNum = 0;
     84          u8 DiffMachInfo = 0;
     85          u8 gStartHCE_DT = 0;
     86          u8 MachInfoSendCnt = 0;
     87          u8 MoniInfoSendCnt = 0;
     88          
     89          u8 RTSFlag_61184 = 0;
     90          u8 CTSFlag_61184 = 0;
     91          u8 RMCU_CTSFlag_61184 = 0;
     92          u8 RecvTotalPacket_61184 = 0;
     93          u8 RMCU_RecvTotalPacket_61184 = 0;
     94          u8 ACK_Multi_61184[8];
     95          u8 RMCU_ACK_Multi_61184[8];
     96          
     97          u8 Flag_UartTxStart = 0;
     98          u8  SendTime_E2PROM = 0;
     99          
    100          u16 Flag_1Sec_MachInfo = 0;
    101          u16 Flag_1Min = 0;
    102          
    103          u8 MachInfoTotalPacketNum = 0;
    104          u8 MoniInfoTotalPacketNum = 0;
    105          u8 Flag_200mSec = 0;
    106          u8 SendRTCnt = 0;
    107          u16 adc_value = 0;
    108          
    109          u8 SerialMsgRTC[16];
    110          u8 eepRomReadData1[32];
    111          u8 MoniInfoData[21];
    112          u8 McuInfoData2[4];
    113          u8 McuInfoData3[4];
    114          u8 McuInfoData4[4];
    115          
    116          u8 SystemReset = 0;
    117          u8 E2PROM_Save = 0;
    118          u8 PwrOffCnt = 0;
    119          u8 gRebootCmd = 0;
    120          
    121          
    122          u8 send_mcu_data=0;
    123          u8 send_bkcu_data=0;
    124          
    125          u8 ST_Update=0;
    126          u8 UpdateMode = 0;
    127          
    128          extern u8 Uart2_RxMsg_Single_252[8];
    129          extern u8 Uart2_RxMsg_Single_253[8];
    130          extern u8 Uart2_RxMsg_Single_239[8];
    131          extern u8 Uart2_RxMsg_Single_239_121[8];
    132          extern u8 Uart2_RxMsg_Single_247[8];
    133          extern u8 Uart2_RxMsg_Save_Data1[8];
    134          extern u8 Uart2_RxMsg_Save_Data2[8];
    135          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    136          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    137          extern u8 McuInfoData1[79];
    138          extern u8 tmpMcuInfoData[78];
    139          extern u8 FatoryInit_Flag;
    140          
    141          extern u8 stop_send_as_phone_data;
    142          extern u8 Flag_TxE2pRomData;
    143          
    144          extern u8 Buz1;
    145          
    146          extern u8 Stm32_Update_CMD;
    147          extern u8 CANUpdateFlag;
    148          
    149          extern u16 pWriteBufPos;
    150          extern u16 pReadBufPos;
    151          
    152          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    153          
    154          /* Private function prototypes -----------------------------------------------*/
    155          /* Private functions ---------------------------------------------------------*/
    156          
    157          void Init_RTC(void)
    158          {
    159          	WL9FM_RTC.Year   = 0;
    160          	WL9FM_RTC.Month  = 1;
    161          	WL9FM_RTC.Date   = 1;
    162          	WL9FM_RTC.Day    = 1;
    163          	WL9FM_RTC.Hour   = 12;
    164          	WL9FM_RTC.Minute = 0;
    165          	WL9FM_RTC.Second = 0;
    166          
    167          	WRITE_RTC(WL9FM_RTC);
    168          }
    169          void InitE2PROM(void)
    170          {
    171          	u8 i;
    172          	u8 tmpBuf1[8];
    173          	u8 tmpBuf2[8];
    174          	u8 tmpBuf3[8];
    175          	u8 tmpBuf4[21];
    176          	
    177          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    178          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    179          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    180          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    181          
    182          	SaveE2PROM1->WorkLoad 				= 0;
    183          	SaveE2PROM1->testWorkLoad 			= 0;
    184          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    185          	SaveE2PROM1->DispType	 			= 0;
    186          	SaveE2PROM1->InfoViewPriority 		= 0;
    187          	SaveE2PROM1->UnitPressure 			= 0;
    188          	SaveE2PROM1->Reserved0 				= 0;
    189          	SaveE2PROM1->Lang 					= 0;
    190          	SaveE2PROM1->ManualBackLight 		= 7;
    191          	SaveE2PROM1->AutoBackLight 			= 0;
    192          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    193          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    194          	SaveE2PROM1->InfoViewCnt 			= 2;
    195          	SaveE2PROM1->HR_Start 				= 0;
    196          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    197          	SaveE2PROM1->ActiveCamNum 			= 1;
    198          	SaveE2PROM1->FirstCam 				= 0;
    199          	SaveE2PROM1->SecondCam 				= 1;
    200          	SaveE2PROM1->ThirdCam 				= 2;
    201          	SaveE2PROM1->Reserved1 				= 0;
    202          
    203          	SaveE2PROM2->LightMode 				= 0;
    204          	SaveE2PROM2->JobTimeView 			= 0;
    205          	SaveE2PROM2->OdoMeterView 			= 0;
    206          	SaveE2PROM2->JobOdoSelect 			= 0;
    207          	SaveE2PROM2->LightLowTime 			= 8;
    208          	SaveE2PROM2->LightUpperTime 		= 16;
    209          	SaveE2PROM2->AutoLightDay 			= 0;
    210          	SaveE2PROM2->AutoLightNight 		= 0;
    211          	SaveE2PROM2->Reserved1 				= 0;
    212          
    213          	SaveE2PROM3->Phone_1  				= 0;
    214          	SaveE2PROM3->Phone_2  				= 8;
    215          	SaveE2PROM3->Phone_3  				= 0;
    216          	SaveE2PROM3->Phone_4  				= 5;
    217          	SaveE2PROM3->Phone_5  				= 5;
    218          	SaveE2PROM3->Phone_6  				= 5;
    219          	SaveE2PROM3->Phone_7  				= 8;
    220          	SaveE2PROM3->Phone_8  				= 2;
    221          	SaveE2PROM3->Phone_9  				= 7;
    222          	SaveE2PROM3->Phone_10 				= 2;
    223          	SaveE2PROM3->Phone_11 				= 0xf;
    224          	SaveE2PROM3->Phone_12 				= 0xf;
    225          
    226          #if 1	// Monitor Change History - temp
    227          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    228          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    229          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    230          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    231          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    232          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    233          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    234          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    235          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    236          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    237          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    238          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    239          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    240          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    241          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    242          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    243          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    244          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    245          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    246          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    247          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    248          #endif
    249          
    250          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    251          
    252          	EEPROM_Write(0, 0);	// tmp
    253          	EEPROM_Write(0, 0);	// tmp
    254          	EEPROM_Write(0, 0);	// tmp
    255          
    256          	for(i = 0 ; i < 8 ; i++)
    257          	{
    258          		EEPROM_Write(i+8, tmpBuf1[i]);
    259          		TimeDelay_msec(5);
    260          		EEPROM_Write(i+16, tmpBuf2[i]);
    261          		TimeDelay_msec(5);
    262          		EEPROM_Write(i+24, tmpBuf3[i]);
    263          		TimeDelay_msec(5);
    264          	}
    265          
    266          	SerialPutString("Initialize : 30 %%\n\r");
    267          	
    268          #if 1	// Monitor Change History - temp
    269          	for(i = 0 ; i < 21 ; i++)
    270          	{
    271          		EEPROM_Write(i+50, tmpBuf4[i]);
    272          		TimeDelay_msec(5);
    273          	}
    274          #endif
    275          
    276          	for(i = 0 ; i < 79 ; i++)
    277          	{
    278          		EEPROM_Write(i+100, 0xff);
    279          		TimeDelay_msec(5);
    280          	}
    281          
    282          	SerialPutString("Initialize : 60 %%\n\r");
    283          
    284          	for(i = 0 ; i < 30 ; i++)
    285          	{
    286          		EEPROM_Write(i+200, 0xff);
    287          		TimeDelay_msec(5);
    288          	}
    289          
    290          	for(i = 0 ; i < 29 ; i++)
    291          	{
    292          		EEPROM_Write(i+230, 0xff);
    293          		TimeDelay_msec(5);
    294          	}
    295          
    296          	SerialPutString("Initialize : 95 %%\n\r");
    297          	Init_RTC();
    298          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    299          }
    300          
    301          void ReadE2PROM_ToSend()
    302          {
    303          #if 1
    304          	u8 i;
    305          
    306          	adc_value = (ADC1->DR & 0x0000FFFF);
    307          
    308          	i = EEPROM_Read(0);	
    309          	i = EEPROM_Read(0);
    310          	i = EEPROM_Read(0);
    311          	i = 0;
    312              
    313          	adc_value = (ADC1->DR & 0x0000FFFF);
    314          
    315          	for(i = 0 ; i < 24 ; i++)
    316          		eepRomReadData1[i] = EEPROM_Read(i+8);
    317          
    318          	for(i = 0 ; i < 8 ; i++)
    319          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    320          
    321          	for(i = 0 ; i < 8 ; i++)
    322          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    323          
    324          	for(i = 0 ; i < 8 ; i++)
    325          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    326          
    327          	for(i = 0 ; i < 21 ; i++)
    328          		MoniInfoData[i] = EEPROM_Read(i+50);
    329          	
    330          	for(i = 0 ; i < 79 ; i++)
    331          		McuInfoData1[i] = EEPROM_Read(i+100);
    332          
    333          	for(i = 0 ; i < 4 ; i++)
    334          		McuInfoData2[i] = EEPROM_Read(i+200);
    335          
    336          	for(i = 0 ; i < 4 ; i++)
    337          		McuInfoData3[i] = EEPROM_Read(i+210);
    338          
    339          	for(i = 0 ; i < 4 ; i++)
    340          		McuInfoData4[i] = EEPROM_Read(i+220);
    341          
    342          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    343          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    344          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    345          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    346          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    347          
    348          
    349          	adc_value = (ADC1->DR & 0x0000FFFF);
    350          	
    351          	eepRomReadData1[12] = (adc_value & 0xff);
    352          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    353          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    354          
    355          #endif
    356          }
    357          
    358          
    359          void Init_Smart_Key_valuable(void)
    360          {
    361          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    362          	AuthResult = 0xff;
    363          	SMK_Msg_Send = 0;
    364          	SMK_Tag_Count = 0;
    365          }
    366          
    367          
    368          void Send_Multipacket_61184_23(void)
    369          {
    370          	if(RTSFlag_61184 == 1)
    371          	{
    372          		TimeDelay_msec(15);
    373          		SendTP_CM_BAM_MultiPacket_61184_23();
    374          		TotalPacketNum += 1;
    375          		RTSFlag_61184 = 0;
    376          	}
    377          	else if(RTSFlag_61184 == 2)
    378          	{
    379          		TimeDelay_msec(15);
    380          		SendMultiPacketData_61184_23(TotalPacketNum);
    381          		TotalPacketNum += 1;
    382          
    383          		if(TotalPacketNum >= 3)
    384          		{
    385          			Flag_SerialRxMsg &= ~(RX_MSG23);
    386          			TotalPacketNum = 0;
    387          		}
    388          	}
    389          }
    390          
    391          void Send_Multipacket_145(void)
    392          {
    393          	if(TotalPacketNum == 0)
    394          	{
    395          		TimeDelay_msec(15);
    396          		SendTP_CM_BAM_MultiPacket_145();
    397          		TotalPacketNum += 1;
    398          	}
    399          	else
    400          	{
    401          		TimeDelay_msec(15);
    402          		SendMultiPacketData_145(TotalPacketNum);
    403          		TotalPacketNum += 1;
    404          
    405          		if(TotalPacketNum > tp_cm_bam_TotPacketNum)
    406          		{
    407          			Flag_SerialRxMsg &= ~(RX_MSG145);
    408          			TotalPacketNum = 0;
    409          		}
    410          	}
    411          }
    412          
    413          
    414          
    415          void read_clock(void)
    416          {
    417          	uint8_t Temp[Serial_COM4_TxSize];
    418          	
    419          	READ_RTC(&WL9FM_RTC);
    420          
    421          	Temp[0] = 0x02;				
    422          	Temp[1] = RTCRES;				
    423          	Temp[2] = WL9FM_RTC.Year;	
    424          	Temp[3] = WL9FM_RTC.Month;	
    425          	Temp[4] = WL9FM_RTC.Date;	
    426          	Temp[5] = WL9FM_RTC.Day;	
    427          	Temp[6] = WL9FM_RTC.Hour;	
    428          	Temp[7] = WL9FM_RTC.Minute;	
    429          	Temp[8] = WL9FM_RTC.Second;	
    430          	Temp[9] = 0xFF;	
    431          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    432          	USARTx_EXYNOS(COM4, (char *)Temp);	
    433          
    434          }
    435          
    436          void SaveDataToEEPROM(void)
    437          {
    438          	u8 i;
    439          	
    440          	for(i = 0 ; i < 8 ; i++)
    441          	{
    442          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    443          		TimeDelay_msec(1);
    444          	}
    445          
    446          	for(i = 0 ; i < 8 ; i++)
    447          	{
    448          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    449          		TimeDelay_msec(1);
    450          	}
    451          
    452          	for(i = 0 ; i < 8 ; i++)
    453          	{
    454          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    455          		TimeDelay_msec(1);
    456          	}
    457          
    458          	for(i = 0 ; i < 21 ; i++)
    459          	{
    460          		EEPROM_Write(i+50, MoniInfoData[i]);
    461          		TimeDelay_msec(1);
    462          	}
    463          	
    464          	for(i = 0 ; i < 79 ; i++)
    465          	{
    466          		EEPROM_Write(i+100, McuInfoData1[i]);
    467          		TimeDelay_msec(1);
    468          	}
    469          
    470          
    471          	if(DiffMachInfo == 1)
    472          	{
    473          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    474          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    475          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    476          	}
    477          
    478          	for(i = 0 ; i < 4 ; i++)
    479          	{
    480          		EEPROM_Write(i+200, McuInfoData2[i]);
    481          		TimeDelay_msec(1);
    482          	}
    483          
    484          	for(i = 0 ; i < 4 ; i++)
    485          	{
    486          		EEPROM_Write(i+210, McuInfoData3[i]);
    487          		TimeDelay_msec(1);
    488          	}
    489          
    490          	for(i = 0 ; i < 4 ; i++)
    491          	{
    492          		EEPROM_Write(i+220, McuInfoData4[i]);
    493          		TimeDelay_msec(1);
    494          	}
    495          }
    496          
    497          
    498          void System_CheckPowerIG()
    499          {
    500          	// Check POWER IG
    501          	if(!WL9FM_GetPowerIG())
    502          	{
    503          		WL9FM_PowerIG(PowerIG_ON);
    504          		SystemReset = 0;
    505          	}
    506          	else
    507          	{
    508          		if(E2PROM_Save == 0)
    509          		{
    510          			SaveDataToEEPROM();
    511          
    512          			PwrOffCnt = 0;
    513          
    514          			while(1)
    515          			{
    516          				//	100msec 마다 15번 체크 -> 1.5초..
    517          				//	PowerIG Off 상태일 경우
    518          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    519          				//	PowerIG On  상태일 경우 
    520          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    521          				if(!WL9FM_GetPowerIG())
    522          				{
    523          					//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    524          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    525          					CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
    526          
    527          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    528          
    529          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    530          					SystemReset = 0;
    531          					return;
    532          				}
    533          			
    534          				TimeDelay_msec(100);
    535          
    536          				PwrOffCnt++;
    537          				if(PwrOffCnt >= 15)	
    538          					break;
    539          			}
    540          
    541          			Buzzer_Off();
    542          
    543          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    544          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    545          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    546          
    547          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    548          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    549          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    550          
    551          			//	POWER OFF 일 때, LAMP Clear
    552          			LAMP_Update_Data = LAMP_ALL_OFF;
    553          			Lamp_Update_System();
    554          			
    555          			//	엔딩화면 딜레이 시간
    556          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    557          			TimeDelay_msec(1200);
    558          
    559          			//	LCDBL, LCD, LED Off
    560          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    561          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    562          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    563          			LED_POWER_ONOFF(LED_OFF);       //  LED Off
    564          
    565          			WL9FM_EXYNOS_PMIC_PWRON();
    566          			
    567          			//	Exynos VDD5V0_4412 Off
    568          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    569          			
    570          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    571          
    572          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    573          			if(!WL9FM_GetPowerIG())
    574          			{
    575          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    576          				SystemReset = 1;			//	Software RESET
    577          				return;
    578          			}
    579          
    580          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	    
    581          		}
    582          	}
    583          }
    584          
    585          /*******************************************************************************
    586          *
    587          *	Smart Key Test Function
    588          *
    589          *******************************************************************************/
    590          #if 1
    591          void SendSMKAuthResult(u8 result)
    592          {
    593          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    594          }
    595          
    596          void SendSMKMsgResult(u8 result)
    597          {
    598          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    599          }
    600          
    601          void SetTagLevel(u8 level)
    602          {
    603          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    604          		send_smartkey.TagLevel = level;
    605          	else
    606          		send_smartkey.TagLevel = 3;
    607          }
    608          
    609          void SetTagCmd(u8 cmd)
    610          {
    611          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    612          		send_smartkey.TagCommand = cmd;
    613          	else
    614          		send_smartkey.TagCommand = 0xf;
    615          }
    616          
    617          void SetVMC(void)
    618          {
    619          	if(rand_value.rand_vmc <= 64255)
    620          		send_smartkey.VMC = rand_value.rand_vmc;
    621          	else
    622          		send_smartkey.VMC = 0xffff;
    623          }
    624          
    625          void SetCPK(void)
    626          {
    627          #if 1
    628          	if(rand_value.rand_cpk <= 0xfaffffff)
    629          		send_smartkey.CPK = rand_value.rand_cpk;
    630          	else
    631          		send_smartkey.CPK = 0xffffffff;
    632          #else
    633          	send_smartkey.CPK = 0x11223344;
    634          #endif
    635          }
    636          
    637          void Srand()
    638          {
    639          	READ_RTC(&WL9FM_RTC);
    640          	srand((u32)WL9FM_RTC.Second);
    641          }
    642          
    643          void GetRandValue(u8 random)
    644          {
    645          	if(random == GET_VMC)	
    646          		rand_value.rand_vmc = (rand() % 64255);
    647          	else if(random == GET_CPK)	
    648          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    649          	else if(random == GET_VMC_CPK)		
    650          	{
    651          		rand_value.rand_vmc = (rand() % 64255);
    652          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    653          	}	
    654          }
    655          
    656          void RequestFirstAuthentication(void)
    657          {
    658          	unsigned int temp;
    659          	
    660          	SetTagLevel(TAG_LEVEL_NORMAL);
    661          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    662          	GetRandValue(GET_VMC_CPK);
    663          	SetVMC();
    664          	SetCPK();
    665          
    666          	setCipherParam(0x8085, 0x8087);
    667          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    668          	
    669          	send_smartkey.CPK = temp;
    670          
    671          	// CPK 암호화 Function 추가 필요
    672          	TimeDelay_msec(10);
    673          	SetCanID(255, 231, 6);
    674          	CAN_TX_Data((u8*)&send_smartkey);
    675          }
    676          
    677          void RequestSecondAuthentication(void)
    678          {
    679          	unsigned short upper_cpk, lower_cpk;
    680          	unsigned int temp;
    681          
    682          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    683          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    684          	
    685          	SetTagLevel(TAG_LEVEL_NORMAL);
    686          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    687          	GetRandValue(GET_VMC);
    688          	SetVMC();
    689          
    690          	setCipherParam(upper_cpk, lower_cpk);
    691          	//setCipherParam(0x1122, 0x3344);
    692          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    693          
    694          	send_smartkey.CPK = temp;
    695          	
    696          	TimeDelay_msec(10);
    697          	SetCanID(255, 231, 6);
    698          	CAN_TX_Data((u8*)&send_smartkey);
    699          
    700          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    701          }
    702          
    703          void RequestSMKRegistration(void)
    704          {
    705          	unsigned short upper_cpk, lower_cpk;
    706          	unsigned int temp;
    707          
    708          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    709          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    710          	
    711          	SetTagLevel(TAG_LEVEL_NORMAL);
    712          	SetTagCmd(TAG_CMD_REGISTRATION);
    713          	GetRandValue(GET_VMC);
    714          	SetVMC();
    715          
    716          	setCipherParam(upper_cpk, lower_cpk);
    717          	//setCipherParam(0x1122, 0x3344);
    718          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    719          
    720          	send_smartkey.CPK = temp;
    721          
    722          	SetCanID(255, 231, 6);
    723          	CAN_TX_Data((u8*)&send_smartkey);
    724          
    725          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    726          }
    727          
    728          void RequestSMKElimination(void)
    729          {
    730          	unsigned short upper_cpk, lower_cpk;
    731          	unsigned int temp;
    732          
    733          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    734          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    735          	
    736          	SetTagLevel(TAG_LEVEL_NORMAL);
    737          	SetTagCmd(TAG_CMD_ELIMINATION);
    738          	GetRandValue(GET_VMC);
    739          	SetVMC();
    740          
    741          	setCipherParam(upper_cpk, lower_cpk);
    742          	//setCipherParam(0x1122, 0x3344);
    743          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    744          
    745          	send_smartkey.CPK = temp;
    746          
    747          	SetCanID(255, 231, 6);
    748          	CAN_TX_Data((u8*)&send_smartkey);
    749          
    750          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    751          }
    752          
    753          void RequestSMKMessage(u8 Msg)
    754          {
    755          	if(Msg == 1)
    756          		RequestSMKRegistration();
    757          	else if(Msg == 2)
    758          		RequestSMKElimination();
    759          }
    760          
    761          void RequestSMKComm(void)
    762          {
    763          	SetTagLevel(TAG_LEVEL_NORMAL);
    764          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    765          	GetRandValue(GET_VMC);
    766          	SetVMC();
    767          
    768          	SetCanID(255, 231, 6);
    769          	CAN_TX_Data((u8*)&send_smartkey);
    770          
    771          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    772          }
    773          
    774          u8 CheckResponseVMC(void)
    775          {
    776          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    777          		return RETURN_VMC_OK;
    778          	else
    779          		return RETURN_VMC_NOT_OK;
    780          }
    781          
    782          u8 CheckResponseAuthentication(u8 Auth)
    783          {
    784          	u8 output_buf[8];
    785          	u16 upper_cpk, lower_cpk;
    786          
    787          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    788          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    789          	
    790          	setCipherParam(upper_cpk, lower_cpk);
    791          	//setCipherParam(0x1122, 0x3344);	// 임시
    792          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    793          
    794          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    795          	
    796          	
    797          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    798          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    799          	{
    800          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    801          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    802          		{
    803          			return SMK_RESPONSE_FLAG_SUCCESS;
    804          		}
    805          		else
    806          			return recv_smartkey.Smk_Response_Flag;
    807          	}
    808          	else
    809          		return SMK_RESPONSE_CODE_NOT_MATCH;
    810          }
    811          
    812          void CheckResponseMsgComm(void)
    813          {
    814          	u8 output_buf[8];
    815          	u16 upper_cpk, lower_cpk;
    816          
    817          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    818          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    819          	
    820          	setCipherParam(upper_cpk, lower_cpk);
    821          	//setCipherParam(0x1122, 0x3344);	// 임시
    822          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    823          
    824          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    825          
    826          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    827          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    828          	{
    829          		if(recv_smartkey.Smk_Response_Code == 1)
    830          		{
    831          			switch(recv_smartkey.Smk_Response_Flag)
    832          			{
    833          				case 2 :
    834          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    835          					break;
    836          				case 3 :
    837          					SendSMKMsgResult(SMK_MSG_FAIL);
    838          					break;
    839          				case 4 :
    840          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    841          					break;
    842          				default :
    843          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    844          					{
    845          						if(recv_smartkey.Registered_Tag_Count == 1)
    846          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    847          						else if(recv_smartkey.Registered_Tag_Count == 2)
    848          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    849          						else
    850          							SendSMKMsgResult(SMK_MSG_FAIL);
    851          					}
    852          					else
    853          					{
    854          						if(SMK_Tag_Count != 0)
    855          							SMK_Tag_Count--;
    856          
    857          						SendSMKMsgResult(SMK_MSG_FAIL);
    858          					}
    859          					break;
    860          			}
    861          			
    862          		}
    863          		else if(recv_smartkey.Smk_Response_Code == 2)
    864          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    865                          else
    866                                  SendSMKMsgResult(SMK_MSG_FAIL);
    867          	}
    868          	else
    869          		SendSMKMsgResult(SMK_MSG_FAIL);
    870          }
    871          
    872          
    873          void SmartKeyAuthentication(void)
    874          {
    875          	u8  Auth = 0;
    876          	u8 returnvalue;
    877          
    878          	if(AuthResult != 1)
    879          	{
    880          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    881          		{
    882          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    883          			{
    884          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    885          				RequestFirstAuthentication();
    886          			}
    887          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    888          			{
    889          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    890          				RequestSecondAuthentication();
    891          			}
    892          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    893          			{
    894          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    895          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    896          
    897          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    898          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    899          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    900          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    901          					
    902          				returnvalue = CheckResponseAuthentication(Auth);
    903          					
    904          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    905          				{
    906          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    907          					{
    908          						gAuthentication_Cnt = 0;
    909          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    910          					}
    911          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    912          					{
    913          						gAuthentication_Cnt = 0;
    914          						AuthResult = 1;
    915          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    916          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    917          						SendSMKAuthResult(SMK_SUCCESS);
    918          					}
    919          				}
    920          				else
    921          				{
    922          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    923          					{
    924          						//AuthResult = 2;
    925          						AuthResult = 1;
    926          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    927          						SendSMKAuthResult(SMK_FAIL);
    928          						return;
    929          					}
    930          
    931          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    932          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    933          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    934          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    935          				}
    936          			}
    937          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
    938          			{
    939          				//RequestFirstAuthentication();
    940          			}
    941          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
    942          			{
    943          				//RequestSecondAuthentication();
    944          			}
    945          		}
    946          	}
    947          	//else if(AuthResult == 1)
    948          	{
    949          		if((Uart2_RxMsg_Smk_Reg_Eli[0] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[0] == 2)) 
    950          		{
    951          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[0]);
    952          			SMK_Msg_Send = 1;
    953          			smk_flag_data.recv_resp_packet = 0;
    954          			Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
    955          			Uart2_RxMsg_Smk_Reg_Eli[0] = 0xff;
    956          		}
    957          
    958          		if(SMK_Msg_Send == 1)
    959          		{
    960          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
    961          			{
    962          				SMK_Msg_Send = 0;
    963          				CheckResponseMsgComm();
    964          			}
    965          		}
    966          	}
    967          }
    968          #endif
    969          /**
    970            * @brief  1msec OperationFunc
    971            * @param  None
    972            * @retval None
    973            */
    974          void WL9FM_1mSecOperationFunc(void)
    975          {
    976          #if 1
    977          	if( Flag_UartTxStart == 1 )
    978          	{
    979          		if (SendTime_E2PROM++ > 3) //	25msec
    980          		{
    981          			SendTime_E2PROM = 0;
    982          			SendTo_E2PROM();
    983          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
    984          		}			
    985          	}
    986          	// CAN_TX Routine
    987          	CAN_TX();
    988          	Write_UART_Single();
    989          #endif
    990          }
    991          
    992          /**
    993            * @brief  10msec OperationFunc
    994            * @param  None
    995            * @retval None
    996            */
    997          void WL9FM_10mSecOperationFunc(void)
    998          {
    999          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
   1000          }
   1001          
   1002          /**
   1003            * @brief  100msec OperationFunc
   1004            * @param  None
   1005            * @retval None
   1006            */
   1007          void WL9FM_100mSecOperationFunc(void)
   1008          {
   1009          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1010          
   1011          #if 1
   1012          	if(Flag_TxE2pRomData == 1)
   1013          		SmartKeyAuthentication();
   1014          #endif
   1015          	
   1016          
   1017          
   1018          	
   1019          	if(CommErrCnt > 1000)
   1020             	{
   1021             		if( Flag_TxE2pRomData == 1 )
   1022          	   	{
   1023          	   		CAN_COMInit();
   1024             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1025          
   1026          			Buz1 = 0;
   1027                      //RTCSend();
   1028          			if(++SendRTCnt >= 10)
   1029          			{
   1030          				SendRTCnt = 0;
   1031          				
   1032          			}
   1033          	   	}
   1034          	}	
   1035          	
   1036          	System_CheckPowerIG();
   1037          
   1038          	if(ST_Update)
   1039          	{
   1040          		if(UpdateMode < 10)
   1041          			UpdateMode++;
   1042          
   1043          		if(UpdateMode >= 10)
   1044          		{
   1045          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1046          			ST_Update=0;
   1047          		}
   1048          	}
   1049          		
   1050          	//	WL9A Monitor RESET Code
   1051          	if((SystemReset == 1) || (gRebootCmd == 1))
   1052          	{
   1053          		if(gRebootCmd == 1)
   1054          			SaveDataToEEPROM();
   1055          				
   1056          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1057          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1058          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1059          		return;
   1060          	}
   1061          
   1062          }
   1063          
   1064          void WL9FM_500mSecOperationFunc(void)
   1065          {
   1066          //	SetCanID(255, 47, 6);
   1067          //	CAN_TX_Data(&Uart2_RxMsg_Single_47[0]);
   1068          
   1069          	if(CANUpdateFlag != 1)
   1070          		MonitorStatus_CAN_TX();
   1071          
   1072          }
   1073          
   1074          
   1075          
   1076          /**
   1077            * @brief  1sec OperationFunc
   1078            * @param  None
   1079            * @retval None
   1080            */
   1081          void WL9FM_1SecOperationFunc(void)
   1082          {
   1083          	if(gStartHCE_DT == 1)
   1084          	{
   1085          		CompareMachBasicInfo();
   1086              
   1087          		if(++Flag_1Min >= 60)
   1088          		{
   1089          			Flag_1Min = 0;
   1090          			RequestMachBasicInfo();
   1091          
   1092          			if((MachInfoSendCnt > 60) && (MoniInfoSendCnt > 60))
   1093          				MultiPacketSendOrder = 0;
   1094          		}
   1095          	}
   1096          	if(UpdateMode < 10)
   1097          		read_clock();
   1098          
   1099          
   1100          	//  ++, kutelf, 131007
   1101          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1102          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1103          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1104          	{
   1105          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1106          			
   1107          		if ((Camera_CheckCnt % 3) == 0)
   1108          		{
   1109          			cam_mode_check();
   1110          		}
   1111          	}
   1112          	else
   1113          	{
   1114          		Camera_CheckCnt = 0;
   1115          	}
   1116          	//  --, kutelf, 131007
   1117          }
   1118          
   1119          
   1120          void WL9FM_System_Init_Start(void)
   1121          {
   1122          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1123          	if (SystemReset != 1)
   1124          	{
   1125          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1126          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1127          	}													
   1128          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1129          	WL9FM_EXYNOS_PMIC_PWRON();
   1130          	
   1131          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1132          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1133          	TW2835_Control_Init();	
   1134          	
   1135          	DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1136          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1137          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1138          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1139          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1140          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1141          												//		LAMP ALL ON
   1142          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1143          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1144          
   1145          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1146          
   1147          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1148          
   1149          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);       				//      COM2 : CAN
   1150          	USART_COMInit(COMPORT4);       				//      COM4 : CMDData
   1151          
   1152          												
   1153          	CAN_COMInit();								//	-> 	CAN_Control.c
   1154          	//InitE2PROM();
   1155          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1156          
   1157          	M25P32_Init();
   1158          
   1159          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1160          }
   1161          
   1162          /**
   1163            * @brief  Application Program Start Point.
   1164            * @param  None
   1165            * @retval None
   1166            */
   1167          void WL9FM_Monitor_APP(void)
   1168          {
   1169          	DebugUART_Init();			//	->	Main.c
   1170          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1171          
   1172          	System_Configuration();		//  ->  System_Init.c
   1173          	                    		//      RCC, NVIC, GPIO Initialize
   1174          
   1175          	System_Initialize();		//	-> 	System_Init.c
   1176          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1177          
   1178          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1179          SYSTEM_RESET :
   1180          	WL9FM_PowerIG(PowerIG_ON);
   1181          	System_Variable_Init();
   1182          	WL9FM_System_Init_Start();
   1183          	
   1184          	/* Infinite loop */
   1185          	while (1)
   1186          	{  
   1187          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1188          		{
   1189          			WL9FM_TIME.Flag_1mSec = 0;
   1190          
   1191          			//  WL9F_1mSecOperationState -> Func 실행..
   1192          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1193          			WL9FM_1mSecOperationFunc();
   1194          		}            
   1195          		
   1196          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1197          		{
   1198          			WL9FM_TIME.Flag_10mSec = 0;
   1199          
   1200          			//  WL9F_10mSecOperationState -> Func 실행..
   1201          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1202          			WL9FM_10mSecOperationFunc();
   1203          		}
   1204          		
   1205          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1206          		{
   1207          			WL9FM_TIME.Flag_100mSec = 0;
   1208          
   1209          			//  WL9F_100mSecOperationState -> Func 실행..
   1210          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1211          			WL9FM_100mSecOperationFunc();
   1212          
   1213          			#if 1
   1214          			//	WL9F Monitor RESET Code
   1215          			if((SystemReset == 1) || (gRebootCmd == 1))
   1216          			{
   1217          				goto SYSTEM_RESET;
   1218          			}
   1219          			#endif
   1220          		}
   1221          
   1222          		if(WL9FM_TIME.Flag_500mSec == 1)
   1223          		{
   1224          			WL9FM_TIME.Flag_500mSec = 0;
   1225          			WL9FM_500mSecOperationFunc();
   1226          		}
   1227          		
   1228          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1229          		{
   1230          			WL9FM_TIME.Flag_1Sec = 0;
   1231          
   1232          			//  WL9F_1SecOperationState -> Func 실행..
   1233          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1234          			WL9FM_1SecOperationFunc();
   1235                                  
   1236          		}
   1237          	}
   1238          }
   1239          
   1240          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SMK_SendToExynos
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      16   RequestFirstAuthentication
        16   -> CAN_TX_Data
        16   -> GetRandValue
        16   -> SetCanID
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> SetVMC
        16   -> TimeDelay_msec
        16   -> encode
        16   -> setCipherParam
       8   RequestSMKComm
         0   -> CAN_TX_Data
         8   -> GetRandValue
         8   -> SetCanID
         8   -> SetTagCmd
         8   -> SetTagLevel
      24   RequestSMKElimination
        24   -> CAN_TX_Data
        24   -> GetRandValue
        24   -> SetCanID
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> encode
        24   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      24   RequestSMKRegistration
        24   -> CAN_TX_Data
        24   -> GetRandValue
        24   -> SetCanID
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> encode
        24   -> setCipherParam
      24   RequestSecondAuthentication
        24   -> CAN_TX_Data
        24   -> GetRandValue
        24   -> SetCanID
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> TimeDelay_msec
        24   -> encode
        24   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SendSMKAuthResult
         0   -> SMK_SendToExynos
       0   SendSMKMsgResult
         0   -> SMK_SendToExynos
       8   Send_Multipacket_145
         8   -> SendMultiPacketData_145
         8   -> SendTP_CM_BAM_MultiPacket_145
         8   -> TimeDelay_msec
       8   Send_Multipacket_61184_23
         8   -> SendMultiPacketData_61184_23
         8   -> SendTP_CM_BAM_MultiPacket_61184_23
         8   -> TimeDelay_msec
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
         0   -> SMK_SendToExynos
        16   -> SMK_SendToExynos
       8   Srand
         8   -> READ_RTC
         0   -> srand
       8   System_CheckPowerIG
         8   -> Buzzer_Off
         8   -> CAN_ITConfig
         8   -> KeySwitch_SendToEXYNOS
         8   -> LCDBL_ONOFF
         8   -> LCDBL_PWM_LEVEL
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> Lamp_Update_System
         8   -> SaveDataToEEPROM
         8   -> TimeDelay_msec
         8   -> USART_ITConfig
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
         8   -> WL9FM_PowerIG
      16   WL9FM_100mSecOperationFunc
        16   -> CAN_COMInit
        16   -> CAN_ITConfig
        16   -> Lamp_Update_System
        16   -> STM32_Update
         0   -> SaveDataToEEPROM
        16   -> SmartKeyAuthentication
        16   -> System_CheckPowerIG
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         8   -> CompareMachBasicInfo
         8   -> RequestMachBasicInfo
         0   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      16   WL9FM_Monitor_APP
        16   -> CAN_TX
        16   -> DebugUART_Init
        16   -> KeySwitch_SendToEXYNOS
        16   -> MonitorStatus_CAN_TX
        16   -> SendTo_E2PROM
        16   -> System_Configuration
        16   -> System_Initialize
        16   -> System_Variable_Init
        16   -> WL9FM_100mSecOperationFunc
        16   -> WL9FM_1SecOperationFunc
        16   -> WL9FM_PowerIG
        16   -> WL9FM_System_Init_Start
        16   -> Write_UART_Single
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         8   -> DPRAM_Init
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> USART_COMInit_DMA
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_20
       4  ??DataTable30_21
       4  ??DataTable30_22
       4  ??DataTable30_23
       4  ??DataTable30_24
       4  ??DataTable30_25
       4  ??DataTable30_26
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      22  ??Subroutine1_0
      28  ?Subroutine0
       8  ACK_Multi_61184
       1  CTSFlag_61184
      88  CheckResponseAuthentication
     180  CheckResponseMsgComm
      20  CheckResponseVMC
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
     118  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      18  Init_Smart_Key_valuable
       4  KeySwitch_Value
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoTotalPacketNum
      44  MultiPacketSendOrder
          gStartHCE_DT
          MachInfoSendCnt
          MoniInfoSendCnt
          Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          WL9FM_TIME
          Flag_1Min
          LAMP_Update_Data
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     100  RequestFirstAuthentication
      60  RequestSMKComm
      40  RequestSMKElimination
      18  RequestSMKMessage
      42  RequestSMKRegistration
      76  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      12  SendSMKAuthResult
      18  SendSMKMsgResult
      74  Send_Multipacket_145
      80  Send_Multipacket_61184_23
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     256  SmartKeyAuthentication
      22  Srand
     242  System_CheckPowerIG
       2  TotalPacketNum
          RTSFlag_61184
     136  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
     122  WL9FM_1SecOperationFunc
      48  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     154  WL9FM_Monitor_APP
       8  WL9FM_RTC
     118  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
      82  read_clock
      32  recv_smartkey
          gAuthentication_Cnt
          AuthResult
          SMK_Msg_Send
          SMK_Tag_Count
          send_smartkey
          rand_value
          smk_flag_data
       1  send_bkcu_data
       1  send_mcu_data

 
 2 836 bytes in section .bss
 3 876 bytes in section .text
 
 3 876 bytes of CODE memory
 2 836 bytes of DATA memory

Errors: none
Warnings: 6
