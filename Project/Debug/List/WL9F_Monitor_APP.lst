###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      21/Nov/2014  10:33:39 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\WL9F_M #
#                    onitor_APP.lst                                           #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\WL9F_Mo #
#                    nitor_APP.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          // ++ , 141118 sys3215
     80          u8 Flag_ESL;
     81          u8 Seed_request;
     82          u8 Seed_received;
     83          u8 ESL_CTS_received;
     84          u8 ESL_ACK_received;
     85          u8 Password_Certification_Result;
     86          // -- , 141118 sys3215
     87          
     88          u8 AuthResult;
     89          u8 SMKSuccess;
     90          u8 SMK_Msg_Send;
     91          u8 SMK_Tag_Count;
     92          u8 MultiPacketSendOrder = 0;
     93          u8 TotalPacketNum = 0;
     94          u8 DiffMachInfo = 0;
     95          u8 MachInfoSendCnt = 0;
     96          u8 MoniInfoSendCnt = 0;
     97          
     98          u8 RTSFlag_61184 = 0;
     99          u8 CTSFlag_61184 = 0;
    100          u8 RMCU_CTSFlag_61184 = 0;
    101          u8 RecvTotalPacket_61184 = 0;
    102          u8 RMCU_RecvTotalPacket_61184 = 0;
    103          u8 ACK_Multi_61184[8];
    104          u8 RMCU_ACK_Multi_61184[8];
    105          
    106          u8 Flag_UartTxStart = 0;
    107          u8  SendTime_E2PROM = 0;
    108          
    109          u16 Flag_1Sec_MachInfo = 0;
    110          u16 Flag_1Min = 0;
    111          
    112          u8 MachInfoTotalPacketNum = 0;
    113          u8 MoniInfoTotalPacketNum = 0;
    114          u8 Flag_200mSec = 0;
    115          u8 SendRTCnt = 0;
    116          u16 adc_value = 0;
    117          
    118          u8 SerialMsgRTC[16];
    119          u8 eepRomReadData1[32];
    120          u8 MoniInfoData[21];
    121          u8 McuInfoData2[4];
    122          u8 McuInfoData3[4];
    123          u8 McuInfoData4[4];
    124          
    125          u8 SystemReset = 0;
    126          u8 E2PROM_Save = 0;
    127          u8 PwrOffCnt = 0;
    128          u8 gRebootCmd = 0;
    129          
    130          
    131          u8 send_mcu_data=0;
    132          u8 send_bkcu_data=0;
    133          
    134          u8 ST_Update=0;
    135          u8 UpdateMode = 0;
    136          
    137          extern u8 Uart2_RxMsg_Single_252[8];
    138          extern u8 Uart2_RxMsg_Single_253[8];
    139          extern u8 Uart2_RxMsg_Single_239[8];
    140          extern u8 Uart2_RxMsg_Single_239_121[8];
    141          extern u8 Uart2_RxMsg_Single_247[8];
    142          extern u8 Uart2_RxMsg_Save_Data1[8];
    143          extern u8 Uart2_RxMsg_Save_Data2[8];
    144          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    145          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    146          extern u8 McuInfoData1[79];
    147          extern u8 tmpMcuInfoData[78];
    148          extern u8 FatoryInit_Flag;
    149          
    150          extern u8 stop_send_as_phone_data;
    151          extern u8 Flag_TxE2pRomData;
    152          
    153          extern u8 Buz1;
    154          
    155          extern u8 Stm32_Update_CMD;
    156          extern u8 CANUpdateFlag;
    157          
    158          extern u16 pWriteBufPos;
    159          extern u16 pReadBufPos;
    160          
    161          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    162          extern char Illumination_Sig;
    163          
    164          // ++, 141006 fort22
    165          u8 LCDOffCount;
    166          u16 OSUpdateCount;
    167          // --, 141006 fort22
    168          
    169          /* Private function prototypes -----------------------------------------------*/
    170          /* Private functions ---------------------------------------------------------*/
    171          
    172          void Init_RTC(void)
    173          {
    174          	WL9FM_RTC.Year   = 0;
    175          	WL9FM_RTC.Month  = 1;
    176          	WL9FM_RTC.Date   = 1;
    177          	WL9FM_RTC.Day    = 1;
    178          	WL9FM_RTC.Hour   = 12;
    179          	WL9FM_RTC.Minute = 0;
    180          	WL9FM_RTC.Second = 0;
    181          
    182          	WRITE_RTC(WL9FM_RTC);
    183          }
    184          void InitE2PROM(void)
    185          {
    186          	u8 i;
    187          	u8 tmpBuf1[8];
    188          	u8 tmpBuf2[8];
    189          	u8 tmpBuf3[8];
    190          	u8 tmpBuf4[21];
    191          	
    192          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    193          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    194          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    195          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    196          
    197          	SaveE2PROM1->WorkLoad 				= 0;
    198          	SaveE2PROM1->testWorkLoad 			= 0;
    199          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    200          	SaveE2PROM1->DispType	 			= 0;
    201          	SaveE2PROM1->InfoViewPriority 		= 0;
    202          	SaveE2PROM1->UnitPressure 			= 0;
    203          	SaveE2PROM1->Reserved0 				= 0;
    204          	SaveE2PROM1->Lang 					= 0;
    205          	SaveE2PROM1->ManualBackLight 		= 7;
    206          	SaveE2PROM1->AutoBackLight 			= 0;
    207          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    208          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    209          	SaveE2PROM1->InfoViewCnt 			= 2;
    210          	SaveE2PROM1->HR_Start 				= 0;
    211          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    212          	SaveE2PROM1->ActiveCamNum 			= 1;
    213          	SaveE2PROM1->FirstCam 				= 0;
    214          	SaveE2PROM1->SecondCam 				= 1;
    215          	SaveE2PROM1->ThirdCam 				= 2;
    216          	SaveE2PROM1->Reserved1 				= 0;
    217          
    218          	SaveE2PROM2->LightMode 				= 0;
    219          	SaveE2PROM2->JobTimeView 			= 0;
    220          	SaveE2PROM2->OdoMeterView 			= 0;
    221          	SaveE2PROM2->JobOdoSelect 			= 0;
    222          	SaveE2PROM2->LightLowTime 			= 8;
    223          	SaveE2PROM2->LightUpperTime 		= 16;
    224          	SaveE2PROM2->AutoLightDay 			= 0;
    225          	SaveE2PROM2->AutoLightNight 		= 0;
    226          	SaveE2PROM2->Reserved1 				= 0;
    227          
    228          	SaveE2PROM3->Phone_1  				= 0;
    229          	SaveE2PROM3->Phone_2  				= 8;
    230          	SaveE2PROM3->Phone_3  				= 0;
    231          	SaveE2PROM3->Phone_4  				= 5;
    232          	SaveE2PROM3->Phone_5  				= 5;
    233          	SaveE2PROM3->Phone_6  				= 5;
    234          	SaveE2PROM3->Phone_7  				= 8;
    235          	SaveE2PROM3->Phone_8  				= 2;
    236          	SaveE2PROM3->Phone_9  				= 7;
    237          	SaveE2PROM3->Phone_10 				= 2;
    238          	SaveE2PROM3->Phone_11 				= 0xf;
    239          	SaveE2PROM3->Phone_12 				= 0xf;
    240          
    241          #if 1	// Monitor Change History - temp
    242          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    243          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    244          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    245          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    246          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    247          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    248          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    249          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    250          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    251          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    252          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    253          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    254          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    255          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    256          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    257          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    258          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    259          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    260          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    261          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    262          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    263          #endif
    264          
    265          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    266          
    267          	EEPROM_Write(0, 0);	// tmp
    268          	EEPROM_Write(0, 0);	// tmp
    269          	EEPROM_Write(0, 0);	// tmp
    270          
    271          	for(i = 0 ; i < 8 ; i++)
    272          	{
    273          		EEPROM_Write(i+8, tmpBuf1[i]);
    274          		TimeDelay_msec(5);
    275          		EEPROM_Write(i+16, tmpBuf2[i]);
    276          		TimeDelay_msec(5);
    277          		EEPROM_Write(i+24, tmpBuf3[i]);
    278          		TimeDelay_msec(5);
    279          	}
    280          
    281          	SerialPutString("Initialize : 30 %%\n\r");
    282          	
    283          #if 1	// Monitor Change History - temp
    284          	for(i = 0 ; i < 21 ; i++)
    285          	{
    286          		EEPROM_Write(i+50, tmpBuf4[i]);
    287          		TimeDelay_msec(5);
    288          	}
    289          #endif
    290          
    291          	for(i = 0 ; i < 79 ; i++)
    292          	{
    293          		EEPROM_Write(i+100, 0xff);
    294          		TimeDelay_msec(5);
    295          	}
    296          
    297          	SerialPutString("Initialize : 60 %%\n\r");
    298          
    299          	for(i = 0 ; i < 30 ; i++)
    300          	{
    301          		EEPROM_Write(i+200, 0xff);
    302          		TimeDelay_msec(5);
    303          	}
    304          
    305          	for(i = 0 ; i < 29 ; i++)
    306          	{
    307          		EEPROM_Write(i+230, 0xff);
    308          		TimeDelay_msec(5);
    309          	}
    310          
    311          	SerialPutString("Initialize : 95 %%\n\r");
    312          	Init_RTC();
    313          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    314          }
    315          
    316          void ReadE2PROM_ToSend()
    317          {
    318          #if 1
    319          	u8 i;
    320          
    321          	adc_value = (ADC1->DR & 0x0000FFFF);
    322          
    323          	i = EEPROM_Read(0);	
    324          	i = EEPROM_Read(0);
    325          	i = EEPROM_Read(0);
    326          	i = 0;
    327              
    328          	adc_value = (ADC1->DR & 0x0000FFFF);
    329          
    330          	for(i = 0 ; i < 24 ; i++)
    331          		eepRomReadData1[i] = EEPROM_Read(i+8);
    332          
    333          	for(i = 0 ; i < 8 ; i++)
    334          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    335          
    336          	for(i = 0 ; i < 8 ; i++)
    337          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    338          
    339          	for(i = 0 ; i < 8 ; i++)
    340          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    341          
    342          	for(i = 0 ; i < 21 ; i++)
    343          		MoniInfoData[i] = EEPROM_Read(i+50);
    344          	
    345          	for(i = 0 ; i < 79 ; i++)
    346          		McuInfoData1[i] = EEPROM_Read(i+100);
    347          
    348          	for(i = 0 ; i < 4 ; i++)
    349          		McuInfoData2[i] = EEPROM_Read(i+200);
    350          
    351          	for(i = 0 ; i < 4 ; i++)
    352          		McuInfoData3[i] = EEPROM_Read(i+210);
    353          
    354          	for(i = 0 ; i < 4 ; i++)
    355          		McuInfoData4[i] = EEPROM_Read(i+220);
    356          
    357          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    358          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    359          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    360          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    361          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    362          
    363          
    364          	adc_value = (ADC1->DR & 0x0000FFFF);
    365          	
    366          	eepRomReadData1[12] = (adc_value & 0xff);
    367          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    368          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    369          
    370          #endif
    371          }
    372          
    373          
    374          void Init_Smart_Key_valuable(void)
    375          {
    376          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    377          	AuthResult = 0xff;
    378          	SMK_Msg_Send = 0;
    379          	SMK_Tag_Count = 0;
    380          	SMKSuccess = 0;
    381          
    382          // ++, 141118 sys3215
    383          	Flag_ESL=0;
    384          	Seed_request=0;
    385          	Seed_received=0;
    386          	ESL_CTS_received=0;
    387          	ESL_ACK_received=0;
    388          	Password_Certification_Result=0;
    389          // --, 141118 sys3215
    390          
    391          }
    392          
    393          
    394          void read_clock(void)
    395          {
    396          	uint8_t Temp[Serial_COM4_TxSize];
    397          	
    398          	READ_RTC(&WL9FM_RTC);
    399          
    400          	Temp[0] = 0x02;				
    401          	Temp[1] = RTCRES;				
    402          	Temp[2] = WL9FM_RTC.Year;	
    403          	Temp[3] = WL9FM_RTC.Month;	
    404          	Temp[4] = WL9FM_RTC.Date;	
    405          	Temp[5] = WL9FM_RTC.Day;	
    406          	Temp[6] = WL9FM_RTC.Hour;	
    407          	Temp[7] = WL9FM_RTC.Minute;	
    408          	Temp[8] = WL9FM_RTC.Second;	
    409          	Temp[9] = 0xFF;	
    410          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    411          	USARTx_EXYNOS(COM4, (char *)Temp);	
    412          
    413          }
    414          
    415          void SaveDataToEEPROM(void)
    416          {
    417          	u8 i;
    418          	
    419          	for(i = 0 ; i < 8 ; i++)
    420          	{
    421          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    422          		TimeDelay_msec(1);
    423          	}
    424          
    425          	for(i = 0 ; i < 8 ; i++)
    426          	{
    427          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    428          		TimeDelay_msec(1);
    429          	}
    430          
    431          	for(i = 0 ; i < 8 ; i++)
    432          	{
    433          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    434          		TimeDelay_msec(1);
    435          	}
    436          
    437          	for(i = 0 ; i < 21 ; i++)
    438          	{
    439          		EEPROM_Write(i+50, MoniInfoData[i]);
    440          		TimeDelay_msec(1);
    441          	}
    442          	
    443          	for(i = 0 ; i < 79 ; i++)
    444          	{
    445          		EEPROM_Write(i+100, McuInfoData1[i]);
    446          		TimeDelay_msec(1);
    447          	}
    448          
    449          
    450          	if(DiffMachInfo == 1)
    451          	{
    452          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    453          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    454          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    455          	}
    456          
    457          	for(i = 0 ; i < 4 ; i++)
    458          	{
    459          		EEPROM_Write(i+200, McuInfoData2[i]);
    460          		TimeDelay_msec(1);
    461          	}
    462          
    463          	for(i = 0 ; i < 4 ; i++)
    464          	{
    465          		EEPROM_Write(i+210, McuInfoData3[i]);
    466          		TimeDelay_msec(1);
    467          	}
    468          
    469          	for(i = 0 ; i < 4 ; i++)
    470          	{
    471          		EEPROM_Write(i+220, McuInfoData4[i]);
    472          		TimeDelay_msec(1);
    473          	}
    474          }
    475          
    476          
    477          void System_CheckPowerIG()
    478          {
    479          	// Check POWER IG
    480          	if(!WL9FM_GetPowerIG())
    481          	{
    482          		WL9FM_PowerIG(PowerIG_ON);
    483          		SystemReset = 0;
    484          	}
    485          	else
    486          	{
    487          		if(E2PROM_Save == 0)
    488          		{
    489          			SaveDataToEEPROM();
    490          
    491          			PwrOffCnt = 0;
    492          			
    493          			while(1)
    494          			{
    495          				//	100msec 마다 15번 체크 -> 1.5초..
    496          				//	PowerIG Off 상태일 경우
    497          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    498          				//	PowerIG On  상태일 경우 
    499          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    500          				
    501          				if(!WL9FM_GetPowerIG())
    502          				{
    503          					
    504          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    505          					
    506          					
    507          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    508          					SystemReset = 0;
    509          					return;
    510          				}
    511          			
    512          				TimeDelay_msec(100);
    513          
    514          				PwrOffCnt++;
    515          				if(PwrOffCnt >= 15)	
    516          					break;
    517          			}
    518          
    519          			Buzzer_Off();
    520          
    521          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    522          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    523          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    524          
    525          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    526          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    527          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    528          
    529          			//	POWER OFF 일 때, LAMP Clear
    530          			LAMP_Update_Data = LAMP_ALL_OFF;
    531          			Old_LAMP_Update_Data = LAMP_ALL_OFF;
    532          		 	Illumination_Sig = 0;
    533          			Lamp_Update_System();
    534          			
    535          			//	엔딩화면 딜레이 시간
    536          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    537          			TimeDelay_msec(1200);
    538          
    539          			//	LCDBL, LCD, LED Off
    540          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    541          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    542          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    543          			LED_POWER_ONOFF(LED_OFF);       //  LED Off
    544          
    545          		//	++, kutelf, 140801
    546          		//	RevD.01.01 
    547          		//	Power, PMIC On/Off 방법 변경 
    548          		#if 0
    549          
    550          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_PMIC_OFF);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
    551          			WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
    552          			WL9FM_EXYNOS_PMIC_nRESET();
    553          		#else
    554          			WL9FM_EXYNOS_PMIC_PWROFF();
    555          			
    556          			//	Exynos VDD5V0_4412 Off
    557          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    558          			
    559          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    560          
    561          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    562          			if(!WL9FM_GetPowerIG())
    563          			{
    564          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    565          				SystemReset = 1;			//	Software RESET
    566          
    567          				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    568          				CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    569          				return;
    570          			}
    571          
    572          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	    
    573          		#endif
    574          		//	--, kutelf, 140801
    575          		}
    576          	}
    577          }
    578          
    579          /*******************************************************************************
    580          *
    581          *	Smart Key Test Function
    582          *
    583          *******************************************************************************/
    584          #if 1
    585          void SendSMKAuthResult(u8 result)
    586          {
    587          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    588          }
    589          
    590          void SendSMKMsgResult(u8 result)
    591          {
    592          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    593          }
    594          
    595          void SetTagLevel(u8 level)
    596          {
    597          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    598          		send_smartkey.TagLevel = level;
    599          	else
    600          		send_smartkey.TagLevel = 3;
    601          }
    602          
    603          void SetTagCmd(u8 cmd)
    604          {
    605          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    606          		send_smartkey.TagCommand = cmd;
    607          	else
    608          		send_smartkey.TagCommand = 0xf;
    609          }
    610          
    611          void SetVMC(void)
    612          {
    613          	if(rand_value.rand_vmc <= 64255)
    614          		send_smartkey.VMC = rand_value.rand_vmc;
    615          	else
    616          		send_smartkey.VMC = 0xffff;
    617          }
    618          
    619          void SetCPK(void)
    620          {
    621          #if 1
    622          	if(rand_value.rand_cpk <= 0xfaffffff)
    623          		send_smartkey.CPK = rand_value.rand_cpk;
    624          	else
    625          		send_smartkey.CPK = 0xffffffff;
    626          #else
    627          	send_smartkey.CPK = 0x11223344;
    628          #endif
    629          }
    630          
    631          void Srand()
    632          {
    633          	READ_RTC(&WL9FM_RTC);
    634          	srand((u32)WL9FM_RTC.Second);
    635          }
    636          
    637          void GetRandValue(u8 random)
    638          {
    639          	if(random == GET_VMC)	
    640          		rand_value.rand_vmc = (rand() % 64255);
    641          	else if(random == GET_CPK)	
    642          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    643          	else if(random == GET_VMC_CPK)		
    644          	{
    645          		rand_value.rand_vmc = (rand() % 64255);
    646          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    647          	}	
    648          }
    649          
    650          void RequestFirstAuthentication(void)
    651          {
    652          	unsigned int temp;
    653          	
    654          	SetTagLevel(TAG_LEVEL_NORMAL);
    655          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    656          	GetRandValue(GET_VMC_CPK);
    657          	SetVMC();
    658          	SetCPK();
    659          
    660          	setCipherParam(0x8085, 0x8087);
    661          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    662          	
    663          	send_smartkey.CPK = temp;
    664          
    665          	// CPK 암호화 Function 추가 필요
    666          	TimeDelay_msec(10);
    667          
    668          	struct st_CAN_Message1 Send_Message;
    669          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    670          	Send_Message.Priority= 0x18;
    671          	Send_Message.PDU_Format= 0xFF;
    672          	Send_Message.PDU_Specific= 0xE7;
    673          	Send_Message.Source_Address= 0x28;
    674          	Write_CAN_Single(Send_Message);
    675          }
    676          
    677          void RequestSecondAuthentication(void)
    678          {
    679          	unsigned short upper_cpk, lower_cpk;
    680          	unsigned int temp;
    681          
    682          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    683          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    684          	
    685          	SetTagLevel(TAG_LEVEL_NORMAL);
    686          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    687          	GetRandValue(GET_VMC);
    688          	SetVMC();
    689          
    690          	setCipherParam(upper_cpk, lower_cpk);
    691          	//setCipherParam(0x1122, 0x3344);
    692          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    693          
    694          	send_smartkey.CPK = temp;
    695          	
    696          	TimeDelay_msec(10);
    697          
    698          	struct st_CAN_Message1 Send_Message;
    699          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    700          	Send_Message.Priority= 0x18;
    701          	Send_Message.PDU_Format= 0xFF;
    702          	Send_Message.PDU_Specific= 0xE7;
    703          	Send_Message.Source_Address= 0x28;
    704          	Write_CAN_Single(Send_Message);
    705          
    706          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    707          }
    708          
    709          void RequestSMKRegistration(void)
    710          {
    711          	unsigned short upper_cpk, lower_cpk;
    712          	unsigned int temp;
    713          
    714          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    715          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    716          	
    717          	SetTagLevel(TAG_LEVEL_NORMAL);
    718          	SetTagCmd(TAG_CMD_REGISTRATION);
    719          	GetRandValue(GET_VMC);
    720          	SetVMC();
    721          
    722          	setCipherParam(upper_cpk, lower_cpk);
    723          	//setCipherParam(0x1122, 0x3344);
    724          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    725          
    726          	send_smartkey.CPK = temp;
    727          
    728          	struct st_CAN_Message1 Send_Message;
    729          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    730          	Send_Message.Priority= 0x18;
    731          	Send_Message.PDU_Format= 0xFF;
    732          	Send_Message.PDU_Specific= 0xE7;
    733          	Send_Message.Source_Address= 0x28;
    734          	Write_CAN_Single(Send_Message);
    735          
    736          
    737          
    738          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    739          }
    740          
    741          void RequestSMKElimination(void)
    742          {
    743          	unsigned short upper_cpk, lower_cpk;
    744          	unsigned int temp;
    745          
    746          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    747          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    748          	
    749          	SetTagLevel(TAG_LEVEL_NORMAL);
    750          	SetTagCmd(TAG_CMD_ELIMINATION);
    751          	GetRandValue(GET_VMC);
    752          	SetVMC();
    753          
    754          	setCipherParam(upper_cpk, lower_cpk);
    755          	//setCipherParam(0x1122, 0x3344);
    756          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    757          
    758          	send_smartkey.CPK = temp;
    759          
    760          	struct st_CAN_Message1 Send_Message;
    761          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    762          	Send_Message.Priority= 0x18;
    763          	Send_Message.PDU_Format= 0xFF;
    764          	Send_Message.PDU_Specific= 0xE7;
    765          	Send_Message.Source_Address= 0x28;
    766          	Write_CAN_Single(Send_Message);
    767          
    768          
    769          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    770          }
    771          
    772          void RequestSMKMessage(u8 Msg)
    773          {
    774          	if(Msg == 1)
    775          		RequestSMKRegistration();
    776          	else if(Msg == 2)
    777          		RequestSMKElimination();
    778          }
    779          
    780          void RequestSMKComm(void)
    781          {
    782          	SetTagLevel(TAG_LEVEL_NORMAL);
    783          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    784          	GetRandValue(GET_VMC);
    785          	SetVMC();
    786          
    787          	struct st_CAN_Message1 Send_Message;
    788          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    789          	Send_Message.Priority= 0x18;
    790          	Send_Message.PDU_Format= 0xFF;
    791          	Send_Message.PDU_Specific= 0xE7;
    792          	Send_Message.Source_Address= 0x28;
    793          	Write_CAN_Single(Send_Message);
    794          
    795          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    796          }
    797          
    798          u8 CheckResponseVMC(void)
    799          {
    800          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    801          		return RETURN_VMC_OK;
    802          	else
    803          		return RETURN_VMC_NOT_OK;
    804          }
    805          
    806          u8 CheckResponseAuthentication(u8 Auth)
    807          {
    808          	u8 output_buf[8];
    809          	u16 upper_cpk, lower_cpk;
    810          
    811          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    812          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    813          	
    814          	setCipherParam(upper_cpk, lower_cpk);
    815          	//setCipherParam(0x1122, 0x3344);	// 임시
    816          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    817          
    818          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    819          	
    820          	
    821          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    822          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    823          	{
    824          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    825          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    826          		{
    827          			return SMK_RESPONSE_FLAG_SUCCESS;
    828          		}
    829          		else
    830          			return recv_smartkey.Smk_Response_Flag;
    831          	}
    832          	else
    833          		return SMK_RESPONSE_CODE_NOT_MATCH;
    834          }
    835          
    836          void CheckResponseMsgComm(void)
    837          {
    838          	u8 output_buf[8];
    839          	u16 upper_cpk, lower_cpk;
    840          
    841          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    842          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    843          	
    844          	setCipherParam(upper_cpk, lower_cpk);
    845          	//setCipherParam(0x1122, 0x3344);	// 임시
    846          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    847          
    848          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    849          
    850          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    851          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    852          	{
    853          		if(recv_smartkey.Smk_Response_Code == 1)
    854          		{
    855          			switch(recv_smartkey.Smk_Response_Flag)
    856          			{
    857          				case 2 :
    858          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    859          					break;
    860          				case 3 :
    861          					SendSMKMsgResult(SMK_MSG_FAIL);
    862          					break;
    863          				case 4 :
    864          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    865          					break;
    866          				default :
    867          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    868          					{
    869          						if(recv_smartkey.Registered_Tag_Count == 1)
    870          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    871          						else if(recv_smartkey.Registered_Tag_Count == 2)
    872          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    873          						else
    874          							SendSMKMsgResult(SMK_MSG_FAIL);
    875          					}
    876          					else
    877          					{
    878          						if(SMK_Tag_Count != 0)
    879          							SMK_Tag_Count--;
    880          
    881          						SendSMKMsgResult(SMK_MSG_FAIL);
    882          					}
    883          					break;
    884          			}
    885          			
    886          		}
    887          		else if(recv_smartkey.Smk_Response_Code == 2)
    888          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    889          		else
    890          			SendSMKMsgResult(SMK_MSG_FAIL);
    891          	}
    892          	else
    893          		SendSMKMsgResult(SMK_MSG_FAIL);
    894          }
    895          
    896          
    897          void SmartKeyAuthentication(void)
    898          {
    899          	u8  Auth = 0;
    900          	u8 returnvalue;
    901          
    902          	if(AuthResult != 1)
    903          	{
    904          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    905          		{
    906          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    907          			{
    908          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    909          				RequestFirstAuthentication();
    910          			}
    911          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    912          			{
    913          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    914          				RequestSecondAuthentication();
    915          			}
    916          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    917          			{
    918          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    919          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    920          
    921          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    922          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    923          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    924          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    925          					
    926          				returnvalue = CheckResponseAuthentication(Auth);
    927          					
    928          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    929          				{
    930          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    931          					{
    932          						gAuthentication_Cnt = 0;
    933          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    934          					}
    935          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    936          					{
    937          						gAuthentication_Cnt = 0;
    938          						AuthResult = 1;
    939          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    940          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    941          						SMKSuccess = SMK_SUCCESS;
    942          						SendSMKAuthResult(SMK_SUCCESS);
    943          
    944          						// ++ , 141118 sys3215
    945          						Flag_ESL=1;
    946          						// -- , 141118 sys3215
    947          						
    948          					}
    949          				}
    950          				else
    951          				{
    952          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    953          					{
    954          						//AuthResult = 2;
    955          						AuthResult = 1;
    956          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    957          						SMKSuccess = SMK_FAIL;
    958          						SendSMKAuthResult(SMK_FAIL);
    959          						return;
    960          					}
    961          
    962          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    963          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    964          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    965          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    966          				}
    967          			}
    968          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
    969          			{
    970          				//RequestFirstAuthentication();
    971          			}
    972          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
    973          			{
    974          				//RequestSecondAuthentication();
    975          			}
    976          		}
    977          	}
    978          	//else if(AuthResult == 1)
    979          	{
    980          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
    981          		{
    982          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
    983          			SMK_Msg_Send = 1;
    984          			smk_flag_data.recv_resp_packet = 0;
    985          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
    986          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
    987          		}
    988          
    989          		if(SMK_Msg_Send == 1)
    990          		{
    991          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
    992          			{
    993          				SMK_Msg_Send = 0;
    994          				CheckResponseMsgComm();
    995          			}
    996          		}
    997          	}
    998          }
    999          #endif
   1000          
   1001          // ++, 141118 sys3215
   1002          void ESL_System(void)
   1003          {
   1004          	if(Seed_request==0)
   1005          	{
   1006          		Seed_request=0xff;
   1007          		Seed_Request_CAN_TX();
   1008          	}
   1009          	if(Seed_received==1)
   1010          	{
   1011          		Seed_received=0xff;
   1012          		SendMultiPacketRTS_ESL();
   1013          	}
   1014          	if(ESL_CTS_received==1)
   1015          	{
   1016          		ESL_CTS_received=0xff;
   1017          		SendMultiPacketData_ESL();
   1018                          Flag_ESL = 0;
   1019          	}
   1020          	if(ESL_ACK_received==1)
   1021          	{
   1022          		Init_Smart_Key_valuable();
   1023          	}
   1024          }
   1025          
   1026          // --, 141118 sys3215
   1027          
   1028          
   1029          
   1030          /**
   1031            * @brief  1msec OperationFunc
   1032            * @param  None
   1033            * @retval None
   1034            */
   1035          void WL9FM_1mSecOperationFunc(void)
   1036          {
   1037          #if 1
   1038          	if( Flag_UartTxStart == 1 )
   1039          	{
   1040          		if (SendTime_E2PROM++ > 3) //	25msec
   1041          		{
   1042          			SendTime_E2PROM = 0;
   1043          			SendTo_E2PROM();
   1044          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
   1045          		}			
   1046          	}
   1047          	// CAN_TX Routine
   1048          	CAN_TX();
   1049          	Write_UART_Single();
   1050          #endif
   1051          }
   1052          
   1053          /**
   1054            * @brief  10msec OperationFunc
   1055            * @param  None
   1056            * @retval None
   1057            */
   1058          void WL9FM_10mSecOperationFunc(void)
   1059          {
   1060          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
   1061          }
   1062          
   1063          /**
   1064            * @brief  100msec OperationFunc
   1065            * @param  None
   1066            * @retval None
   1067            */
   1068          void WL9FM_100mSecOperationFunc(void)
   1069          {
   1070          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1071          
   1072          #if 1
   1073          	//if(Flag_TxE2pRomData == 1)
   1074          		SmartKeyAuthentication();
   1075          #endif
   1076          
   1077          // ++ , 141118 sys3215
   1078          	if(Flag_ESL==1)
   1079          	{
   1080          		ESL_System();
   1081          	}
   1082          // -- , 141118 sys3215
   1083          	
   1084          	if(LCDOffCount < 30)
   1085          	{
   1086          		LCDOffCount++;
   1087          		LCDBL_ONOFF(LCDBL_OFF);
   1088          	}
   1089          	else if(LCDOffCount == 30)
   1090          	{
   1091          		LCDOffCount++;
   1092          		LCDBL_ONOFF(LCDBL_ON);
   1093          	}
   1094          	else
   1095          	{
   1096          		LCDBL_ONOFF(LCDBL_ON);
   1097          	}
   1098          	
   1099          	if(CommErrCnt > 1000)
   1100             	{
   1101             		if( Flag_TxE2pRomData == 1 )
   1102          	   	{
   1103          	   		CAN_COMInit();
   1104             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1105          
   1106          			Buz1 = 0;
   1107                      //RTCSend();
   1108          			if(++SendRTCnt >= 10)
   1109          			{
   1110          				SendRTCnt = 0;
   1111          				
   1112          			}
   1113          	   	}
   1114          	}	
   1115          	if(OSUpdateCount < 200)
   1116          	{
   1117          		OSUpdateCount++;
   1118          	}
   1119          	else if(OSUpdateCount == 200)
   1120          	{
   1121          		OSUpdateCount++;
   1122          		System_CheckPowerIG();
   1123          	}
   1124          	else
   1125          	{
   1126          		System_CheckPowerIG();
   1127          	}
   1128          	
   1129          
   1130          	if(ST_Update)
   1131          	{
   1132          		if(UpdateMode < 10)
   1133          			UpdateMode++;
   1134          
   1135          		if(UpdateMode >= 10)
   1136          		{
   1137          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1138          			ST_Update=0;
   1139          		}
   1140          	}
   1141          		
   1142          	//	WL9A Monitor RESET Code
   1143          	if((SystemReset == 1) || (gRebootCmd == 1))
   1144          	{
   1145          		if(gRebootCmd == 1)
   1146          			SaveDataToEEPROM();
   1147          				
   1148          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1149          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1150          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1151          		return;
   1152          	}
   1153          
   1154          }
   1155          
   1156          void WL9FM_500mSecOperationFunc(void)
   1157          {
   1158          	if(CANUpdateFlag != 1)
   1159          		MonitorStatus_CAN_TX();
   1160          
   1161          }
   1162          
   1163          
   1164          
   1165          /**
   1166            * @brief  1sec OperationFunc
   1167            * @param  None
   1168            * @retval None
   1169            */
   1170          void WL9FM_1SecOperationFunc(void)
   1171          {
   1172          	if(UpdateMode < 10)
   1173          		read_clock();
   1174          
   1175          
   1176          	//  ++, kutelf, 131007
   1177          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1178          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1179          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1180          	{
   1181          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1182          			
   1183          		if ((Camera_CheckCnt % 3) == 0)
   1184          		{
   1185          			cam_mode_check();
   1186          		}
   1187          	}
   1188          	else
   1189          	{
   1190          		Camera_CheckCnt = 0;
   1191          	}
   1192          	//  --, kutelf, 131007
   1193          }
   1194          
   1195          //	++, kutelf, 140801
   1196          //	RevD.01.01
   1197          //	RevD 보드와 호환성을 위하여 함수 추가 및 이름 변경
   1198          void CameraMode(u8 Mode, u8 OSD)
   1199          {
   1200          	#ifdef BoardVersion_RevD
   1201          		TW8816_CameraMode(Mode, OSD);
   1202          	#else
   1203          		TW2835_CameraMode(Mode, OSD);
   1204          	#endif
   1205          }
   1206          
   1207          void CheckCamera_Input(u8 Mode)
   1208          {
   1209          	#ifdef BoardVersion_RevD
   1210          		TW8816_CheckCamera_Input(Mode);
   1211          	#else
   1212          		TW2835_CheckCamera_Input(Mode);
   1213          	#endif
   1214          }
   1215          //	--, kutelf, 140801
   1216          
   1217          void WL9FM_System_Init_Start(void)
   1218          {
   1219          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1220          	if (SystemReset != 1)
   1221          	{
   1222          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1223          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1224          	}				
   1225          
   1226          //	++, kutelf, 140801
   1227          //	RevD.01.01
   1228          //	Power, PMIC On/Off 방법 변경 
   1229          #if 0
   1230          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1231          	WL9FM_EXYNOS_PMIC_nRESET();
   1232          	WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
   1233          
   1234          #else
   1235          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1236          	WL9FM_EXYNOS_PMIC_PWRON();
   1237          #endif
   1238          //	--, kutelf, 140801
   1239          	
   1240          //	++, kutelf, 140801
   1241          //	RevD.01.01 
   1242          //	Camera Input, LCD Controller 변경
   1243          //		=> TW2835 + TW8832 -> TW8816
   1244          //	DPRAM 삭제 - FSMC 사용 안함.
   1245          #ifdef BoardVersion_RevD
   1246          	WL9FM_CAMERA_nRESET();						//	-> 	TW8816 Power On..
   1247          	TW8816_Control_Init();
   1248          #else
   1249          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1250          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1251          	TW2835_Control_Init();	
   1252          	//DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1253          #endif
   1254          //	--, kutelf, 140801	
   1255          
   1256          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1257          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1258          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1259          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1260          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1261          												//		LAMP ALL ON
   1262          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1263          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1264          
   1265          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1266          
   1267          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1268          
   1269          	//USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1270          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);   //      COM2 : CAN
   1271          	USART_COMInit(COMPORT4);       					//      COM4 : CMDData
   1272          
   1273          												
   1274          	CAN_COMInit();								//	-> 	CAN_Control.c
   1275          	//InitE2PROM();
   1276          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1277          
   1278          	M25P32_Init();
   1279          
   1280          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1281          	//Old_LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1282          
   1283          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1284          
   1285          	SetFontOSDWindow();
   1286          }
   1287          
   1288          /**
   1289            * @brief  Application Program Start Point.
   1290            * @param  None
   1291            * @retval None
   1292            */
   1293          void WL9FM_Monitor_APP(void)
   1294          {
   1295          	DebugUART_Init();			//	->	Main.c
   1296          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1297          
   1298          //	++, kutelf, 140925
   1299          //	KeyIG Off에서 무한 RESET 되는 현상 수정 => SYSTEM_RESET 위치 변경
   1300          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1301          SYSTEM_RESET :
   1302          //	--, kutelf, 140925
   1303          	System_Configuration();		//  ->  System_Init.c
   1304          	                    		//      RCC, NVIC, GPIO Initialize
   1305          
   1306          	System_Initialize();		//	-> 	System_Init.c
   1307          
   1308          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1309          	System_Variable_Init();
   1310          	WL9FM_System_Init_Start();
   1311          	
   1312          	/* Infinite loop */
   1313          	while (1)
   1314          	{  
   1315          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1316          		{
   1317          			WL9FM_TIME.Flag_1mSec = 0;
   1318          
   1319          			//  WL9F_1mSecOperationState -> Func 실행..
   1320          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1321          			WL9FM_1mSecOperationFunc();
   1322          		}            
   1323          		
   1324          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1325          		{
   1326          			WL9FM_TIME.Flag_10mSec = 0;
   1327          
   1328          			//  WL9F_10mSecOperationState -> Func 실행..
   1329          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1330          			WL9FM_10mSecOperationFunc();
   1331          		}
   1332          		
   1333          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1334          		{
   1335          			WL9FM_TIME.Flag_100mSec = 0;
   1336          
   1337          			//  WL9F_100mSecOperationState -> Func 실행..
   1338          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1339          			WL9FM_100mSecOperationFunc();
   1340          
   1341          			#if 1
   1342          			//	WL9F Monitor RESET Code
   1343          			if((SystemReset == 1) || (gRebootCmd == 1))
   1344          			{
   1345          				goto SYSTEM_RESET;
   1346          			}
   1347          			#endif
   1348          		}
   1349          
   1350          		if(WL9FM_TIME.Flag_500mSec == 1)
   1351          		{
   1352          			WL9FM_TIME.Flag_500mSec = 0;
   1353          			WL9FM_500mSecOperationFunc();
   1354          		}
   1355          		
   1356          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1357          		{
   1358          			WL9FM_TIME.Flag_1Sec = 0;
   1359          
   1360          			//  WL9F_1SecOperationState -> Func 실행..
   1361          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1362          			WL9FM_1SecOperationFunc();
   1363                                  
   1364          		}
   1365          	}
   1366          }
   1367          
   1368          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CameraMode
         0   -> TW2835_CameraMode
       0   CheckCamera_Input
         0   -> TW2835_CheckCamera_Input
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SMK_SendToExynos
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   ESL_System
         8   -> Init_Smart_Key_valuable
         8   -> Seed_Request_CAN_TX
         8   -> SendMultiPacketData_ESL
         8   -> SendMultiPacketRTS_ESL
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> SetVMC
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      16   RequestSMKComm
        16   -> GetRandValue
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> SetVMC
        16   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SendSMKAuthResult
         0   -> SMK_SendToExynos
       0   SendSMKMsgResult
         0   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
         0   -> SMK_SendToExynos
        16   -> SMK_SendToExynos
       8   Srand
         8   -> READ_RTC
         0   -> srand
      24   System_CheckPowerIG
        24   -> Buzzer_Off
         0   -> CAN_ITConfig
        24   -> CAN_ITConfig
        24   -> KeySwitch_SendToEXYNOS
        24   -> LCDBL_ONOFF
        24   -> LCDBL_PWM_LEVEL
        24   -> LCD_POWER_ONOFF
        24   -> LED_POWER_ONOFF
        24   -> Lamp_Update_System
        24   -> SaveDataToEEPROM
        24   -> TimeDelay_msec
        24   -> USART_ITConfig
        24   -> WL9FM_EXYNOS_PMIC_PWROFF
        24   -> WL9FM_EXYNOS_POWER_ONOFF
        24   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
        24   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         8   -> ESL_System
         8   -> LCDBL_ONOFF
         8   -> Lamp_Update_System
         8   -> STM32_Update
         0   -> SaveDataToEEPROM
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         0   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      24   WL9FM_Monitor_APP
        24   -> CAN_TX
        24   -> DebugUART_Init
        24   -> KeySwitch_SendToEXYNOS
        24   -> MonitorStatus_CAN_TX
        24   -> SendTo_E2PROM
        24   -> System_Configuration
        24   -> System_Initialize
        24   -> System_Variable_Init
        24   -> WL9FM_100mSecOperationFunc
        24   -> WL9FM_System_Init_Start
        24   -> Write_UART_Single
        24   -> cam_mode_check
        24   -> read_clock
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         0   -> SetFontOSDWindow
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> USART_COMInit_DMA
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
      34  ??Subroutine1_0
      52  ?Subroutine0
       8  ACK_Multi_61184
       1  CTSFlag_61184
       4  CameraMode
       4  CheckCamera_Input
      88  CheckResponseAuthentication
     180  CheckResponseMsgComm
      20  CheckResponseVMC
       8  E2PROM_Save
          PwrOffCnt
          Old_LAMP_Update_Data
      64  ESL_System
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
     118  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      28  Init_Smart_Key_valuable
       4  KeySwitch_Value
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     126  RequestFirstAuthentication
      72  RequestSMKComm
      18  RequestSMKElimination
      18  RequestSMKMessage
      20  RequestSMKRegistration
      78  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      12  SendSMKAuthResult
      18  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     262  SmartKeyAuthentication
      22  Srand
     260  System_CheckPowerIG
       1  TotalPacketNum
     190  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
      78  WL9FM_1SecOperationFunc
      48  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     218  WL9FM_Monitor_APP
       8  WL9FM_RTC
     130  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
      82  read_clock
      76  recv_smartkey
          gAuthentication_Cnt
          Flag_ESL
          Seed_request
          Seed_received
          ESL_CTS_received
          ESL_ACK_received
          Password_Certification_Result
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          gRebootCmd
          ST_Update
          UpdateMode
          LCDOffCount
          send_smartkey
          WL9FM_TIME
          rand_value
          OSUpdateCount
          LAMP_Update_Data
          smk_flag_data
       1  send_bkcu_data
       1  send_mcu_data

 
 2 849 bytes in section .bss
 3 942 bytes in section .text
 
 3 942 bytes of CODE memory
 2 849 bytes of DATA memory

Errors: none
Warnings: 4
