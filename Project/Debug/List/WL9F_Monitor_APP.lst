###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/Oct/2014  14:31:23 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\WL9F_M #
#                    onitor_APP.lst                                           #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\WL9F_Mo #
#                    nitor_APP.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          u8 AuthResult;
     80          u8 SMKSuccess;
     81          u8 SMK_Msg_Send;
     82          u8 SMK_Tag_Count;
     83          u8 MultiPacketSendOrder = 0;
     84          u8 TotalPacketNum = 0;
     85          u8 DiffMachInfo = 0;
     86          u8 MachInfoSendCnt = 0;
     87          u8 MoniInfoSendCnt = 0;
     88          
     89          u8 RTSFlag_61184 = 0;
     90          u8 CTSFlag_61184 = 0;
     91          u8 RMCU_CTSFlag_61184 = 0;
     92          u8 RecvTotalPacket_61184 = 0;
     93          u8 RMCU_RecvTotalPacket_61184 = 0;
     94          u8 ACK_Multi_61184[8];
     95          u8 RMCU_ACK_Multi_61184[8];
     96          
     97          u8 Flag_UartTxStart = 0;
     98          u8  SendTime_E2PROM = 0;
     99          
    100          u16 Flag_1Sec_MachInfo = 0;
    101          u16 Flag_1Min = 0;
    102          
    103          u8 MachInfoTotalPacketNum = 0;
    104          u8 MoniInfoTotalPacketNum = 0;
    105          u8 Flag_200mSec = 0;
    106          u8 SendRTCnt = 0;
    107          u16 adc_value = 0;
    108          
    109          u8 SerialMsgRTC[16];
    110          u8 eepRomReadData1[32];
    111          u8 MoniInfoData[21];
    112          u8 McuInfoData2[4];
    113          u8 McuInfoData3[4];
    114          u8 McuInfoData4[4];
    115          
    116          u8 SystemReset = 0;
    117          u8 E2PROM_Save = 0;
    118          u8 PwrOffCnt = 0;
    119          u8 gRebootCmd = 0;
    120          
    121          
    122          u8 send_mcu_data=0;
    123          u8 send_bkcu_data=0;
    124          
    125          u8 ST_Update=0;
    126          u8 UpdateMode = 0;
    127          
    128          extern u8 Uart2_RxMsg_Single_252[8];
    129          extern u8 Uart2_RxMsg_Single_253[8];
    130          extern u8 Uart2_RxMsg_Single_239[8];
    131          extern u8 Uart2_RxMsg_Single_239_121[8];
    132          extern u8 Uart2_RxMsg_Single_247[8];
    133          extern u8 Uart2_RxMsg_Save_Data1[8];
    134          extern u8 Uart2_RxMsg_Save_Data2[8];
    135          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    136          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    137          extern u8 McuInfoData1[79];
    138          extern u8 tmpMcuInfoData[78];
    139          extern u8 FatoryInit_Flag;
    140          
    141          extern u8 stop_send_as_phone_data;
    142          extern u8 Flag_TxE2pRomData;
    143          
    144          extern u8 Buz1;
    145          
    146          extern u8 Stm32_Update_CMD;
    147          extern u8 CANUpdateFlag;
    148          
    149          extern u16 pWriteBufPos;
    150          extern u16 pReadBufPos;
    151          
    152          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    153          extern char Illumination_Sig;
    154          
    155          // ++, 141006 fort22
    156          u8 LCDOffCount;
    157          u16 OSUpdateCount;
    158          // --, 141006 fort22
    159          
    160          /* Private function prototypes -----------------------------------------------*/
    161          /* Private functions ---------------------------------------------------------*/
    162          
    163          void Init_RTC(void)
    164          {
    165          	WL9FM_RTC.Year   = 0;
    166          	WL9FM_RTC.Month  = 1;
    167          	WL9FM_RTC.Date   = 1;
    168          	WL9FM_RTC.Day    = 1;
    169          	WL9FM_RTC.Hour   = 12;
    170          	WL9FM_RTC.Minute = 0;
    171          	WL9FM_RTC.Second = 0;
    172          
    173          	WRITE_RTC(WL9FM_RTC);
    174          }
    175          void InitE2PROM(void)
    176          {
    177          	u8 i;
    178          	u8 tmpBuf1[8];
    179          	u8 tmpBuf2[8];
    180          	u8 tmpBuf3[8];
    181          	u8 tmpBuf4[21];
    182          	
    183          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    184          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    185          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    186          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    187          
    188          	SaveE2PROM1->WorkLoad 				= 0;
    189          	SaveE2PROM1->testWorkLoad 			= 0;
    190          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    191          	SaveE2PROM1->DispType	 			= 0;
    192          	SaveE2PROM1->InfoViewPriority 		= 0;
    193          	SaveE2PROM1->UnitPressure 			= 0;
    194          	SaveE2PROM1->Reserved0 				= 0;
    195          	SaveE2PROM1->Lang 					= 0;
    196          	SaveE2PROM1->ManualBackLight 		= 7;
    197          	SaveE2PROM1->AutoBackLight 			= 0;
    198          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    199          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    200          	SaveE2PROM1->InfoViewCnt 			= 2;
    201          	SaveE2PROM1->HR_Start 				= 0;
    202          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    203          	SaveE2PROM1->ActiveCamNum 			= 1;
    204          	SaveE2PROM1->FirstCam 				= 0;
    205          	SaveE2PROM1->SecondCam 				= 1;
    206          	SaveE2PROM1->ThirdCam 				= 2;
    207          	SaveE2PROM1->Reserved1 				= 0;
    208          
    209          	SaveE2PROM2->LightMode 				= 0;
    210          	SaveE2PROM2->JobTimeView 			= 0;
    211          	SaveE2PROM2->OdoMeterView 			= 0;
    212          	SaveE2PROM2->JobOdoSelect 			= 0;
    213          	SaveE2PROM2->LightLowTime 			= 8;
    214          	SaveE2PROM2->LightUpperTime 		= 16;
    215          	SaveE2PROM2->AutoLightDay 			= 0;
    216          	SaveE2PROM2->AutoLightNight 		= 0;
    217          	SaveE2PROM2->Reserved1 				= 0;
    218          
    219          	SaveE2PROM3->Phone_1  				= 0;
    220          	SaveE2PROM3->Phone_2  				= 8;
    221          	SaveE2PROM3->Phone_3  				= 0;
    222          	SaveE2PROM3->Phone_4  				= 5;
    223          	SaveE2PROM3->Phone_5  				= 5;
    224          	SaveE2PROM3->Phone_6  				= 5;
    225          	SaveE2PROM3->Phone_7  				= 8;
    226          	SaveE2PROM3->Phone_8  				= 2;
    227          	SaveE2PROM3->Phone_9  				= 7;
    228          	SaveE2PROM3->Phone_10 				= 2;
    229          	SaveE2PROM3->Phone_11 				= 0xf;
    230          	SaveE2PROM3->Phone_12 				= 0xf;
    231          
    232          #if 1	// Monitor Change History - temp
    233          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    234          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    235          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    236          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    237          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    238          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    239          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    240          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    241          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    242          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    243          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    244          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    245          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    246          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    247          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    248          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    249          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    250          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    251          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    252          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    253          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    254          #endif
    255          
    256          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    257          
    258          	EEPROM_Write(0, 0);	// tmp
    259          	EEPROM_Write(0, 0);	// tmp
    260          	EEPROM_Write(0, 0);	// tmp
    261          
    262          	for(i = 0 ; i < 8 ; i++)
    263          	{
    264          		EEPROM_Write(i+8, tmpBuf1[i]);
    265          		TimeDelay_msec(5);
    266          		EEPROM_Write(i+16, tmpBuf2[i]);
    267          		TimeDelay_msec(5);
    268          		EEPROM_Write(i+24, tmpBuf3[i]);
    269          		TimeDelay_msec(5);
    270          	}
    271          
    272          	SerialPutString("Initialize : 30 %%\n\r");
    273          	
    274          #if 1	// Monitor Change History - temp
    275          	for(i = 0 ; i < 21 ; i++)
    276          	{
    277          		EEPROM_Write(i+50, tmpBuf4[i]);
    278          		TimeDelay_msec(5);
    279          	}
    280          #endif
    281          
    282          	for(i = 0 ; i < 79 ; i++)
    283          	{
    284          		EEPROM_Write(i+100, 0xff);
    285          		TimeDelay_msec(5);
    286          	}
    287          
    288          	SerialPutString("Initialize : 60 %%\n\r");
    289          
    290          	for(i = 0 ; i < 30 ; i++)
    291          	{
    292          		EEPROM_Write(i+200, 0xff);
    293          		TimeDelay_msec(5);
    294          	}
    295          
    296          	for(i = 0 ; i < 29 ; i++)
    297          	{
    298          		EEPROM_Write(i+230, 0xff);
    299          		TimeDelay_msec(5);
    300          	}
    301          
    302          	SerialPutString("Initialize : 95 %%\n\r");
    303          	Init_RTC();
    304          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    305          }
    306          
    307          void ReadE2PROM_ToSend()
    308          {
    309          #if 1
    310          	u8 i;
    311          
    312          	adc_value = (ADC1->DR & 0x0000FFFF);
    313          
    314          	i = EEPROM_Read(0);	
    315          	i = EEPROM_Read(0);
    316          	i = EEPROM_Read(0);
    317          	i = 0;
    318              
    319          	adc_value = (ADC1->DR & 0x0000FFFF);
    320          
    321          	for(i = 0 ; i < 24 ; i++)
    322          		eepRomReadData1[i] = EEPROM_Read(i+8);
    323          
    324          	for(i = 0 ; i < 8 ; i++)
    325          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    326          
    327          	for(i = 0 ; i < 8 ; i++)
    328          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    329          
    330          	for(i = 0 ; i < 8 ; i++)
    331          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    332          
    333          	for(i = 0 ; i < 21 ; i++)
    334          		MoniInfoData[i] = EEPROM_Read(i+50);
    335          	
    336          	for(i = 0 ; i < 79 ; i++)
    337          		McuInfoData1[i] = EEPROM_Read(i+100);
    338          
    339          	for(i = 0 ; i < 4 ; i++)
    340          		McuInfoData2[i] = EEPROM_Read(i+200);
    341          
    342          	for(i = 0 ; i < 4 ; i++)
    343          		McuInfoData3[i] = EEPROM_Read(i+210);
    344          
    345          	for(i = 0 ; i < 4 ; i++)
    346          		McuInfoData4[i] = EEPROM_Read(i+220);
    347          
    348          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    349          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    350          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    351          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    352          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    353          
    354          
    355          	adc_value = (ADC1->DR & 0x0000FFFF);
    356          	
    357          	eepRomReadData1[12] = (adc_value & 0xff);
    358          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    359          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    360          
    361          #endif
    362          }
    363          
    364          
    365          void Init_Smart_Key_valuable(void)
    366          {
    367          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    368          	AuthResult = 0xff;
    369          	SMK_Msg_Send = 0;
    370          	SMK_Tag_Count = 0;
    371          	SMKSuccess = 0;
    372          }
    373          
    374          
    375          void read_clock(void)
    376          {
    377          	uint8_t Temp[Serial_COM4_TxSize];
    378          	
    379          	READ_RTC(&WL9FM_RTC);
    380          
    381          	Temp[0] = 0x02;				
    382          	Temp[1] = RTCRES;				
    383          	Temp[2] = WL9FM_RTC.Year;	
    384          	Temp[3] = WL9FM_RTC.Month;	
    385          	Temp[4] = WL9FM_RTC.Date;	
    386          	Temp[5] = WL9FM_RTC.Day;	
    387          	Temp[6] = WL9FM_RTC.Hour;	
    388          	Temp[7] = WL9FM_RTC.Minute;	
    389          	Temp[8] = WL9FM_RTC.Second;	
    390          	Temp[9] = 0xFF;	
    391          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    392          	USARTx_EXYNOS(COM4, (char *)Temp);	
    393          
    394          }
    395          
    396          void SaveDataToEEPROM(void)
    397          {
    398          	u8 i;
    399          	
    400          	for(i = 0 ; i < 8 ; i++)
    401          	{
    402          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    403          		TimeDelay_msec(1);
    404          	}
    405          
    406          	for(i = 0 ; i < 8 ; i++)
    407          	{
    408          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    409          		TimeDelay_msec(1);
    410          	}
    411          
    412          	for(i = 0 ; i < 8 ; i++)
    413          	{
    414          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    415          		TimeDelay_msec(1);
    416          	}
    417          
    418          	for(i = 0 ; i < 21 ; i++)
    419          	{
    420          		EEPROM_Write(i+50, MoniInfoData[i]);
    421          		TimeDelay_msec(1);
    422          	}
    423          	
    424          	for(i = 0 ; i < 79 ; i++)
    425          	{
    426          		EEPROM_Write(i+100, McuInfoData1[i]);
    427          		TimeDelay_msec(1);
    428          	}
    429          
    430          
    431          	if(DiffMachInfo == 1)
    432          	{
    433          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    434          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    435          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    436          	}
    437          
    438          	for(i = 0 ; i < 4 ; i++)
    439          	{
    440          		EEPROM_Write(i+200, McuInfoData2[i]);
    441          		TimeDelay_msec(1);
    442          	}
    443          
    444          	for(i = 0 ; i < 4 ; i++)
    445          	{
    446          		EEPROM_Write(i+210, McuInfoData3[i]);
    447          		TimeDelay_msec(1);
    448          	}
    449          
    450          	for(i = 0 ; i < 4 ; i++)
    451          	{
    452          		EEPROM_Write(i+220, McuInfoData4[i]);
    453          		TimeDelay_msec(1);
    454          	}
    455          }
    456          
    457          
    458          void System_CheckPowerIG()
    459          {
    460          	// Check POWER IG
    461          	if(!WL9FM_GetPowerIG())
    462          	{
    463          		WL9FM_PowerIG(PowerIG_ON);
    464          		SystemReset = 0;
    465          	}
    466          	else
    467          	{
    468          		if(E2PROM_Save == 0)
    469          		{
    470          			SaveDataToEEPROM();
    471          
    472          			PwrOffCnt = 0;
    473          			
    474          			while(1)
    475          			{
    476          				//	100msec 마다 15번 체크 -> 1.5초..
    477          				//	PowerIG Off 상태일 경우
    478          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    479          				//	PowerIG On  상태일 경우 
    480          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    481          				
    482          				if(!WL9FM_GetPowerIG())
    483          				{
    484          					
    485          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    486          					
    487          					
    488          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    489          					SystemReset = 0;
    490          					return;
    491          				}
    492          			
    493          				TimeDelay_msec(100);
    494          
    495          				PwrOffCnt++;
    496          				if(PwrOffCnt >= 15)	
    497          					break;
    498          			}
    499          
    500          			Buzzer_Off();
    501          
    502          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    503          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    504          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    505          
    506          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    507          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    508          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    509          
    510          			//	POWER OFF 일 때, LAMP Clear
    511          			LAMP_Update_Data = LAMP_ALL_OFF;
    512          		 	Illumination_Sig = 0;
    513          			Lamp_Update_System();
    514          			
    515          			//	엔딩화면 딜레이 시간
    516          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    517          			TimeDelay_msec(1200);
    518          
    519          			//	LCDBL, LCD, LED Off
    520          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    521          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    522          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    523          			LED_POWER_ONOFF(LED_OFF);       //  LED Off
    524          
    525          			WL9FM_EXYNOS_PMIC_PWRON();
    526          
    527          			
    528          			//	Exynos VDD5V0_4412 Off
    529          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    530          			
    531          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    532          
    533          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    534          			if(!WL9FM_GetPowerIG())
    535          			{
    536          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    537          				SystemReset = 1;			//	Software RESET
    538          
    539          				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    540          				CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    541          				return;
    542          			}
    543          
    544          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	    
    545          		}
    546          	}
    547          }
    548          
    549          /*******************************************************************************
    550          *
    551          *	Smart Key Test Function
    552          *
    553          *******************************************************************************/
    554          #if 1
    555          void SendSMKAuthResult(u8 result)
    556          {
    557          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    558          }
    559          
    560          void SendSMKMsgResult(u8 result)
    561          {
    562          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    563          }
    564          
    565          void SetTagLevel(u8 level)
    566          {
    567          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    568          		send_smartkey.TagLevel = level;
    569          	else
    570          		send_smartkey.TagLevel = 3;
    571          }
    572          
    573          void SetTagCmd(u8 cmd)
    574          {
    575          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    576          		send_smartkey.TagCommand = cmd;
    577          	else
    578          		send_smartkey.TagCommand = 0xf;
    579          }
    580          
    581          void SetVMC(void)
    582          {
    583          	if(rand_value.rand_vmc <= 64255)
    584          		send_smartkey.VMC = rand_value.rand_vmc;
    585          	else
    586          		send_smartkey.VMC = 0xffff;
    587          }
    588          
    589          void SetCPK(void)
    590          {
    591          #if 1
    592          	if(rand_value.rand_cpk <= 0xfaffffff)
    593          		send_smartkey.CPK = rand_value.rand_cpk;
    594          	else
    595          		send_smartkey.CPK = 0xffffffff;
    596          #else
    597          	send_smartkey.CPK = 0x11223344;
    598          #endif
    599          }
    600          
    601          void Srand()
    602          {
    603          	READ_RTC(&WL9FM_RTC);
    604          	srand((u32)WL9FM_RTC.Second);
    605          }
    606          
    607          void GetRandValue(u8 random)
    608          {
    609          	if(random == GET_VMC)	
    610          		rand_value.rand_vmc = (rand() % 64255);
    611          	else if(random == GET_CPK)	
    612          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    613          	else if(random == GET_VMC_CPK)		
    614          	{
    615          		rand_value.rand_vmc = (rand() % 64255);
    616          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    617          	}	
    618          }
    619          
    620          void RequestFirstAuthentication(void)
    621          {
    622          	unsigned int temp;
    623          	
    624          	SetTagLevel(TAG_LEVEL_NORMAL);
    625          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    626          	GetRandValue(GET_VMC_CPK);
    627          	SetVMC();
    628          	SetCPK();
    629          
    630          	setCipherParam(0x8085, 0x8087);
    631          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    632          	
    633          	send_smartkey.CPK = temp;
    634          
    635          	// CPK 암호화 Function 추가 필요
    636          	TimeDelay_msec(10);
    637          
    638          	struct st_CAN_Message1 Send_Message;
    639          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    640          	Send_Message.Priority= 0x18;
    641          	Send_Message.PDU_Format= 0xFF;
    642          	Send_Message.PDU_Specific= 0xE7;
    643          	Send_Message.Source_Address= 0x28;
    644          	Write_CAN_Single(Send_Message);
    645          }
    646          
    647          void RequestSecondAuthentication(void)
    648          {
    649          	unsigned short upper_cpk, lower_cpk;
    650          	unsigned int temp;
    651          
    652          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    653          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    654          	
    655          	SetTagLevel(TAG_LEVEL_NORMAL);
    656          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    657          	GetRandValue(GET_VMC);
    658          	SetVMC();
    659          
    660          	setCipherParam(upper_cpk, lower_cpk);
    661          	//setCipherParam(0x1122, 0x3344);
    662          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    663          
    664          	send_smartkey.CPK = temp;
    665          	
    666          	TimeDelay_msec(10);
    667          
    668          	struct st_CAN_Message1 Send_Message;
    669          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    670          	Send_Message.Priority= 0x18;
    671          	Send_Message.PDU_Format= 0xFF;
    672          	Send_Message.PDU_Specific= 0xE7;
    673          	Send_Message.Source_Address= 0x28;
    674          	Write_CAN_Single(Send_Message);
    675          
    676          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    677          }
    678          
    679          void RequestSMKRegistration(void)
    680          {
    681          	unsigned short upper_cpk, lower_cpk;
    682          	unsigned int temp;
    683          
    684          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    685          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    686          	
    687          	SetTagLevel(TAG_LEVEL_NORMAL);
    688          	SetTagCmd(TAG_CMD_REGISTRATION);
    689          	GetRandValue(GET_VMC);
    690          	SetVMC();
    691          
    692          	setCipherParam(upper_cpk, lower_cpk);
    693          	//setCipherParam(0x1122, 0x3344);
    694          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    695          
    696          	send_smartkey.CPK = temp;
    697          
    698          	struct st_CAN_Message1 Send_Message;
    699          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    700          	Send_Message.Priority= 0x18;
    701          	Send_Message.PDU_Format= 0xFF;
    702          	Send_Message.PDU_Specific= 0xE7;
    703          	Send_Message.Source_Address= 0x28;
    704          	Write_CAN_Single(Send_Message);
    705          
    706          
    707          
    708          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    709          }
    710          
    711          void RequestSMKElimination(void)
    712          {
    713          	unsigned short upper_cpk, lower_cpk;
    714          	unsigned int temp;
    715          
    716          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    717          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    718          	
    719          	SetTagLevel(TAG_LEVEL_NORMAL);
    720          	SetTagCmd(TAG_CMD_ELIMINATION);
    721          	GetRandValue(GET_VMC);
    722          	SetVMC();
    723          
    724          	setCipherParam(upper_cpk, lower_cpk);
    725          	//setCipherParam(0x1122, 0x3344);
    726          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    727          
    728          	send_smartkey.CPK = temp;
    729          
    730          	struct st_CAN_Message1 Send_Message;
    731          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    732          	Send_Message.Priority= 0x18;
    733          	Send_Message.PDU_Format= 0xFF;
    734          	Send_Message.PDU_Specific= 0xE7;
    735          	Send_Message.Source_Address= 0x28;
    736          	Write_CAN_Single(Send_Message);
    737          
    738          
    739          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    740          }
    741          
    742          void RequestSMKMessage(u8 Msg)
    743          {
    744          	if(Msg == 1)
    745          		RequestSMKRegistration();
    746          	else if(Msg == 2)
    747          		RequestSMKElimination();
    748          }
    749          
    750          void RequestSMKComm(void)
    751          {
    752          	SetTagLevel(TAG_LEVEL_NORMAL);
    753          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    754          	GetRandValue(GET_VMC);
    755          	SetVMC();
    756          
    757          	struct st_CAN_Message1 Send_Message;
    758          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    759          	Send_Message.Priority= 0x18;
    760          	Send_Message.PDU_Format= 0xFF;
    761          	Send_Message.PDU_Specific= 0xE7;
    762          	Send_Message.Source_Address= 0x28;
    763          	Write_CAN_Single(Send_Message);
    764          
    765          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    766          }
    767          
    768          u8 CheckResponseVMC(void)
    769          {
    770          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    771          		return RETURN_VMC_OK;
    772          	else
    773          		return RETURN_VMC_NOT_OK;
    774          }
    775          
    776          u8 CheckResponseAuthentication(u8 Auth)
    777          {
    778          	u8 output_buf[8];
    779          	u16 upper_cpk, lower_cpk;
    780          
    781          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    782          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    783          	
    784          	setCipherParam(upper_cpk, lower_cpk);
    785          	//setCipherParam(0x1122, 0x3344);	// 임시
    786          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    787          
    788          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    789          	
    790          	
    791          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    792          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    793          	{
    794          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    795          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    796          		{
    797          			return SMK_RESPONSE_FLAG_SUCCESS;
    798          		}
    799          		else
    800          			return recv_smartkey.Smk_Response_Flag;
    801          	}
    802          	else
    803          		return SMK_RESPONSE_CODE_NOT_MATCH;
    804          }
    805          
    806          void CheckResponseMsgComm(void)
    807          {
    808          	u8 output_buf[8];
    809          	u16 upper_cpk, lower_cpk;
    810          
    811          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    812          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    813          	
    814          	setCipherParam(upper_cpk, lower_cpk);
    815          	//setCipherParam(0x1122, 0x3344);	// 임시
    816          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    817          
    818          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    819          
    820          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    821          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    822          	{
    823          		if(recv_smartkey.Smk_Response_Code == 1)
    824          		{
    825          			switch(recv_smartkey.Smk_Response_Flag)
    826          			{
    827          				case 2 :
    828          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    829          					break;
    830          				case 3 :
    831          					SendSMKMsgResult(SMK_MSG_FAIL);
    832          					break;
    833          				case 4 :
    834          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    835          					break;
    836          				default :
    837          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    838          					{
    839          						if(recv_smartkey.Registered_Tag_Count == 1)
    840          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    841          						else if(recv_smartkey.Registered_Tag_Count == 2)
    842          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    843          						else
    844          							SendSMKMsgResult(SMK_MSG_FAIL);
    845          					}
    846          					else
    847          					{
    848          						if(SMK_Tag_Count != 0)
    849          							SMK_Tag_Count--;
    850          
    851          						SendSMKMsgResult(SMK_MSG_FAIL);
    852          					}
    853          					break;
    854          			}
    855          			
    856          		}
    857          		else if(recv_smartkey.Smk_Response_Code == 2)
    858          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    859          		else
    860          			SendSMKMsgResult(SMK_MSG_FAIL);
    861          	}
    862          	else
    863          		SendSMKMsgResult(SMK_MSG_FAIL);
    864          }
    865          
    866          
    867          void SmartKeyAuthentication(void)
    868          {
    869          	u8  Auth = 0;
    870          	u8 returnvalue;
    871          
    872          	if(AuthResult != 1)
    873          	{
    874          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    875          		{
    876          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    877          			{
    878          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    879          				RequestFirstAuthentication();
    880          			}
    881          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    882          			{
    883          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    884          				RequestSecondAuthentication();
    885          			}
    886          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    887          			{
    888          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    889          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    890          
    891          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    892          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    893          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    894          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    895          					
    896          				returnvalue = CheckResponseAuthentication(Auth);
    897          					
    898          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    899          				{
    900          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    901          					{
    902          						gAuthentication_Cnt = 0;
    903          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    904          					}
    905          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    906          					{
    907          						gAuthentication_Cnt = 0;
    908          						AuthResult = 1;
    909          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    910          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    911          						SMKSuccess = SMK_SUCCESS;
    912          						SendSMKAuthResult(SMK_SUCCESS);
    913          					}
    914          				}
    915          				else
    916          				{
    917          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    918          					{
    919          						//AuthResult = 2;
    920          						AuthResult = 1;
    921          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    922          						SMKSuccess = SMK_FAIL;
    923          						SendSMKAuthResult(SMK_FAIL);
    924          						return;
    925          					}
    926          
    927          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    928          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    929          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    930          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    931          				}
    932          			}
    933          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
    934          			{
    935          				//RequestFirstAuthentication();
    936          			}
    937          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
    938          			{
    939          				//RequestSecondAuthentication();
    940          			}
    941          		}
    942          	}
    943          	//else if(AuthResult == 1)
    944          	{
    945          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
    946          		{
    947          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
    948          			SMK_Msg_Send = 1;
    949          			smk_flag_data.recv_resp_packet = 0;
    950          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
    951          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
    952          		}
    953          
    954          		if(SMK_Msg_Send == 1)
    955          		{
    956          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
    957          			{
    958          				SMK_Msg_Send = 0;
    959          				CheckResponseMsgComm();
    960          			}
    961          		}
    962          	}
    963          }
    964          #endif
    965          /**
    966            * @brief  1msec OperationFunc
    967            * @param  None
    968            * @retval None
    969            */
    970          void WL9FM_1mSecOperationFunc(void)
    971          {
    972          #if 1
    973          	if( Flag_UartTxStart == 1 )
    974          	{
    975          		if (SendTime_E2PROM++ > 3) //	25msec
    976          		{
    977          			SendTime_E2PROM = 0;
    978          			SendTo_E2PROM();
    979          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
    980          		}			
    981          	}
    982          	// CAN_TX Routine
    983          	CAN_TX();
    984          	Write_UART_Single();
    985          #endif
    986          }
    987          
    988          /**
    989            * @brief  10msec OperationFunc
    990            * @param  None
    991            * @retval None
    992            */
    993          void WL9FM_10mSecOperationFunc(void)
    994          {
    995          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
    996          }
    997          
    998          /**
    999            * @brief  100msec OperationFunc
   1000            * @param  None
   1001            * @retval None
   1002            */
   1003          void WL9FM_100mSecOperationFunc(void)
   1004          {
   1005          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1006          
   1007          #if 1
   1008          	//if(Flag_TxE2pRomData == 1)
   1009          		SmartKeyAuthentication();
   1010          #endif
   1011          	
   1012          	if(LCDOffCount < 30)
   1013          	{
   1014          		LCDOffCount++;
   1015          		LCDBL_ONOFF(LCDBL_OFF);
   1016          	}
   1017          	else if(LCDOffCount == 30)
   1018          	{
   1019          		LCDOffCount++;
   1020          		LCDBL_ONOFF(LCDBL_ON);
   1021          	}
   1022          	else
   1023          	{
   1024          		LCDBL_ONOFF(LCDBL_ON);
   1025          	}
   1026          	
   1027          	if(CommErrCnt > 1000)
   1028             	{
   1029             		if( Flag_TxE2pRomData == 1 )
   1030          	   	{
   1031          	   		CAN_COMInit();
   1032             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1033          
   1034          			Buz1 = 0;
   1035                      //RTCSend();
   1036          			if(++SendRTCnt >= 10)
   1037          			{
   1038          				SendRTCnt = 0;
   1039          				
   1040          			}
   1041          	   	}
   1042          	}	
   1043          	if(OSUpdateCount < 200)
   1044          	{
   1045          		OSUpdateCount++;
   1046          	}
   1047          	else if(OSUpdateCount == 200)
   1048          	{
   1049          		OSUpdateCount++;
   1050          		System_CheckPowerIG();
   1051          	}
   1052          	else
   1053          	{
   1054          		System_CheckPowerIG();
   1055          	}
   1056          	
   1057          
   1058          	if(ST_Update)
   1059          	{
   1060          		if(UpdateMode < 10)
   1061          			UpdateMode++;
   1062          
   1063          		if(UpdateMode >= 10)
   1064          		{
   1065          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1066          			ST_Update=0;
   1067          		}
   1068          	}
   1069          		
   1070          	//	WL9A Monitor RESET Code
   1071          	if((SystemReset == 1) || (gRebootCmd == 1))
   1072          	{
   1073          		if(gRebootCmd == 1)
   1074          			SaveDataToEEPROM();
   1075          				
   1076          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1077          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1078          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1079          		return;
   1080          	}
   1081          
   1082          }
   1083          
   1084          void WL9FM_500mSecOperationFunc(void)
   1085          {
   1086          	if(CANUpdateFlag != 1)
   1087          		MonitorStatus_CAN_TX();
   1088          
   1089          }
   1090          
   1091          
   1092          
   1093          /**
   1094            * @brief  1sec OperationFunc
   1095            * @param  None
   1096            * @retval None
   1097            */
   1098          void WL9FM_1SecOperationFunc(void)
   1099          {
   1100          	if(UpdateMode < 10)
   1101          		read_clock();
   1102          
   1103          
   1104          	//  ++, kutelf, 131007
   1105          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1106          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1107          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1108          	{
   1109          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1110          			
   1111          		if ((Camera_CheckCnt % 3) == 0)
   1112          		{
   1113          			cam_mode_check();
   1114          		}
   1115          	}
   1116          	else
   1117          	{
   1118          		Camera_CheckCnt = 0;
   1119          	}
   1120          	//  --, kutelf, 131007
   1121          }
   1122          
   1123          
   1124          void WL9FM_System_Init_Start(void)
   1125          {
   1126          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1127          	if (SystemReset != 1)
   1128          	{
   1129          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1130          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1131          	}	
   1132          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1133          	WL9FM_EXYNOS_PMIC_PWRON();
   1134          	
   1135          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1136          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1137          	TW2835_Control_Init();	
   1138          	
   1139          	DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1140          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1141          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1142          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1143          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1144          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1145          												//		LAMP ALL ON
   1146          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1147          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1148          
   1149          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1150          
   1151          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1152          
   1153          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);       				//      COM2 : CAN
   1154          	USART_COMInit(COMPORT4);       				//      COM4 : CMDData
   1155          
   1156          												
   1157          	CAN_COMInit();								//	-> 	CAN_Control.c
   1158          	//InitE2PROM();
   1159          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1160          
   1161          	M25P32_Init();
   1162          
   1163          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1164          
   1165          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1166          
   1167          
   1168          }
   1169          
   1170          /**
   1171            * @brief  Application Program Start Point.
   1172            * @param  None
   1173            * @retval None
   1174            */
   1175          void WL9FM_Monitor_APP(void)
   1176          {
   1177          	DebugUART_Init();			//	->	Main.c
   1178          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1179          	//	System 강제 RESET시키기 위하여 goto lable 추가..	
   1180          	SYSTEM_RESET :
   1181          
   1182          	System_Configuration();		//  ->  System_Init.c
   1183          	                    		//      RCC, NVIC, GPIO Initialize
   1184          
   1185          	System_Initialize();		//	-> 	System_Init.c
   1186          
   1187          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1188          	//WL9FM_PowerIG(PowerIG_ON);
   1189          	System_Variable_Init();
   1190          	WL9FM_System_Init_Start();
   1191          	
   1192          	/* Infinite loop */
   1193          	while (1)
   1194          	{  
   1195          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1196          		{
   1197          			WL9FM_TIME.Flag_1mSec = 0;
   1198          
   1199          			//  WL9F_1mSecOperationState -> Func 실행..
   1200          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1201          			WL9FM_1mSecOperationFunc();
   1202          		}            
   1203          		
   1204          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1205          		{
   1206          			WL9FM_TIME.Flag_10mSec = 0;
   1207          
   1208          			//  WL9F_10mSecOperationState -> Func 실행..
   1209          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1210          			WL9FM_10mSecOperationFunc();
   1211          		}
   1212          		
   1213          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1214          		{
   1215          			WL9FM_TIME.Flag_100mSec = 0;
   1216          
   1217          			//  WL9F_100mSecOperationState -> Func 실행..
   1218          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1219          			WL9FM_100mSecOperationFunc();
   1220          
   1221          			#if 1
   1222          			//	WL9F Monitor RESET Code
   1223          			if((SystemReset == 1) || (gRebootCmd == 1))
   1224          			{
   1225          				goto SYSTEM_RESET;
   1226          			}
   1227          			#endif
   1228          		}
   1229          
   1230          		if(WL9FM_TIME.Flag_500mSec == 1)
   1231          		{
   1232          			WL9FM_TIME.Flag_500mSec = 0;
   1233          			WL9FM_500mSecOperationFunc();
   1234          		}
   1235          		
   1236          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1237          		{
   1238          			WL9FM_TIME.Flag_1Sec = 0;
   1239          
   1240          			//  WL9F_1SecOperationState -> Func 실행..
   1241          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1242          			WL9FM_1SecOperationFunc();
   1243                                  
   1244          		}
   1245          	}
   1246          }
   1247          
   1248          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SMK_SendToExynos
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetCPK
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> SetVMC
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      16   RequestSMKComm
        16   -> GetRandValue
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> SetVMC
        16   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SendSMKAuthResult
         0   -> SMK_SendToExynos
       0   SendSMKMsgResult
         0   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
         0   -> SMK_SendToExynos
        16   -> SMK_SendToExynos
       8   Srand
         8   -> READ_RTC
         0   -> srand
      24   System_CheckPowerIG
        24   -> Buzzer_Off
         0   -> CAN_ITConfig
        24   -> CAN_ITConfig
        24   -> KeySwitch_SendToEXYNOS
        24   -> LCDBL_ONOFF
        24   -> LCDBL_PWM_LEVEL
        24   -> LCD_POWER_ONOFF
        24   -> LED_POWER_ONOFF
        24   -> Lamp_Update_System
        24   -> SaveDataToEEPROM
        24   -> TimeDelay_msec
        24   -> USART_ITConfig
        24   -> WL9FM_EXYNOS_PMIC_PWRON
        24   -> WL9FM_EXYNOS_POWER_ONOFF
        24   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
        24   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         8   -> LCDBL_ONOFF
         8   -> Lamp_Update_System
         8   -> STM32_Update
         0   -> SaveDataToEEPROM
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         0   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      24   WL9FM_Monitor_APP
        24   -> CAN_TX
        24   -> DebugUART_Init
        24   -> KeySwitch_SendToEXYNOS
        24   -> MonitorStatus_CAN_TX
        24   -> SendTo_E2PROM
        24   -> System_Configuration
        24   -> System_Initialize
        24   -> System_Variable_Init
        24   -> WL9FM_100mSecOperationFunc
        24   -> WL9FM_System_Init_Start
        24   -> Write_UART_Single
        24   -> cam_mode_check
        24   -> read_clock
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         0   -> CAN_ITConfig
         8   -> DPRAM_Init
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> USART_COMInit_DMA
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_23
       4  ??DataTable28_24
       4  ??DataTable28_25
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      34  ??Subroutine1_0
      52  ?Subroutine0
       8  ACK_Multi_61184
       1  CTSFlag_61184
      88  CheckResponseAuthentication
     180  CheckResponseMsgComm
      20  CheckResponseVMC
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
      40  Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          LCDOffCount
          WL9FM_TIME
          OSUpdateCount
          LAMP_Update_Data
     118  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      20  Init_Smart_Key_valuable
       4  KeySwitch_Value
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     116  RequestFirstAuthentication
      72  RequestSMKComm
      18  RequestSMKElimination
      18  RequestSMKMessage
      20  RequestSMKRegistration
      78  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      12  SendSMKAuthResult
      18  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     256  SmartKeyAuthentication
      22  Srand
     244  System_CheckPowerIG
       1  TotalPacketNum
     174  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
      78  WL9FM_1SecOperationFunc
      48  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     218  WL9FM_Monitor_APP
       8  WL9FM_RTC
     130  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
      82  read_clock
      36  recv_smartkey
          gAuthentication_Cnt
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          send_smartkey
          rand_value
          smk_flag_data
       1  send_bkcu_data
       1  send_mcu_data

 
 2 841 bytes in section .bss
 3 814 bytes in section .text
 
 3 814 bytes of CODE memory
 2 841 bytes of DATA memory

Errors: none
Warnings: 6
