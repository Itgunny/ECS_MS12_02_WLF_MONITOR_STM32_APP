###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      26/Jun/2014  11:19:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Platform #
#                    \TaeHa - ECS\SRC\WL9F_Monitor_APP.c                      #
#    Command line =  "C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Platfor #
#                    m\TaeHa - ECS\SRC\WL9F_Monitor_APP.c" -D                 #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN "C:\Users\1\Desktop\140626       #
#                    울산\WL_F_Monitor_APP\Project\Debug\List\" -o            #
#                    "C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Project #
#                    \Debug\Obj\" --debug --endian=little --cpu=Cortex-M4 -e  #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\arm\INC\c\DLib_Config_Full.h" -I                 #
#                    "C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Project #
#                    \..\Platform\COMMON\INC\" -I "C:\Users\1\Desktop\140626  #
#                    울산\WL_F_Monitor_APP\Project\..\Platform\TaeHa -        #
#                    ECS\INC\" -I "C:\Users\1\Desktop\140626                  #
#                    울산\WL_F_Monitor_APP\Project\..\Libraries\CMSIS\Device\ #
#                    ST\STM32F4xx\Include\" -I "C:\Users\1\Desktop\140626     #
#                    울산\WL_F_Monitor_APP\Project\..\Libraries\STM32F4xx_Std #
#                    Periph_Driver\inc\" -Oh --use_c++_inline -I              #
#                    "C:\Tools\IAR Systems\arm\CMSIS\Include\"                #
#    List file    =  C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Project\ #
#                    Debug\List\WL9F_Monitor_APP.lst                          #
#    Object file  =  C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Project\ #
#                    Debug\Obj\WL9F_Monitor_APP.o                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\1\Desktop\140626 울산\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          u8 AuthResult;
     80          u8 SMK_Msg_Send;
     81          u8 SMK_Tag_Count;
     82          u8 MultiPacketSendOrder = 0;
     83          u8 TotalPacketNum = 0;
     84          u8 DiffMachInfo = 0;
     85          u8 gStartHCE_DT = 0;
     86          u8 MachInfoSendCnt = 0;
     87          u8 MoniInfoSendCnt = 0;
     88          
     89          u8 RTSFlag_61184 = 0;
     90          u8 CTSFlag_61184 = 0;
     91          u8 RMCU_CTSFlag_61184 = 0;
     92          u8 RecvTotalPacket_61184 = 0;
     93          u8 RMCU_RecvTotalPacket_61184 = 0;
     94          u8 ACK_Multi_61184[8];
     95          u8 RMCU_ACK_Multi_61184[8];
     96          
     97          u8 Flag_UartTxStart = 0;
     98          u8  SendTime_E2PROM = 0;
     99          
    100          u16 Flag_1Sec_MachInfo = 0;
    101          u16 Flag_1Sec_MoniInfo = 0;
    102          u16 Flag_1Min = 0;
    103          
    104          u8 MachInfoTotalPacketNum = 0;
    105          u8 MoniInfoTotalPacketNum = 0;
    106          u8 Flag_200mSec = 0;
    107          u8 SendRTCnt = 0;
    108          u16 adc_value = 0;
    109          
    110          u8 SerialMsgRTC[16];
    111          u8 eepRomReadData1[32];
    112          u8 MoniInfoData[21];
    113          u8 McuInfoData2[4];
    114          u8 McuInfoData3[4];
    115          u8 McuInfoData4[4];
    116          
    117          u8 SystemReset = 0;
    118          u8 E2PROM_Save = 0;
    119          u8 PwrOffCnt = 0;
    120          u8 gRebootCmd = 0;
    121          
    122          
    123          u8 send_mcu_data=0;
    124          u8 send_bkcu_data=0;
    125          
    126          u8 ST_Update=0;
    127          
    128          extern u8 Uart2_RxMsg_Single_252[8];
    129          extern u8 Uart2_RxMsg_Single_253[8];
    130          extern u8 Uart2_RxMsg_Single_239[8];
    131          extern u8 Uart2_RxMsg_Single_239_121[8];
    132          extern u8 Uart2_RxMsg_Single_247[8];
    133          extern u8 Uart2_RxMsg_Save_Data1[8];
    134          extern u8 Uart2_RxMsg_Save_Data2[8];
    135          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    136          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    137          extern u8 McuInfoData1[79];
    138          extern u8 tmpMcuInfoData[78];
    139          
    140          extern u8 stop_send_as_phone_data;
    141          extern u8 Flag_TxE2pRomData;
    142          
    143          extern u8 Buz1;
    144          
    145          extern u8 Stm32_Update_CMD;
    146          /* Private function prototypes -----------------------------------------------*/
    147          /* Private functions ---------------------------------------------------------*/
    148          
    149          void Init_RTC(void)
    150          {
    151          	WL9FM_RTC.Year   = 0;
    152          	WL9FM_RTC.Month  = 1;
    153          	WL9FM_RTC.Date   = 1;
    154          	WL9FM_RTC.Day    = 1;
    155          	WL9FM_RTC.Hour   = 12;
    156          	WL9FM_RTC.Minute = 0;
    157          	WL9FM_RTC.Second = 0;
    158          
    159          	WRITE_RTC(WL9FM_RTC);
    160          }
    161          void InitE2PROM(void)
    162          {
    163          	u8 i;
    164          	u8 tmpBuf1[8];
    165          	u8 tmpBuf2[8];
    166          	u8 tmpBuf3[8];
    167          	u8 tmpBuf4[21];
    168          	
    169          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    170          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    171          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    172          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    173          
    174          	SaveE2PROM1->WorkLoad 				= 0;
    175          	SaveE2PROM1->testWorkLoad 			= 0;
    176          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    177          	SaveE2PROM1->DispType	 			= 0;
    178          	SaveE2PROM1->InfoViewPriority 		= 0;
    179          	SaveE2PROM1->UnitPressure 			= 0;
    180          	SaveE2PROM1->Reserved0 				= 0;
    181          	SaveE2PROM1->Lang 					= 0;
    182          	SaveE2PROM1->ManualBackLight 		= 7;
    183          	SaveE2PROM1->AutoBackLight 			= 0;
    184          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    185          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    186          	SaveE2PROM1->InfoViewCnt 			= 2;
    187          	SaveE2PROM1->HR_Start 				= 0;
    188          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    189          	SaveE2PROM1->ActiveCamNum 			= 1;
    190          	SaveE2PROM1->FirstCam 				= 0;
    191          	SaveE2PROM1->SecondCam 				= 1;
    192          	SaveE2PROM1->ThirdCam 				= 2;
    193          	SaveE2PROM1->Reserved1 				= 0;
    194          
    195          	SaveE2PROM2->LightMode 				= 0;
    196          	SaveE2PROM2->JobTimeView 			= 0;
    197          	SaveE2PROM2->OdoMeterView 			= 0;
    198          	SaveE2PROM2->JobOdoSelect 			= 0;
    199          	SaveE2PROM2->LightLowTime 			= 8;
    200          	SaveE2PROM2->LightUpperTime 		= 16;
    201          	SaveE2PROM2->AutoLightDay 			= 0;
    202          	SaveE2PROM2->AutoLightNight 		= 0;
    203          	SaveE2PROM2->Reserved1 				= 0;
    204          
    205          	SaveE2PROM3->Phone_1  				= 0;
    206          	SaveE2PROM3->Phone_2  				= 8;
    207          	SaveE2PROM3->Phone_3  				= 0;
    208          	SaveE2PROM3->Phone_4  				= 5;
    209          	SaveE2PROM3->Phone_5  				= 5;
    210          	SaveE2PROM3->Phone_6  				= 5;
    211          	SaveE2PROM3->Phone_7  				= 8;
    212          	SaveE2PROM3->Phone_8  				= 2;
    213          	SaveE2PROM3->Phone_9  				= 7;
    214          	SaveE2PROM3->Phone_10 				= 2;
    215          	SaveE2PROM3->Phone_11 				= 0xf;
    216          	SaveE2PROM3->Phone_12 				= 0xf;
    217          
    218          #if 1	// Monitor Change History - temp
    219          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    220          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    221          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    222          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    223          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    224          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    225          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    226          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    227          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    228          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    229          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    230          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    231          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    232          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    233          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    234          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    235          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    236          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    237          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    238          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    239          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    240          #endif
    241          
    242          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    243          
    244          	EEPROM_Write(0, 0);	// tmp
    245          	EEPROM_Write(0, 0);	// tmp
    246          	EEPROM_Write(0, 0);	// tmp
    247          
    248          	for(i = 0 ; i < 8 ; i++)
    249          	{
    250          		EEPROM_Write(i+8, tmpBuf1[i]);
    251          		TimeDelay_msec(5);
    252          		EEPROM_Write(i+16, tmpBuf2[i]);
    253          		TimeDelay_msec(5);
    254          		EEPROM_Write(i+24, tmpBuf3[i]);
    255          		TimeDelay_msec(5);
    256          	}
    257          
    258          	SerialPutString("Initialize : 30 %%\n\r");
    259          	
    260          #if 1	// Monitor Change History - temp
    261          	for(i = 0 ; i < 21 ; i++)
    262          	{
    263          		EEPROM_Write(i+50, tmpBuf4[i]);
    264          		TimeDelay_msec(5);
    265          	}
    266          #endif
    267          
    268          	for(i = 0 ; i < 79 ; i++)
    269          	{
    270          		EEPROM_Write(i+100, 0xff);
    271          		TimeDelay_msec(5);
    272          	}
    273          
    274          	SerialPutString("Initialize : 60 %%\n\r");
    275          
    276          	for(i = 0 ; i < 30 ; i++)
    277          	{
    278          		EEPROM_Write(i+200, 0xff);
    279          		TimeDelay_msec(5);
    280          	}
    281          
    282          	for(i = 0 ; i < 29 ; i++)
    283          	{
    284          		EEPROM_Write(i+230, 0xff);
    285          		TimeDelay_msec(5);
    286          	}
    287          
    288          	SerialPutString("Initialize : 95 %%\n\r");
    289          	Init_RTC();
    290          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    291          }
    292          
    293          void ReadE2PROM_ToSend()
    294          {
    295          #if 1
    296          	u8 i;
    297          
    298          	adc_value = (ADC1->DR & 0x0000FFFF);
    299          
    300          	i = EEPROM_Read(0);	
    301          	i = EEPROM_Read(0);
    302          	i = EEPROM_Read(0);
    303          	i = 0;
    304              
    305          	adc_value = (ADC1->DR & 0x0000FFFF);
    306          
    307          	for(i = 0 ; i < 24 ; i++)
    308          		eepRomReadData1[i] = EEPROM_Read(i+8);
    309          
    310          	for(i = 0 ; i < 8 ; i++)
    311          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    312          
    313          	for(i = 0 ; i < 8 ; i++)
    314          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    315          
    316          	for(i = 0 ; i < 8 ; i++)
    317          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    318          
    319          	for(i = 0 ; i < 21 ; i++)
    320          		MoniInfoData[i] = EEPROM_Read(i+50);
    321          	
    322          	for(i = 0 ; i < 79 ; i++)
    323          		McuInfoData1[i] = EEPROM_Read(i+100);
    324          
    325          	for(i = 0 ; i < 4 ; i++)
    326          		McuInfoData2[i] = EEPROM_Read(i+200);
    327          
    328          	for(i = 0 ; i < 4 ; i++)
    329          		McuInfoData3[i] = EEPROM_Read(i+210);
    330          
    331          	for(i = 0 ; i < 4 ; i++)
    332          		McuInfoData4[i] = EEPROM_Read(i+220);
    333          
    334          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    335          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    336          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    337          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    338          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    339          
    340          
    341          	adc_value = (ADC1->DR & 0x0000FFFF);
    342          	
    343          	eepRomReadData1[12] = (adc_value & 0xff);
    344          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    345          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    346          
    347          #endif
    348          }
    349          
    350          void Send_Multipacket_61184_23(void)
    351          {
    352          	if(RTSFlag_61184 == 1)
    353          	{
    354          		TimeDelay_msec(15);
    355          		SendTP_CM_BAM_MultiPacket_61184_23();
    356          		TotalPacketNum += 1;
    357          		RTSFlag_61184 = 0;
    358          	}
    359          	else if(RTSFlag_61184 == 2)
    360          	{
    361          		TimeDelay_msec(15);
    362          		SendMultiPacketData_61184_23(TotalPacketNum);
    363          		TotalPacketNum += 1;
    364          
    365          		if(TotalPacketNum >= 3)
    366          		{
    367          			Flag_SerialRxMsg &= ~(RX_MSG23);
    368          			TotalPacketNum = 0;
    369          		}
    370          	}
    371          }
    372          
    373          void Send_Multipacket_145(void)
    374          {
    375          	if(TotalPacketNum == 0)
    376          	{
    377          		TimeDelay_msec(15);
    378          		SendTP_CM_BAM_MultiPacket_145();
    379          		TotalPacketNum += 1;
    380          	}
    381          	else
    382          	{
    383          		TimeDelay_msec(15);
    384          		SendMultiPacketData_145(TotalPacketNum);
    385          		TotalPacketNum += 1;
    386          
    387          		if(TotalPacketNum > tp_cm_bam_TotPacketNum)
    388          		{
    389          			Flag_SerialRxMsg &= ~(RX_MSG145);
    390          			TotalPacketNum = 0;
    391          		}
    392          	}
    393          }
    394          
    395          
    396          
    397          void read_clock(void)
    398          {
    399          	READ_RTC(&WL9FM_RTC);
    400          	SerialMsgRTC[8] = WL9FM_RTC.Hour;
    401          	SerialMsgRTC[9] = WL9FM_RTC.Minute;
    402          }
    403          
    404          void SaveDataToEEPROM(void)
    405          {
    406          	u8 i;
    407          	
    408          	for(i = 0 ; i < 8 ; i++)
    409          	{
    410          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    411          		TimeDelay_msec(1);
    412          	}
    413          
    414          	for(i = 0 ; i < 8 ; i++)
    415          	{
    416          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    417          		TimeDelay_msec(1);
    418          	}
    419          
    420          	for(i = 0 ; i < 8 ; i++)
    421          	{
    422          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    423          		TimeDelay_msec(1);
    424          	}
    425          
    426          	for(i = 0 ; i < 21 ; i++)
    427          	{
    428          		EEPROM_Write(i+50, MoniInfoData[i]);
    429          		TimeDelay_msec(1);
    430          	}
    431          	
    432          	for(i = 0 ; i < 79 ; i++)
    433          	{
    434          		EEPROM_Write(i+100, McuInfoData1[i]);
    435          		TimeDelay_msec(1);
    436          	}
    437          
    438          
    439          	if(DiffMachInfo == 1)
    440          	{
    441          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    442          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    443          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    444          	}
    445          
    446          	for(i = 0 ; i < 4 ; i++)
    447          	{
    448          		EEPROM_Write(i+200, McuInfoData2[i]);
    449          		TimeDelay_msec(1);
    450          	}
    451          
    452          	for(i = 0 ; i < 4 ; i++)
    453          	{
    454          		EEPROM_Write(i+210, McuInfoData3[i]);
    455          		TimeDelay_msec(1);
    456          	}
    457          
    458          	for(i = 0 ; i < 4 ; i++)
    459          	{
    460          		EEPROM_Write(i+220, McuInfoData4[i]);
    461          		TimeDelay_msec(1);
    462          	}
    463          }
    464          
    465          
    466          void System_CheckPowerIG()
    467          {
    468          	// Check POWER IG
    469          	if(!WL9FM_GetPowerIG())
    470          	{
    471          		WL9FM_PowerIG(PowerIG_ON);
    472          		SystemReset = 0;
    473          	}
    474          	else
    475          	{
    476          		if(E2PROM_Save == 0)
    477          		{
    478          			SaveDataToEEPROM();
    479          
    480          			PwrOffCnt = 0;
    481          
    482          			while(1)
    483          			{
    484          				if(!WL9FM_GetPowerIG())
    485          				{
    486          					//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    487          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    488          					CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
    489          
    490          					WL9FM_PowerIG(PowerIG_ON);	// System Reset
    491          					//SystemReset = 1;
    492          					SystemReset = 0;
    493          					return;
    494          				}
    495          			
    496          				TimeDelay_msec(100);
    497          
    498          				PwrOffCnt++;
    499          				if(PwrOffCnt >= 15)	//	100msec 마다 15번 체크 -> 1.5초..
    500          					break;
    501          			}
    502          
    503          			Buzzer_Off();
    504          
    505          			//	POWER OFF Code를 3msec 마다 2번 SPICA로 보낸다. 
    506          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	
    507          			TimeDelay_msec(3);
    508          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	
    509          			TimeDelay_msec(3);
    510          
    511          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    512          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    513          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    514          
    515          			//	엔딩화면 딜레이 시간
    516          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    517          
    518          			LAMP_Update_Data = LAMP_ALL_OFF;
    519          			Lamp_Update_System();
    520          			
    521          			TimeDelay_msec(1200);
    522          
    523          			LCDBL_PWM_LEVEL(0);                         	//  LCDBL PWM LEVEL0
    524          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On!!!
    525          	
    526          
    527          			LCD_POWER_ONOFF(LCDPWR_OFF);                        //  LCD Power Off
    528          			LED_POWER_ONOFF(LED_OFF);                        	//  LED Off
    529          
    530          			
    531          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    532          			TimeDelay_msec(100);
    533          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);
    534          			
    535          			WL9FM_EXYNOS_PMIC_ONOFF();
    536          				
    537          			
    538          			
    539          			
    540          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    541          			
    542          			
    543          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    544          			TimeDelay_msec(1000);
    545          			if(!WL9FM_GetPowerIG())
    546          			{
    547          				WL9FM_PowerIG(PowerIG_ON);
    548          				SystemReset = 1;
    549          				return;
    550          			}
    551          
    552          			WL9FM_PowerIG(PowerIG_OFF);                    //  24v Main Power Off	    
    553          
    554          			
    555          		}
    556          	}
    557          }
    558          
    559          /*******************************************************************************
    560          *
    561          *	Smart Key Test Function
    562          *
    563          *******************************************************************************/
    564          #if 0
    565          void SendSMKAuthResult(u8 result)
    566          {
    567          	RTC_SendToExynos( result, SMK_Tag_Count );
    568          }
    569          
    570          void SendSMKMsgResult(u8 result)
    571          {
    572          	RTC_SendToExynos( result, recv_smartkey.Registered_Tag_Count );
    573          }
    574          
    575          void SetTagLevel(u8 level)
    576          {
    577          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    578          		send_smartkey.TagLevel = level;
    579          	else
    580          		send_smartkey.TagLevel = 3;
    581          }
    582          
    583          void SetTagCmd(u8 cmd)
    584          {
    585          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    586          		send_smartkey.TagCommand = cmd;
    587          	else
    588          		send_smartkey.TagCommand = 0xf;
    589          }
    590          
    591          void SetVMC(void)
    592          {
    593          	if(rand_value.rand_vmc <= 64255)
    594          		send_smartkey.VMC = rand_value.rand_vmc;
    595          	else
    596          		send_smartkey.VMC = 0xffff;
    597          }
    598          
    599          void SetCPK(void)
    600          {
    601          #if 1
    602          	if(rand_value.rand_cpk <= 0xfaffffff)
    603          		send_smartkey.CPK = rand_value.rand_cpk;
    604          	else
    605          		send_smartkey.CPK = 0xffffffff;
    606          #else
    607          	send_smartkey.CPK = 0x11223344;
    608          #endif
    609          }
    610          
    611          void Srand()
    612          {
    613          	READ_RTC(&WL9FM_RTC);
    614          	srand((u32)WL9FM_RTC.Second);
    615          }
    616          
    617          void GetRandValue(u8 random)
    618          {
    619          	if(random == GET_VMC)	
    620          		rand_value.rand_vmc = (rand() % 64255);
    621          	else if(random == GET_CPK)	
    622          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    623          	else if(random == GET_VMC_CPK)		
    624          	{
    625          		rand_value.rand_vmc = (rand() % 64255);
    626          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    627          	}	
    628          }
    629          
    630          void RequestFirstAuthentication(void)
    631          {
    632          	unsigned int temp;
    633          	
    634          	SetTagLevel(TAG_LEVEL_NORMAL);
    635          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    636          	GetRandValue(GET_VMC_CPK);
    637          	SetVMC();
    638          	SetCPK();
    639          
    640          	setCipherParam(0x8085, 0x8087);
    641          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    642          	
    643          	send_smartkey.CPK = temp;
    644          
    645          	// CPK 암호화 Function 추가 필요
    646          	TimeDelay_msec(10);
    647          	SetCanID(255, 231, 6);
    648          	CAN_TX_Data((u8*)&send_smartkey);
    649          }
    650          
    651          void RequestSecondAuthentication(void)
    652          {
    653          	unsigned short upper_cpk, lower_cpk;
    654          	unsigned int temp;
    655          
    656          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    657          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    658          	
    659          	SetTagLevel(TAG_LEVEL_NORMAL);
    660          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    661          	GetRandValue(GET_VMC);
    662          	SetVMC();
    663          
    664          	setCipherParam(upper_cpk, lower_cpk);
    665          	//setCipherParam(0x1122, 0x3344);
    666          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    667          
    668          	send_smartkey.CPK = temp;
    669          	
    670          	TimeDelay_msec(10);
    671          	SetCanID(255, 231, 6);
    672          	CAN_TX_Data((u8*)&send_smartkey);
    673          
    674          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    675          }
    676          
    677          void RequestSMKRegistration(void)
    678          {
    679          	unsigned short upper_cpk, lower_cpk;
    680          	unsigned int temp;
    681          
    682          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    683          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    684          	
    685          	SetTagLevel(TAG_LEVEL_NORMAL);
    686          	SetTagCmd(TAG_CMD_REGISTRATION);
    687          	GetRandValue(GET_VMC);
    688          	SetVMC();
    689          
    690          	setCipherParam(upper_cpk, lower_cpk);
    691          	//setCipherParam(0x1122, 0x3344);
    692          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    693          
    694          	send_smartkey.CPK = temp;
    695          
    696          	SetCanID(255, 231, 6);
    697          	CAN_TX_Data((u8*)&send_smartkey);
    698          
    699          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    700          }
    701          
    702          void RequestSMKElimination(void)
    703          {
    704          	unsigned short upper_cpk, lower_cpk;
    705          	unsigned int temp;
    706          
    707          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    708          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    709          	
    710          	SetTagLevel(TAG_LEVEL_NORMAL);
    711          	SetTagCmd(TAG_CMD_ELIMINATION);
    712          	GetRandValue(GET_VMC);
    713          	SetVMC();
    714          
    715          	setCipherParam(upper_cpk, lower_cpk);
    716          	//setCipherParam(0x1122, 0x3344);
    717          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    718          
    719          	send_smartkey.CPK = temp;
    720          
    721          	SetCanID(255, 231, 6);
    722          	CAN_TX_Data((u8*)&send_smartkey);
    723          
    724          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    725          }
    726          
    727          void RequestSMKMessage(u8 Msg)
    728          {
    729          	if(Msg == 1)
    730          		RequestSMKRegistration();
    731          	else if(Msg == 2)
    732          		RequestSMKElimination();
    733          }
    734          
    735          void RequestSMKComm(void)
    736          {
    737          	SetTagLevel(TAG_LEVEL_NORMAL);
    738          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    739          	GetRandValue(GET_VMC);
    740          	SetVMC();
    741          
    742          	SetCanID(255, 231, 6);
    743          	CAN_TX_Data((u8*)&send_smartkey);
    744          
    745          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    746          }
    747          
    748          u8 CheckResponseVMC(void)
    749          {
    750          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    751          		return RETURN_VMC_OK;
    752          	else
    753          		return RETURN_VMC_NOT_OK;
    754          }
    755          
    756          u8 CheckResponseAuthentication(u8 Auth)
    757          {
    758          	u8 output_buf[8];
    759          	u16 upper_cpk, lower_cpk;
    760          
    761          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    762          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    763          	
    764          	setCipherParam(upper_cpk, lower_cpk);
    765          	//setCipherParam(0x1122, 0x3344);	// 임시
    766          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    767          
    768          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    769          	
    770          	
    771          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    772          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    773          	{
    774          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    775          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    776          		{
    777          			return SMK_RESPONSE_FLAG_SUCCESS;
    778          		}
    779          		else
    780          			return recv_smartkey.Smk_Response_Flag;
    781          	}
    782          	else
    783          		return SMK_RESPONSE_CODE_NOT_MATCH;
    784          }
    785          
    786          void CheckResponseMsgComm(void)
    787          {
    788          	u8 output_buf[8];
    789          	u16 upper_cpk, lower_cpk;
    790          
    791          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    792          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    793          	
    794          	setCipherParam(upper_cpk, lower_cpk);
    795          	//setCipherParam(0x1122, 0x3344);	// 임시
    796          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    797          
    798          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    799          
    800          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    801          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    802          	{
    803          		if(recv_smartkey.Smk_Response_Code == 1)
    804          		{
    805          			switch(recv_smartkey.Smk_Response_Flag)
    806          			{
    807          				case 2 :
    808          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    809          					break;
    810          				case 3 :
    811          					SendSMKMsgResult(SMK_MSG_FAIL);
    812          					break;
    813          				case 4 :
    814          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    815          					break;
    816          				default :
    817          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    818          					{
    819          						if(recv_smartkey.Registered_Tag_Count == 1)
    820          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    821          						else if(recv_smartkey.Registered_Tag_Count == 2)
    822          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    823          						else
    824          							SendSMKMsgResult(SMK_MSG_FAIL);
    825          					}
    826          					else
    827          					{
    828          						if(SMK_Tag_Count != 0)
    829          							SMK_Tag_Count--;
    830          
    831          						SendSMKMsgResult(SMK_MSG_FAIL);
    832          					}
    833          					break;
    834          			}
    835          			
    836          		}
    837          		else if(recv_smartkey.Smk_Response_Code == 2)
    838          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    839                          else
    840                                  SendSMKMsgResult(SMK_MSG_FAIL);
    841          	}
    842          	else
    843          		SendSMKMsgResult(SMK_MSG_FAIL);
    844          }
    845          
    846          void SmartKeyAuthentication(void)
    847          {
    848          	u8  Auth = 0;
    849          	u8 returnvalue;
    850          
    851          	if(AuthResult != 1)
    852          	{
    853          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    854          		{
    855          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    856          			{
    857          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    858          				RequestFirstAuthentication();
    859          			}
    860          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    861          			{
    862          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    863          				RequestSecondAuthentication();
    864          			}
    865          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    866          			{
    867          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    868          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    869          
    870          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    871          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    872          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    873          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    874          					
    875          				returnvalue = CheckResponseAuthentication(Auth);
    876          					
    877          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    878          				{
    879          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    880          					{
    881          						gAuthentication_Cnt = 0;
    882          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    883          					}
    884          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    885          					{
    886          						gAuthentication_Cnt = 0;
    887          						AuthResult = 1;
    888          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    889          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    890          						SendSMKAuthResult(SMK_SUCCESS);
    891          					}
    892          				}
    893          				else
    894          				{
    895          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    896          					{
    897          						//AuthResult = 2;
    898          						AuthResult = 1;
    899          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    900          						SendSMKAuthResult(SMK_FAIL);
    901          						return;
    902          					}
    903          
    904          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    905          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    906          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    907          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    908          				}
    909          			}
    910          		}
    911          	}
    912          	//else if(AuthResult == 1)
    913          	{
    914          		if((Uart2_RxMsg_Smk_Reg_Eli[0] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[0] == 2)) 
    915          		{
    916          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[0]);
    917          			SMK_Msg_Send = 1;
    918          			smk_flag_data.recv_resp_packet = 0;
    919          			Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
    920          			Uart2_RxMsg_Smk_Reg_Eli[0] = 0xff;
    921          		}
    922          
    923          		if(SMK_Msg_Send == 1)
    924          		{
    925          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
    926          			{
    927          				SMK_Msg_Send = 0;
    928          				CheckResponseMsgComm();
    929          			}
    930          		}
    931          	}
    932          }
    933          #endif
    934          /**
    935            * @brief  1msec OperationFunc
    936            * @param  None
    937            * @retval None
    938            */
    939          void WL9FM_1mSecOperationFunc(void)
    940          {
    941          #if 1
    942          	if( Flag_UartTxStart == 1 )
    943          	{
    944          		if (SendTime_E2PROM++ > 3) //	25msec
    945          		{
    946          			SendTime_E2PROM = 0;
    947          			SendTo_E2PROM();
    948          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
    949          		}			
    950          	}
    951          #endif
    952          }
    953          
    954          /**
    955            * @brief  10msec OperationFunc
    956            * @param  None
    957            * @retval None
    958            */
    959          void WL9FM_10mSecOperationFunc(void)
    960          {
    961          	Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
    962          	//Lamp_Update_System();  
    963          	if(Flag_SerialRxMsg != 0)
    964          	{
    965          		if((Flag_SerialRxMsg & RX_MSG11) != 0)
    966          		{
    967          			Flag_SerialRxMsg &= ~(RX_MSG11);
    968          			SetCanID(239, 71, 6);
    969          			CAN_TX_Data(&Uart2_RxMsg_Single_11[0]);
    970          		}
    971          
    972          		if((Flag_SerialRxMsg & RX_MSG12) != 0)
    973          		{
    974          			Flag_SerialRxMsg &= ~(RX_MSG12);
    975          			SetCanID(239, 71, 6);
    976          			CAN_TX_Data(&Uart2_RxMsg_Single_12[0]);
    977          		}
    978          
    979          		if((Flag_SerialRxMsg & RX_MSG21) != 0)
    980          		{
    981          			Flag_SerialRxMsg &= ~(RX_MSG21);
    982          			SetCanID(239, 71, 6);
    983          			CAN_TX_Data(&Uart2_RxMsg_Single_21[0]);
    984          		}
    985          
    986          		if((Flag_SerialRxMsg & RX_MSG23) != 0)
    987          		{
    988          			Send_Multipacket_61184_23();
    989          		}
    990          
    991          		if((Flag_SerialRxMsg & RX_MSG61) != 0)
    992          		{
    993          			Flag_SerialRxMsg &= ~(RX_MSG61);
    994          			SetCanID(239, 71, 6);
    995          			CAN_TX_Data(&Uart2_RxMsg_Single_61[0]);
    996          		}
    997          
    998          		if((Flag_SerialRxMsg & RX_MSG62) != 0)
    999          		{
   1000          			Flag_SerialRxMsg &= ~(RX_MSG62);
   1001          			SetCanID(239, 71, 6);
   1002          			CAN_TX_Data(&Uart2_RxMsg_Single_62[0]);
   1003          		}
   1004          
   1005          		if((Flag_SerialRxMsg & RX_MSG101) != 0)
   1006          		{
   1007          			Flag_SerialRxMsg &= ~(RX_MSG101);
   1008          			SetCanID(239, 71, 6);
   1009          			CAN_TX_Data(&Uart2_RxMsg_Single_101[0]);
   1010          		}
   1011          
   1012          		if((Flag_SerialRxMsg & RX_MSG104) != 0)
   1013          		{
   1014          			Flag_SerialRxMsg &= ~(RX_MSG104);
   1015          			SetCanID(239, 71, 6);
   1016          			CAN_TX_Data(&Uart2_RxMsg_Single_104[0]);
   1017          		}
   1018          
   1019          		if((Flag_SerialRxMsg & RX_MSG105) != 0)
   1020          		{
   1021          			Flag_SerialRxMsg &= ~(RX_MSG105);
   1022          			SetCanID(239, 71, 6);
   1023          			CAN_TX_Data(&Uart2_RxMsg_Single_105[0]);
   1024          		}
   1025          
   1026          		if((Flag_SerialRxMsg & RX_MSG109) != 0)
   1027          		{
   1028          			Flag_SerialRxMsg &= ~(RX_MSG109);
   1029          			SetCanID(239, 71, 6);
   1030          			CAN_TX_Data(&Uart2_RxMsg_Single_109[0]);
   1031          			if(Uart2_RxMsg_Single_109[2] != 0xFF )
   1032          			{	
   1033          				WL9FM_RTC.Hour = Uart2_RxMsg_Single_109[2];
   1034          				WL9FM_RTC.Minute= Uart2_RxMsg_Single_109[3];
   1035          			
   1036          				WRITE_RTC(WL9FM_RTC);
   1037          			}
   1038          		}
   1039          
   1040          		if((Flag_SerialRxMsg & RX_MSG121) != 0)
   1041          		{
   1042          			Flag_SerialRxMsg &= ~(RX_MSG121);
   1043          			SetCanID(239, 71, 6);
   1044          			CAN_TX_Data(&Uart2_RxMsg_Single_121[0]);
   1045          			SetCanID(239, 52, 6);
   1046          			CAN_TX_Data(&Uart2_RxMsg_Single_121[0]);
   1047          		}
   1048          
   1049          		if((Flag_SerialRxMsg & RX_MSG123) != 0)
   1050          		{
   1051          			Flag_SerialRxMsg &= ~(RX_MSG123);
   1052          			SetCanID(239, 71, 6);
   1053          			CAN_TX_Data(&Uart2_RxMsg_Single_123[0]);
   1054          		}
   1055          
   1056          		if((Flag_SerialRxMsg & RX_MSG201) != 0)
   1057          		{
   1058          			Flag_SerialRxMsg &= ~(RX_MSG201);
   1059          			SetCanID(239, 71, 6);
   1060          			CAN_TX_Data(&Uart2_RxMsg_Single_201[0]);
   1061          		}
   1062          
   1063          		if((Flag_SerialRxMsg & RX_MSG203) != 0)
   1064          		{
   1065          			Flag_SerialRxMsg &= ~(RX_MSG203);
   1066          			SetCanID(239, 228, 6);		// EHCU
   1067          			CAN_TX_Data(&Uart2_RxMsg_Single_203[0]);
   1068          		}
   1069          
   1070          		if((Flag_SerialRxMsg & RX_MSG145) != 0)
   1071          		{
   1072          			Send_Multipacket_145();
   1073          		}
   1074          
   1075          		
   1076          		if((Flag_SerialRxMsg & RX_MSG247) != 0)
   1077          		{
   1078          			Flag_SerialRxMsg &= ~(RX_MSG247);
   1079          			SetCanID(255, 247, 6);
   1080          			CAN_TX_Data(&Uart2_RxMsg_Single_247[0]);
   1081          		}
   1082          	}
   1083          	
   1084          	#if 0
   1085          	if(Flag_SerialRxMsg != 0)
   1086          	{
   1087          		if((Flag_SerialRxMsg & RX_MSG247) != 0)
   1088          		{
   1089          			Flag_SerialRxMsg &= ~(RX_MSG247);
   1090          			SetCanID(255, 247, 6);
   1091          			CAN_TX_Data(&Uart2_RxMsg_Single_247[0]);
   1092          		}
   1093          		
   1094          		if((Flag_SerialRxMsg & RX_MSG253) != 0)
   1095          		{
   1096          			Flag_SerialRxMsg &= ~(RX_MSG253);
   1097          			SetCanID(255, 253, 6);
   1098          			CAN_TX_Data(&Uart2_RxMsg_Single_253[0]);
   1099          		}
   1100          		
   1101          		if((Flag_SerialRxMsg & RX_MSG203) != 0)	    // 61184 -203 
   1102          		{
   1103          			Flag_SerialRxMsg &= ~(RX_MSG203);
   1104          			SetCanID(239, 228, 6);
   1105          			CAN_TX_Data(&Uart2_RxMsg_Single_46[0]);
   1106          		}
   1107          
   1108          		if((Flag_SerialRxMsg & RX_MSG69) != 0)	    // 69 - Single Packet
   1109          		{
   1110          			Flag_SerialRxMsg &= ~(RX_MSG69);
   1111          			SetCanID(255, 69, 6);
   1112          			CAN_TX_Data(&Uart2_RxMsg_Single_69[0]);
   1113          		}
   1114          		
   1115          		if((Flag_SerialRxMsg & RX_MSG163) != 0)
   1116          		{
   1117          			Flag_SerialRxMsg &= ~(RX_MSG163);
   1118          			SetCanID(255, 163, 6);
   1119          			CAN_TX_Data(&Uart2_RxMsg_Single_163[0]);
   1120          		}
   1121          
   1122          		if((Flag_SerialRxMsg & RX_MSG174) != 0)
   1123          		{
   1124          			Flag_SerialRxMsg &= ~(RX_MSG174);
   1125          			SetCanID(255, 174, 6);
   1126          			CAN_TX_Data(&Uart2_RxMsg_Single_174[0]);
   1127          		}
   1128          		
   1129          		if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
   1130          		{
   1131          			Send_Multipacket_69();
   1132          		}
   1133          		else if((Flag_SerialRxMsg & RX_MSG161) != 0)
   1134          		{
   1135          			Send_Multipacket_161();
   1136          		}
   1137          		else if((Flag_SerialRxMsg & RX_MSG202) != 0)
   1138          		{
   1139          			Send_Multipacket_AS_Num();
   1140          		}
   1141          		else
   1142          		{
   1143          			///+++
   1144          			if(gStartHCE_DT == 1)
   1145          			{
   1146          				if(MachInfoSendCnt <= 60)
   1147          				{
   1148          					if(MultiPacketSendOrder == 0)
   1149          						MultiPacketSendOrder = 1;
   1150          				}
   1151          				else if(MoniInfoSendCnt <= 60)
   1152          					MultiPacketSendOrder = 2;
   1153          			}
   1154          		}
   1155          	}
   1156          	else
   1157          	{
   1158          		///+++
   1159          		if(gStartHCE_DT == 1)
   1160          		{
   1161          			if(MachInfoSendCnt <= 60)
   1162          			{
   1163          				if(MultiPacketSendOrder == 0)
   1164          					MultiPacketSendOrder = 1;
   1165          			}
   1166          			else if(MoniInfoSendCnt <= 60)
   1167          				MultiPacketSendOrder = 2;
   1168          		}
   1169          	}
   1170          
   1171          	if(gStartHCE_DT == 1)
   1172          	{
   1173          		Send_Multipacket_Info();
   1174          	}
   1175          	#endif
   1176          }
   1177          
   1178          /**
   1179            * @brief  100msec OperationFunc
   1180            * @param  None
   1181            * @retval None
   1182            */
   1183          void WL9FM_100mSecOperationFunc(void)
   1184          {
   1185          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1186          
   1187          #if 0
   1188          	if(Flag_TxE2pRomData == 1)
   1189          		SmartKeyAuthentication();
   1190          #endif
   1191          	
   1192          
   1193          
   1194          	
   1195          	if(CommErrCnt > 1000)
   1196             	{
   1197             		if( Flag_TxE2pRomData == 1 )
   1198          	   	{
   1199          	   		CAN_COMInit();
   1200             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1201          
   1202          			Buz1 = 0;
   1203          
   1204          			if(++SendRTCnt >= 10)
   1205          			{
   1206          				SendRTCnt = 0;
   1207          
   1208          				RTC_SendToExynos( WL9FM_RTC.Hour, WL9FM_RTC.Minute );
   1209          			}
   1210          			//Buzzer_SendToEXYNOS(1);
   1211          	   	}
   1212          	}	
   1213          	
   1214          	System_CheckPowerIG();
   1215          
   1216          	if(ST_Update)
   1217          	{
   1218          		STM32_Update(Stm32_Update_CMD);	
   1219          		ST_Update=0;
   1220          	}
   1221          		
   1222          	//	WL9A Monitor RESET Code
   1223          	if((SystemReset == 1) || (gRebootCmd == 1))
   1224          	{
   1225          		if(gRebootCmd == 1)
   1226          			SaveDataToEEPROM();
   1227          				
   1228          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1229          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1230          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1231          		return;
   1232          	}
   1233          
   1234          }
   1235          
   1236          void WL9FM_500mSecOperationFunc(void)
   1237          {
   1238          
   1239          	SetCanID(255, 47, 6);
   1240          	CAN_TX_Data(&Uart2_RxMsg_Single_47[0]);
   1241          	
   1242          }
   1243          
   1244          
   1245          
   1246          /**
   1247            * @brief  1sec OperationFunc
   1248            * @param  None
   1249            * @retval None
   1250            */
   1251          void WL9FM_1SecOperationFunc(void)
   1252          {
   1253          	if(gStartHCE_DT == 1)
   1254          	{
   1255          		CompareMachBasicInfo();
   1256              
   1257          		if(++Flag_1Min >= 60)
   1258          		{
   1259          			Flag_1Min = 0;
   1260          			RequestMachBasicInfo();
   1261          
   1262          			if((MachInfoSendCnt > 60) && (MoniInfoSendCnt > 60))
   1263          				MultiPacketSendOrder = 0;
   1264          		}
   1265          	}
   1266          	read_clock();
   1267          
   1268          
   1269          	//  ++, kutelf, 131007
   1270          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1271          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1272          	if (Camera_CheckFlag == 1)
   1273          	{
   1274          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1275          			
   1276          		if ((Camera_CheckCnt % 3) == 0)
   1277          		{
   1278          			cam_mode_check();
   1279          		}
   1280          	}
   1281          	else
   1282          	{
   1283          		Camera_CheckCnt = 0;
   1284          	}
   1285          	//  --, kutelf, 131007
   1286          }
   1287          
   1288          
   1289          void WL9FM_System_Init_Start(void)
   1290          {
   1291          	WL9FM_PowerIG(PowerIG_OFF);					//    ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고, 
   1292          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1293          	WL9FM_EXYNOS_PMIC_ONOFF();
   1294          	
   1295          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1296          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1297          	TW2835_Control_Init();	
   1298          	
   1299          	DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1300          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1301          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1302          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1303          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1304          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1305          												//		LAMP ALL ON
   1306          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1307          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1308          
   1309          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1310          
   1311          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1312          
   1313          	USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1314          	USART_COMInit(COMPORT4);       				//      COM4 : CMDData
   1315          
   1316          												
   1317          	CAN_COMInit();								//	-> 	CAN_Control.c
   1318          	//InitE2PROM();
   1319          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1320          
   1321          	M25P32_Init();
   1322          
   1323          	//WL9FM_PowerIG(PowerIG_ON);				//	->	GPIO_Control.c 초기화가 끝나면, PowerIG를 ON 한다.!!
   1324          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF
   1325          	
   1326          
   1327          
   1328          
   1329          	
   1330          }
   1331          
   1332          /**
   1333            * @brief  Application Program Start Point.
   1334            * @param  None
   1335            * @retval None
   1336            */
   1337          void WL9FM_Monitor_APP(void)
   1338          {
   1339          	DebugUART_Init();			//	->	Main.c
   1340          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1341          
   1342          	System_Configuration();		//  ->  System_Init.c
   1343          	                    //      RCC, NVIC, GPIO Initialize
   1344          
   1345          	System_Initialize();		//	-> 	System_Init.c
   1346          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1347          
   1348          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1349          SYSTEM_RESET :
   1350          	WL9FM_PowerIG(PowerIG_ON);
   1351          	System_Variable_Init();
   1352          	WL9FM_System_Init_Start();
   1353          	
   1354          	/* Infinite loop */
   1355          	while (1)
   1356          	{  
   1357          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1358          		{
   1359          			WL9FM_TIME.Flag_1mSec = 0;
   1360          
   1361          			//  WL9F_1mSecOperationState -> Func 실행..
   1362          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1363          			WL9FM_1mSecOperationFunc();
   1364          		}            
   1365          		
   1366          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1367          		{
   1368          			WL9FM_TIME.Flag_10mSec = 0;
   1369          
   1370          			//  WL9F_10mSecOperationState -> Func 실행..
   1371          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1372          			WL9FM_10mSecOperationFunc();
   1373          		}
   1374          		
   1375          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1376          		{
   1377          			WL9FM_TIME.Flag_100mSec = 0;
   1378          
   1379          			//  WL9F_100mSecOperationState -> Func 실행..
   1380          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1381          			WL9FM_100mSecOperationFunc();
   1382          
   1383          			#if 1
   1384          			//	WL9F Monitor RESET Code
   1385          			if((SystemReset == 1) || (gRebootCmd == 1))
   1386          			{
   1387          				goto SYSTEM_RESET;
   1388          			}
   1389          			#endif
   1390          		}
   1391          
   1392          		if(WL9FM_TIME.Flag_500mSec == 1)
   1393          		{
   1394          			WL9FM_TIME.Flag_500mSec = 0;
   1395          			WL9FM_500mSecOperationFunc();
   1396          		}
   1397          		
   1398          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1399          		{
   1400          			WL9FM_TIME.Flag_1Sec = 0;
   1401          
   1402          			//  WL9F_1SecOperationState -> Func 실행..
   1403          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1404          			WL9FM_1SecOperationFunc();
   1405                                  
   1406          		}
   1407          	}
   1408          }
   1409          
   1410          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       8   Send_Multipacket_145
         8   -> SendMultiPacketData_145
         8   -> SendTP_CM_BAM_MultiPacket_145
         8   -> TimeDelay_msec
       8   Send_Multipacket_61184_23
         8   -> SendMultiPacketData_61184_23
         8   -> SendTP_CM_BAM_MultiPacket_61184_23
         8   -> TimeDelay_msec
       8   System_CheckPowerIG
         8   -> Buzzer_Off
         8   -> CAN_ITConfig
         8   -> KeySwitch_SendToEXYNOS
         8   -> LCDBL_ONOFF
         8   -> LCDBL_PWM_LEVEL
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> Lamp_Update_System
         8   -> SaveDataToEEPROM
         8   -> TimeDelay_msec
         8   -> USART_ITConfig
         8   -> WL9FM_EXYNOS_PMIC_ONOFF
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
         8   -> WL9FM_PowerIG
      16   WL9FM_100mSecOperationFunc
        16   -> CAN_COMInit
        16   -> CAN_ITConfig
        16   -> Lamp_Update_System
        16   -> RTC_SendToExynos
        16   -> STM32_Update
         0   -> SaveDataToEEPROM
        16   -> System_CheckPowerIG
      24   WL9FM_10mSecOperationFunc
        24   -> CAN_TX_Data
        24   -> Lamp_Update_State
        24   -> Send_Multipacket_145
        24   -> Send_Multipacket_61184_23
        24   -> SetCanID
        24   -> WRITE_RTC
       8   WL9FM_1SecOperationFunc
         8   -> CompareMachBasicInfo
         8   -> READ_RTC
         8   -> RequestMachBasicInfo
         0   -> cam_mode_check
       8   WL9FM_1mSecOperationFunc
         0   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
       8   WL9FM_500mSecOperationFunc
         0   -> CAN_TX_Data
         8   -> SetCanID
      24   WL9FM_Monitor_APP
        24   -> CAN_TX_Data
        24   -> CompareMachBasicInfo
        24   -> DebugUART_Init
        24   -> KeySwitch_SendToEXYNOS
        24   -> READ_RTC
        24   -> RequestMachBasicInfo
        24   -> SendTo_E2PROM
        24   -> SetCanID
        24   -> System_Configuration
        24   -> System_Initialize
        24   -> System_Variable_Init
        24   -> WL9FM_100mSecOperationFunc
        24   -> WL9FM_10mSecOperationFunc
        24   -> WL9FM_PowerIG
        24   -> WL9FM_System_Init_Start
        24   -> cam_mode_check
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         8   -> DPRAM_Init
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_ONOFF
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
       8   read_clock
         8   -> READ_RTC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_29
       4  ??DataTable14_3
       4  ??DataTable14_30
       4  ??DataTable14_31
       4  ??DataTable14_32
       4  ??DataTable14_33
       4  ??DataTable14_34
       4  ??DataTable14_35
       4  ??DataTable14_36
       4  ??DataTable14_37
       4  ??DataTable14_38
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       8  ACK_Multi_61184
       1  AuthResult
       1  CTSFlag_61184
       8  E2PROM_Save
          PwrOffCnt
          LAMP_Update_Data
       2  Flag_1Sec_MachInfo
       2  Flag_1Sec_MoniInfo
       1  Flag_200mSec
     458  InitE2PROM
      50  Init_RTC
       1  KeySwitch_Value
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoTotalPacketNum
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
       1  SMK_Msg_Send
       1  SMK_Tag_Count
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
       2  SendRTCnt
          ST_Update
      74  Send_Multipacket_145
      80  Send_Multipacket_61184_23
     272  System_CheckPowerIG
       2  TotalPacketNum
          RTSFlag_61184
     116  WL9FM_100mSecOperationFunc
     502  WL9FM_10mSecOperationFunc
     116  WL9FM_1SecOperationFunc
      46  WL9FM_1mSecOperationFunc
      22  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     260  WL9FM_Monitor_APP
      54  WL9FM_RTC
          SerialMsgRTC
          MultiPacketSendOrder
          gStartHCE_DT
          MachInfoSendCnt
          MoniInfoSendCnt
          Flag_UartTxStart
          SendTime_E2PROM
          SystemReset
          gRebootCmd
          WL9FM_TIME
          Flag_1Min
     110  WL9FM_System_Init_Start
     520  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
       1  gAuthentication_Cnt
       8  rand_value
      22  read_clock
       8  recv_smartkey
       1  send_bkcu_data
       1  send_mcu_data
       8  send_smartkey
       4  smk_flag_data

 
 2 819 bytes in section .bss
 3 242 bytes in section .text
 
 3 242 bytes of CODE memory
 2 819 bytes of DATA memory

Errors: none
Warnings: none
