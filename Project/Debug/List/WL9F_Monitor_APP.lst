###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      25/Sep/2014  14:42:53 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -      #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -     #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\   #
#                    -o C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\ #
#                     --debug --endian=little --cpu=Cortex-M4 -e              #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Pl #
#                    atform\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP_DM #
#                    A\Project\..\Platform\TaeHa - ECS\INC\" -I               #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    CMSIS\Device\ST\STM32F4xx\Include\ -I                    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    STM32F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I  #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\WL #
#                    9F_Monitor_APP.lst                                       #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\WL9 #
#                    F_Monitor_APP.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          /* Private macro -------------------------------------------------------------*/
     71          WL9FM_send_smartkey send_smartkey;
     72          WL9FM_receive_smartkey recv_smartkey;
     73          WL9FM_save_rand_value rand_value;
     74          WL9FM_flag_data smk_flag_data;	
     75          
     76          /* Private variables ---------------------------------------------------------*/
     77          u8 gAuthentication_Cnt = 0;
     78          
     79          u8 AuthResult;
     80          u8 SMKSuccess;
     81          u8 SMK_Msg_Send;
     82          u8 SMK_Tag_Count;
     83          u8 MultiPacketSendOrder = 0;
     84          u8 TotalPacketNum = 0;
     85          u8 DiffMachInfo = 0;
     86          u8 MachInfoSendCnt = 0;
     87          u8 MoniInfoSendCnt = 0;
     88          
     89          u8 RTSFlag_61184 = 0;
     90          u8 CTSFlag_61184 = 0;
     91          u8 RMCU_CTSFlag_61184 = 0;
     92          u8 RecvTotalPacket_61184 = 0;
     93          u8 RMCU_RecvTotalPacket_61184 = 0;
     94          u8 ACK_Multi_61184[8];
     95          u8 RMCU_ACK_Multi_61184[8];
     96          
     97          u8 Flag_UartTxStart = 0;
     98          u8  SendTime_E2PROM = 0;
     99          
    100          u16 Flag_1Sec_MachInfo = 0;
    101          u16 Flag_1Min = 0;
    102          
    103          u8 MachInfoTotalPacketNum = 0;
    104          u8 MoniInfoTotalPacketNum = 0;
    105          u8 Flag_200mSec = 0;
    106          u8 SendRTCnt = 0;
    107          u16 adc_value = 0;
    108          
    109          u8 SerialMsgRTC[16];
    110          u8 eepRomReadData1[32];
    111          u8 MoniInfoData[21];
    112          u8 McuInfoData2[4];
    113          u8 McuInfoData3[4];
    114          u8 McuInfoData4[4];
    115          
    116          u8 SystemReset = 0;
    117          u8 E2PROM_Save = 0;
    118          u8 PwrOffCnt = 0;
    119          u8 gRebootCmd = 0;
    120          
    121          
    122          u8 send_mcu_data=0;
    123          u8 send_bkcu_data=0;
    124          
    125          u8 ST_Update=0;
    126          u8 UpdateMode = 0;
    127          
    128          extern u8 Uart2_RxMsg_Single_252[8];
    129          extern u8 Uart2_RxMsg_Single_253[8];
    130          extern u8 Uart2_RxMsg_Single_239[8];
    131          extern u8 Uart2_RxMsg_Single_239_121[8];
    132          extern u8 Uart2_RxMsg_Single_247[8];
    133          extern u8 Uart2_RxMsg_Save_Data1[8];
    134          extern u8 Uart2_RxMsg_Save_Data2[8];
    135          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    136          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    137          extern u8 McuInfoData1[79];
    138          extern u8 tmpMcuInfoData[78];
    139          extern u8 FatoryInit_Flag;
    140          
    141          extern u8 stop_send_as_phone_data;
    142          extern u8 Flag_TxE2pRomData;
    143          
    144          extern u8 Buz1;
    145          
    146          extern u8 Stm32_Update_CMD;
    147          extern u8 CANUpdateFlag;
    148          
    149          extern u16 pWriteBufPos;
    150          extern u16 pReadBufPos;
    151          
    152          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    153          
    154          /* Private function prototypes -----------------------------------------------*/
    155          /* Private functions ---------------------------------------------------------*/
    156          
    157          void Init_RTC(void)
    158          {
    159          	WL9FM_RTC.Year   = 0;
    160          	WL9FM_RTC.Month  = 1;
    161          	WL9FM_RTC.Date   = 1;
    162          	WL9FM_RTC.Day    = 1;
    163          	WL9FM_RTC.Hour   = 12;
    164          	WL9FM_RTC.Minute = 0;
    165          	WL9FM_RTC.Second = 0;
    166          
    167          	WRITE_RTC(WL9FM_RTC);
    168          }
    169          void InitE2PROM(void)
    170          {
    171          	u8 i;
    172          	u8 tmpBuf1[8];
    173          	u8 tmpBuf2[8];
    174          	u8 tmpBuf3[8];
    175          	u8 tmpBuf4[21];
    176          	
    177          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    178          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    179          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    180          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    181          
    182          	SaveE2PROM1->WorkLoad 				= 0;
    183          	SaveE2PROM1->testWorkLoad 			= 0;
    184          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    185          	SaveE2PROM1->DispType	 			= 0;
    186          	SaveE2PROM1->InfoViewPriority 		= 0;
    187          	SaveE2PROM1->UnitPressure 			= 0;
    188          	SaveE2PROM1->Reserved0 				= 0;
    189          	SaveE2PROM1->Lang 					= 0;
    190          	SaveE2PROM1->ManualBackLight 		= 7;
    191          	SaveE2PROM1->AutoBackLight 			= 0;
    192          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    193          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    194          	SaveE2PROM1->InfoViewCnt 			= 2;
    195          	SaveE2PROM1->HR_Start 				= 0;
    196          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    197          	SaveE2PROM1->ActiveCamNum 			= 1;
    198          	SaveE2PROM1->FirstCam 				= 0;
    199          	SaveE2PROM1->SecondCam 				= 1;
    200          	SaveE2PROM1->ThirdCam 				= 2;
    201          	SaveE2PROM1->Reserved1 				= 0;
    202          
    203          	SaveE2PROM2->LightMode 				= 0;
    204          	SaveE2PROM2->JobTimeView 			= 0;
    205          	SaveE2PROM2->OdoMeterView 			= 0;
    206          	SaveE2PROM2->JobOdoSelect 			= 0;
    207          	SaveE2PROM2->LightLowTime 			= 8;
    208          	SaveE2PROM2->LightUpperTime 		= 16;
    209          	SaveE2PROM2->AutoLightDay 			= 0;
    210          	SaveE2PROM2->AutoLightNight 		= 0;
    211          	SaveE2PROM2->Reserved1 				= 0;
    212          
    213          	SaveE2PROM3->Phone_1  				= 0;
    214          	SaveE2PROM3->Phone_2  				= 8;
    215          	SaveE2PROM3->Phone_3  				= 0;
    216          	SaveE2PROM3->Phone_4  				= 5;
    217          	SaveE2PROM3->Phone_5  				= 5;
    218          	SaveE2PROM3->Phone_6  				= 5;
    219          	SaveE2PROM3->Phone_7  				= 8;
    220          	SaveE2PROM3->Phone_8  				= 2;
    221          	SaveE2PROM3->Phone_9  				= 7;
    222          	SaveE2PROM3->Phone_10 				= 2;
    223          	SaveE2PROM3->Phone_11 				= 0xf;
    224          	SaveE2PROM3->Phone_12 				= 0xf;
    225          
    226          #if 1	// Monitor Change History - temp
    227          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    228          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    229          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    230          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    231          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    232          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    233          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    234          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    235          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    236          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    237          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    238          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    239          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    240          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    241          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    242          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    243          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    244          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    245          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    246          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    247          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    248          #endif
    249          
    250          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    251          
    252          	EEPROM_Write(0, 0);	// tmp
    253          	EEPROM_Write(0, 0);	// tmp
    254          	EEPROM_Write(0, 0);	// tmp
    255          
    256          	for(i = 0 ; i < 8 ; i++)
    257          	{
    258          		EEPROM_Write(i+8, tmpBuf1[i]);
    259          		TimeDelay_msec(5);
    260          		EEPROM_Write(i+16, tmpBuf2[i]);
    261          		TimeDelay_msec(5);
    262          		EEPROM_Write(i+24, tmpBuf3[i]);
    263          		TimeDelay_msec(5);
    264          	}
    265          
    266          	SerialPutString("Initialize : 30 %%\n\r");
    267          	
    268          #if 1	// Monitor Change History - temp
    269          	for(i = 0 ; i < 21 ; i++)
    270          	{
    271          		EEPROM_Write(i+50, tmpBuf4[i]);
    272          		TimeDelay_msec(5);
    273          	}
    274          #endif
    275          
    276          	for(i = 0 ; i < 79 ; i++)
    277          	{
    278          		EEPROM_Write(i+100, 0xff);
    279          		TimeDelay_msec(5);
    280          	}
    281          
    282          	SerialPutString("Initialize : 60 %%\n\r");
    283          
    284          	for(i = 0 ; i < 30 ; i++)
    285          	{
    286          		EEPROM_Write(i+200, 0xff);
    287          		TimeDelay_msec(5);
    288          	}
    289          
    290          	for(i = 0 ; i < 29 ; i++)
    291          	{
    292          		EEPROM_Write(i+230, 0xff);
    293          		TimeDelay_msec(5);
    294          	}
    295          
    296          	SerialPutString("Initialize : 95 %%\n\r");
    297          	Init_RTC();
    298          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    299          }
    300          
    301          void ReadE2PROM_ToSend()
    302          {
    303          #if 1
    304          	u8 i;
    305          
    306          	adc_value = (ADC1->DR & 0x0000FFFF);
    307          
    308          	i = EEPROM_Read(0);	
    309          	i = EEPROM_Read(0);
    310          	i = EEPROM_Read(0);
    311          	i = 0;
    312              
    313          	adc_value = (ADC1->DR & 0x0000FFFF);
    314          
    315          	for(i = 0 ; i < 24 ; i++)
    316          		eepRomReadData1[i] = EEPROM_Read(i+8);
    317          
    318          	for(i = 0 ; i < 8 ; i++)
    319          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    320          
    321          	for(i = 0 ; i < 8 ; i++)
    322          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    323          
    324          	for(i = 0 ; i < 8 ; i++)
    325          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    326          
    327          	for(i = 0 ; i < 21 ; i++)
    328          		MoniInfoData[i] = EEPROM_Read(i+50);
    329          	
    330          	for(i = 0 ; i < 79 ; i++)
    331          		McuInfoData1[i] = EEPROM_Read(i+100);
    332          
    333          	for(i = 0 ; i < 4 ; i++)
    334          		McuInfoData2[i] = EEPROM_Read(i+200);
    335          
    336          	for(i = 0 ; i < 4 ; i++)
    337          		McuInfoData3[i] = EEPROM_Read(i+210);
    338          
    339          	for(i = 0 ; i < 4 ; i++)
    340          		McuInfoData4[i] = EEPROM_Read(i+220);
    341          
    342          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    343          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    344          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    345          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    346          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    347          
    348          
    349          	adc_value = (ADC1->DR & 0x0000FFFF);
    350          	
    351          	eepRomReadData1[12] = (adc_value & 0xff);
    352          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    353          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    354          
    355          #endif
    356          }
    357          
    358          
    359          void Init_Smart_Key_valuable(void)
    360          {
    361          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    362          	AuthResult = 0xff;
    363          	SMK_Msg_Send = 0;
    364          	SMK_Tag_Count = 0;
    365          	SMKSuccess = 0;
    366          }
    367          
    368          
    369          void read_clock(void)
    370          {
    371          	uint8_t Temp[Serial_COM4_TxSize];
    372          	
    373          	READ_RTC(&WL9FM_RTC);
    374          
    375          	Temp[0] = 0x02;				
    376          	Temp[1] = RTCRES;				
    377          	Temp[2] = WL9FM_RTC.Year;	
    378          	Temp[3] = WL9FM_RTC.Month;	
    379          	Temp[4] = WL9FM_RTC.Date;	
    380          	Temp[5] = WL9FM_RTC.Day;	
    381          	Temp[6] = WL9FM_RTC.Hour;	
    382          	Temp[7] = WL9FM_RTC.Minute;	
    383          	Temp[8] = WL9FM_RTC.Second;	
    384          	Temp[9] = 0xFF;	
    385          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    386          	USARTx_EXYNOS(COM4, (char *)Temp);	
    387          
    388          }
    389          
    390          void SaveDataToEEPROM(void)
    391          {
    392          	u8 i;
    393          	
    394          	for(i = 0 ; i < 8 ; i++)
    395          	{
    396          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    397          		TimeDelay_msec(1);
    398          	}
    399          
    400          	for(i = 0 ; i < 8 ; i++)
    401          	{
    402          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    403          		TimeDelay_msec(1);
    404          	}
    405          
    406          	for(i = 0 ; i < 8 ; i++)
    407          	{
    408          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    409          		TimeDelay_msec(1);
    410          	}
    411          
    412          	for(i = 0 ; i < 21 ; i++)
    413          	{
    414          		EEPROM_Write(i+50, MoniInfoData[i]);
    415          		TimeDelay_msec(1);
    416          	}
    417          	
    418          	for(i = 0 ; i < 79 ; i++)
    419          	{
    420          		EEPROM_Write(i+100, McuInfoData1[i]);
    421          		TimeDelay_msec(1);
    422          	}
    423          
    424          
    425          	if(DiffMachInfo == 1)
    426          	{
    427          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    428          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    429          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    430          	}
    431          
    432          	for(i = 0 ; i < 4 ; i++)
    433          	{
    434          		EEPROM_Write(i+200, McuInfoData2[i]);
    435          		TimeDelay_msec(1);
    436          	}
    437          
    438          	for(i = 0 ; i < 4 ; i++)
    439          	{
    440          		EEPROM_Write(i+210, McuInfoData3[i]);
    441          		TimeDelay_msec(1);
    442          	}
    443          
    444          	for(i = 0 ; i < 4 ; i++)
    445          	{
    446          		EEPROM_Write(i+220, McuInfoData4[i]);
    447          		TimeDelay_msec(1);
    448          	}
    449          }
    450          
    451          
    452          void System_CheckPowerIG()
    453          {
    454          	// Check POWER IG
    455          	if(!WL9FM_GetPowerIG())
    456          	{
    457          		WL9FM_PowerIG(PowerIG_ON);
    458          		SystemReset = 0;
    459          	}
    460          	else
    461          	{
    462          		if(E2PROM_Save == 0)
    463          		{
    464          			SaveDataToEEPROM();
    465          
    466          			PwrOffCnt = 0;
    467          
    468          			while(1)
    469          			{
    470          				//	100msec 마다 15번 체크 -> 1.5초..
    471          				//	PowerIG Off 상태일 경우
    472          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    473          				//	PowerIG On  상태일 경우 
    474          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    475          				if(!WL9FM_GetPowerIG())
    476          				{
    477          					//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    478          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    479          					CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
    480          
    481          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    482          
    483          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    484          					SystemReset = 0;
    485          					return;
    486          				}
    487          			
    488          				TimeDelay_msec(100);
    489          
    490          				PwrOffCnt++;
    491          				if(PwrOffCnt >= 15)	
    492          					break;
    493          			}
    494          
    495          			Buzzer_Off();
    496          
    497          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    498          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    499          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(3);
    500          
    501          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    502          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    503          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    504          
    505          			//	POWER OFF 일 때, LAMP Clear
    506          			LAMP_Update_Data = LAMP_ALL_OFF;
    507          			Lamp_Update_System();
    508          			
    509          			//	엔딩화면 딜레이 시간
    510          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    511          			TimeDelay_msec(1200);
    512          
    513          			//	LCDBL, LCD, LED Off
    514          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    515          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    516          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    517          			LED_POWER_ONOFF(LED_OFF);       //  LED Off
    518          
    519          			WL9FM_EXYNOS_PMIC_PWRON();
    520          
    521          			
    522          			//	Exynos VDD5V0_4412 Off
    523          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    524          			
    525          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    526          
    527          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    528          			if(!WL9FM_GetPowerIG())
    529          			{
    530          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    531          				SystemReset = 1;			//	Software RESET
    532          				return;
    533          			}
    534          
    535          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	    
    536          		}
    537          	}
    538          }
    539          
    540          /*******************************************************************************
    541          *
    542          *	Smart Key Test Function
    543          *
    544          *******************************************************************************/
    545          #if 1
    546          void SendSMKAuthResult(u8 result)
    547          {
    548          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    549          }
    550          
    551          void SendSMKMsgResult(u8 result)
    552          {
    553          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    554          }
    555          
    556          void SetTagLevel(u8 level)
    557          {
    558          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    559          		send_smartkey.TagLevel = level;
    560          	else
    561          		send_smartkey.TagLevel = 3;
    562          }
    563          
    564          void SetTagCmd(u8 cmd)
    565          {
    566          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    567          		send_smartkey.TagCommand = cmd;
    568          	else
    569          		send_smartkey.TagCommand = 0xf;
    570          }
    571          
    572          void SetVMC(void)
    573          {
    574          	if(rand_value.rand_vmc <= 64255)
    575          		send_smartkey.VMC = rand_value.rand_vmc;
    576          	else
    577          		send_smartkey.VMC = 0xffff;
    578          }
    579          
    580          void SetCPK(void)
    581          {
    582          #if 1
    583          	if(rand_value.rand_cpk <= 0xfaffffff)
    584          		send_smartkey.CPK = rand_value.rand_cpk;
    585          	else
    586          		send_smartkey.CPK = 0xffffffff;
    587          #else
    588          	send_smartkey.CPK = 0x11223344;
    589          #endif
    590          }
    591          
    592          void Srand()
    593          {
    594          	READ_RTC(&WL9FM_RTC);
    595          	srand((u32)WL9FM_RTC.Second);
    596          }
    597          
    598          void GetRandValue(u8 random)
    599          {
    600          	if(random == GET_VMC)	
    601          		rand_value.rand_vmc = (rand() % 64255);
    602          	else if(random == GET_CPK)	
    603          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    604          	else if(random == GET_VMC_CPK)		
    605          	{
    606          		rand_value.rand_vmc = (rand() % 64255);
    607          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    608          	}	
    609          }
    610          
    611          void RequestFirstAuthentication(void)
    612          {
    613          	unsigned int temp;
    614          	
    615          	SetTagLevel(TAG_LEVEL_NORMAL);
    616          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    617          	GetRandValue(GET_VMC_CPK);
    618          	SetVMC();
    619          	SetCPK();
    620          
    621          	setCipherParam(0x8085, 0x8087);
    622          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    623          	
    624          	send_smartkey.CPK = temp;
    625          
    626          	// CPK 암호화 Function 추가 필요
    627          	TimeDelay_msec(10);
    628          
    629          	struct st_CAN_Message1 Send_Message;
    630          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    631          	Send_Message.Priority= 0x18;
    632          	Send_Message.PDU_Format= 0xFF;
    633          	Send_Message.PDU_Specific= 0xE7;
    634          	Send_Message.Source_Address= 0x28;
    635          	Write_CAN_Single(Send_Message);
    636          }
    637          
    638          void RequestSecondAuthentication(void)
    639          {
    640          	unsigned short upper_cpk, lower_cpk;
    641          	unsigned int temp;
    642          
    643          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    644          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    645          	
    646          	SetTagLevel(TAG_LEVEL_NORMAL);
    647          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    648          	GetRandValue(GET_VMC);
    649          	SetVMC();
    650          
    651          	setCipherParam(upper_cpk, lower_cpk);
    652          	//setCipherParam(0x1122, 0x3344);
    653          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    654          
    655          	send_smartkey.CPK = temp;
    656          	
    657          	TimeDelay_msec(10);
    658          
    659          	struct st_CAN_Message1 Send_Message;
    660          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    661          	Send_Message.Priority= 0x18;
    662          	Send_Message.PDU_Format= 0xFF;
    663          	Send_Message.PDU_Specific= 0xE7;
    664          	Send_Message.Source_Address= 0x28;
    665          	Write_CAN_Single(Send_Message);
    666          
    667          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    668          }
    669          
    670          void RequestSMKRegistration(void)
    671          {
    672          	unsigned short upper_cpk, lower_cpk;
    673          	unsigned int temp;
    674          
    675          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    676          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    677          	
    678          	SetTagLevel(TAG_LEVEL_NORMAL);
    679          	SetTagCmd(TAG_CMD_REGISTRATION);
    680          	GetRandValue(GET_VMC);
    681          	SetVMC();
    682          
    683          	setCipherParam(upper_cpk, lower_cpk);
    684          	//setCipherParam(0x1122, 0x3344);
    685          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    686          
    687          	send_smartkey.CPK = temp;
    688          
    689          	struct st_CAN_Message1 Send_Message;
    690          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    691          	Send_Message.Priority= 0x18;
    692          	Send_Message.PDU_Format= 0xFF;
    693          	Send_Message.PDU_Specific= 0xE7;
    694          	Send_Message.Source_Address= 0x28;
    695          	Write_CAN_Single(Send_Message);
    696          
    697          
    698          
    699          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    700          }
    701          
    702          void RequestSMKElimination(void)
    703          {
    704          	unsigned short upper_cpk, lower_cpk;
    705          	unsigned int temp;
    706          
    707          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    708          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    709          	
    710          	SetTagLevel(TAG_LEVEL_NORMAL);
    711          	SetTagCmd(TAG_CMD_ELIMINATION);
    712          	GetRandValue(GET_VMC);
    713          	SetVMC();
    714          
    715          	setCipherParam(upper_cpk, lower_cpk);
    716          	//setCipherParam(0x1122, 0x3344);
    717          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    718          
    719          	send_smartkey.CPK = temp;
    720          
    721          	struct st_CAN_Message1 Send_Message;
    722          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    723          	Send_Message.Priority= 0x18;
    724          	Send_Message.PDU_Format= 0xFF;
    725          	Send_Message.PDU_Specific= 0xE7;
    726          	Send_Message.Source_Address= 0x28;
    727          	Write_CAN_Single(Send_Message);
    728          
    729          
    730          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    731          }
    732          
    733          void RequestSMKMessage(u8 Msg)
    734          {
    735          	if(Msg == 1)
    736          		RequestSMKRegistration();
    737          	else if(Msg == 2)
    738          		RequestSMKElimination();
    739          }
    740          
    741          void RequestSMKComm(void)
    742          {
    743          	SetTagLevel(TAG_LEVEL_NORMAL);
    744          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    745          	GetRandValue(GET_VMC);
    746          	SetVMC();
    747          
    748          	struct st_CAN_Message1 Send_Message;
    749          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    750          	Send_Message.Priority= 0x18;
    751          	Send_Message.PDU_Format= 0xFF;
    752          	Send_Message.PDU_Specific= 0xE7;
    753          	Send_Message.Source_Address= 0x28;
    754          	Write_CAN_Single(Send_Message);
    755          
    756          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    757          }
    758          
    759          u8 CheckResponseVMC(void)
    760          {
    761          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    762          		return RETURN_VMC_OK;
    763          	else
    764          		return RETURN_VMC_NOT_OK;
    765          }
    766          
    767          u8 CheckResponseAuthentication(u8 Auth)
    768          {
    769          	u8 output_buf[8];
    770          	u16 upper_cpk, lower_cpk;
    771          
    772          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    773          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    774          	
    775          	setCipherParam(upper_cpk, lower_cpk);
    776          	//setCipherParam(0x1122, 0x3344);	// 임시
    777          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    778          
    779          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    780          	
    781          	
    782          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    783          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    784          	{
    785          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    786          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    787          		{
    788          			return SMK_RESPONSE_FLAG_SUCCESS;
    789          		}
    790          		else
    791          			return recv_smartkey.Smk_Response_Flag;
    792          	}
    793          	else
    794          		return SMK_RESPONSE_CODE_NOT_MATCH;
    795          }
    796          
    797          void CheckResponseMsgComm(void)
    798          {
    799          	u8 output_buf[8];
    800          	u16 upper_cpk, lower_cpk;
    801          
    802          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    803          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    804          	
    805          	setCipherParam(upper_cpk, lower_cpk);
    806          	//setCipherParam(0x1122, 0x3344);	// 임시
    807          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    808          
    809          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    810          
    811          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    812          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    813          	{
    814          		if(recv_smartkey.Smk_Response_Code == 1)
    815          		{
    816          			switch(recv_smartkey.Smk_Response_Flag)
    817          			{
    818          				case 2 :
    819          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    820          					break;
    821          				case 3 :
    822          					SendSMKMsgResult(SMK_MSG_FAIL);
    823          					break;
    824          				case 4 :
    825          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    826          					break;
    827          				default :
    828          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    829          					{
    830          						if(recv_smartkey.Registered_Tag_Count == 1)
    831          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    832          						else if(recv_smartkey.Registered_Tag_Count == 2)
    833          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    834          						else
    835          							SendSMKMsgResult(SMK_MSG_FAIL);
    836          					}
    837          					else
    838          					{
    839          						if(SMK_Tag_Count != 0)
    840          							SMK_Tag_Count--;
    841          
    842          						SendSMKMsgResult(SMK_MSG_FAIL);
    843          					}
    844          					break;
    845          			}
    846          			
    847          		}
    848          		else if(recv_smartkey.Smk_Response_Code == 2)
    849          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    850          		else
    851          			SendSMKMsgResult(SMK_MSG_FAIL);
    852          	}
    853          	else
    854          		SendSMKMsgResult(SMK_MSG_FAIL);
    855          }
    856          
    857          
    858          void SmartKeyAuthentication(void)
    859          {
    860          	u8  Auth = 0;
    861          	u8 returnvalue;
    862          
    863          	if(AuthResult != 1)
    864          	{
    865          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    866          		{
    867          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    868          			{
    869          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    870          				RequestFirstAuthentication();
    871          			}
    872          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    873          			{
    874          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    875          				RequestSecondAuthentication();
    876          			}
    877          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    878          			{
    879          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    880          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    881          
    882          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    883          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    884          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    885          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    886          					
    887          				returnvalue = CheckResponseAuthentication(Auth);
    888          					
    889          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    890          				{
    891          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    892          					{
    893          						gAuthentication_Cnt = 0;
    894          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    895          					}
    896          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    897          					{
    898          						gAuthentication_Cnt = 0;
    899          						AuthResult = 1;
    900          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    901          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    902          						SMKSuccess = SMK_SUCCESS;
    903          						SendSMKAuthResult(SMK_SUCCESS);
    904          					}
    905          				}
    906          				else
    907          				{
    908          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    909          					{
    910          						//AuthResult = 2;
    911          						AuthResult = 1;
    912          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    913          						SMKSuccess = SMK_FAIL;
    914          						SendSMKAuthResult(SMK_FAIL);
    915          						return;
    916          					}
    917          
    918          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    919          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    920          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    921          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    922          				}
    923          			}
    924          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
    925          			{
    926          				//RequestFirstAuthentication();
    927          			}
    928          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
    929          			{
    930          				//RequestSecondAuthentication();
    931          			}
    932          		}
    933          	}
    934          	//else if(AuthResult == 1)
    935          	{
    936          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
    937          		{
    938          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
    939          			SMK_Msg_Send = 1;
    940          			smk_flag_data.recv_resp_packet = 0;
    941          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
    942          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
    943          		}
    944          
    945          		if(SMK_Msg_Send == 1)
    946          		{
    947          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
    948          			{
    949          				SMK_Msg_Send = 0;
    950          				CheckResponseMsgComm();
    951          			}
    952          		}
    953          	}
    954          }
    955          #endif
    956          /**
    957            * @brief  1msec OperationFunc
    958            * @param  None
    959            * @retval None
    960            */
    961          void WL9FM_1mSecOperationFunc(void)
    962          {
    963          #if 1
    964          	if( Flag_UartTxStart == 1 )
    965          	{
    966          		if (SendTime_E2PROM++ > 3) //	25msec
    967          		{
    968          			SendTime_E2PROM = 0;
    969          			SendTo_E2PROM();
    970          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
    971          		}			
    972          	}
    973          	// CAN_TX Routine
    974          	CAN_TX();
    975          	Write_UART_Single();
    976          #endif
    977          }
    978          
    979          /**
    980            * @brief  10msec OperationFunc
    981            * @param  None
    982            * @retval None
    983            */
    984          void WL9FM_10mSecOperationFunc(void)
    985          {
    986          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
    987          }
    988          
    989          /**
    990            * @brief  100msec OperationFunc
    991            * @param  None
    992            * @retval None
    993            */
    994          void WL9FM_100mSecOperationFunc(void)
    995          {
    996          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
    997          
    998          #if 1
    999          	//if(Flag_TxE2pRomData == 1)
   1000          		SmartKeyAuthentication();
   1001          #endif
   1002          	
   1003          
   1004          
   1005          	
   1006          	if(CommErrCnt > 1000)
   1007             	{
   1008             		if( Flag_TxE2pRomData == 1 )
   1009          	   	{
   1010          	   		CAN_COMInit();
   1011             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1012          
   1013          			Buz1 = 0;
   1014                      //RTCSend();
   1015          			if(++SendRTCnt >= 10)
   1016          			{
   1017          				SendRTCnt = 0;
   1018          				
   1019          			}
   1020          	   	}
   1021          	}	
   1022          	
   1023          	System_CheckPowerIG();
   1024          
   1025          	if(ST_Update)
   1026          	{
   1027          		if(UpdateMode < 10)
   1028          			UpdateMode++;
   1029          
   1030          		if(UpdateMode >= 10)
   1031          		{
   1032          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1033          			ST_Update=0;
   1034          		}
   1035          	}
   1036          		
   1037          	//	WL9A Monitor RESET Code
   1038          	if((SystemReset == 1) || (gRebootCmd == 1))
   1039          	{
   1040          		if(gRebootCmd == 1)
   1041          			SaveDataToEEPROM();
   1042          				
   1043          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1044          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1045          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1046          		return;
   1047          	}
   1048          
   1049          }
   1050          
   1051          void WL9FM_500mSecOperationFunc(void)
   1052          {
   1053          	if(CANUpdateFlag != 1)
   1054          		MonitorStatus_CAN_TX();
   1055          
   1056          }
   1057          
   1058          
   1059          
   1060          /**
   1061            * @brief  1sec OperationFunc
   1062            * @param  None
   1063            * @retval None
   1064            */
   1065          void WL9FM_1SecOperationFunc(void)
   1066          {
   1067          	if(UpdateMode < 10)
   1068          		read_clock();
   1069          
   1070          
   1071          	//  ++, kutelf, 131007
   1072          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1073          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1074          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1075          	{
   1076          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1077          			
   1078          		if ((Camera_CheckCnt % 3) == 0)
   1079          		{
   1080          			cam_mode_check();
   1081          		}
   1082          	}
   1083          	else
   1084          	{
   1085          		Camera_CheckCnt = 0;
   1086          	}
   1087          	//  --, kutelf, 131007
   1088          }
   1089          
   1090          
   1091          void WL9FM_System_Init_Start(void)
   1092          {
   1093          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1094          	if (SystemReset != 1)
   1095          	{
   1096          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1097          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1098          	}	
   1099          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1100          	WL9FM_EXYNOS_PMIC_PWRON();
   1101          	
   1102          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1103          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1104          	TW2835_Control_Init();	
   1105          	
   1106          	DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1107          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1108          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1109          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1110          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1111          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1112          												//		LAMP ALL ON
   1113          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1114          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1115          
   1116          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1117          
   1118          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1119          
   1120          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);       				//      COM2 : CAN
   1121          	USART_COMInit(COMPORT4);       				//      COM4 : CMDData
   1122          
   1123          												
   1124          	CAN_COMInit();								//	-> 	CAN_Control.c
   1125          	//InitE2PROM();
   1126          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1127          
   1128          	M25P32_Init();
   1129          
   1130          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1131          
   1132          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1133          
   1134          
   1135          }
   1136          
   1137          /**
   1138            * @brief  Application Program Start Point.
   1139            * @param  None
   1140            * @retval None
   1141            */
   1142          void WL9FM_Monitor_APP(void)
   1143          {
   1144          	DebugUART_Init();			//	->	Main.c
   1145          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1146          
   1147          	System_Configuration();		//  ->  System_Init.c
   1148          	                    		//      RCC, NVIC, GPIO Initialize
   1149          
   1150          	System_Initialize();		//	-> 	System_Init.c
   1151          
   1152          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1153          	//	System 강제 RESET시키기 위하여 goto lable 추가..	
   1154          	SYSTEM_RESET :
   1155          	//WL9FM_PowerIG(PowerIG_ON);
   1156          	System_Variable_Init();
   1157          	WL9FM_System_Init_Start();
   1158          	
   1159          	/* Infinite loop */
   1160          	while (1)
   1161          	{  
   1162          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1163          		{
   1164          			WL9FM_TIME.Flag_1mSec = 0;
   1165          
   1166          			//  WL9F_1mSecOperationState -> Func 실행..
   1167          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1168          			WL9FM_1mSecOperationFunc();
   1169          		}            
   1170          		
   1171          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1172          		{
   1173          			WL9FM_TIME.Flag_10mSec = 0;
   1174          
   1175          			//  WL9F_10mSecOperationState -> Func 실행..
   1176          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1177          			WL9FM_10mSecOperationFunc();
   1178          		}
   1179          		
   1180          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1181          		{
   1182          			WL9FM_TIME.Flag_100mSec = 0;
   1183          
   1184          			//  WL9F_100mSecOperationState -> Func 실행..
   1185          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1186          			WL9FM_100mSecOperationFunc();
   1187          
   1188          			#if 1
   1189          			//	WL9F Monitor RESET Code
   1190          			if((SystemReset == 1) || (gRebootCmd == 1))
   1191          			{
   1192          				goto SYSTEM_RESET;
   1193          			}
   1194          			#endif
   1195          		}
   1196          
   1197          		if(WL9FM_TIME.Flag_500mSec == 1)
   1198          		{
   1199          			WL9FM_TIME.Flag_500mSec = 0;
   1200          			WL9FM_500mSecOperationFunc();
   1201          		}
   1202          		
   1203          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1204          		{
   1205          			WL9FM_TIME.Flag_1Sec = 0;
   1206          
   1207          			//  WL9F_1SecOperationState -> Func 실행..
   1208          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1209          			WL9FM_1SecOperationFunc();
   1210                                  
   1211          		}
   1212          	}
   1213          }
   1214          
   1215          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SMK_SendToExynos
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> SetVMC
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      16   RequestSMKComm
        16   -> GetRandValue
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> SetVMC
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SendSMKAuthResult
         0   -> SMK_SendToExynos
       0   SendSMKMsgResult
         0   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
         0   -> SMK_SendToExynos
        16   -> SMK_SendToExynos
       8   Srand
         8   -> READ_RTC
         0   -> srand
       8   System_CheckPowerIG
         8   -> Buzzer_Off
         8   -> CAN_ITConfig
         8   -> KeySwitch_SendToEXYNOS
         8   -> LCDBL_ONOFF
         8   -> LCDBL_PWM_LEVEL
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> Lamp_Update_System
         8   -> SaveDataToEEPROM
         8   -> TimeDelay_msec
         8   -> USART_ITConfig
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
         8   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         8   -> Lamp_Update_System
         8   -> STM32_Update
         0   -> SaveDataToEEPROM
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         0   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      16   WL9FM_Monitor_APP
        16   -> CAN_TX
        16   -> DebugUART_Init
        16   -> KeySwitch_SendToEXYNOS
        16   -> MonitorStatus_CAN_TX
        16   -> SendTo_E2PROM
        16   -> System_Configuration
        16   -> System_Initialize
        16   -> System_Variable_Init
        16   -> WL9FM_100mSecOperationFunc
        16   -> WL9FM_1SecOperationFunc
        16   -> WL9FM_System_Init_Start
        16   -> Write_UART_Single
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         0   -> CAN_ITConfig
         8   -> DPRAM_Init
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCDBL_ONOFF
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> USART_COMInit_DMA
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_PMIC_PWRON
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_23
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      34  ??Subroutine1_0
      52  ?Subroutine0
       8  ACK_Multi_61184
       1  CTSFlag_61184
      88  CheckResponseAuthentication
     180  CheckResponseMsgComm
      20  CheckResponseVMC
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
      36  Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          WL9FM_TIME
          LAMP_Update_Data
     118  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      20  Init_Smart_Key_valuable
       4  KeySwitch_Value
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     126  RequestFirstAuthentication
      84  RequestSMKComm
      18  RequestSMKElimination
      18  RequestSMKMessage
      20  RequestSMKRegistration
      78  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      12  SendSMKAuthResult
      18  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     254  SmartKeyAuthentication
      22  Srand
     242  System_CheckPowerIG
       1  TotalPacketNum
     130  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
      78  WL9FM_1SecOperationFunc
      48  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     148  WL9FM_Monitor_APP
       8  WL9FM_RTC
     130  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
      82  read_clock
      36  recv_smartkey
          gAuthentication_Cnt
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          send_smartkey
          rand_value
          smk_flag_data
       1  send_bkcu_data
       1  send_mcu_data

 
 2 837 bytes in section .bss
 3 710 bytes in section .text
 
 3 710 bytes of CODE memory
 2 837 bytes of DATA memory

Errors: none
Warnings: 6
