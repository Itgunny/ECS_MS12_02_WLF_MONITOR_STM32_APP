###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      14/Apr/2014  09:39:25 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\WL9F_Monitor_APP.c                               #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\WL9F_Monitor_APP.c" -D USE_STDPERIPH_DRIVER -D   #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\WL9F_M #
#                    onitor_APP.lst                                           #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\WL9F_Mo #
#                    nitor_APP.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          #define RX_MSG69		0x01
     28          #define RX_MSG69_M		0x02
     29          #define RX_MSG145		0x04
     30          #define RX_MSG161		0x08
     31          #define RX_MSG162		0x10
     32          #define RX_MSG163		0x20
     33          #define RX_MSG251		0x40
     34          #define RX_MSG252		0x80
     35          #define RX_MSG202		0x100
     36          #define RX_MSG253		0x200
     37          #define RX_MSG203		0x400
     38          #define RX_MSG239		0x800
     39          #define RX_MSG247		0x1000
     40          #define RX_MSG174		0x2000
     41          #define RX_MSG239_121	0x4000
     42          
     43          
     44          
     45          
     46          
     47          /* Private define ------------------------------------------------------------*/
     48          /* Private macro -------------------------------------------------------------*/
     49          WL9FM_send_smartkey send_smartkey;
     50          WL9FM_receive_smartkey recv_smartkey;
     51          WL9FM_save_rand_value rand_value;
     52          WL9FM_flag_data smk_flag_data;	
     53          
     54          /* Private variables ---------------------------------------------------------*/
     55          u8 gAuthentication_Cnt = 0;
     56          
     57          u8 AuthResult;
     58          u8 SMK_Msg_Send;
     59          u8 SMK_Tag_Count;
     60          u8 MultiPacketSendOrder = 0;
     61          u8 TotalPacketNum = 0;
     62          u8 DiffMachInfo = 0;
     63          u8 gStartHCE_DT = 0;
     64          u8 MachInfoSendCnt = 0;
     65          u8 MoniInfoSendCnt = 0;
     66          
     67          u8 Flag_UartTxStart = 0;
     68          u8  SendTime_E2PROM = 0;
     69          
     70          u16 Flag_1Sec_MachInfo = 0;
     71          u16 Flag_1Sec_MoniInfo = 0;
     72          u16 Flag_1Min = 0;
     73          
     74          u8 MachInfoTotalPacketNum = 0;
     75          u8 MoniInfoTotalPacketNum = 0;
     76          u8 Flag_200mSec = 0;
     77          u8 SendRTCnt = 0;
     78          u16 adc_value = 0;
     79          
     80          u8 SerialMsgRTC[16];
     81          u8 eepRomReadData1[32];
     82          u8 MoniInfoData[21];
     83          u8 McuInfoData2[4];
     84          u8 McuInfoData3[4];
     85          u8 McuInfoData4[4];
     86          
     87          u8 SystemReset = 0;
     88          u8 E2PROM_Save = 0;
     89          u8 PwrOffCnt = 0;
     90          u8 gRebootCmd = 0;
     91          
     92          
     93          u8 send_mcu_data=0;
     94          u8 send_bkcu_data=0;
     95          
     96          u8 ST_Update=0;
     97          
     98          extern u8 Uart2_RxMsg_Single_252[8];
     99          extern u8 Uart2_RxMsg_Single_253[8];
    100          extern u8 Uart2_RxMsg_Single_239[8];
    101          extern u8 Uart2_RxMsg_Single_239_121[8];
    102          extern u8 Uart2_RxMsg_Single_247[8];
    103          extern u8 Uart2_RxMsg_Save_Data1[8];
    104          extern u8 Uart2_RxMsg_Save_Data2[8];
    105          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    106          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    107          extern u8 McuInfoData1[79];
    108          extern u8 tmpMcuInfoData[78];
    109          
    110          extern u8 stop_send_as_phone_data;
    111          extern u8 Flag_TxE2pRomData;
    112          
    113          extern u8 Buz1, Buz2;
    114          
    115          extern u8 Stm32_Update_CMD;
    116          /* Private function prototypes -----------------------------------------------*/
    117          /* Private functions ---------------------------------------------------------*/
    118          
    119          void Init_RTC(void)
    120          {
    121          	WL9FM_RTC.Year   = 0;
    122          	WL9FM_RTC.Month  = 1;
    123          	WL9FM_RTC.Date   = 1;
    124          	WL9FM_RTC.Day    = 1;
    125          	WL9FM_RTC.Hour   = 12;
    126          	WL9FM_RTC.Minute = 0;
    127          	WL9FM_RTC.Second = 0;
    128          
    129          	WRITE_RTC(WL9FM_RTC);
    130          }
    131          void InitE2PROM(void)
    132          {
    133          	u8 i;
    134          	u8 tmpBuf1[8];
    135          	u8 tmpBuf2[8];
    136          	u8 tmpBuf3[8];
    137          	u8 tmpBuf4[21];
    138          	
    139          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    140          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    141          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    142          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    143          
    144          	SaveE2PROM1->WorkLoad 				= 0;
    145          	SaveE2PROM1->testWorkLoad 			= 0;
    146          	SaveE2PROM1->Unit 					= 3;	//	¼·¾¾ ( C ) , km/h
    147          	SaveE2PROM1->DispType	 			= 0;
    148          	SaveE2PROM1->InfoViewPriority 		= 0;
    149          	SaveE2PROM1->UnitPressure 			= 0;
    150          	SaveE2PROM1->Reserved0 				= 0;
    151          	SaveE2PROM1->Lang 					= 0;
    152          	SaveE2PROM1->ManualBackLight 		= 7;
    153          	SaveE2PROM1->AutoBackLight 			= 0;
    154          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    155          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    156          	SaveE2PROM1->InfoViewCnt 			= 2;
    157          	SaveE2PROM1->HR_Start 				= 0;
    158          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    159          	SaveE2PROM1->ActiveCamNum 			= 1;
    160          	SaveE2PROM1->FirstCam 				= 0;
    161          	SaveE2PROM1->SecondCam 				= 1;
    162          	SaveE2PROM1->ThirdCam 				= 2;
    163          	SaveE2PROM1->Reserved1 				= 0;
    164          
    165          	SaveE2PROM2->LightMode 				= 0;
    166          	SaveE2PROM2->JobTimeView 			= 0;
    167          	SaveE2PROM2->OdoMeterView 			= 0;
    168          	SaveE2PROM2->JobOdoSelect 			= 0;
    169          	SaveE2PROM2->LightLowTime 			= 8;
    170          	SaveE2PROM2->LightUpperTime 		= 16;
    171          	SaveE2PROM2->AutoLightDay 			= 0;
    172          	SaveE2PROM2->AutoLightNight 		= 0;
    173          	SaveE2PROM2->Reserved1 				= 0;
    174          
    175          	SaveE2PROM3->Phone_1  				= 0;
    176          	SaveE2PROM3->Phone_2  				= 8;
    177          	SaveE2PROM3->Phone_3  				= 0;
    178          	SaveE2PROM3->Phone_4  				= 5;
    179          	SaveE2PROM3->Phone_5  				= 5;
    180          	SaveE2PROM3->Phone_6  				= 5;
    181          	SaveE2PROM3->Phone_7  				= 8;
    182          	SaveE2PROM3->Phone_8  				= 2;
    183          	SaveE2PROM3->Phone_9  				= 7;
    184          	SaveE2PROM3->Phone_10 				= 2;
    185          	SaveE2PROM3->Phone_11 				= 0xf;
    186          	SaveE2PROM3->Phone_12 				= 0xf;
    187          
    188          #if 1	// Monitor Change History - temp
    189          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    190          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    191          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    192          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    193          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    194          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    195          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    196          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    197          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    198          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    199          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    200          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    201          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    202          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    203          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    204          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    205          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    206          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    207          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    208          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    209          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    210          #endif
    211          
    212          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    213          
    214          	EEPROM_Write(0, 0);	// tmp
    215          	EEPROM_Write(0, 0);	// tmp
    216          	EEPROM_Write(0, 0);	// tmp
    217          
    218          	for(i = 0 ; i < 8 ; i++)
    219          	{
    220          		EEPROM_Write(i+8, tmpBuf1[i]);
    221          		TimeDelay_msec(5);
    222          		EEPROM_Write(i+16, tmpBuf2[i]);
    223          		TimeDelay_msec(5);
    224          		EEPROM_Write(i+24, tmpBuf3[i]);
    225          		TimeDelay_msec(5);
    226          	}
    227          
    228          	SerialPutString("Initialize : 30 %%\n\r");
    229          	
    230          #if 1	// Monitor Change History - temp
    231          	for(i = 0 ; i < 21 ; i++)
    232          	{
    233          		EEPROM_Write(i+50, tmpBuf4[i]);
    234          		TimeDelay_msec(5);
    235          	}
    236          #endif
    237          
    238          	for(i = 0 ; i < 79 ; i++)
    239          	{
    240          		EEPROM_Write(i+100, 0xff);
    241          		TimeDelay_msec(5);
    242          	}
    243          
    244          	SerialPutString("Initialize : 60 %%\n\r");
    245          
    246          	for(i = 0 ; i < 30 ; i++)
    247          	{
    248          		EEPROM_Write(i+200, 0xff);
    249          		TimeDelay_msec(5);
    250          	}
    251          
    252          	for(i = 0 ; i < 29 ; i++)
    253          	{
    254          		EEPROM_Write(i+230, 0xff);
    255          		TimeDelay_msec(5);
    256          	}
    257          
    258          	SerialPutString("Initialize : 95 %%\n\r");
    259          	Init_RTC();
    260          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    261          }
    262          
    263          void ReadE2PROM_ToSend()
    264          {
    265          #if 1
    266          	u8 i;
    267          
    268          	adc_value = (ADC1->DR & 0x0000FFFF);
    269          
    270          	i = EEPROM_Read(0);	
    271          	i = EEPROM_Read(0);
    272          	i = EEPROM_Read(0);
    273          	i = 0;
    274              
    275          	adc_value = (ADC1->DR & 0x0000FFFF);
    276          
    277          	for(i = 0 ; i < 24 ; i++)
    278          		eepRomReadData1[i] = EEPROM_Read(i+8);
    279          
    280          	for(i = 0 ; i < 8 ; i++)
    281          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    282          
    283          	for(i = 0 ; i < 8 ; i++)
    284          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    285          
    286          	for(i = 0 ; i < 8 ; i++)
    287          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    288          
    289          	for(i = 0 ; i < 21 ; i++)
    290          		MoniInfoData[i] = EEPROM_Read(i+50);
    291          	
    292          	for(i = 0 ; i < 79 ; i++)
    293          		McuInfoData1[i] = EEPROM_Read(i+100);
    294          
    295          	for(i = 0 ; i < 4 ; i++)
    296          		McuInfoData2[i] = EEPROM_Read(i+200);
    297          
    298          	for(i = 0 ; i < 4 ; i++)
    299          		McuInfoData3[i] = EEPROM_Read(i+210);
    300          
    301          	for(i = 0 ; i < 4 ; i++)
    302          		McuInfoData4[i] = EEPROM_Read(i+220);
    303          
    304          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    305          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    306          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    307          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    308          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    309          
    310          
    311          	adc_value = (ADC1->DR & 0x0000FFFF);
    312          	
    313          	eepRomReadData1[12] = (adc_value & 0xff);
    314          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    315          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    316          
    317          #endif
    318          }
    319          
    320          void Send_Multipacket_69(void)
    321          {
    322          	if(MultiPacketSendOrder == 0)
    323          	{
    324          		if(TotalPacketNum == 0)
    325          		{
    326          			TimeDelay_msec(15);
    327          			SendTP_CM_BAM_MultiPacket_69();
    328          			TotalPacketNum += 1;
    329          		}
    330          		else if(TotalPacketNum == 1)
    331          		{
    332          			// TP.DT
    333          			TimeDelay_msec(15);
    334          			SendFirstMultiPacket_69();
    335          			TotalPacketNum += 1;
    336          		}
    337          		else if(TotalPacketNum == 2)
    338          		{
    339          			// TP.DT
    340          			TimeDelay_msec(15);
    341          			SendSecondMultiPacket_69();
    342          
    343          			if(TotalPacketNum == tp_cm_bam_TotPacketNum)
    344          			{
    345          				Flag_SerialRxMsg &= ~(RX_MSG69_M);
    346          				TotalPacketNum = 0;
    347          
    348          				///+++
    349          				if((DiffMachInfo == 1) && (gStartHCE_DT == 1))
    350          				{
    351          					if(MachInfoSendCnt <= 60)
    352          						MultiPacketSendOrder = 1;	// Machine Basic Information
    353          					else if(MoniInfoSendCnt <= 60)
    354          						MultiPacketSendOrder = 2;	// Monitor Basic Information
    355          				}
    356          			}
    357          			else
    358          				TotalPacketNum += 1;
    359          		}
    360          		else if(TotalPacketNum == 3)
    361          		{
    362          			TimeDelay_msec(15);
    363          			SendThirdMultiPacket_69();
    364          			TotalPacketNum = 0;
    365          
    366          					///+++
    367          			if((DiffMachInfo == 1) && (gStartHCE_DT == 1))
    368          			{
    369          				if(MachInfoSendCnt <= 60)
    370          					MultiPacketSendOrder = 1;	// Machine Basic Information
    371          				else if(MoniInfoSendCnt <= 60)
    372          					MultiPacketSendOrder = 2;	// Monitor Basic Information
    373          			}
    374          		}
    375          	}
    376          }
    377          
    378          void Send_Multipacket_161(void)
    379          {
    380          	if(TotalPacketNum == 0)
    381          	{
    382          		TimeDelay_msec(15);
    383          		SendTP_CM_BAM_MultiPacket_161();
    384          		TotalPacketNum += 1;
    385          	}
    386          	else if((TotalPacketNum == 1) || (TotalPacketNum == 2))
    387          	{
    388          		TimeDelay_msec(15);
    389          		SendMultiPacketData_161(TotalPacketNum);
    390          		TotalPacketNum += 1;
    391          
    392          		if(TotalPacketNum >= 3)
    393          		{
    394          			Flag_SerialRxMsg &= ~(RX_MSG161);
    395          			TotalPacketNum = 0;
    396          		}
    397          	}
    398          }
    399          
    400          void Send_Multipacket_AS_Num(void)
    401          {
    402          	if(check_as_data_len == 0)
    403          		CheckASDataLen();
    404          
    405          	if(as_data_len < 8)	// Single Packet
    406          	{
    407          		SetCanID(255, 145, 6);
    408          		CAN_TX_Data(&tmpbuf_AS[0]);
    409          		check_as_data_len = 0;
    410          
    411          		if(stop_send_as_phone_data == 1)
    412          		{
    413          			stop_send_as_phone_data = 0;
    414          			Flag_SerialRxMsg &= ~(RX_MSG202);
    415          		}
    416          	}
    417          	else	        	// Multi Packet
    418          	{
    419          		if(TotalPacketNum == 0)
    420          		{
    421          			TimeDelay_msec(15);
    422          			SendTP_CM_BAM_MultiPacket_202_AS();
    423          			TotalPacketNum += 1;
    424          		}
    425          		else if((TotalPacketNum == 1) || (TotalPacketNum == 2))
    426          		{
    427          			TimeDelay_msec(15);
    428          			SendMultiPacketData_202_AS(TotalPacketNum);
    429          			TotalPacketNum += 1;
    430          
    431          			if(TotalPacketNum >= 3)
    432          			{
    433          				if(stop_send_as_phone_data == 1)
    434          				{
    435          					stop_send_as_phone_data = 0;
    436          					Flag_SerialRxMsg &= ~(RX_MSG202);
    437          				}
    438          				
    439          				TotalPacketNum = 0;
    440          				check_as_data_len = 0;
    441          			}
    442          		}
    443          	}
    444          }
    445          
    446          void Send_Multipacket_Info(void)
    447          {
    448          	if(MultiPacketSendOrder == 1)
    449          	{
    450          		if(MachInfoSendCnt <= 60)
    451          		{
    452          			if(++Flag_1Sec_MachInfo >= 100)
    453          			{
    454          				if(MachInfoTotalPacketNum == 0)
    455          				{
    456          					SendTP_CM_BAM_MultiPacket_MachInfo();
    457          					MachInfoTotalPacketNum++;
    458          				}
    459          				else
    460          					SendMultiPacket_MachInfo();
    461          			}
    462          			else
    463          			{
    464          				if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
    465          					MultiPacketSendOrder = 0;
    466          			}
    467          		}
    468          		else
    469          		{
    470          			if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
    471          				MultiPacketSendOrder = 0;
    472          			else if(MoniInfoSendCnt <= 60)
    473          				MultiPacketSendOrder = 2;
    474          		}
    475          	}
    476          	else if(MultiPacketSendOrder == 2)
    477          	{
    478          		if(MoniInfoSendCnt <= 60)
    479          		{
    480          			if(++Flag_1Sec_MoniInfo >= 100)
    481          			{
    482          				if(MoniInfoTotalPacketNum == 0)
    483          				{
    484          					SendTP_CM_BAM_MultiPacket_MoniInfo();
    485          					MoniInfoTotalPacketNum++;
    486          				}
    487          				else
    488          					SendMultiPacket_MoniInfo();
    489          			}
    490          			else
    491          			{
    492          				if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
    493          					MultiPacketSendOrder = 0;
    494          			}
    495          		}
    496          		else
    497          		{
    498          			if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
    499          				MultiPacketSendOrder = 0;
    500          			else if(MachInfoSendCnt <= 60)
    501          				MultiPacketSendOrder = 1;
    502          		}
    503          	}
    504          }
    505          
    506          void read_clock(void)
    507          {
    508          	READ_RTC(&WL9FM_RTC);
    509          	SerialMsgRTC[8] = WL9FM_RTC.Hour;
    510          	SerialMsgRTC[9] = WL9FM_RTC.Minute;
    511          }
    512          
    513          void SaveDataToEEPROM(void)
    514          {
    515          	u8 i;
    516          	
    517          	for(i = 0 ; i < 8 ; i++)
    518          	{
    519          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    520          		TimeDelay_msec(1);
    521          	}
    522          
    523          	for(i = 0 ; i < 8 ; i++)
    524          	{
    525          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    526          		TimeDelay_msec(1);
    527          	}
    528          
    529          	for(i = 0 ; i < 8 ; i++)
    530          	{
    531          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    532          		TimeDelay_msec(1);
    533          	}
    534          
    535          	for(i = 0 ; i < 21 ; i++)
    536          	{
    537          		EEPROM_Write(i+50, MoniInfoData[i]);
    538          		TimeDelay_msec(1);
    539          	}
    540          	
    541          	for(i = 0 ; i < 79 ; i++)
    542          	{
    543          		EEPROM_Write(i+100, McuInfoData1[i]);
    544          		TimeDelay_msec(1);
    545          	}
    546          
    547          
    548          	if(DiffMachInfo == 1)
    549          	{
    550          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    551          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    552          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    553          	}
    554          
    555          	for(i = 0 ; i < 4 ; i++)
    556          	{
    557          		EEPROM_Write(i+200, McuInfoData2[i]);
    558          		TimeDelay_msec(1);
    559          	}
    560          
    561          	for(i = 0 ; i < 4 ; i++)
    562          	{
    563          		EEPROM_Write(i+210, McuInfoData3[i]);
    564          		TimeDelay_msec(1);
    565          	}
    566          
    567          	for(i = 0 ; i < 4 ; i++)
    568          	{
    569          		EEPROM_Write(i+220, McuInfoData4[i]);
    570          		TimeDelay_msec(1);
    571          	}
    572          }
    573          
    574          
    575          void System_CheckPowerIG()
    576          {
    577          	// Check POWER IG
    578          	if(!WL9FM_GetPowerIG())
    579          	{
    580          		WL9FM_PowerIG(PowerIG_ON);
    581          		SystemReset = 0;
    582          	}
    583          	else
    584          	{
    585          		if(E2PROM_Save == 0)
    586          		{
    587          			SaveDataToEEPROM();
    588          
    589          			PwrOffCnt = 0;
    590          
    591          			while(1)
    592          			{
    593          				if(!WL9FM_GetPowerIG())
    594          				{
    595          					//	POWER OFF ÀÏ ¶§, ½Ã¸®¾ó°ú Äµ Åë½Å ºÎºÐÀ» Á×¿©³ö¾ßÁö, Á¤»óÀûÀ¸·Î RESET µ¿ÀÛÀ» ¼öÇà
    596          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    597          					CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
    598          
    599          					WL9FM_PowerIG(PowerIG_ON);	// System Reset
    600          					SystemReset = 1;
    601          					return;
    602          				}
    603          			
    604          				TimeDelay_msec(100);
    605          
    606          				PwrOffCnt++;
    607          				if(PwrOffCnt >= 15)	//	100msec ¸¶´Ù 15¹ø Ã¼Å© -> 1.5ÃÊ..
    608          					break;
    609          			}
    610          
    611          			Buzzer_Off();
    612          
    613          			//	POWER OFF Code¸¦ 3msec ¸¶´Ù 2¹ø SPICA·Î º¸³½´Ù. 
    614          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	
    615          			TimeDelay_msec(3);
    616          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	
    617          			TimeDelay_msec(3);
    618          
    619          			//	POWER OFF ÀÏ ¶§, ½Ã¸®¾ó°ú Äµ Åë½Å ºÎºÐÀ» Á×¿©³ö¾ßÁö, Á¤»óÀûÀ¸·Î RESET µ¿ÀÛÀ» ¼öÇà
    620          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    621          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    622          
    623          			//	¿£µùÈ­¸é µô·¹ÀÌ ½Ã°£
    624          			//	1200msec ÀÌ»ó ¼³Á¤ÇÏ¸é, LCD°¡ ÇÏ¾é°Ô µÈ´Ù. -> POWER Off TimeÀ¸·Î ÀÎÇÏ¿©
    625          			TimeDelay_msec(1200);
    626          
    627          			LCDBL_PWM_LEVEL(0);                         	//  LCDBL PWM LEVEL0
    628          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On!!!
    629          	
    630          	        
    631          			//	¿£µùÈ­¸éÀÌ Áö³­ ÈÄ¿¡ PowerIG°¡ ´Ù½Ã µé¾î¿À¸é, SystemÀ» RESET ½ÃÅ²´Ù. 
    632          			if(!WL9FM_GetPowerIG())
    633          			{
    634          				WL9FM_PowerIG(PowerIG_ON);
    635          				SystemReset = 1;
    636          				return;
    637          			}
    638          	        
    639          			LCD_POWER_ONOFF(LCDPWR_OFF);                        //  LCD Power Off
    640          			LED_POWER_ONOFF(LED_OFF);                        	//  LED Off
    641          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);	
    642          			WL9FM_PowerIG(PowerIG_OFF);                    //  24v Main Power Off	        
    643          		}
    644          	}
    645          }
    646          
    647          /*******************************************************************************
    648          *
    649          *	Smart Key Test Function
    650          *
    651          *******************************************************************************/
    652          #if 0
    653          void SendSMKAuthResult(u8 result)
    654          {
    655          	RTC_SendToExynos( result, SMK_Tag_Count );
    656          }
    657          
    658          void SendSMKMsgResult(u8 result)
    659          {
    660          	RTC_SendToExynos( result, recv_smartkey.Registered_Tag_Count );
    661          }
    662          
    663          void SetTagLevel(u8 level)
    664          {
    665          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    666          		send_smartkey.TagLevel = level;
    667          	else
    668          		send_smartkey.TagLevel = 3;
    669          }
    670          
    671          void SetTagCmd(u8 cmd)
    672          {
    673          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    674          		send_smartkey.TagCommand = cmd;
    675          	else
    676          		send_smartkey.TagCommand = 0xf;
    677          }
    678          
    679          void SetVMC(void)
    680          {
    681          	if(rand_value.rand_vmc <= 64255)
    682          		send_smartkey.VMC = rand_value.rand_vmc;
    683          	else
    684          		send_smartkey.VMC = 0xffff;
    685          }
    686          
    687          void SetCPK(void)
    688          {
    689          #if 1
    690          	if(rand_value.rand_cpk <= 0xfaffffff)
    691          		send_smartkey.CPK = rand_value.rand_cpk;
    692          	else
    693          		send_smartkey.CPK = 0xffffffff;
    694          #else
    695          	send_smartkey.CPK = 0x11223344;
    696          #endif
    697          }
    698          
    699          void Srand()
    700          {
    701          	READ_RTC(&WL9FM_RTC);
    702          	srand((u32)WL9FM_RTC.Second);
    703          }
    704          
    705          void GetRandValue(u8 random)
    706          {
    707          	if(random == GET_VMC)	
    708          		rand_value.rand_vmc = (rand() % 64255);
    709          	else if(random == GET_CPK)	
    710          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    711          	else if(random == GET_VMC_CPK)		
    712          	{
    713          		rand_value.rand_vmc = (rand() % 64255);
    714          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    715          	}	
    716          }
    717          
    718          void RequestFirstAuthentication(void)
    719          {
    720          	unsigned int temp;
    721          	
    722          	SetTagLevel(TAG_LEVEL_NORMAL);
    723          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    724          	GetRandValue(GET_VMC_CPK);
    725          	SetVMC();
    726          	SetCPK();
    727          
    728          	setCipherParam(0x8085, 0x8087);
    729          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    730          	
    731          	send_smartkey.CPK = temp;
    732          
    733          	// CPK ¾ÏÈ£È­ Function Ãß°¡ ÇÊ¿ä
    734          	TimeDelay_msec(10);
    735          	SetCanID(255, 231, 6);
    736          	CAN_TX_Data((u8*)&send_smartkey);
    737          }
    738          
    739          void RequestSecondAuthentication(void)
    740          {
    741          	unsigned short upper_cpk, lower_cpk;
    742          	unsigned int temp;
    743          
    744          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    745          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    746          	
    747          	SetTagLevel(TAG_LEVEL_NORMAL);
    748          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    749          	GetRandValue(GET_VMC);
    750          	SetVMC();
    751          
    752          	setCipherParam(upper_cpk, lower_cpk);
    753          	//setCipherParam(0x1122, 0x3344);
    754          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    755          
    756          	send_smartkey.CPK = temp;
    757          	
    758          	TimeDelay_msec(10);
    759          	SetCanID(255, 231, 6);
    760          	CAN_TX_Data((u8*)&send_smartkey);
    761          
    762          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    763          }
    764          
    765          void RequestSMKRegistration(void)
    766          {
    767          	unsigned short upper_cpk, lower_cpk;
    768          	unsigned int temp;
    769          
    770          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    771          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    772          	
    773          	SetTagLevel(TAG_LEVEL_NORMAL);
    774          	SetTagCmd(TAG_CMD_REGISTRATION);
    775          	GetRandValue(GET_VMC);
    776          	SetVMC();
    777          
    778          	setCipherParam(upper_cpk, lower_cpk);
    779          	//setCipherParam(0x1122, 0x3344);
    780          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    781          
    782          	send_smartkey.CPK = temp;
    783          
    784          	SetCanID(255, 231, 6);
    785          	CAN_TX_Data((u8*)&send_smartkey);
    786          
    787          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    788          }
    789          
    790          void RequestSMKElimination(void)
    791          {
    792          	unsigned short upper_cpk, lower_cpk;
    793          	unsigned int temp;
    794          
    795          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    796          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    797          	
    798          	SetTagLevel(TAG_LEVEL_NORMAL);
    799          	SetTagCmd(TAG_CMD_ELIMINATION);
    800          	GetRandValue(GET_VMC);
    801          	SetVMC();
    802          
    803          	setCipherParam(upper_cpk, lower_cpk);
    804          	//setCipherParam(0x1122, 0x3344);
    805          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    806          
    807          	send_smartkey.CPK = temp;
    808          
    809          	SetCanID(255, 231, 6);
    810          	CAN_TX_Data((u8*)&send_smartkey);
    811          
    812          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    813          }
    814          
    815          void RequestSMKMessage(u8 Msg)
    816          {
    817          	if(Msg == 1)
    818          		RequestSMKRegistration();
    819          	else if(Msg == 2)
    820          		RequestSMKElimination();
    821          }
    822          
    823          void RequestSMKComm(void)
    824          {
    825          	SetTagLevel(TAG_LEVEL_NORMAL);
    826          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    827          	GetRandValue(GET_VMC);
    828          	SetVMC();
    829          
    830          	SetCanID(255, 231, 6);
    831          	CAN_TX_Data((u8*)&send_smartkey);
    832          
    833          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    834          }
    835          
    836          u8 CheckResponseVMC(void)
    837          {
    838          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    839          		return RETURN_VMC_OK;
    840          	else
    841          		return RETURN_VMC_NOT_OK;
    842          }
    843          
    844          u8 CheckResponseAuthentication(u8 Auth)
    845          {
    846          	u8 output_buf[8];
    847          	u16 upper_cpk, lower_cpk;
    848          
    849          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    850          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    851          	
    852          	setCipherParam(upper_cpk, lower_cpk);
    853          	//setCipherParam(0x1122, 0x3344);	// ÀÓ½Ã
    854          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    855          
    856          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    857          	
    858          	
    859          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    860          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    861          	{
    862          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    863          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    864          		{
    865          			return SMK_RESPONSE_FLAG_SUCCESS;
    866          		}
    867          		else
    868          			return recv_smartkey.Smk_Response_Flag;
    869          	}
    870          	else
    871          		return SMK_RESPONSE_CODE_NOT_MATCH;
    872          }
    873          
    874          void CheckResponseMsgComm(void)
    875          {
    876          	u8 output_buf[8];
    877          	u16 upper_cpk, lower_cpk;
    878          
    879          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    880          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    881          	
    882          	setCipherParam(upper_cpk, lower_cpk);
    883          	//setCipherParam(0x1122, 0x3344);	// ÀÓ½Ã
    884          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    885          
    886          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    887          
    888          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    889          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    890          	{
    891          		if(recv_smartkey.Smk_Response_Code == 1)
    892          		{
    893          			switch(recv_smartkey.Smk_Response_Flag)
    894          			{
    895          				case 2 :
    896          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
    897          					break;
    898          				case 3 :
    899          					SendSMKMsgResult(SMK_MSG_FAIL);
    900          					break;
    901          				case 4 :
    902          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
    903          					break;
    904          				default :
    905          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
    906          					{
    907          						if(recv_smartkey.Registered_Tag_Count == 1)
    908          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
    909          						else if(recv_smartkey.Registered_Tag_Count == 2)
    910          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
    911          						else
    912          							SendSMKMsgResult(SMK_MSG_FAIL);
    913          					}
    914          					else
    915          					{
    916          						if(SMK_Tag_Count != 0)
    917          							SMK_Tag_Count--;
    918          
    919          						SendSMKMsgResult(SMK_MSG_FAIL);
    920          					}
    921          					break;
    922          			}
    923          			
    924          		}
    925          		else if(recv_smartkey.Smk_Response_Code == 2)
    926          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
    927                          else
    928                                  SendSMKMsgResult(SMK_MSG_FAIL);
    929          	}
    930          	else
    931          		SendSMKMsgResult(SMK_MSG_FAIL);
    932          }
    933          
    934          void SmartKeyAuthentication(void)
    935          {
    936          	u8  Auth = 0;
    937          	u8 returnvalue;
    938          
    939          	if(AuthResult != 1)
    940          	{
    941          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
    942          		{
    943          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
    944          			{
    945          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    946          				RequestFirstAuthentication();
    947          			}
    948          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
    949          			{
    950          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
    951          				RequestSecondAuthentication();
    952          			}
    953          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
    954          			{
    955          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
    956          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
    957          
    958          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    959          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
    960          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    961          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
    962          					
    963          				returnvalue = CheckResponseAuthentication(Auth);
    964          					
    965          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
    966          				{
    967          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    968          					{
    969          						gAuthentication_Cnt = 0;
    970          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    971          					}
    972          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    973          					{
    974          						gAuthentication_Cnt = 0;
    975          						AuthResult = 1;
    976          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
    977          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
    978          						SendSMKAuthResult(SMK_SUCCESS);
    979          					}
    980          				}
    981          				else
    982          				{
    983          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
    984          					{
    985          						//AuthResult = 2;
    986          						AuthResult = 1;
    987          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
    988          						SendSMKAuthResult(SMK_FAIL);
    989          						return;
    990          					}
    991          
    992          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
    993          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    994          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
    995          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    996          				}
    997          			}
    998          		}
    999          	}
   1000          	//else if(AuthResult == 1)
   1001          	{
   1002          		if((Uart2_RxMsg_Smk_Reg_Eli[0] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[0] == 2)) 
   1003          		{
   1004          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[0]);
   1005          			SMK_Msg_Send = 1;
   1006          			smk_flag_data.recv_resp_packet = 0;
   1007          			Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
   1008          			Uart2_RxMsg_Smk_Reg_Eli[0] = 0xff;
   1009          		}
   1010          
   1011          		if(SMK_Msg_Send == 1)
   1012          		{
   1013          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
   1014          			{
   1015          				SMK_Msg_Send = 0;
   1016          				CheckResponseMsgComm();
   1017          			}
   1018          		}
   1019          	}
   1020          }
   1021          #endif
   1022          /**
   1023            * @brief  1msec OperationFunc
   1024            * @param  None
   1025            * @retval None
   1026            */
   1027          void WL9FM_1mSecOperationFunc(void)
   1028          {
   1029          #if 1
   1030          	if( Flag_UartTxStart == 1 )
   1031          	{
   1032          		if (SendTime_E2PROM++ > 3) //	25msec
   1033          		{
   1034          			SendTime_E2PROM = 0;
   1035          			SendTo_E2PROM();
   1036          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
   1037          		}			
   1038          	}
   1039          #endif
   1040          }
   1041          
   1042          /**
   1043            * @brief  10msec OperationFunc
   1044            * @param  None
   1045            * @retval None
   1046            */
   1047          void WL9FM_10mSecOperationFunc(void)
   1048          {
   1049          	Lamp_Update_State();	//	LAMP Update »óÅÂ¸¦ Ã¼Å©ÇÑ´Ù.
   1050          	//Lamp_Update_System();  
   1051          	
   1052          	if(Flag_SerialRxMsg != 0)
   1053          	{
   1054          		if((Flag_SerialRxMsg & RX_MSG247) != 0)
   1055          		{
   1056          			Flag_SerialRxMsg &= ~(RX_MSG247);
   1057          			SetCanID(255, 247, 6);
   1058          			CAN_TX_Data(&Uart2_RxMsg_Single_247[0]);
   1059          		}
   1060          		
   1061          		if((Flag_SerialRxMsg & RX_MSG253) != 0)
   1062          		{
   1063          			Flag_SerialRxMsg &= ~(RX_MSG253);
   1064          			SetCanID(255, 253, 6);
   1065          			CAN_TX_Data(&Uart2_RxMsg_Single_253[0]);
   1066          		}
   1067          		
   1068          		if((Flag_SerialRxMsg & RX_MSG203) != 0)	    // 61184 -203 
   1069          		{
   1070          			Flag_SerialRxMsg &= ~(RX_MSG203);
   1071          			SetCanID(239, 228, 6);
   1072          			CAN_TX_Data(&Uart2_RxMsg_Single_46[0]);
   1073          		}
   1074          
   1075          		if((Flag_SerialRxMsg & RX_MSG69) != 0)	    // 69 - Single Packet
   1076          		{
   1077          			Flag_SerialRxMsg &= ~(RX_MSG69);
   1078          			SetCanID(255, 69, 6);
   1079          			CAN_TX_Data(&Uart2_RxMsg_Single_69[0]);
   1080          		}
   1081          		
   1082          		if((Flag_SerialRxMsg & RX_MSG163) != 0)
   1083          		{
   1084          			Flag_SerialRxMsg &= ~(RX_MSG163);
   1085          			SetCanID(255, 163, 6);
   1086          			CAN_TX_Data(&Uart2_RxMsg_Single_163[0]);
   1087          		}
   1088          
   1089          		if((Flag_SerialRxMsg & RX_MSG174) != 0)
   1090          		{
   1091          			Flag_SerialRxMsg &= ~(RX_MSG174);
   1092          			SetCanID(255, 174, 6);
   1093          			CAN_TX_Data(&Uart2_RxMsg_Single_174[0]);
   1094          		}
   1095          		
   1096          		if((Flag_SerialRxMsg & RX_MSG69_M) != 0)	// 69 - Multi Packet
   1097          		{
   1098          			Send_Multipacket_69();
   1099          		}
   1100          		else if((Flag_SerialRxMsg & RX_MSG161) != 0)
   1101          		{
   1102          			Send_Multipacket_161();
   1103          		}
   1104          		else if((Flag_SerialRxMsg & RX_MSG202) != 0)
   1105          		{
   1106          			Send_Multipacket_AS_Num();
   1107          		}
   1108          		else
   1109          		{
   1110          			///+++
   1111          			if(gStartHCE_DT == 1)
   1112          			{
   1113          				if(MachInfoSendCnt <= 60)
   1114          				{
   1115          					if(MultiPacketSendOrder == 0)
   1116          						MultiPacketSendOrder = 1;
   1117          				}
   1118          				else if(MoniInfoSendCnt <= 60)
   1119          					MultiPacketSendOrder = 2;
   1120          			}
   1121          		}
   1122          	}
   1123          	else
   1124          	{
   1125          		///+++
   1126          		if(gStartHCE_DT == 1)
   1127          		{
   1128          			if(MachInfoSendCnt <= 60)
   1129          			{
   1130          				if(MultiPacketSendOrder == 0)
   1131          					MultiPacketSendOrder = 1;
   1132          			}
   1133          			else if(MoniInfoSendCnt <= 60)
   1134          				MultiPacketSendOrder = 2;
   1135          		}
   1136          	}
   1137          
   1138          	if(gStartHCE_DT == 1)
   1139          	{
   1140          		Send_Multipacket_Info();
   1141          	}
   1142          }
   1143          
   1144          /**
   1145            * @brief  100msec OperationFunc
   1146            * @param  None
   1147            * @retval None
   1148            */
   1149          void WL9FM_100mSecOperationFunc(void)
   1150          {
   1151          	Lamp_Update_System();	//	Ã¼Å©µÈ LAMP »óÅÂ¸¦ ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
   1152          
   1153          	SetCanID(255, 160, 6);
   1154          	
   1155          	CAN_TX_Data(&Uart2_RxMsg_Single_160[0]);
   1156          
   1157          	if(((Uart2_RxMsg_Single_160[0] & 0xc0) == 0x00) || ((Uart2_RxMsg_Single_160[0] & 0xc0) == 0x40))		// Speed Up/Down
   1158          		Uart2_RxMsg_Single_160[0] |= 0xc0;
   1159          
   1160              	//  STM32¿¡¼­ KeySwitch¿¡ µû¸¥ BUZZER¿¡ °üÇÑ ¸í·ÉÀ» MCU·Î º¸³»±â À§ÇØ¼­ Ãß°¡~
   1161          	if( (Uart2_RxMsg_Single_160[0] & 0x10 ) == 0x10 )
   1162          	{
   1163          		if( WL9FM_BUZZER.Status == 0 )
   1164          			Uart2_RxMsg_Single_160[0] = Uart2_RxMsg_Single_160[0] & 0xCF;
   1165          	}
   1166          
   1167          	if((Flag_SerialRxMsg & RX_MSG251) != 0)
   1168          	{
   1169          		Flag_SerialRxMsg &= ~(RX_MSG251);
   1170          		SetCanID(255, 251, 6);
   1171          		CAN_TX_Data(&Uart2_RxMsg_Single_251[0]);
   1172          	}
   1173          
   1174          	if((Flag_SerialRxMsg & RX_MSG239) != 0) // send 61184 to mcu
   1175          	{
   1176          		SetCanID(239, 71, 6);
   1177          		CAN_TX_Data(&Uart2_RxMsg_Single_239[0]);
   1178          		if(++send_mcu_data>2)
   1179          		{
   1180          			send_mcu_data=0;
   1181          			Flag_SerialRxMsg &= ~(RX_MSG239);
   1182          		}
   1183          	}
   1184          
   1185          		if((Flag_SerialRxMsg & RX_MSG239_121) != 0) // send 61184 to bkcu
   1186          	{
   1187          		SetCanID(239, 52, 6);
   1188          		CAN_TX_Data(&Uart2_RxMsg_Single_239_121[0]);
   1189          		if(++send_bkcu_data>2)
   1190          		{
   1191          			send_bkcu_data=0;
   1192          			Flag_SerialRxMsg &= ~(RX_MSG239_121);
   1193          		}
   1194          	}
   1195          
   1196          	
   1197          
   1198             	if(++Flag_200mSec >= 2)
   1199             	{
   1200             		Flag_200mSec = 0;
   1201             		SetCanID(255, 162, 6);
   1202             		CAN_TX_Data(&Uart2_RxMsg_Single_162[0]);
   1203             		if(Uart2_RxMsg_Single_162[4] != 0)
   1204             			Uart2_RxMsg_Single_162[4] = 0;
   1205             	}
   1206          #if 0
   1207          	if(Flag_TxE2pRomData == 1)
   1208          		SmartKeyAuthentication();
   1209          #endif
   1210          	
   1211          
   1212          	if((Flag_SerialRxMsg & RX_MSG252) != 0)
   1213          	{
   1214          		Flag_SerialRxMsg &= ~(RX_MSG252);
   1215          
   1216          		WL9FM_RTC.Hour = Uart2_RxMsg_Single_252[4];
   1217          		WL9FM_RTC.Minute = Uart2_RxMsg_Single_252[5];
   1218          		WRITE_RTC(WL9FM_RTC);
   1219          	}
   1220          
   1221          	
   1222          	if(CommErrCnt > 1000)
   1223             	{
   1224             		if( Flag_TxE2pRomData == 1 )
   1225          	   	{
   1226          	   		CAN_COMInit();
   1227             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1228          
   1229          			Buz1 = Buz2 = 0;
   1230          
   1231          			if(++SendRTCnt >= 10)
   1232          			{
   1233          				SendRTCnt = 0;
   1234          
   1235          				RTC_SendToExynos( WL9FM_RTC.Hour, WL9FM_RTC.Minute );
   1236          			}
   1237          			//Buzzer_SendToEXYNOS(1);
   1238          	   	}
   1239          	}	
   1240          	
   1241          	System_CheckPowerIG();
   1242          
   1243          	if(ST_Update)
   1244          	{
   1245          		STM32_Update(Stm32_Update_CMD);	
   1246          		ST_Update=0;
   1247          	}
   1248          		
   1249          	//	WL9A Monitor RESET Code
   1250          	if((SystemReset == 1) || (gRebootCmd == 1))
   1251          	{
   1252          		if(gRebootCmd == 1)
   1253          			SaveDataToEEPROM();
   1254          				
   1255          		//	¿©±â¼­ WL99F_100mSecOperationFunc() ÇÔ¼ö¸¦ ºüÁ®³ª°£´Ù.
   1256          		//	WL9F_100mSecOperationFunc() ÇÔ¼ö°¡ Á¾·áµÇ´Â ½ÃÁ¡¿¡ SYSTEM RESETÀ» ½ÃÅ²´Ù.
   1257          		//	WL9F_Monitor_APP() ÇÔ¼ö·Î ÀÌµ¿!!!
   1258          		return;
   1259          	}
   1260          
   1261          }
   1262          
   1263          
   1264          
   1265          
   1266          /**
   1267            * @brief  1sec OperationFunc
   1268            * @param  None
   1269            * @retval None
   1270            */
   1271          void WL9FM_1SecOperationFunc(void)
   1272          {
   1273          	if(gStartHCE_DT == 1)
   1274          	{
   1275          		CompareMachBasicInfo();
   1276              
   1277          		if(++Flag_1Min >= 60)
   1278          		{
   1279          			Flag_1Min = 0;
   1280          			RequestMachBasicInfo();
   1281          
   1282          			if((MachInfoSendCnt > 60) && (MoniInfoSendCnt > 60))
   1283          				MultiPacketSendOrder = 0;
   1284          		}
   1285          	}
   1286          	read_clock();
   1287          
   1288          
   1289          	//  ++, kutelf, 131007
   1290          	//	Ä«¸Þ¶ó µ¿ÀÛ ¸ðµå ÀÏ °æ¿ì, 3ÃÊ ¸¶´Ù ÇÑ¹ø¾¿ °¢ Ã¤³ÎÀÇ
   1291          	//	»óÅÂ¸¦ Ã¼Å©ÇÏ¿©, Video°¡ ¾øÀ¸¸é No Video ¶ç¿öÁØ´Ù.
   1292          	if (Camera_CheckFlag == 1)
   1293          	{
   1294          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1295          			
   1296          		if ((Camera_CheckCnt % 3) == 0)
   1297          		{
   1298          			cam_mode_check();
   1299          		}
   1300          	}
   1301          	else
   1302          	{
   1303          		Camera_CheckCnt = 0;
   1304          	}
   1305          	//  --, kutelf, 131007
   1306          }
   1307          
   1308          
   1309          void WL9FM_System_Init_Start(void)
   1310          {
   1311          	WL9FM_PowerIG(PowerIG_OFF);					//    ->	GPIO_Control.c PowerIG¸¦ OFF·Î ¸¸µé¾î ³õ°í, 
   1312          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1313          	
   1314          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1315          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1316          	TW2835_Control_Init();	
   1317          	
   1318          	DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1319          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1320          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1321          	FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1322          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1323          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1324          												//		LAMP ALL ON
   1325          	LED_POWER_ONOFF(LED_ON);					//	->	LCD_Control.c (LED On/Off)
   1326          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1327          
   1328          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1329          
   1330          	USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1331          	USART_COMInit(COMPORT4);       				//      COM4 : CMDData
   1332          
   1333          												
   1334          	CAN_COMInit();								//	-> 	CAN_Control.c
   1335          	//InitE2PROM();
   1336          	ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1337          
   1338          	M25P32_Init();
   1339          
   1340          	//WL9FM_PowerIG(PowerIG_ON);				//	->	GPIO_Control.c ÃÊ±âÈ­°¡ ³¡³ª¸é, PowerIG¸¦ ON ÇÑ´Ù.!!
   1341          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF
   1342          	
   1343          
   1344          
   1345          
   1346          	
   1347          }
   1348          
   1349          /**
   1350            * @brief  Application Program Start Point.
   1351            * @param  None
   1352            * @retval None
   1353            */
   1354          void WL9FM_Monitor_APP(void)
   1355          {
   1356          	DebugUART_Init();			//	->	Main.c
   1357          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1358          
   1359          	System_Configuration();		//  ->  System_Init.c
   1360          	                    //      RCC, NVIC, GPIO Initialize
   1361          
   1362          	System_Initialize();		//	-> 	System_Init.c
   1363          								//		IAP¿Í µ¿ÀÏÇÑ ÃÊ±âÈ­¸¦ ÇÑ´Ù. -> »óÅÂ º¯°æ ¾øÀ½.
   1364          	
   1365          //	System °­Á¦ RESET½ÃÅ°±â À§ÇÏ¿© goto lable Ãß°¡..
   1366          SYSTEM_RESET :
   1367          
   1368          	System_Variable_Init();
   1369          	WL9FM_System_Init_Start();
   1370          	
   1371          	/* Infinite loop */
   1372          	while (1)
   1373          	{  
   1374          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1375          		{
   1376          			WL9FM_TIME.Flag_1mSec = 0;
   1377          
   1378          			//  WL9F_1mSecOperationState -> Func ½ÇÇà..
   1379          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1380          			WL9FM_1mSecOperationFunc();
   1381          		}            
   1382          		
   1383          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1384          		{
   1385          			WL9FM_TIME.Flag_10mSec = 0;
   1386          
   1387          			//  WL9F_10mSecOperationState -> Func ½ÇÇà..
   1388          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1389          			WL9FM_10mSecOperationFunc();
   1390          		}
   1391          		
   1392          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1393          		{
   1394          			WL9FM_TIME.Flag_100mSec = 0;
   1395          
   1396          			//  WL9F_100mSecOperationState -> Func ½ÇÇà..
   1397          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1398          			WL9FM_100mSecOperationFunc();
   1399          
   1400          			#if 1
   1401          			//	WL9F Monitor RESET Code
   1402          			if((SystemReset == 1) || (gRebootCmd == 1))
   1403          			{
   1404          				goto SYSTEM_RESET;
   1405          			}
   1406          			#endif
   1407          		}
   1408          		
   1409          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1410          		{
   1411          			WL9FM_TIME.Flag_1Sec = 0;
   1412          
   1413          			//  WL9F_1SecOperationState -> Func ½ÇÇà..
   1414          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1415          			WL9FM_1SecOperationFunc();
   1416                                  
   1417          		}
   1418          	}
   1419          }
   1420          
   1421          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       8   Send_Multipacket_161
         8   -> SendMultiPacketData_161
         8   -> SendTP_CM_BAM_MultiPacket_161
         8   -> TimeDelay_msec
       8   Send_Multipacket_69
         8   -> SendFirstMultiPacket_69
         8   -> SendSecondMultiPacket_69
         8   -> SendTP_CM_BAM_MultiPacket_69
         8   -> SendThirdMultiPacket_69
         8   -> TimeDelay_msec
      16   Send_Multipacket_AS_Num
        16   -> CAN_TX_Data
        16   -> CheckASDataLen
        16   -> SendMultiPacketData_202_AS
        16   -> SendTP_CM_BAM_MultiPacket_202_AS
        16   -> SetCanID
        16   -> TimeDelay_msec
       8   Send_Multipacket_Info
         8   -> SendMultiPacket_MachInfo
         8   -> SendMultiPacket_MoniInfo
         8   -> SendTP_CM_BAM_MultiPacket_MachInfo
         8   -> SendTP_CM_BAM_MultiPacket_MoniInfo
       8   System_CheckPowerIG
         8   -> Buzzer_Off
         8   -> CAN_ITConfig
         8   -> KeySwitch_SendToEXYNOS
         8   -> LCDBL_ONOFF
         8   -> LCDBL_PWM_LEVEL
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> SaveDataToEEPROM
         8   -> TimeDelay_msec
         8   -> USART_ITConfig
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
         8   -> WL9FM_PowerIG
      24   WL9FM_100mSecOperationFunc
        24   -> CAN_COMInit
        24   -> CAN_ITConfig
        24   -> CAN_TX_Data
        24   -> Lamp_Update_System
        24   -> RTC_SendToExynos
        24   -> STM32_Update
        24   -> SaveDataToEEPROM
        24   -> SetCanID
        24   -> System_CheckPowerIG
        24   -> WRITE_RTC
      16   WL9FM_10mSecOperationFunc
        16   -> CAN_TX_Data
        16   -> Lamp_Update_State
        16   -> Send_Multipacket_161
        16   -> Send_Multipacket_69
        16   -> Send_Multipacket_AS_Num
        16   -> Send_Multipacket_Info
        16   -> SetCanID
       8   WL9FM_1SecOperationFunc
         8   -> CompareMachBasicInfo
         8   -> READ_RTC
         8   -> RequestMachBasicInfo
         0   -> cam_mode_check
       8   WL9FM_1mSecOperationFunc
         0   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
      16   WL9FM_Monitor_APP
        16   -> CompareMachBasicInfo
        16   -> DebugUART_Init
        16   -> KeySwitch_SendToEXYNOS
        16   -> READ_RTC
        16   -> RequestMachBasicInfo
        16   -> SendTo_E2PROM
        16   -> System_Configuration
        16   -> System_Initialize
        16   -> System_Variable_Init
        16   -> WL9FM_100mSecOperationFunc
        16   -> WL9FM_10mSecOperationFunc
        16   -> WL9FM_System_Init_Start
        16   -> cam_mode_check
       8   WL9FM_System_Init_Start
         8   -> Buzzer_Init
         8   -> CAN_COMInit
         8   -> DPRAM_Init
         8   -> FM3164_Watchdog_Init
         8   -> Hardware_Version_Init
         8   -> KeySwitch_Init
         8   -> LAMP_Control_Init
         8   -> LCD_Control_Init
         8   -> LCD_POWER_ONOFF
         8   -> LED_POWER_ONOFF
         8   -> M25P32_Init
         8   -> ReadE2PROM_ToSend
         8   -> TW2835_Control_Init
         8   -> TW8832_Control_Init
         8   -> USART_COMInit
         8   -> WL9FM_CAMERA_nRESET
         8   -> WL9FM_EXYNOS_POWER_ONOFF
         8   -> WL9FM_PowerIG
       8   read_clock
         8   -> READ_RTC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_27
       4  ??DataTable15_28
       4  ??DataTable15_29
       4  ??DataTable15_3
       4  ??DataTable15_30
       4  ??DataTable15_31
       4  ??DataTable15_32
       4  ??DataTable15_33
       4  ??DataTable15_34
       4  ??DataTable15_35
       4  ??DataTable15_36
       4  ??DataTable15_37
       4  ??DataTable15_38
       4  ??DataTable15_39
       4  ??DataTable15_4
       4  ??DataTable15_40
       4  ??DataTable15_41
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       1  AuthResult
       2  E2PROM_Save
          PwrOffCnt
      16  Flag_200mSec
          SendRTCnt
          send_mcu_data
          send_bkcu_data
          ST_Update
          WL9FM_BUZZER
     458  InitE2PROM
      50  Init_RTC
       1  KeySwitch_Value
       4  LAMP_Update_Data
       6  MachInfoTotalPacketNum
          MoniInfoTotalPacketNum
          Flag_1Sec_MachInfo
          Flag_1Sec_MoniInfo
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
     326  ReadE2PROM_ToSend
       1  SMK_Msg_Send
       1  SMK_Tag_Count
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      76  Send_Multipacket_161
     176  Send_Multipacket_69
     166  Send_Multipacket_AS_Num
     190  Send_Multipacket_Info
     222  System_CheckPowerIG
     374  WL9FM_100mSecOperationFunc
     278  WL9FM_10mSecOperationFunc
     116  WL9FM_1SecOperationFunc
      46  WL9FM_1mSecOperationFunc
       4  WL9FM_LCDBL
     228  WL9FM_Monitor_APP
      58  WL9FM_RTC
          SerialMsgRTC
          MultiPacketSendOrder
          TotalPacketNum
          gStartHCE_DT
          MachInfoSendCnt
          MoniInfoSendCnt
          Flag_UartTxStart
          SendTime_E2PROM
          SystemReset
          gRebootCmd
          WL9FM_TIME
          Flag_1Min
     100  WL9FM_System_Init_Start
     520  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
      58  eepRomReadData1
          MoniInfoData
          adc_value
       1  gAuthentication_Cnt
       8  rand_value
      22  read_clock
       8  recv_smartkey
       8  send_smartkey
       4  smk_flag_data

 
 2 802 bytes in section .bss
 3 628 bytes in section .text
 
 3 628 bytes of CODE memory
 2 802 bytes of DATA memory

Errors: none
Warnings: none
