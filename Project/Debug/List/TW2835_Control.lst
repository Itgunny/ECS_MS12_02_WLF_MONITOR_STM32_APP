###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:36 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW2835_Control.c                                 #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW2835_Control.c" -D USE_STDPERIPH_DRIVER -D     #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\TW2835 #
#                    _Control.lst                                             #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\TW2835_ #
#                    Control.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\TW2835_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    TW2835_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   TW2835_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          //==================================================================================
     29          //						Page1 initialize table description
     30          //==================================================================================
     31          unsigned char	tbl_pg1_x_cmn[] = {
     32          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     33          	     0x02,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0xd7,0x23,0x2d,0x1e,0xa7,	//...  0x01
     34          	0x80,0x02,0x00,0x00,0x02,0x00,0x10,0x00,	0x81,0x02,0x00,0x01,0x02,0x00,0x11,0x00,	//...  0x10	//... normal quad
     35          	0x82,0x02,0x00,0x02,0x02,0x00,0x12,0x00,	0x83,0x02,0x00,0x03,0x02,0x00,0x13,0x00,	//...  0x20
     36          //	0x90,0x02,0x00,0x90,0x02,0x00,0x10,0x00,	0x91,0x02,0x00,0x91,0x02,0x00,0x11,0x00,	//... 0x10	//... non-realtime
     37          //	0x92,0x02,0x00,0x92,0x02,0x00,0x12,0x00,	0x93,0x02,0x00,0x93,0x02,0x00,0x13,0x00,	//... 0x20
     38          };
     39          
     40          //--------------------------		NTSC		------------------------------//
     41          //... H:60(3c),90(5a),120(78),180(b4), V:40(28),60(3c),80(50),120(78) for NTSC, 48(30),72(48),96(60),144(90) for PAL
     42          unsigned char	tbl_ntsc_pg1_pic_fl[] = {
     43          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     44          	0x00,0xb4,0x00,0x78,0x00,0xb4,0x00,0x78,	0x00,0xb4,0x00,0x78,0x00,0xb4,0x00,0x78	//...  
     45          };
     46          
     47          unsigned char	tbl_ntsc_pg1_pic_qd[] = {
     48          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     49          	0x00,0x5a,0x00,0x3c,0x5a,0xb4,0x00,0x3c,	0x00,0x5a,0x3c,0x78,0x5a,0xb4,0x3c,0x78	//...  
     50          };
     51          
     52          unsigned char	tbl_ntsc_pg1_pic_9_lt[] = {
     53          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     54          	0x00,0x3c,0x00,0x28,0x3c,0x78,0x00,0x28,	0x78,0xb4,0x00,0x28,0x00,0x3c,0x28,0x50	//...   
     55          };
     56          
     57          unsigned char	tbl_ntsc_pg1_pic_9_rb[] = {
     58          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     59          	0x78,0xb4,0x28,0x50,0x00,0x3c,0x50,0x78,	0x3c,0x78,0x50,0x78,0x78,0xb4,0x50,0x78	//...   
     60          };
     61          
     62          //--------------------------		PAL		------------------------------//
     63          //... H:60(3c),90(5a),120(78),180(b4), V:40(28),60(3c),80(50),120(78) for NTSC, 48(30),72(48),96(60),144(90) for PAL
     64          unsigned char	tbl_pal_pg1_pic_fl[] = {
     65          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     66          	0x00,0xb4,0x00,0x90,0x00,0xb4,0x00,0x90,	0x00,0xb4,0x00,0x90,0x00,0xb4,0x00,0x90	//...  
     67          };
     68          
     69          unsigned char	tbl_pal_pg1_pic_qd[] = {
     70          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     71          	0x00,0x5a,0x00,0x48,0x5a,0xb4,0x00,0x48,	0x00,0x5a,0x48,0x90,0x5a,0xb4,0x48,0x90	//...  
     72          };
     73          
     74          unsigned char	tbl_pal_pg1_pic_9_lt[] = {
     75          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     76          	0x00,0x3c,0x00,0x30,0x3c,0x78,0x00,0x30,	0x78,0xb4,0x00,0x30,0x00,0x3c,0x30,0x60	//...   
     77          };
     78          
     79          unsigned char	tbl_pal_pg1_pic_9_rb[] = {
     80          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     81          	0x78,0xb4,0x30,0x60,0x00,0x3c,0x60,0x90,	0x3c,0x78,0x60,0x90,0x78,0xb4,0x60,0x90	//...   
     82          };
     83          
     84          //=================================================================================
     85          
     86          unsigned char	tbl_pg1_y_cmn[] = {
     87          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
     88          	0x28,0x00,0x10,0xa0,0x00,0x00,0x00,0x03,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa7,//... 0x50 
     89          	0x80,0x02,0x00,0x81,0x02,0x00,0x82,0x02,	0x00,0x83,0x02,0x00,0x00,0xe4,0x00,0x00,//... 0x60	//... normal quad
     90          //	0x90,0x02,0x00,0x91,0x02,0x00,0x92,0x02,	0x00,0x93,0x02,0x00,0x00,0xe4,0x00,0x00,//...0x60	//...non-realtime
     91          	0x00,0x03,0x00,0x00,0x00,0x00,0x02,0x00,	0xff,0xff,0xff,0xff,0xf0,0x00,0x8b,0x84,//... 0x70 
     92          //	0xff,0x00,0x51,0x07,0xeb,0x10,0xa8,0x00,	0x51,0xe7,0x80,0x00,0x00,0x00,0x00,0x00,//...0x80
     93          	0xdf,0x00,0x91,0x07,0xeb,0x10,0xa8,0x00,	0x91,0xe7,0x80,0x00,0x00,0x00,0x00,0x00,//... 0x80	//... update:060715
     94          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//... 0x90
     95          };
     96          
     97          //--------------------------		NTSC		------------------------------//
     98          //=================================================================================
     99          unsigned char	tbl_ntsc_pg1_enc[] = {
    100          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    101          	0x77,0x23,0xd7,0x01,0x80,0x20,0x00,0x0c,	0x20,0x09,0xaa,0x00,0x40,0x40,0x00,0x00	//... 0xa0
    102          //	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...0xb0
    103          };
    104          //--------------------------		PAL		------------------------------//
    105          //=================================================================================
    106          unsigned char	tbl_pal_pg1_enc[] = {
    107          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    108          	0x77,0x23,0xd7,0x01,0x80,0x20,0x00,0x0c,	0x20,0x4c,0xaa,0x00,0x40,0x40,0x00,0x00	//... 0xa0
    109          //	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...0xb0
    110          };
    111          //=================================================================================
    112          
    113          //==================================================================================
    114          //						Page2 initialize table description
    115          //==================================================================================
    116          
    117          //--------------------------		PAGE 2		------------------------------//
    118          unsigned char	tbl_pg2_mse_box[] = {		// 80 EA
    119          //  00   01   02   03   04   05   06   07		 08   09   0A   0B   0C   0D   0E   0F
    120          	//... mouse & LUT
    121          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x10
    122          	//... single box
    123          	0x00,0xb0,0x00,0x00,0x00,0x00,0x40,0x00,	0x00,0x00,0x00,0x00,0x00,0xb0,0x00,0x00,//...  0x20
    124          	0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x30
    125          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x40
    126          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x40,0x40,0x40,0x42,0xff	//...  0x50
    127          };
    128          
    129          unsigned char	tbl_ntsc_pg2_2dbox[] = {		// 32 EA
    130          	//... 2d array box
    131          	0x88,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,	0x89,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,//...  0x60
    132          	0x8a,0x00,0x00,0x00,0x00,0x00,0xfb,0x00,	0x8b,0x00,0x00,0x00,0x00,0x00,0xfb,0x00	//...  0x70
    133          };
    134          
    135          unsigned char	tbl_ntsc_pg2_mtn[] = {		// 32 EA
    136          	//... sensitivity & mask info
    137          	0x17,0x73,0x88,0x4a,0x07,0x24,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x80
    138          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...  0x90
    139          };
    140          
    141          
    142          unsigned char	tbl_pal_pg2_2dbox[] = {		// 32 EA
    143          	//... 2d array box
    144          	0x20,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,	0x21,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,//...  0x60
    145          	0x22,0x28,0x00,0x00,0x00,0x00,0xfb,0x00,	0x23,0x28,0x00,0x00,0x00,0x00,0xfb,0x00	//...  0x70
    146          };
    147          
    148          unsigned char	tbl_pal_pg2_mtn[] = {		// 32 EA
    149          	//... sensitivity & mask info
    150          	0x17,0x73,0x88,0x4a,0x07,0x24,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...  0x80
    151          	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	//...  0x90
    152          };
    153          
    154          unsigned char Register_Table_Page0[] = {
    155          //  0    1    2    3    4    5    6    7       8    9    a    b    c    d    e    f   
    156              0x00,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x00 
    157              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x10
    158              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x20
    159              0x80,0xC8,0x20,0xD0,0x06,0xF0,0x08,0x80,   0x80,0x80,0x80,0x00,0x00,0x00,0x11,0x00, //  0x30
    160              0x00,0x77,0x77,0x45,0xA0,0xD0,0x2F,0x64,   0x80,0x80,0x82,0x82,0x00,0x0F,0x05,0x00, //  0x40
    161              0x00,0x80,0x06,0x00,0x40,0xFF,0x00,0x00,   0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x50
    162              0xFF,0xFF,0x00,0x00,0x10,0x32,0x54,0x76,   0x00,0xBA,0xDC,0xFE,0x00,0x00,0x88,0x88, //  0x60
    163              0x08,0x54,0x00,0x00,0x00,0x00,0x00,0x00,   0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x70
    164              0x01,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0x31,0x00,0xD0,0x00,0xF0,0x08, //  0x80
    165              0x41,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0x71,0x00,0xD0,0x00,0xF0,0x08, //  0x90
    166              0x81,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0xB1,0x00,0xD0,0x00,0xF0,0x08, //  0xa0 
    167              0xC1,0x7F,0xFF,0x7F,0xFF,0x00,0xFF,0xFF,   0xFF,0xFF,0xF1,0x00,0xD0,0x00,0xF0,0x08, //  0xb0 
    168              0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,   0x00,0x3C,0x4F,0x00,0x00,0x00,0x00,0x00, //  0xc0 
    169              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xd0 
    170              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xe0 
    171              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00  //  0xf0 
    172          };
    173          unsigned char Register_Table_Page1[] = { 
    174          //  0    1    2    3    4    5    6    7                         8    9         a       b       c    d    e    f       
    175              0x00,0x00,0x00,0x00,0x0F,0x04,0x00,0x00,   0x00,0x00,0x20,0xD7,0x23,0x2D,0x1E,0xA3, //  0x00 
    176              0x80,0x02,0x00,0x00,0x02,0x00,0x10,0x00,   0x81,0x02,0x00,0x01,0x02,0x00,0x11,0x00, //  0x10 
    177              0x82,0x02,0x00,0x02,0x02,0x00,0x12,0x00,   0x83,0x02,0x00,0x03,0x02,0x00,0x13,0x00, //  0x20
    178              //0x00,0x02,0x00,0x00,0x02,0x00,0x10,0x00,   0x01,0x02,0x00,0x01,0x02,0x00,0x11,0x00, //  0x10 
    179              //0x02,0x02,0x00,0x02,0x02,0x00,0x12,0x00,   0x03,0x02,0x00,0x03,0x02,0x00,0x13,0x00, //  0x20
    180              0x00,0x58,0x00,0x3C,0x58,0xB0,0x00,0x3C,   0x00,0x58,0x3C,0x78,0x58,0xB0,0x3C,0x78, //  0x30 
    181              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x40 
    182              0x28,0x41,0x10,0xa0,0x00,0x00,0x00,0x03,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa3, //  0x50 
    183              0x80,0x00,0x00,0x81,0x00,0x00,0x82,0x00,   0x00,0x83,0x00,0x00,0x00,0xe4,0x00,0x00, //  0x60 
    184              0x00,0x03,0x00,0x00,0x00,0x00,0x02,0x00,   0xff,0xff,0xff,0xff,0xf0,0x00,0x89,0x84, //  0x70 
    185              0xdf,0x00,0x91,0x07,0xeb,0x10,0xa8,0x00,   0x91,0xe7,0x80,0x00,0x00,0x00,0x00,0x00, //  0x80 
    186              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0x90 
    187              0x77,0x91,0x90,0x00,0x80,0x20,0x00,0x0c,   0x20,0x09,0xaa,0x00,0x40,0x40,0x00,0x00, //  0xa0 
    188              0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x0F,   0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xb0 
    189              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xc0 
    190              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xd0 
    191              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  0xe0 
    192              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //  0xf0
    193          };
    194          
    195          struct	{							//	struct cmn_flg Byte   
    196          	union {							//	ST        
    197                 	u8 BYTE;					//  Byte Access 
    198                 	struct {					//  Bit  Access 
    199                      u8 b_cmn_tmp:1;	    	//  Bit 7     
    200                      u8 b_cmn_NA:1;       	//  Bit 6     
    201                      u8 b_cmn_prtcl_bsy:1;	//  Bit 5     
    202                      u8 b_cmn_irq:1;		    //  Bit 4     
    203                      u8 b_cmn_wndw_mn:1;		//  Bit 3     
    204                      u8 b_cmn_wndw_pop:1;	//  Bit 2     
    205                    	u8 b_cmn_jp_vdo:2;	    //  Bit 1     
    206                     	u8 b_cmn_dtct_vs:1;		//  Bit 0     
    207                    	
    208                	}	BIT;					
    209          	}		ST;						
    210          }			cmn_flg;
    211          
    212          struct	{							//	struct cmn_flg Byte   
    213          	union {							//	ST        
    214                 	u8 BYTE;					//  Byte Access 
    215                 	struct {					//  Bit  Access 
    216                 	    u8 b_cmn_NA:1;	    	//  Bit 7     
    217                      u8 b_cmn_cnt_1s:1;	    //  Bit 6     
    218                      u8 b_cmn_cnt_05s:1;	    //  Bit 5     
    219                      u8 b_cmn_cnt_02s:1;		//  Bit 4     
    220                      u8 b_cmn_cnt_01s:1;		//  Bit 3     
    221                      u8 b_cmn_cnt_tgl:1;	    //  Bit 2     
    222                    	u8 b_cmn_cnt_fld:2;	    //  Bit 1     
    223                     	u8 b_cmn_cnt_vs:1;		//  Bit 0     
    224                    	
    225                	}	BIT;						
    226          	}		ST;							
    227          }			cmn_flg_cnt;
    228          
    229          struct	{							//	struct cmn_flg Byte   
    230          	union {							//	ST        
    231                 	u8 BYTE;					//  Byte Access 
    232                 	struct {					//  Bit  Access 
    233                      u8 b_ds_wth_cif:1;	    //  Bit 7     
    234                      u8 b_ds_wth_4pb:1;	    //  Bit 6     
    235                      u8 b_ds_wth_16pb:1;		//  Bit 5     
    236                      u8 b_ds_wth_rc:1;		//  Bit 4     
    237                      u8 b_ds_in_run:2;	    //  Bit 3     
    238                     	u8 b_ds_in_auto:1;		//  Bit 2     
    239                     	u8 b_cmn_NA:2;	    	//  Bit 0~1
    240                    	
    241                	}	BIT;						
    242          	}		ST;							
    243          }			wndw_flg_ds;
    244          
    245          struct	{							//	struct cmn_flg Byte   
    246          	union {							//	ST        
    247                 	u8 BYTE;					//  Byte Access 
    248                 	struct {					//  Bit  Access 
    249                 	    u8 b_ch_src:1;	    	//  Bit 7     
    250                      u8 b_ado_lv_mr:1;	    //  Bit 6     
    251                      u8 b_ado_lv_mr_arw_pb:1;//  Bit 5     
    252                      u8 b_cmn_NA:5;  		//  Bit 0~4     
    253                      
    254                	}	BIT;						
    255          	}		ST;							
    256          }			wndw_flg;
    257          
    258          
    259          
    260          u8	cmn_bot;
    261          u8	cmn_cnt_vs = 0;
    262          u8	cmn_cnt_vs_sub = 0;
    263          u8	cmn_vga_det = 0;				//... __WTH_VGA__일때 idata 없애면 compile시 error 발생.
    264          
    265          
    266          u8	cmn_dvc = MASTER;
    267          u8	cmn_lst_slvr_x = MASTER;
    268          u8	cmn_lst_slvr_y = MASTER;
    269          u8	cmn_max_ch = 4;
    270          
    271          u8 	read_data[0x0100];
    272          u8 	Temp;
    273          
    274          /* Private function prototypes -----------------------------------------------*/
    275          /* Private functions ---------------------------------------------------------*/
    276          
    277          void SetAsicFlgType(u8 _dvc, u8 _pg, u8 _addr, u8 _flg, u8 _data)
    278          {
    279          	u8 _t1_;
    280          
    281          	_t1_ = ReadAsicByte(_dvc,_pg,_addr);
    282          	_t1_ = (_t1_ & ~_flg)|_data;
    283          	WriteAsicByte(_dvc,_pg,_addr,_t1_);
    284          }
    285          
    286          void InitPg0(void)
    287          {
    288              	WriteAsicTable(MASTER,DVC_PG0,0x00,Register_Table_Page0,0xff);
    289          }
    290          
    291          void InitPg1(void)
    292          {
    293          	WriteAsicTable(MASTER,DVC_PG1,0x00,Register_Table_Page1,0xff);
    294          }
    295          
    296          void InitPg2(void)
    297          {
    298          	u8 _t1_;
    299          
    300          	//... OSD color index
    301          	InitOSDCol();
    302          
    303          	WriteAsicByte(MASTER,DVC_PG2,0x0f,0x0f);		//... OSD Enable for Display/Capture	
    304          
    305          	WriteOSDClrX(MASTER,0,0,0,45,31);				//... max line num is 310 line for OSD
    306          	WriteOSDClrX(MASTER,1,0,0,45,31);				//... max line num is 310 line for OSD
    307          	WriteOSDClrX(MASTER,2,0,0,45,31);				//... max line num is 310 line for OSD
    308          	WriteOSDClrX(MASTER,3,0,0,45,31);				//... max line num is 310 line for OSD
    309          	WriteOSDClrY(MASTER,0,0,45,31);					//... max line num is 310 line for OSD
    310          
    311          	WriteAsicByte(MASTER,DVC_PG2,0x10,0xf0);		//... cursor
    312          
    313          	//... other ( mouse, single box, 2d box, mask ..)
    314          	WriteAsicTable(MASTER,DVC_PG2,0x10,tbl_pg2_mse_box,80);
    315          	if(cmn_flg.ST.BIT.b_cmn_jp_vdo == VDO_NTSC){
    316          		WriteAsicTable(MASTER,DVC_PG2,0x60,tbl_ntsc_pg2_2dbox,32);
    317          		for(_t1_=0;_t1_<4;_t1_++)	WriteAsicTable(MASTER,DVC_PG2,0x80+0x20*_t1_,tbl_ntsc_pg2_mtn,32);
    318          	}
    319          	else{
    320          		WriteAsicTable(MASTER,DVC_PG2,0x60,tbl_pal_pg2_2dbox,32);
    321          		for(_t1_=0;_t1_<4;_t1_++)	WriteAsicTable(MASTER,DVC_PG2,0x80+0x20*_t1_,tbl_pal_pg2_mtn,32);
    322          	}
    323          }
    324          
    325          void WriteAsicByteOSD(u8 _dvc, u8 _addr, u8 _wdat)
    326          {
    327          #if	defined(__EN_ISR__)
    328          	EA = 0;
    329          #endif
    330          	Temp = _dvc;
    331          
    332          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    333          
    334          	HALE_RESET;
    335          	HRDB_SET;
    336          	HWRB_SET;
    337          	HSPB_RESET;
    338          
    339          	_dvc = 0;							//... temporal
    340          	HCSB0_RESET;
    341          	HCSB1_SET;
    342          
    343          	Write_TW2835(_addr);
    344          	HALE_SET;
    345          	HALE_RESET;
    346          
    347          	Write_TW2835(_wdat);
    348          	HWRB_RESET;
    349          	HWRB_SET;
    350          
    351          	HALE_RESET;
    352          	HRDB_SET;
    353          	HWRB_SET;
    354          	HSPB_RESET;
    355          
    356          	HCSB0_SET;
    357          	HCSB1_SET;
    358          
    359          	Write_TW2835(0xFF);
    360          
    361          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    362          #if	defined(__EN_ISR__)
    363          	EA = 1;
    364          #endif
    365          }
    366          
    367          void WriteAsicTableOSD(u8 _dvc, u8 _addr, u8 *_tbl_ptr)
    368          {
    369          	u8 _t1_;
    370          
    371          #if	defined(__EN_ISR__)
    372          	EA = 0;
    373          #endif
    374             	Temp = _dvc;
    375          
    376          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    377          
    378          	HALE_RESET;
    379          	HRDB_SET;
    380          	HWRB_SET;
    381          	HSPB_RESET;
    382          
    383          	_dvc = 0;							//... temporal
    384          	HCSB0_RESET;
    385          	HCSB1_SET;
    386          
    387          	Write_TW2835(_addr);
    388          
    389          	HALE_SET;
    390          	HALE_RESET;
    391          
    392          
    393          	for(_t1_=0;_t1_<5;_t1_++)
    394          	{
    395          		Write_TW2835(_tbl_ptr[_t1_]);
    396          		HWRB_RESET;
    397          		HWRB_SET;
    398          	}
    399          
    400          	HALE_RESET;
    401          	HRDB_SET;
    402          	HWRB_SET;
    403          	HSPB_RESET;
    404          
    405          
    406          	HCSB0_SET;
    407          	HCSB1_SET;
    408          
    409          	Write_TW2835(0xFF);
    410          
    411          
    412          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    413          #if	defined(__EN_ISR__)
    414          	EA = 1;
    415          #endif
    416          
    417          }
    418          
    419          void WriteAsicByte(u8 _dvc, u8 _pg, u8 _addr, u8 _wdat)
    420          {
    421          
    422          #if	defined(__EN_ISR__)
    423          	EA = 0;
    424          #endif
    425             	Temp = _dvc;
    426                  
    427          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    428          
    429          	HALE_RESET;
    430          	HRDB_SET;
    431          	HWRB_SET;
    432          	HSPB_RESET;
    433          
    434          	_dvc = 0;							//... temporal
    435          	if(_pg == DVC_PG0)
    436          	{	
    437          		HCSB1_RESET;	HCSB0_RESET;
    438          	}
    439          	else if(_pg == DVC_PG1)
    440          	{	
    441          		HCSB1_RESET;	
    442          		HCSB0_SET;
    443          	}
    444          	else if(_pg == DVC_PG2)
    445          	{	
    446          		HCSB1_SET;	
    447          		HCSB0_RESET;
    448          	}
    449          
    450          	Write_TW2835(_addr);
    451          	HALE_SET;
    452          	HALE_RESET;
    453          
    454          	Write_TW2835(_wdat);
    455          	HWRB_RESET;
    456          	HWRB_SET;
    457          
    458          	HALE_RESET;
    459          	HRDB_SET;
    460          	HWRB_SET;
    461          	HSPB_RESET;
    462          
    463          	HCSB0_SET;
    464          	HCSB1_SET;
    465          
    466          	Write_TW2835(0xFF);
    467          
    468          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    469          #if	defined(__EN_ISR__)
    470          	EA = 1;
    471          #endif
    472          }
    473          
    474          void WriteAsicTable(u8 _dvc, u8 _pg, u8 _addr, u8 *_tbl_ptr, u16 _tbl_cnt)
    475          {
    476          	u16 _t1_;
    477          
    478          
    479          #if	defined(__EN_ISR__)
    480          	EA = 0;
    481          #endif
    482             	Temp = _dvc;
    483          
    484          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    485          
    486          	HALE_RESET;
    487          	HRDB_SET;
    488          	HWRB_SET;
    489          	HSPB_RESET;
    490          
    491          
    492          	_dvc = 0;							//... temporal
    493          	if(_pg == DVC_PG0)      
    494          	{	
    495          		HCSB1_RESET;	
    496          		HCSB0_RESET;
    497          	}
    498          	else if(_pg == DVC_PG1) 
    499          	{	
    500          		HCSB1_RESET;	
    501          		HCSB0_SET;
    502          	}
    503          	else if(_pg == DVC_PG2)
    504          	{	
    505          		HCSB1_SET;	 
    506          		HCSB0_RESET;
    507          	}
    508          
    509          
    510          	Write_TW2835(_addr);
    511          	HALE_SET;
    512          	HALE_RESET;
    513          
    514          
    515          	for(_t1_=0;_t1_<_tbl_cnt;_t1_++)
    516          	{
    517          		Write_TW2835(_tbl_ptr[_t1_]);
    518          		HWRB_RESET;
    519          		HWRB_SET;   
    520          	}	
    521          
    522          	HALE_RESET;
    523          	HRDB_SET;
    524          	HWRB_SET;
    525          	HSPB_RESET;
    526          
    527          	HCSB0_SET;
    528          	HCSB1_SET;
    529          
    530          	Write_TW2835(0xFF);
    531          
    532          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    533          
    534          #if	defined(__EN_ISR__)
    535          	EA = 1;
    536          #endif
    537          }
    538          
    539          void ReadAsicTable(u8 _dvc, u8 _pg, u8 _addr, u16 _data_cnt)
    540          {
    541          	u16 _t1_;
    542          
    543          #if	defined(__EN_ISR__)
    544          	EA = 0;
    545          #endif
    546             	Temp = _dvc;
    547              
    548          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    549          
    550          	HALE_RESET;
    551          	HRDB_SET;
    552          	HWRB_SET;
    553          	HSPB_RESET;
    554          
    555          	_dvc = 0;							//... temporal
    556          	if(_pg == DVC_PG0)     
    557          	{
    558          		HCSB1_RESET;	
    559          		HCSB0_RESET;
    560          	}
    561          	else if(_pg == DVC_PG1) 
    562          	{
    563          		HCSB1_RESET;	
    564          		HCSB0_SET;
    565          	}
    566          	else if(_pg == DVC_PG2) 
    567          	{
    568          		HCSB1_SET;	    
    569          		HCSB0_RESET;
    570          	}
    571          
    572          	Write_TW2835(_addr);
    573          	HALE_SET;
    574          	HALE_RESET;
    575          
    576          	for(_t1_=0;_t1_<_data_cnt;_t1_++)
    577          	{
    578          		//Write_TW2835(0xFF);
    579          		HRDB_RESET;		
    580          		read_data[_t1_]= Read_TW2835();
    581          		HRDB_SET;
    582          	}
    583          
    584          	HALE_RESET;
    585          	HRDB_SET;
    586          	HWRB_SET;
    587          	HSPB_RESET;
    588          
    589          	HCSB0_SET;
    590          	HCSB1_SET;
    591          
    592          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    593          
    594          #if	defined(__EN_ISR__)
    595          	EA = 1;
    596          #endif
    597          
    598          }
    599          
    600          u8 ReadAsicByte(u8 _dvc, u8 _pg, u8 _addr)
    601          {
    602          	u8 _rdat_;
    603          
    604          #if	defined(__EN_ISR__)
    605          	EA = 0;
    606          #endif
    607             	Temp = _dvc;
    608              
    609          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    610          
    611          	HALE_RESET;
    612          	HRDB_SET;
    613          	HWRB_SET;
    614          	HSPB_RESET;
    615          
    616          	if(_pg == DVC_PG0)      
    617          	{	
    618          		HCSB1_RESET;	
    619          		HCSB0_RESET;
    620          	}
    621          	else if(_pg == DVC_PG1)
    622          	{
    623          		HCSB1_RESET;
    624          		HCSB0_SET;
    625          	}
    626          	else if(_pg == DVC_PG2) 
    627          	{	
    628          		HCSB1_SET;	 
    629          		HCSB0_RESET;
    630          	}
    631          
    632          	Write_TW2835(_addr);
    633          	HALE_SET;
    634          	HALE_RESET;
    635          
    636          	//Write_TW2835(0xFF);
    637          
    638          	HRDB_RESET;
    639          	_rdat_ = Read_TW2835();
    640          	HRDB_SET;
    641          
    642          
    643          	HALE_RESET;
    644          	HRDB_SET;
    645          	HWRB_SET;
    646          	HSPB_RESET;
    647          
    648          	HCSB0_SET;
    649          	HCSB1_SET;
    650          
    651          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    652          
    653          #if	defined(__EN_ISR__)
    654          	EA = 1;
    655          #endif
    656          
    657          	return _rdat_;
    658          }
    659          
    660          u8	ReadAsicOSDMemWr(u8 _dvc)
    661          {
    662          	u8 _rdat_;
    663          //	u16 temp_16;
    664          
    665          #if	defined(__EN_ISR__)
    666          	EA = 0;
    667          #endif
    668             	Temp = _dvc;
    669          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=1;
    670          
    671          	HALE_RESET;
    672          	HRDB_SET;
    673          	HWRB_SET;
    674          	HSPB_RESET;
    675          
    676          
    677          	_dvc = 0;							//... temporal
    678          	HCSB0_RESET;
    679          	HCSB1_SET;
    680          
    681          
    682          	Write_TW2835(0x0A);
    683          	HALE_SET;
    684          	HALE_RESET;
    685          
    686          
    687          	Write_TW2835(0xFF);
    688          	HRDB_RESET;
    689          
    690          
    691          	_rdat_ = Read_TW2835();
    692          	HRDB_SET;
    693          
    694          
    695          	HALE_RESET;	
    696          	HRDB_SET;
    697          	HWRB_SET;
    698          	HSPB_RESET;
    699          
    700          	HCSB0_SET;
    701          	HCSB1_SET;
    702          
    703          	cmn_flg.ST.BIT.b_cmn_prtcl_bsy=0;
    704          
    705          #if	defined(__EN_ISR__)
    706          	EA = 1;
    707          #endif
    708          
    709          	return _rdat_;
    710          }
    711          
    712          void	InitVdo(void)
    713          {
    714          	cmn_flg.ST.BIT.b_cmn_jp_vdo = VDO_NTSC;
    715          	cmn_bot = 120;
    716          	cmn_cnt_vs_sub = 54;
    717          }
    718          
    719          
    720          void Write_TW2835(u8 Data)
    721          {
    722          	u16 TempData;
    723          
    724          	Port_Change(TW2835_WRITE);
    725          
    726          	TempData = GPIO_ReadOutputData(TW2835_DATAPORT) & 0xFF00;
    727          	TempData |= ((u16)Data & 0x00FF);
    728          	
    729          	GPIO_Write(TW2835_DATAPORT,TempData);
    730          }
    731          
    732          u8 Read_TW2835()
    733          {
    734          	u8 Result;
    735          	Port_Change(TW2835_READ);
    736          
    737          	Result = (u8)(GPIO_ReadInputData(TW2835_DATAPORT) & 0x00FF);
    738          	
    739          
    740          	return Result;
    741          }
    742          
    743          void Port_Change(u8 in_Dir)
    744          {
    745          	GPIO_InitTypeDef GPIO_InitStructure;
    746          
    747          
    748          	if(in_Dir == TW2835_WRITE)
    749          	{
    750          		GPIO_InitStructure.GPIO_Pin = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | 
    751          										TW2835_D5 | TW2835_D6 | TW2835_D7;
    752          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    753          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    754                          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    755                          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;    
    756          		GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    757          	}
    758          	else if(in_Dir == TW2835_READ)
    759          	{
    760          		GPIO_InitStructure.GPIO_Pin = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | 
    761          										TW2835_D5 | TW2835_D6 | TW2835_D7;
    762          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    763          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    764                          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    765                          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;    
    766          		GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    767          	}
    768          }
    769          
    770          void CameraMode(u8 Mode, u8 OSD)
    771          {
    772          
    773          	if(Mode == 0)
    774          	{
    775          		
    776          		if(OSD)
    777          		{
    778          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
    779          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
    780          		        WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
    781          		        WriteOSDBmpX(MASTER,76,125,0x00,0x00,gt_CHANNEL_CH3_O);
    782          		        WriteOSDBmpX(MASTER,162,125,0x00,0x00,gt_CHANNEL_CH4_O);
    783          		}
    784          
    785          		
    786          		
    787          		
    788          		// Scale CAM_0 // Select CAM
    789          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
    790          		WriteAsicByte(MASTER,DVC_PG0,0x81,0x7f);
    791          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
    792          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
    793          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
    794          		// Scale CAM_1 // Select CAM
    795          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
    796          		WriteAsicByte(MASTER,DVC_PG0,0x91,0x7f);
    797          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
    798          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
    799          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
    800          		// Scale CAM_2 // Select CAM
    801          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
    802          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0x7f);
    803          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
    804          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0x7f);
    805          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
    806          		// Scale CAM_3 // Select CAM
    807          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
    808          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0x7f);
    809          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
    810          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0x7f);
    811          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
    812          
    813          		// ON/OFF CAMERA
    814          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);   
    815          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
    816          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
    817          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83); 
    818          
    819          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
    820          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
    821          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
    822          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x3C);
    823          
    824          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x58);    // Position CAM_1
    825          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
    826          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
    827          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x3C);
    828          
    829          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
    830          		WriteAsicByte(MASTER,DVC_PG1,0x39,0x58);
    831          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x3C);
    832          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
    833          
    834          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
    835          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
    836          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x3C);
    837          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
    838          
    839          	}
    840          	else if(Mode == 1)
    841          	{
    842          		
    843          		if(OSD)
    844          		{
    845          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
    846          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH1_O);
    847                  		WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
    848          		}
    849          		
    850          		// Scale CAM_0 // Select CAM
    851          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
    852          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
    853          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
    854          		WriteAsicByte(MASTER,DVC_PG0,0x83,0x7f);
    855          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
    856          		// Scale CAM_1 // Select CAM
    857          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
    858          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
    859          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
    860          		WriteAsicByte(MASTER,DVC_PG0,0x93,0x7f);
    861          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
    862          
    863          
    864          		// ON/OFF CAMERA
    865          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);  
    866          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
    867          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);   
    868          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);   
    869          
    870          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
    871          		WriteAsicByte(MASTER,DVC_PG1,0x31,0x58);
    872          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);    //0x00);
    873          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
    874          
    875          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x58);    // Position CAM_1
    876          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
    877          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);    //0x00);
    878          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
    879          
    880          		
    881          		
    882          
    883          	}
    884          	else if(Mode == 2)
    885          	{
    886          		if(OSD)
    887          		{
    888          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
    889          			WriteOSDBmpX(MASTER,76,5,0x00,0x00,gt_CHANNEL_CH3_O);
    890                 	 	WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
    891          		}
    892          		
    893          
    894          		// Scale CAM_2 // Select CAM
    895          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
    896          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
    897          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
    898          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0x7f);
    899          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
    900          		// Scale CAM_3 // Select CAM
    901          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
    902          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
    903          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
    904          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0x7f);
    905          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
    906          		    
    907          		// ON/OFF CAMERA
    908          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);  
    909          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
    910          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);   
    911          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    
    912          
    913          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
    914          		WriteAsicByte(MASTER,DVC_PG1,0x39,0x58);
    915          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
    916          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
    917          
    918          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x58);    // Position CAM_3
    919          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
    920          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
    921          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
    922          
    923          
    924          
    925          
    926          	}
    927          
    928          	else if(Mode == 3)
    929          	{
    930          		if(OSD)
    931          		{
    932          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
    933          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH1_O);
    934          		}
    935          		
    936          		// Scale CAM_0 // Select CAM
    937          		WriteAsicByte(MASTER,DVC_PG0,0x80,0x01);    
    938          		WriteAsicByte(MASTER,DVC_PG0,0x81,0xff);
    939          		WriteAsicByte(MASTER,DVC_PG0,0x82,0xff);
    940          		WriteAsicByte(MASTER,DVC_PG0,0x83,0xff);
    941          		WriteAsicByte(MASTER,DVC_PG0,0x84,0xff);
    942          		    
    943          		// ON/OFF CAMERA
    944          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x80);    // ON CAM_0
    945          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);	// OFF CAM_1
    946          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_2
    947          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_3
    948          
    949          		WriteAsicByte(MASTER,DVC_PG1,0x30,0x00);    // Position CAM_0
    950          		WriteAsicByte(MASTER,DVC_PG1,0x31,0xb0);
    951          		WriteAsicByte(MASTER,DVC_PG1,0x32,0x00);
    952          		WriteAsicByte(MASTER,DVC_PG1,0x33,0x78);
    953          
    954          
    955          		
    956          	}
    957          
    958          	else if(Mode == 4)
    959          	{
    960          		if(OSD)
    961          		{
    962          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);	
    963          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH2_O);
    964          		}
    965          		
    966          
    967          		// Scale CAM_1 // Select CAM
    968          		WriteAsicByte(MASTER,DVC_PG0,0x90,0x41);
    969          		WriteAsicByte(MASTER,DVC_PG0,0x91,0xff);
    970          		WriteAsicByte(MASTER,DVC_PG0,0x92,0xff);
    971          		WriteAsicByte(MASTER,DVC_PG0,0x93,0xff);
    972          		WriteAsicByte(MASTER,DVC_PG0,0x94,0xff);
    973          		    
    974          		// ON/OFF CAMERA
    975          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
    976          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x81);
    977          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_3
    978          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_4
    979          
    980          
    981          		WriteAsicByte(MASTER,DVC_PG1,0x34,0x00);    // Position CAM_1
    982          		WriteAsicByte(MASTER,DVC_PG1,0x35,0xb0);
    983          		WriteAsicByte(MASTER,DVC_PG1,0x36,0x00);
    984          		WriteAsicByte(MASTER,DVC_PG1,0x37,0x78);
    985          
    986          
    987          
    988          	}
    989          
    990          	else if(Mode == 5)
    991          	{
    992          		if(OSD)
    993          		{
    994          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
    995          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH3_O);
    996          		}
    997          		
    998          
    999          		// Scale CAM_2 // Select CAM
   1000          		WriteAsicByte(MASTER,DVC_PG0,0xa0,0x81);
   1001          		WriteAsicByte(MASTER,DVC_PG0,0xa1,0xff);
   1002          		WriteAsicByte(MASTER,DVC_PG0,0xa2,0xff);
   1003          		WriteAsicByte(MASTER,DVC_PG0,0xa3,0xff);
   1004          		WriteAsicByte(MASTER,DVC_PG0,0xa4,0xff);
   1005          		    
   1006          		// ON/OFF CAMERA
   1007          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
   1008          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1009          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x82);    // OFF CAM_3
   1010          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x03);    // OFF CAM_4
   1011          
   1012          
   1013          
   1014          		WriteAsicByte(MASTER,DVC_PG1,0x38,0x00);    // Position CAM_2
   1015          		WriteAsicByte(MASTER,DVC_PG1,0x39,0xb0);
   1016          		WriteAsicByte(MASTER,DVC_PG1,0x3a,0x00);
   1017          		WriteAsicByte(MASTER,DVC_PG1,0x3b,0x78);
   1018          
   1019          	}
   1020          
   1021          	else if(Mode == 6)
   1022          	{
   1023          		if(OSD)
   1024          		{
   1025          			WriteOSDClrX(MASTER, 0, 0, 0, 45, 31);
   1026          			WriteOSDBmpX(MASTER,162,5,0x00,0x00,gt_CHANNEL_CH4_O);
   1027          		}
   1028          		
   1029          		// Scale CAM_3 // Select CAM
   1030          		WriteAsicByte(MASTER,DVC_PG0,0xb0,0xc1);
   1031          		WriteAsicByte(MASTER,DVC_PG0,0xb1,0xff);
   1032          		WriteAsicByte(MASTER,DVC_PG0,0xb2,0xff);
   1033          		WriteAsicByte(MASTER,DVC_PG0,0xb3,0xff);
   1034          		WriteAsicByte(MASTER,DVC_PG0,0xb4,0xff);
   1035          		    
   1036          		// ON/OFF CAMERA
   1037          		WriteAsicByte(MASTER,DVC_PG1,0x10,0x00);    // ON/OFF CAM
   1038          		WriteAsicByte(MASTER,DVC_PG1,0x18,0x01);
   1039          		WriteAsicByte(MASTER,DVC_PG1,0x20,0x02);    // OFF CAM_3
   1040          		WriteAsicByte(MASTER,DVC_PG1,0x28,0x83);    // OFF CAM_4
   1041          
   1042          		WriteAsicByte(MASTER,DVC_PG1,0x3c,0x00);    // Position CAM_3
   1043          		WriteAsicByte(MASTER,DVC_PG1,0x3d,0xb0);
   1044          		WriteAsicByte(MASTER,DVC_PG1,0x3e,0x00);
   1045          		WriteAsicByte(MASTER,DVC_PG1,0x3f,0x78); 
   1046          
   1047          
   1048            	}
   1049          }
   1050          
   1051          
   1052          /**\
   1053            * @brief  None
   1054            * @param  None
   1055            * @retval None
   1056            */
   1057          void TW2835_Control_Init(void)
   1058          {
   1059          	DebugMsg_printf("++ TW2835_Control_Init (GPIO Mode), Initialize START\r\n");
   1060          
   1061          	InitPg0();
   1062          	InitPg1();
   1063          	InitPg2();
   1064          
   1065          	//CameraMode(3,1);
   1066          
   1067          	DebugMsg_printf("-- TW2835_Control_Init (GPIO Mode), Initialize END\r\n");
   1068          }
   1069          
   1070          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CameraMode
         0   -> WriteAsicByte
        16   -> WriteAsicByte
        16   -> WriteOSDBmpX
        16   -> WriteOSDClrX
       8   InitPg0
         8   -> WriteAsicTable
       8   InitPg1
         8   -> WriteAsicTable
      16   InitPg2
        16   -> InitOSDCol
        16   -> WriteAsicByte
        16   -> WriteAsicTable
        16   -> WriteOSDClrX
        16   -> WriteOSDClrY
       0   InitVdo
      16   Port_Change
        16   -> GPIO_Init
      24   ReadAsicByte
        24   -> GPIO_ReadInputData
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      24   ReadAsicOSDMemWr
        24   -> GPIO_ReadInputData
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      32   ReadAsicTable
        32   -> GPIO_ReadInputData
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
       8   Read_TW2835
         8   -> GPIO_ReadInputData
         8   -> Port_Change
      24   SetAsicFlgType
        24   -> ReadAsicByte
         0   -> WriteAsicByte
      16   TW2835_Control_Init
         0   -> InitPg2
        16   -> WriteAsicTable
      32   WriteAsicByte
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
      24   WriteAsicByteOSD
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      32   WriteAsicTable
        32   -> GPIO_ReadOutputData
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_Write
        32   -> Port_Change
      24   WriteAsicTableOSD
        24   -> GPIO_ReadOutputData
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> GPIO_Write
        24   -> Port_Change
      16   Write_TW2835
        16   -> GPIO_ReadOutputData
         0   -> GPIO_Write
        16   -> Port_Change


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       8  ?Subroutine0
      12  ?Subroutine1
    2004  CameraMode
      16  InitPg0
      14  InitPg1
     322  InitPg2
      20  InitVdo
      58  Port_Change
     284  ReadAsicByte
     252  ReadAsicOSDMemWr
     288  ReadAsicTable
      18  Read_TW2835
     512  Register_Table_Page0
          Register_Table_Page1
      36  SetAsicFlgType
      48  TW2835_Control_Init
     322  WriteAsicByte
     276  WriteAsicByteOSD
     326  WriteAsicTable
     470  WriteAsicTableOSD
      36  Write_TW2835
     216  cmn_bot
          cmn_cnt_vs_sub
          Temp
          cmn_flg
          tbl_pg2_mse_box
          tbl_ntsc_pg2_2dbox
          tbl_ntsc_pg2_mtn
          tbl_pal_pg2_2dbox
          tbl_pal_pg2_mtn
       1  cmn_cnt_vs
       1  cmn_dvc
       4  cmn_flg_cnt
       1  cmn_lst_slvr_x
       1  cmn_lst_slvr_y
       1  cmn_max_ch
       1  cmn_vga_det
     256  read_data
      16  tbl_ntsc_pg1_enc
      16  tbl_ntsc_pg1_pic_9_lt
      16  tbl_ntsc_pg1_pic_9_rb
      16  tbl_ntsc_pg1_pic_fl
      16  tbl_ntsc_pg1_pic_qd
      16  tbl_pal_pg1_enc
      16  tbl_pal_pg1_pic_9_lt
      16  tbl_pal_pg1_pic_9_rb
      16  tbl_pal_pg1_pic_fl
      16  tbl_pal_pg1_pic_qd
      48  tbl_pg1_x_cmn
      80  tbl_pg1_y_cmn
       4  wndw_flg
       4  wndw_flg_ds

 
   270 bytes in section .bss
 1 020 bytes in section .data
 4 854 bytes in section .text
 
 4 854 bytes of CODE memory
 1 290 bytes of DATA memory

Errors: none
Warnings: none
