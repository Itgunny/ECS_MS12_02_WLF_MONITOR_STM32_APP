###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      11/May/2016  16:53:12 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WLF Monitor - STM32_APP\Platform\TaeHa -   #
#                    ECS\SRC\M25PXX.c                                         #
#    Command line =  "C:\Tools\WL9F\WLF Monitor - STM32_APP\Platform\TaeHa -  #
#                    ECS\SRC\M25PXX.c" -D USE_STDPERIPH_DRIVER -D STM32F4XX   #
#                    -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN             #
#                    "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\Project\Debug\List\" -o "C:\Tools\WL9F\WLF     #
#                    Monitor - STM32_APP\Project\Debug\Obj\" --debug          #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp        #
#                    --dlib_config "C:\Tools\IAR Systems\Embedded Workbench   #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\WL9F\WLF  #
#                    Monitor - STM32_APP\Project\..\Platform\COMMON\INC\" -I  #
#                    "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\Project\..\Platform\TaeHa - ECS\INC\" -I       #
#                    "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\Project\..\Libraries\CMSIS\Device\ST\STM32F4xx #
#                    \Include\" -I "C:\Tools\WL9F\WLF Monitor -               #
#                    STM32_APP\Project\..\Libraries\STM32F4xx_StdPeriph_Drive #
#                    r\inc\" -Oh --use_c++_inline -I "C:\Tools\IAR            #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  C:\Tools\WL9F\WLF Monitor -                              #
#                    STM32_APP\Project\Debug\List\M25PXX.lst                  #
#    Object file  =  C:\Tools\WL9F\WLF Monitor -                              #
#                    STM32_APP\Project\Debug\Obj\M25PXX.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WLF Monitor - STM32_APP\Platform\TaeHa - ECS\SRC\M25PXX.c
      1          /**
      2            ******************************************************************************
      3            * @file    M25PXX.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   M25PXX.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          #define Sector_0		0			// ++, --, 160511 bwk
     25          #define Sector_1 	0x10000
     26          #define Sector_10 	0xA0000
     27          #define Sector_60 	0x3c0000
     28          #define Sector_61 	0x3d0000
     29          #define Sector_62 	0x3e0000
     30          #define Sector_63 	0x3f0000
     31          
     32          const unsigned short Crc16Table[256] = {
     33             0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
     34             0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
     35             0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
     36             0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
     37             0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
     38             0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
     39             0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
     40             0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
     41             0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
     42             0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
     43             0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
     44             0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
     45             0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
     46             0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
     47             0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
     48             0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
     49             0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
     50             0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
     51             0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
     52             0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
     53             0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
     54             0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
     55             0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
     56             0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
     57             0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
     58             0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
     59             0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
     60             0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
     61             0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
     62             0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
     63             0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
     64             0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
     65          };
     66          
     67          u8 Change_UART4_for_Download;
     68          
     69          u8 download_enable_code[6]={0xd4,0xc3,0xb2,0xa1, };
     70          u8 fatoryinit_enable_code[6]={0x8d,0x7c,0x6b,0x5a, };
     71          
     72          u8 temp3[6];
     73          uint16_t Index_temp;
     74          u8 Flag_St_Update;
     75          
     76          void SPI_FLASH_SectorErase(unsigned long SectorAddr)
     77          {
     78          	// Send write enable instruction 
     79          	SPI_FLASH_WriteEnable();
     80          	// Sector Erase  
     81          	// Select the FLASH: Chip Select low 
     82          	SPI_FLASH_CS_LOW();
     83          	// Send Sector Erase instruction 
     84          	SPI_Transfer(SE);
     85          	// Send SectorAddr high nibble address byte 
     86          	SPI_Transfer((SectorAddr & 0xFF0000) >> 16);
     87          	// Send SectorAddr medium nibble address byte 
     88          	SPI_Transfer((SectorAddr & 0xFF00) >> 8);
     89          	// Send SectorAddr low nibble address byte 
     90          	SPI_Transfer(SectorAddr & 0xFF);
     91          	// Deselect the FLASH: Chip Select high 
     92          	SPI_FLASH_CS_HIGH();
     93          
     94          	// Wait the end of Flash writing 
     95          	SPI_FLASH_WaitForWriteEnd();
     96          }
     97          
     98          void SPI_FLASH_BulkErase(void)
     99          {
    100          	// Send write enable instruction 
    101          	SPI_FLASH_WriteEnable();
    102          
    103          	// Bulk Erase  
    104          	// Select the FLASH: Chip Select low 
    105          	SPI_FLASH_CS_LOW();
    106          	// Send Bulk Erase instruction  
    107          	SPI_Transfer(BE);
    108          	// Deselect the FLASH: Chip Select high 
    109          	SPI_FLASH_CS_HIGH();
    110          
    111          	// Wait the end of Flash writing 
    112          	SPI_FLASH_WaitForWriteEnd();
    113          }
    114          
    115          void SPI_FLASH_PageWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short NumByteToWrite)
    116          {
    117          	// Enable the write access to the FLASH 
    118          	SPI_FLASH_WriteEnable();
    119          
    120          	// Select the FLASH: Chip Select low 
    121          	SPI_FLASH_CS_LOW();
    122          	// Send "Write to Memory " instruction 
    123          	SPI_Transfer(WRITE);
    124          	// Send WriteAddr high nibble address byte to write to 
    125          	SPI_Transfer((WriteAddr & 0xFF0000) >> 16);
    126          	// Send WriteAddr medium nibble address byte to write to 
    127          	SPI_Transfer((WriteAddr & 0xFF00) >> 8);  
    128          	// Send WriteAddr low nibble address byte to write to 
    129          	SPI_Transfer(WriteAddr & 0xFF);
    130          
    131          	// while there is data to be written on the FLASH 
    132          	while(NumByteToWrite--) 
    133          	{
    134          		// Send the current byte 
    135          		SPI_Transfer(*pBuffer);
    136          		// Point on the next byte to be written 
    137          		pBuffer++; 
    138          	}
    139          
    140          	// Deselect the FLASH: Chip Select high 
    141          	SPI_FLASH_CS_HIGH();
    142          
    143          	// Wait the end of Flash writing 
    144          	SPI_FLASH_WaitForWriteEnd();
    145          }
    146          
    147          void SPI_FLASH_BufferWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short  NumByteToWrite)
    148          {
    149          	unsigned char NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    150          
    151          	Addr = WriteAddr % SPI_FLASH_PageSize;
    152          	count = SPI_FLASH_PageSize - Addr;
    153          	NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    154          	NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    155          
    156          	if(Addr == 0) // WriteAddr is SPI_FLASH_PageSize aligned  
    157          	{
    158          		if(NumOfPage == 0) // NumByteToWrite < SPI_FLASH_PageSize 
    159          		{
    160          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    161          		}
    162          		else // NumByteToWrite > SPI_FLASH_PageSize  
    163          		{
    164          			while(NumOfPage--)
    165          			{
    166          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    167          				WriteAddr +=  SPI_FLASH_PageSize;
    168          				pBuffer += SPI_FLASH_PageSize;  
    169          			}    
    170          
    171          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    172          		}
    173          	}
    174          	
    175          	else // WriteAddr is not SPI_FLASH_PageSize aligned  
    176          	{
    177          		if(NumOfPage== 0) // NumByteToWrite < SPI_FLASH_PageSize 
    178          		{
    179          			if(NumOfSingle > count) // (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize 
    180          			{
    181          				temp = NumOfSingle - count;
    182          
    183          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    184          				WriteAddr +=  count;
    185          				pBuffer += count; 
    186          
    187          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
    188          			}
    189          			else
    190          			{
    191          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    192          			}
    193          		
    194          		}
    195          		
    196          		else // NumByteToWrite > SPI_FLASH_PageSize 
    197          		{
    198          			NumByteToWrite -= count;
    199          			NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    200          			NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    201          
    202          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    203          			WriteAddr +=  count;
    204          			pBuffer += count;  
    205          
    206          			while(NumOfPage--)
    207          			{
    208          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    209          				WriteAddr +=  SPI_FLASH_PageSize;
    210          				pBuffer += SPI_FLASH_PageSize;
    211          			}
    212          
    213          			if(NumOfSingle != 0)
    214          			{
    215          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    216          			}
    217          		}
    218          	}
    219          }
    220          
    221          void SPI_FLASH_BufferRead(unsigned char* pBuffer, unsigned long ReadAddr, unsigned short  NumByteToRead)
    222          {
    223          	// Select the FLASH: Chip Select low 
    224          	SPI_FLASH_CS_LOW();
    225          
    226          	// Send "Read from Memory " instruction 
    227          	SPI_Transfer(READ);
    228          
    229          	// Send ReadAddr high nibble address byte to read from 
    230          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    231          	// Send ReadAddr medium nibble address byte to read from 
    232          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    233          	// Send ReadAddr low nibble address byte to read from 
    234          	SPI_Transfer(ReadAddr & 0xFF);
    235          
    236          	while(NumByteToRead--) // while there is data to be read 
    237          	{
    238          		// Read a byte from the FLASH 
    239          		*pBuffer = SPI_Transfer(Dummy_Byte);
    240          		// Point to the next location where the byte read will be saved 
    241          		pBuffer++;
    242          	}
    243          
    244          	// Deselect the FLASH: Chip Select high 
    245          	SPI_FLASH_CS_HIGH();
    246          }
    247          
    248          //unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    249          
    250          unsigned long SPI_FLASH_ReadID(void)
    251          {
    252          	unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    253          
    254          	// Select the FLASH: Chip Select low 
    255          	SPI_FLASH_CS_LOW();
    256          	// Send "RDID " instruction 
    257          	SPI_Transfer(0x9F);
    258          	// Read a byte from the FLASH 
    259          	Temp0 = SPI_Transfer(Dummy_Byte);
    260          
    261          	// Read a byte from the FLASH 
    262          	Temp1 = SPI_Transfer(Dummy_Byte);
    263          
    264          	// Read a byte from the FLASH 
    265          	Temp2 = SPI_Transfer(Dummy_Byte);
    266          
    267          	// Deselect the FLASH: Chip Select high 
    268          	SPI_FLASH_CS_HIGH();
    269          	Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
    270          
    271          	return Temp;
    272          }
    273          
    274          void SPI_FLASH_StartReadSequence(unsigned long ReadAddr)
    275          {
    276          	// Select the FLASH: Chip Select low 
    277          	SPI_FLASH_CS_LOW();
    278          
    279          	// Send "Read from Memory " instruction 
    280          	SPI_Transfer(READ);
    281          
    282          	// Send the 24-bit address of the address to read from -----------------------  
    283          	// Send ReadAddr high nibble address byte 
    284          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    285          	// Send ReadAddr medium nibble address byte 
    286          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    287          	// Send ReadAddr low nibble address byte 
    288          	SPI_Transfer(ReadAddr & 0xFF);
    289          }
    290          
    291          unsigned char SPI_FLASH_ReadByte(void)
    292          {
    293          	return (SPI_Transfer(Dummy_Byte));
    294          }
    295          
    296          unsigned char  SPI_Transfer(u8 data)
    297          {      
    298          	unsigned char i;
    299          	unsigned char result;
    300          
    301          	result = 0;
    302          
    303          	for (i = 0; i < 8; i++)
    304          	{
    305          		SPI_FLASH_SCK_LOW();
    306          		(data & (1 << (7- i))) ? SPI_FLASH_MOSI_HIGH():SPI_FLASH_MOSI_LOW();
    307          		SPI_FLASH_SCK_HIGH();
    308          
    309          		result <<= 1;
    310          		result |= GPIO_ReadInputDataBit(SFLASH_SPI1_PORT,SFLASH_SPI1_MISO);
    311          	}
    312          
    313          	return result;
    314              
    315          }
    316          
    317          unsigned char SPI_FLASH_SendByte(unsigned char byte)
    318          {
    319          	
    320          	// Loop while DR register in not emplty 
    321          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
    322          	// Send byte through the SPI1 peripheral 
    323          	SPI_I2S_SendData(SPI1, byte);
    324          	// Wait to receive a byte 
    325          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
    326          	// Return the byte read from the SPI bus 
    327          	
    328          	return SPI_I2S_ReceiveData(SPI1);
    329          }
    330          
    331          void SPI_FLASH_WriteEnable(void)
    332          {
    333          	// Select the FLASH: Chip Select low 
    334          	SPI_FLASH_CS_LOW();
    335          
    336          	// Send "Write Enable" instruction 
    337          	SPI_Transfer(WREN);
    338          
    339          	// Deselect the FLASH: Chip Select high 
    340          	SPI_FLASH_CS_HIGH();
    341          }
    342          
    343          void SPI_FLASH_WaitForWriteEnd(void)
    344          {
    345          	unsigned char FLASH_Status = 0;
    346          
    347              //  ++, kutelf, 140801    
    348              //unsigned int TimeOut = 0;
    349              //  --, kutelf, 140801
    350              
    351          	// Select the FLASH: Chip Select low 
    352          	SPI_FLASH_CS_LOW();
    353          
    354          	// Send "Read Status Register" instruction 
    355          	SPI_Transfer(RDSR);
    356              
    357          	// Loop as long as the memory is busy with a write cycle 
    358            
    359          	do
    360          	{
    361          		// Send a dummy byte to generate the clock needed by the FLASH and put the value of the status register in FLASH_Status variable 
    362          		FLASH_Status = SPI_Transfer(Dummy_Byte);
    363          
    364                  //  ++, kutelf, 140801
    365                  //  SPI Flash가 문제가 있을 경우 - 무한루프에서 빠져나오지 못할 수 있음. 
    366                  //if (TimeOut++ > 2000)
    367                  //  break;
    368                  //  --, kutelf, 140801
    369          
    370          	} while((FLASH_Status & WIP_Flag) == SET); // Write in progress 
    371          
    372          	// Deselect the FLASH: Chip Select high 
    373          
    374          	SPI_FLASH_CS_HIGH();
    375          }
    376          
    377          
    378          unsigned short MakeCrc16(unsigned char *data, unsigned short nLen)
    379          {
    380              unsigned short i = 0;
    381              unsigned short crc16 = 0;
    382              
    383              while (nLen--)
    384              {
    385                  crc16 = Crc16Table[((crc16 ^ data[i]) & 0xff)] ^ (crc16 >> 8);
    386                  i++;
    387              }
    388              
    389              return(crc16);
    390          }
    391          
    392          void M25P32_Init(void)
    393          {
    394          	SPI_FLASH_CS_HIGH();
    395          	
    396          	SPI_FLASH_HOLD_DISABLE();
    397          
    398          	SPI_FLASH_WP_DISABLE();
    399          }
    400          uint8_t temp1024[1024];
    401          
    402          uint8_t temp_cmp[1024];
    403          
    404          
    405          void STM32_Update(unsigned char cmd, unsigned char FactoryInitFlag)
    406          {
    407          	unsigned long temp_address;
    408          	if(FactoryInitFlag == 1)
    409          	{
    410          		switch(cmd)
    411          		{
    412          			case FILE_WRITE_ENABLE :
    413          				if(Change_UART4_for_Download == 0)
    414          				{
    415          					SPI_FLASH_SectorErase(Sector_10);
    416          					Change_UART4_for_Download = 1;
    417          					CMD_ACK_SendToExynos(FILE_WRITE_ENABLE); 
    418          					// can serial disable
    419          					//USART_Cmd(Serial_COM2, DISABLE);
    420          				}
    421          				else
    422          				{
    423          					temp_address = Sector_10 + (WL9FM_USART_FILE_DATA.Bin_Data.index  *1024);
    424          					File_Write_to_SFLAH(temp_address);
    425          				}
    426          				break;
    427          
    428          			case FILE_VERIFY :
    429          
    430          				if(Change_UART4_for_Download == 0)
    431          				{
    432          					Change_UART4_for_Download = 1;
    433          					CMD_ACK_SendToExynos(FILE_VERIFY);
    434          				}
    435          				else
    436          				{
    437          					temp_address = Sector_10 + (WL9FM_USART_FILE_DATA.Bin_Data.index  * 1024);
    438          					Read_File_From_SFLAH(temp_address);
    439          				}
    440          				break;
    441          
    442          			case FILE_WRITE_FINISH :
    443          				SPI_FLASH_SectorErase(Sector_61);
    444          				SPI_FLASH_SectorErase(Sector_62);
    445          
    446          				fatoryinit_enable_code[4]=WL9FM_USART_FILE_DATA.Bin_Data.index;
    447          				fatoryinit_enable_code[5]=WL9FM_USART_FILE_DATA.Bin_Data.index>>8;
    448          				SPI_FLASH_PageWrite(fatoryinit_enable_code,Sector_61,6);
    449          				SPI_FLASH_PageWrite(fatoryinit_enable_code,Sector_62,6);
    450          				SPI_FLASH_BufferRead(temp3,Sector_62,6);
    451          				Change_UART4_for_Download=0;
    452          				CMD_ACK_SendToExynos(FILE_WRITE_FINISH);
    453          				// can serial disable
    454          				//USART_Cmd(Serial_COM2, ENABLE);
    455          				
    456          				break;	
    457          
    458          				
    459          		}
    460          
    461          	}
    462          	else
    463          	{
    464          		switch(cmd)
    465          		{
    466          			case FILE_WRITE_ENABLE :
    467          				if(Change_UART4_for_Download == 0)
    468          				{
    469          					SPI_FLASH_SectorErase(Sector_1);
    470          					Change_UART4_for_Download = 1;
    471          					CMD_ACK_SendToExynos(FILE_WRITE_ENABLE); 
    472          					Flag_St_Update=0;
    473          					// can serial disable
    474          					//USART_Cmd(Serial_COM2, DISABLE);
    475          				}
    476          				else
    477          				{
    478          					temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  *1024);
    479          					File_Write_to_SFLAH(temp_address);
    480          				}
    481          				break;
    482          
    483          			case FILE_VERIFY :
    484          
    485          				if(Change_UART4_for_Download == 0)
    486          				{
    487          					Change_UART4_for_Download = 1;
    488          					CMD_ACK_SendToExynos(FILE_VERIFY);
    489          				}
    490          				else
    491          				{
    492          					temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  * 1024);
    493          					Read_File_From_SFLAH(temp_address);
    494          				}
    495          				break;
    496          
    497          			case FILE_WRITE_FINISH :
    498          				SPI_FLASH_SectorErase(Sector_63);
    499          
    500          				download_enable_code[4]=WL9FM_USART_FILE_DATA.Bin_Data.index;
    501          				download_enable_code[5]=WL9FM_USART_FILE_DATA.Bin_Data.index>>8;
    502          				SPI_FLASH_PageWrite(download_enable_code,Sector_63,6);
    503          				SPI_FLASH_BufferRead(temp3,Sector_63,6);
    504          				Change_UART4_for_Download=0;
    505          				CMD_ACK_SendToExynos(FILE_WRITE_FINISH);
    506          				Flag_St_Update=1;
    507          				break;					
    508          		}
    509          	}
    510          	
    511          }
    512          
    513          void ACK_NACK_SendToExynos(uint8_t data)
    514          {
    515          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    516          
    517          	ValueBuffer[0] = 0x02;				//	STX
    518          	ValueBuffer[1] = WL9FM_USART_FILE_DATA.Bin_Data.index ;			//	index L
    519          	ValueBuffer[2] = WL9FM_USART_FILE_DATA.Bin_Data.index>>8  ; 	//	index H
    520          	ValueBuffer[Serial_COM4_TxSize-1] = data;				//	ETX
    521          	
    522          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    523          }
    524          
    525          void CMD_ACK_SendToExynos(uint8_t data)
    526          {
    527          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    528          
    529          	ValueBuffer[0] = 0x02;				//	STX
    530          	ValueBuffer[1] = DOWNRES;			//	KeyValue Command, 0x4B
    531          	ValueBuffer[2] = data;   			//	Key Value HexCode, 
    532          	ValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    533          	
    534          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    535          }
    536          
    537          
    538          void File_Write_to_SFLAH(unsigned long addr)
    539          {
    540          	uint16_t	temp_crc;
    541          	uint8_t i=0;
    542          	
    543          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    544          
    545          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    546          	{
    547          		
    548          		ACK_NACK_SendToExynos(ACK);
    549          
    550          		for(i=0;i<4;i++)
    551          		{
    552          			SPI_FLASH_PageWrite(&WL9FM_USART_FILE_DATA.Bin_Data.data[i*256],addr+(i<<8),256);
    553          		}
    554                          
    555                          // ++, 150324 sys
    556                          //SPI_FLASH_BufferRead(temp1024,addr,1024);
    557                          // --, 150324 sys
    558          
    559          		if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    560          	}
    561          	else
    562          	{
    563          		ACK_NACK_SendToExynos(NAK);
    564          	}
    565          }
    566          
    567          uint16_t	temp_crc;
    568          
    569          void Read_File_From_SFLAH(unsigned long addr)
    570          {
    571          		
    572          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    573          
    574          	//if(memcmp(temp_crc,WL9FM_USART_FILE_DATA.Bin_Data.CRC_data,1)==0)
    575          
    576          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    577          	{
    578          		
    579          
    580          		memset(temp1024,0xff,1024);
    581          		
    582          		SPI_FLASH_BufferRead(temp1024,addr,1024);
    583          
    584          		if(memcmp(temp1024,WL9FM_USART_FILE_DATA.Bin_Data.data,1024)==0)
    585          		{
    586          
    587          			if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    588          
    589          			ACK_NACK_SendToExynos(ACK);
    590          		}
    591          		else
    592          			ACK_NACK_SendToExynos(NAK);
    593          	}
    594          	else
    595          	{
    596          		ACK_NACK_SendToExynos(NAK);
    597          	}
    598          }
    599          
    600          void CMD_DUMMY_SendToExynos(uint8_t data)
    601          {
    602          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    603          
    604          	ValueBuffer[0] = 0x02;				//	STX
    605          	ValueBuffer[1] = DUMMYCMD;			//	DUMMYCMD
    606          	ValueBuffer[2] = data;   			//	Data
    607          	ValueBuffer[3] = 0x03;				//	ETX
    608          	
    609          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    610          }
    611          
    612          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ACK_NACK_SendToExynos
        16   -> USARTx_EXYNOS
      16   CMD_ACK_SendToExynos
        16   -> USARTx_EXYNOS
      16   CMD_DUMMY_SendToExynos
        16   -> USARTx_EXYNOS
      16   File_Write_to_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_PageWrite
       8   M25P32_Init
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
       4   MakeCrc16
      16   Read_File_From_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_BufferRead
        16   -> __aeabi_memset4
        16   -> memcmp
      32   SPI_FLASH_BufferRead
        32   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        32   -> GPIO_WriteBit
        32   -> SPI_Transfer
      24   SPI_FLASH_BufferWrite
         0   -> SPI_FLASH_PageWrite
        24   -> SPI_FLASH_PageWrite
       8   SPI_FLASH_BulkErase
         8   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_WriteEnable
         8   -> SPI_Transfer
      32   SPI_FLASH_PageWrite
        32   -> GPIO_ReadInputDataBit
        32   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        32   -> SPI_FLASH_WriteEnable
        32   -> SPI_Transfer
       0   SPI_FLASH_ReadByte
         0   -> SPI_Transfer
      24   SPI_FLASH_ReadID
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
      16   SPI_FLASH_SectorErase
        16   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
        16   -> SPI_Transfer
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   SPI_FLASH_StartReadSequence
         8   -> GPIO_WriteBit
         0   -> SPI_Transfer
         8   -> SPI_Transfer
      24   SPI_FLASH_WaitForWriteEnd
        24   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
       8   SPI_FLASH_WriteEnable
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
         8   -> SPI_Transfer
      24   SPI_Transfer
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
       8   STM32_Update
         0   -> CMD_ACK_SendToExynos
         8   -> CMD_ACK_SendToExynos
         0   -> File_Write_to_SFLAH
         0   -> Read_File_From_SFLAH
         8   -> SPI_FLASH_BufferRead
         8   -> SPI_FLASH_PageWrite
         8   -> SPI_FLASH_SectorErase


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       8  ?Subroutine0
      16  ?Subroutine1
      30  ACK_NACK_SendToExynos
      22  CMD_ACK_SendToExynos
      26  CMD_DUMMY_SendToExynos
     512  Crc16Table
     114  File_Write_to_SFLAH
       2  Index_temp
      42  M25P32_Init
      38  MakeCrc16
      94  Read_File_From_SFLAH
     142  SPI_FLASH_BufferRead
     156  SPI_FLASH_BufferWrite
      42  SPI_FLASH_BulkErase
     150  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
      66  SPI_FLASH_ReadID
      66  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      46  SPI_FLASH_StartReadSequence
     102  SPI_FLASH_WaitForWriteEnd
      26  SPI_FLASH_WriteEnable
      84  SPI_Transfer
     318  STM32_Update
    1052  download_enable_code
          fatoryinit_enable_code
          Change_UART4_for_Download
          Flag_St_Update
          temp_crc
          temp3
          temp1024
    1024  temp_cmp

 
 1 026 bytes in section .bss
 1 052 bytes in section .data
 2 170 bytes in section .text
 
 2 170 bytes of CODE memory
 2 078 bytes of DATA memory

Errors: none
Warnings: none
