###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      13/May/2014  13:28:58 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\TaeH #
#                    a - ECS\SRC\M25PXX.c                                     #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\Tae #
#                    Ha - ECS\SRC\M25PXX.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \List\ -o C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Pro #
#                    ject\Debug\Obj\ --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR            #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Proje #
#                    ct\..\Platform\COMMON\INC\ -I                            #
#                    "C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\P #
#                    latform\TaeHa - ECS\INC\" -I                             #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\Li #
#                    braries\CMSIS\Device\ST\STM32F4xx\Include\ -I            #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\..\Li #
#                    braries\STM32F4xx_StdPeriph_Driver\inc\ -Oh              #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \List\M25PXX.lst                                         #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Project\Debug #
#                    \Obj\M25PXX.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP_Keypad04.01\Platform\TaeHa - ECS\SRC\M25PXX.c
      1          /**
      2            ******************************************************************************
      3            * @file    M25PXX.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   M25PXX.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          #define Sector_1 	0x10000
     25          #define Sector_63 	0x3f0000
     26          
     27          const unsigned short Crc16Table[256] = {
     28             0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
     29             0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
     30             0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
     31             0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
     32             0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
     33             0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
     34             0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
     35             0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
     36             0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
     37             0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
     38             0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
     39             0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
     40             0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
     41             0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
     42             0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
     43             0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
     44             0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
     45             0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
     46             0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
     47             0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
     48             0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
     49             0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
     50             0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
     51             0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
     52             0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
     53             0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
     54             0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
     55             0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
     56             0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
     57             0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
     58             0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
     59             0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
     60          };
     61          
     62          u8 Change_UART4_for_Download;
     63          
     64          u8 download_enable_code[6]={0xd4,0xc3,0xb2,0xa1, };
     65          u8 temp3[6];
     66          uint16_t Index_temp;
     67          
     68          
     69          void SPI_FLASH_SectorErase(unsigned long SectorAddr)
     70          {
     71          	// Send write enable instruction 
     72          	SPI_FLASH_WriteEnable();
     73          	// Sector Erase  
     74          	// Select the FLASH: Chip Select low 
     75          	SPI_FLASH_CS_LOW();
     76          	// Send Sector Erase instruction 
     77          	SPI_Transfer(SE);
     78          	// Send SectorAddr high nibble address byte 
     79          	SPI_Transfer((SectorAddr & 0xFF0000) >> 16);
     80          	// Send SectorAddr medium nibble address byte 
     81          	SPI_Transfer((SectorAddr & 0xFF00) >> 8);
     82          	// Send SectorAddr low nibble address byte 
     83          	SPI_Transfer(SectorAddr & 0xFF);
     84          	// Deselect the FLASH: Chip Select high 
     85          	SPI_FLASH_CS_HIGH();
     86          
     87          	// Wait the end of Flash writing 
     88          	SPI_FLASH_WaitForWriteEnd();
     89          }
     90          
     91          void SPI_FLASH_BulkErase(void)
     92          {
     93          	// Send write enable instruction 
     94          	SPI_FLASH_WriteEnable();
     95          
     96          	// Bulk Erase  
     97          	// Select the FLASH: Chip Select low 
     98          	SPI_FLASH_CS_LOW();
     99          	// Send Bulk Erase instruction  
    100          	SPI_Transfer(BE);
    101          	// Deselect the FLASH: Chip Select high 
    102          	SPI_FLASH_CS_HIGH();
    103          
    104          	// Wait the end of Flash writing 
    105          	SPI_FLASH_WaitForWriteEnd();
    106          }
    107          
    108          void SPI_FLASH_PageWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short NumByteToWrite)
    109          {
    110          	// Enable the write access to the FLASH 
    111          	SPI_FLASH_WriteEnable();
    112          
    113          	// Select the FLASH: Chip Select low 
    114          	SPI_FLASH_CS_LOW();
    115          	// Send "Write to Memory " instruction 
    116          	SPI_Transfer(WRITE);
    117          	// Send WriteAddr high nibble address byte to write to 
    118          	SPI_Transfer((WriteAddr & 0xFF0000) >> 16);
    119          	// Send WriteAddr medium nibble address byte to write to 
    120          	SPI_Transfer((WriteAddr & 0xFF00) >> 8);  
    121          	// Send WriteAddr low nibble address byte to write to 
    122          	SPI_Transfer(WriteAddr & 0xFF);
    123          
    124          	// while there is data to be written on the FLASH 
    125          	while(NumByteToWrite--) 
    126          	{
    127          		// Send the current byte 
    128          		SPI_Transfer(*pBuffer);
    129          		// Point on the next byte to be written 
    130          		pBuffer++; 
    131          	}
    132          
    133          	// Deselect the FLASH: Chip Select high 
    134          	SPI_FLASH_CS_HIGH();
    135          
    136          	// Wait the end of Flash writing 
    137          	SPI_FLASH_WaitForWriteEnd();
    138          }
    139          
    140          void SPI_FLASH_BufferWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short  NumByteToWrite)
    141          {
    142          	unsigned char NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    143          
    144          	Addr = WriteAddr % SPI_FLASH_PageSize;
    145          	count = SPI_FLASH_PageSize - Addr;
    146          	NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    147          	NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    148          
    149          	if(Addr == 0) // WriteAddr is SPI_FLASH_PageSize aligned  
    150          	{
    151          		if(NumOfPage == 0) // NumByteToWrite < SPI_FLASH_PageSize 
    152          		{
    153          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    154          		}
    155          		else // NumByteToWrite > SPI_FLASH_PageSize  
    156          		{
    157          			while(NumOfPage--)
    158          			{
    159          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    160          				WriteAddr +=  SPI_FLASH_PageSize;
    161          				pBuffer += SPI_FLASH_PageSize;  
    162          			}    
    163          
    164          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    165          		}
    166          	}
    167          	
    168          	else // WriteAddr is not SPI_FLASH_PageSize aligned  
    169          	{
    170          		if(NumOfPage== 0) // NumByteToWrite < SPI_FLASH_PageSize 
    171          		{
    172          			if(NumOfSingle > count) // (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize 
    173          			{
    174          				temp = NumOfSingle - count;
    175          
    176          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    177          				WriteAddr +=  count;
    178          				pBuffer += count; 
    179          
    180          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
    181          			}
    182          			else
    183          			{
    184          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    185          			}
    186          		
    187          		}
    188          		
    189          		else // NumByteToWrite > SPI_FLASH_PageSize 
    190          		{
    191          			NumByteToWrite -= count;
    192          			NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    193          			NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    194          
    195          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    196          			WriteAddr +=  count;
    197          			pBuffer += count;  
    198          
    199          			while(NumOfPage--)
    200          			{
    201          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    202          				WriteAddr +=  SPI_FLASH_PageSize;
    203          				pBuffer += SPI_FLASH_PageSize;
    204          			}
    205          
    206          			if(NumOfSingle != 0)
    207          			{
    208          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    209          			}
    210          		}
    211          	}
    212          }
    213          
    214          void SPI_FLASH_BufferRead(unsigned char* pBuffer, unsigned long ReadAddr, unsigned short  NumByteToRead)
    215          {
    216          	// Select the FLASH: Chip Select low 
    217          	SPI_FLASH_CS_LOW();
    218          
    219          	// Send "Read from Memory " instruction 
    220          	SPI_Transfer(READ);
    221          
    222          	// Send ReadAddr high nibble address byte to read from 
    223          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    224          	// Send ReadAddr medium nibble address byte to read from 
    225          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    226          	// Send ReadAddr low nibble address byte to read from 
    227          	SPI_Transfer(ReadAddr & 0xFF);
    228          
    229          	while(NumByteToRead--) // while there is data to be read 
    230          	{
    231          		// Read a byte from the FLASH 
    232          		*pBuffer = SPI_Transfer(Dummy_Byte);
    233          		// Point to the next location where the byte read will be saved 
    234          		pBuffer++;
    235          	}
    236          
    237          	// Deselect the FLASH: Chip Select high 
    238          	SPI_FLASH_CS_HIGH();
    239          }
    240          
    241          //unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    242          
    243          unsigned long SPI_FLASH_ReadID(void)
    244          {
    245          	unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    246          
    247          	// Select the FLASH: Chip Select low 
    248          	SPI_FLASH_CS_LOW();
    249          	// Send "RDID " instruction 
    250          	SPI_Transfer(0x9F);
    251          	// Read a byte from the FLASH 
    252          	Temp0 = SPI_Transfer(Dummy_Byte);
    253          
    254          	// Read a byte from the FLASH 
    255          	Temp1 = SPI_Transfer(Dummy_Byte);
    256          
    257          	// Read a byte from the FLASH 
    258          	Temp2 = SPI_Transfer(Dummy_Byte);
    259          
    260          	// Deselect the FLASH: Chip Select high 
    261          	SPI_FLASH_CS_HIGH();
    262          	Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
    263          
    264          	return Temp;
    265          }
    266          
    267          void SPI_FLASH_StartReadSequence(unsigned long ReadAddr)
    268          {
    269          	// Select the FLASH: Chip Select low 
    270          	SPI_FLASH_CS_LOW();
    271          
    272          	// Send "Read from Memory " instruction 
    273          	SPI_Transfer(READ);
    274          
    275          	// Send the 24-bit address of the address to read from -----------------------  
    276          	// Send ReadAddr high nibble address byte 
    277          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    278          	// Send ReadAddr medium nibble address byte 
    279          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    280          	// Send ReadAddr low nibble address byte 
    281          	SPI_Transfer(ReadAddr & 0xFF);
    282          }
    283          
    284          unsigned char SPI_FLASH_ReadByte(void)
    285          {
    286          	return (SPI_Transfer(Dummy_Byte));
    287          }
    288          
    289          unsigned char  SPI_Transfer(u8 data)
    290          {      
    291          	unsigned char i;
    292          	unsigned char result;
    293          
    294          	result = 0;
    295          
    296          	for (i = 0; i < 8; i++)
    297          	{
    298          		SPI_FLASH_SCK_LOW();
    299          		(data & (1 << (7- i))) ? SPI_FLASH_MOSI_HIGH():SPI_FLASH_MOSI_LOW();
    300          		SPI_FLASH_SCK_HIGH();
    301          
    302          		result <<= 1;
    303          		result |= GPIO_ReadInputDataBit(SFLASH_SPI1_PORT,SFLASH_SPI1_MISO);
    304          	}
    305          
    306          	return result;
    307              
    308          }
    309          
    310          unsigned char SPI_FLASH_SendByte(unsigned char byte)
    311          {
    312          	
    313          	// Loop while DR register in not emplty 
    314          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
    315          	// Send byte through the SPI1 peripheral 
    316          	SPI_I2S_SendData(SPI1, byte);
    317          	// Wait to receive a byte 
    318          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
    319          	// Return the byte read from the SPI bus 
    320          	
    321          	return SPI_I2S_ReceiveData(SPI1);
    322          }
    323          
    324          void SPI_FLASH_WriteEnable(void)
    325          {
    326          	// Select the FLASH: Chip Select low 
    327          	SPI_FLASH_CS_LOW();
    328          
    329          	// Send "Write Enable" instruction 
    330          	SPI_Transfer(WREN);
    331          
    332          	// Deselect the FLASH: Chip Select high 
    333          	SPI_FLASH_CS_HIGH();
    334          }
    335          
    336          void SPI_FLASH_WaitForWriteEnd(void)
    337          {
    338          	unsigned char FLASH_Status = 0;
    339          
    340          	// Select the FLASH: Chip Select low 
    341          	SPI_FLASH_CS_LOW();
    342          
    343          	// Send "Read Status Register" instruction 
    344          	SPI_Transfer(RDSR);
    345              
    346          	// Loop as long as the memory is busy with a write cycle 
    347            
    348          	do
    349          	{
    350          		// Send a dummy byte to generate the clock needed by the FLASH and put the value of the status register in FLASH_Status variable 
    351          		FLASH_Status = SPI_Transfer(Dummy_Byte);
    352          
    353          	} while((FLASH_Status & WIP_Flag) == SET); // Write in progress 
    354          
    355          	// Deselect the FLASH: Chip Select high 
    356          
    357          	SPI_FLASH_CS_HIGH();
    358          }
    359          
    360          
    361          unsigned short MakeCrc16(unsigned char *data, unsigned short nLen)
    362          {
    363              unsigned short i = 0;
    364              unsigned short crc16 = 0;
    365              
    366              while (nLen--)
    367              {
    368                  crc16 = Crc16Table[((crc16 ^ data[i]) & 0xff)] ^ (crc16 >> 8);
    369                  i++;
    370              }
    371              
    372              return(crc16);
    373          }
    374          
    375          void M25P32_Init(void)
    376          {
    377          	SPI_FLASH_CS_HIGH();
    378          	
    379          	SPI_FLASH_HOLD_DISABLE();
    380          
    381          	SPI_FLASH_WP_DISABLE();
    382          }
    383          uint8_t temp1024[1024];
    384          
    385          uint8_t temp_cmp[1024];
    386          
    387          
    388          void STM32_Update(unsigned char cmd)
    389          {
    390          	u16 i=0;
    391          	
    392          	switch(cmd)
    393          	{
    394          		case FILE_WRITE_ENABLE :
    395          			if(Change_UART4_for_Download == 0)
    396          			{
    397          				SPI_FLASH_SectorErase(Sector_1);
    398          				Change_UART4_for_Download = 1;
    399          				CMD_ACK_SendToExynos(FILE_WRITE_ENABLE); 
    400          
    401          				// can serial disable
    402          				//USART_Cmd(Serial_COM2, DISABLE);
    403          			}
    404          			else
    405          			{
    406          				File_Write_to_SFLAH();
    407          			}
    408          			break;
    409          
    410          		case FILE_VERIFY :
    411          
    412          			if(Change_UART4_for_Download == 0)
    413          			{
    414          				Change_UART4_for_Download = 1;
    415          				CMD_ACK_SendToExynos(FILE_VERIFY);
    416          			}
    417          			else
    418          			{
    419          				Read_File_From_SFLAH();
    420          			}
    421          			break;
    422          
    423          		case FILE_WRITE_FINISH :
    424          			SPI_FLASH_SectorErase(Sector_63);
    425          
    426          			download_enable_code[4]=WL9FM_USART_FILE_DATA.Bin_Data.index;
    427          			download_enable_code[5]=WL9FM_USART_FILE_DATA.Bin_Data.index>>8;
    428          			SPI_FLASH_PageWrite(download_enable_code,Sector_63,6);
    429          			SPI_FLASH_BufferRead(temp3,Sector_63,6);
    430          			Change_UART4_for_Download=0;
    431          			CMD_ACK_SendToExynos(FILE_WRITE_FINISH);
    432          
    433          			// can serial disable
    434          			//USART_Cmd(Serial_COM2, ENABLE);
    435          			
    436          			break;	
    437          
    438          			
    439          	}
    440          }
    441          
    442          void ACK_NACK_SendToExynos(uint8_t data)
    443          {
    444          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    445          
    446          	ValueBuffer[0] = 0x02;				//	STX
    447          	ValueBuffer[1] = WL9FM_USART_FILE_DATA.Bin_Data.index ;			//	index L
    448          	ValueBuffer[2] = WL9FM_USART_FILE_DATA.Bin_Data.index>>8  ; 	//	index H
    449          	ValueBuffer[3] = data;				//	ETX
    450          	
    451          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    452          }
    453          
    454          void CMD_ACK_SendToExynos(uint8_t data)
    455          {
    456          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    457          
    458          	ValueBuffer[0] = 0x02;				//	STX
    459          	ValueBuffer[1] = DOWNCMD;			//	KeyValue Command, 0x4B
    460          	ValueBuffer[2] = data;   			//	Key Value HexCode, 
    461          	ValueBuffer[3] = 0x03;				//	ETX
    462          	
    463          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    464          }
    465          
    466          
    467          void File_Write_to_SFLAH(void)
    468          {
    469          	uint16_t	temp_crc;
    470          	unsigned long temp_address;
    471          	uint8_t i=0;
    472          	
    473          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    474          
    475          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    476          	{
    477          		ACK_NACK_SendToExynos(ACK);
    478          
    479          		temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  *1024);
    480          
    481          		for(i=0;i<4;i++)
    482          		{
    483          			SPI_FLASH_PageWrite(&WL9FM_USART_FILE_DATA.Bin_Data.data[i*256],temp_address+(i<<8),256);
    484          		}
    485                          
    486                          
    487                          SPI_FLASH_BufferRead(temp1024,temp_address,1024);
    488                          
    489          
    490          		if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    491          	}
    492          	else
    493          	{
    494          		ACK_NACK_SendToExynos(NAK);
    495          	}
    496          }
    497          
    498          uint16_t	temp_crc;
    499          
    500          void Read_File_From_SFLAH(void)
    501          {
    502          	
    503          	unsigned long temp_address;
    504          	
    505          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    506          
    507          	//if(memcmp(temp_crc,WL9FM_USART_FILE_DATA.Bin_Data.CRC_data,1)==0)
    508          
    509          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    510          	{
    511          		temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  * 1024);
    512          
    513          		memset(temp1024,0xff,1024);
    514          		
    515          		SPI_FLASH_BufferRead(temp1024,temp_address,1024);
    516          
    517          		if(memcmp(temp1024,WL9FM_USART_FILE_DATA.Bin_Data.data,1024)==0)
    518          		{
    519          
    520          			if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    521          
    522          			ACK_NACK_SendToExynos(ACK);
    523          		}
    524          		else
    525          			ACK_NACK_SendToExynos(NAK);
    526          	}
    527          	else
    528          	{
    529          		ACK_NACK_SendToExynos(NAK);
    530          	}
    531          }
    532          
    533          void CMD_DUMMY_SendToExynos(uint8_t data)
    534          {
    535          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    536          
    537          	ValueBuffer[0] = 0x02;				//	STX
    538          	ValueBuffer[1] = DUMMYCMD;			//	DUMMYCMD
    539          	ValueBuffer[2] = data;   			//	Data
    540          	ValueBuffer[3] = 0x03;				//	ETX
    541          	
    542          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    543          }
    544          
    545          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ACK_NACK_SendToExynos
         8   -> USARTx_EXYNOS
       8   CMD_ACK_SendToExynos
         8   -> USARTx_EXYNOS
       8   CMD_DUMMY_SendToExynos
         8   -> USARTx_EXYNOS
      16   File_Write_to_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_BufferRead
        16   -> SPI_FLASH_PageWrite
       8   M25P32_Init
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
       4   MakeCrc16
      16   Read_File_From_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_BufferRead
        16   -> __aeabi_memset4
        16   -> memcmp
      32   SPI_FLASH_BufferRead
        32   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        32   -> GPIO_WriteBit
        32   -> SPI_Transfer
      24   SPI_FLASH_BufferWrite
         0   -> SPI_FLASH_PageWrite
        24   -> SPI_FLASH_PageWrite
       8   SPI_FLASH_BulkErase
         8   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_WriteEnable
         8   -> SPI_Transfer
      32   SPI_FLASH_PageWrite
        32   -> GPIO_ReadInputDataBit
        32   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        32   -> SPI_FLASH_WriteEnable
        32   -> SPI_Transfer
       0   SPI_FLASH_ReadByte
         0   -> SPI_Transfer
      24   SPI_FLASH_ReadID
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
      16   SPI_FLASH_SectorErase
        16   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
        16   -> SPI_Transfer
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   SPI_FLASH_StartReadSequence
         8   -> GPIO_WriteBit
         0   -> SPI_Transfer
         8   -> SPI_Transfer
      24   SPI_FLASH_WaitForWriteEnd
        24   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
       8   SPI_FLASH_WriteEnable
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
         8   -> SPI_Transfer
      24   SPI_Transfer
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
       8   STM32_Update
         0   -> CMD_ACK_SendToExynos
         0   -> File_Write_to_SFLAH
         0   -> Read_File_From_SFLAH
         8   -> SPI_FLASH_BufferRead
         8   -> SPI_FLASH_PageWrite
         8   -> SPI_FLASH_SectorErase


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       8  ??Subroutine2_0
       8  ?Subroutine0
      12  ?Subroutine1
      34  ACK_NACK_SendToExynos
      12  CMD_ACK_SendToExynos
      10  CMD_DUMMY_SendToExynos
     512  Crc16Table
     136  File_Write_to_SFLAH
       2  Index_temp
      42  M25P32_Init
      38  MakeCrc16
     102  Read_File_From_SFLAH
     142  SPI_FLASH_BufferRead
     156  SPI_FLASH_BufferWrite
      42  SPI_FLASH_BulkErase
     150  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
      64  SPI_FLASH_ReadID
      66  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      44  SPI_FLASH_StartReadSequence
     102  SPI_FLASH_WaitForWriteEnd
      26  SPI_FLASH_WriteEnable
      84  SPI_Transfer
     124  STM32_Update
    1044  download_enable_code
          Change_UART4_for_Download
          temp_crc
          temp3
          temp1024
    1024  temp_cmp

 
 1 026 bytes in section .bss
 1 044 bytes in section .data
 1 984 bytes in section .text
 
 1 984 bytes of CODE memory
 2 070 bytes of DATA memory

Errors: none
Warnings: 1
