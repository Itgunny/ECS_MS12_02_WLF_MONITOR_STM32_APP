###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      08/Oct/2014  16:38:33 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa -         #
#                    ECS\SRC\M25PXX.c                                         #
#    Command line =  "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa -         #
#                    ECS\SRC\M25PXX.c" -D USE_STDPERIPH_DRIVER -D STM32F4XX   #
#                    -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN             #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\List\" -o  #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\Obj\"      #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\arm\INC\c\DLib_Config_Full.h" -I                 #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Platform\COMM #
#                    ON\INC\" -I "C:\Users\1\Desktop\141007 울산\CAN          #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Platform\TaeH #
#                    a - ECS\INC\" -I "C:\Users\1\Desktop\141007 울산\CAN     #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\" -I                      #
#                    "C:\Users\1\Desktop\141007 울산\CAN                      #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\..\Libraries\STM #
#                    32F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I    #
#                    "C:\Tools\IAR Systems\arm\CMSIS\Include\"                #
#    List file    =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\List\M25PX #
#                    X.lst                                                    #
#    Object file  =  C:\Users\1\Desktop\141007 울산\CAN                       #
#                    Update\SRC\WL_F_Monitor_APP_DMA\Project\Debug\Obj\M25PXX #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\1\Desktop\141007 울산\CAN Update\SRC\WL_F_Monitor_APP_DMA\Platform\TaeHa - ECS\SRC\M25PXX.c
      1          /**
      2            ******************************************************************************
      3            * @file    M25PXX.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   M25PXX.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          #define Sector_1 	0x10000
     25          #define Sector_10 	0xA0000
     26          #define Sector_61 	0x3d0000
     27          #define Sector_62 	0x3e0000
     28          #define Sector_63 	0x3f0000
     29          
     30          const unsigned short Crc16Table[256] = {
     31             0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
     32             0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
     33             0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
     34             0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
     35             0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
     36             0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
     37             0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
     38             0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
     39             0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
     40             0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
     41             0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
     42             0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
     43             0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
     44             0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
     45             0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
     46             0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
     47             0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
     48             0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
     49             0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
     50             0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
     51             0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
     52             0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
     53             0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
     54             0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
     55             0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
     56             0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
     57             0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
     58             0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
     59             0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
     60             0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
     61             0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
     62             0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
     63          };
     64          
     65          u8 Change_UART4_for_Download;
     66          
     67          u8 download_enable_code[6]={0xd4,0xc3,0xb2,0xa1, };
     68          u8 fatoryinit_enable_code[6]={0x8d,0x7c,0x6b,0x5a, };
     69          
     70          u8 temp3[6];
     71          uint16_t Index_temp;
     72          
     73          
     74          void SPI_FLASH_SectorErase(unsigned long SectorAddr)
     75          {
     76          	// Send write enable instruction 
     77          	SPI_FLASH_WriteEnable();
     78          	// Sector Erase  
     79          	// Select the FLASH: Chip Select low 
     80          	SPI_FLASH_CS_LOW();
     81          	// Send Sector Erase instruction 
     82          	SPI_Transfer(SE);
     83          	// Send SectorAddr high nibble address byte 
     84          	SPI_Transfer((SectorAddr & 0xFF0000) >> 16);
     85          	// Send SectorAddr medium nibble address byte 
     86          	SPI_Transfer((SectorAddr & 0xFF00) >> 8);
     87          	// Send SectorAddr low nibble address byte 
     88          	SPI_Transfer(SectorAddr & 0xFF);
     89          	// Deselect the FLASH: Chip Select high 
     90          	SPI_FLASH_CS_HIGH();
     91          
     92          	// Wait the end of Flash writing 
     93          	SPI_FLASH_WaitForWriteEnd();
     94          }
     95          
     96          void SPI_FLASH_BulkErase(void)
     97          {
     98          	// Send write enable instruction 
     99          	SPI_FLASH_WriteEnable();
    100          
    101          	// Bulk Erase  
    102          	// Select the FLASH: Chip Select low 
    103          	SPI_FLASH_CS_LOW();
    104          	// Send Bulk Erase instruction  
    105          	SPI_Transfer(BE);
    106          	// Deselect the FLASH: Chip Select high 
    107          	SPI_FLASH_CS_HIGH();
    108          
    109          	// Wait the end of Flash writing 
    110          	SPI_FLASH_WaitForWriteEnd();
    111          }
    112          
    113          void SPI_FLASH_PageWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short NumByteToWrite)
    114          {
    115          	// Enable the write access to the FLASH 
    116          	SPI_FLASH_WriteEnable();
    117          
    118          	// Select the FLASH: Chip Select low 
    119          	SPI_FLASH_CS_LOW();
    120          	// Send "Write to Memory " instruction 
    121          	SPI_Transfer(WRITE);
    122          	// Send WriteAddr high nibble address byte to write to 
    123          	SPI_Transfer((WriteAddr & 0xFF0000) >> 16);
    124          	// Send WriteAddr medium nibble address byte to write to 
    125          	SPI_Transfer((WriteAddr & 0xFF00) >> 8);  
    126          	// Send WriteAddr low nibble address byte to write to 
    127          	SPI_Transfer(WriteAddr & 0xFF);
    128          
    129          	// while there is data to be written on the FLASH 
    130          	while(NumByteToWrite--) 
    131          	{
    132          		// Send the current byte 
    133          		SPI_Transfer(*pBuffer);
    134          		// Point on the next byte to be written 
    135          		pBuffer++; 
    136          	}
    137          
    138          	// Deselect the FLASH: Chip Select high 
    139          	SPI_FLASH_CS_HIGH();
    140          
    141          	// Wait the end of Flash writing 
    142          	SPI_FLASH_WaitForWriteEnd();
    143          }
    144          
    145          void SPI_FLASH_BufferWrite(unsigned char* pBuffer, unsigned long WriteAddr, unsigned short  NumByteToWrite)
    146          {
    147          	unsigned char NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    148          
    149          	Addr = WriteAddr % SPI_FLASH_PageSize;
    150          	count = SPI_FLASH_PageSize - Addr;
    151          	NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    152          	NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    153          
    154          	if(Addr == 0) // WriteAddr is SPI_FLASH_PageSize aligned  
    155          	{
    156          		if(NumOfPage == 0) // NumByteToWrite < SPI_FLASH_PageSize 
    157          		{
    158          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    159          		}
    160          		else // NumByteToWrite > SPI_FLASH_PageSize  
    161          		{
    162          			while(NumOfPage--)
    163          			{
    164          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    165          				WriteAddr +=  SPI_FLASH_PageSize;
    166          				pBuffer += SPI_FLASH_PageSize;  
    167          			}    
    168          
    169          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    170          		}
    171          	}
    172          	
    173          	else // WriteAddr is not SPI_FLASH_PageSize aligned  
    174          	{
    175          		if(NumOfPage== 0) // NumByteToWrite < SPI_FLASH_PageSize 
    176          		{
    177          			if(NumOfSingle > count) // (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize 
    178          			{
    179          				temp = NumOfSingle - count;
    180          
    181          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    182          				WriteAddr +=  count;
    183          				pBuffer += count; 
    184          
    185          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
    186          			}
    187          			else
    188          			{
    189          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    190          			}
    191          		
    192          		}
    193          		
    194          		else // NumByteToWrite > SPI_FLASH_PageSize 
    195          		{
    196          			NumByteToWrite -= count;
    197          			NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    198          			NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
    199          
    200          			SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
    201          			WriteAddr +=  count;
    202          			pBuffer += count;  
    203          
    204          			while(NumOfPage--)
    205          			{
    206          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
    207          				WriteAddr +=  SPI_FLASH_PageSize;
    208          				pBuffer += SPI_FLASH_PageSize;
    209          			}
    210          
    211          			if(NumOfSingle != 0)
    212          			{
    213          				SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    214          			}
    215          		}
    216          	}
    217          }
    218          
    219          void SPI_FLASH_BufferRead(unsigned char* pBuffer, unsigned long ReadAddr, unsigned short  NumByteToRead)
    220          {
    221          	// Select the FLASH: Chip Select low 
    222          	SPI_FLASH_CS_LOW();
    223          
    224          	// Send "Read from Memory " instruction 
    225          	SPI_Transfer(READ);
    226          
    227          	// Send ReadAddr high nibble address byte to read from 
    228          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    229          	// Send ReadAddr medium nibble address byte to read from 
    230          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    231          	// Send ReadAddr low nibble address byte to read from 
    232          	SPI_Transfer(ReadAddr & 0xFF);
    233          
    234          	while(NumByteToRead--) // while there is data to be read 
    235          	{
    236          		// Read a byte from the FLASH 
    237          		*pBuffer = SPI_Transfer(Dummy_Byte);
    238          		// Point to the next location where the byte read will be saved 
    239          		pBuffer++;
    240          	}
    241          
    242          	// Deselect the FLASH: Chip Select high 
    243          	SPI_FLASH_CS_HIGH();
    244          }
    245          
    246          //unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    247          
    248          unsigned long SPI_FLASH_ReadID(void)
    249          {
    250          	unsigned long Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    251          
    252          	// Select the FLASH: Chip Select low 
    253          	SPI_FLASH_CS_LOW();
    254          	// Send "RDID " instruction 
    255          	SPI_Transfer(0x9F);
    256          	// Read a byte from the FLASH 
    257          	Temp0 = SPI_Transfer(Dummy_Byte);
    258          
    259          	// Read a byte from the FLASH 
    260          	Temp1 = SPI_Transfer(Dummy_Byte);
    261          
    262          	// Read a byte from the FLASH 
    263          	Temp2 = SPI_Transfer(Dummy_Byte);
    264          
    265          	// Deselect the FLASH: Chip Select high 
    266          	SPI_FLASH_CS_HIGH();
    267          	Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
    268          
    269          	return Temp;
    270          }
    271          
    272          void SPI_FLASH_StartReadSequence(unsigned long ReadAddr)
    273          {
    274          	// Select the FLASH: Chip Select low 
    275          	SPI_FLASH_CS_LOW();
    276          
    277          	// Send "Read from Memory " instruction 
    278          	SPI_Transfer(READ);
    279          
    280          	// Send the 24-bit address of the address to read from -----------------------  
    281          	// Send ReadAddr high nibble address byte 
    282          	SPI_Transfer((ReadAddr & 0xFF0000) >> 16);
    283          	// Send ReadAddr medium nibble address byte 
    284          	SPI_Transfer((ReadAddr& 0xFF00) >> 8);
    285          	// Send ReadAddr low nibble address byte 
    286          	SPI_Transfer(ReadAddr & 0xFF);
    287          }
    288          
    289          unsigned char SPI_FLASH_ReadByte(void)
    290          {
    291          	return (SPI_Transfer(Dummy_Byte));
    292          }
    293          
    294          unsigned char  SPI_Transfer(u8 data)
    295          {      
    296          	unsigned char i;
    297          	unsigned char result;
    298          
    299          	result = 0;
    300          
    301          	for (i = 0; i < 8; i++)
    302          	{
    303          		SPI_FLASH_SCK_LOW();
    304          		(data & (1 << (7- i))) ? SPI_FLASH_MOSI_HIGH():SPI_FLASH_MOSI_LOW();
    305          		SPI_FLASH_SCK_HIGH();
    306          
    307          		result <<= 1;
    308          		result |= GPIO_ReadInputDataBit(SFLASH_SPI1_PORT,SFLASH_SPI1_MISO);
    309          	}
    310          
    311          	return result;
    312              
    313          }
    314          
    315          unsigned char SPI_FLASH_SendByte(unsigned char byte)
    316          {
    317          	
    318          	// Loop while DR register in not emplty 
    319          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
    320          	// Send byte through the SPI1 peripheral 
    321          	SPI_I2S_SendData(SPI1, byte);
    322          	// Wait to receive a byte 
    323          	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
    324          	// Return the byte read from the SPI bus 
    325          	
    326          	return SPI_I2S_ReceiveData(SPI1);
    327          }
    328          
    329          void SPI_FLASH_WriteEnable(void)
    330          {
    331          	// Select the FLASH: Chip Select low 
    332          	SPI_FLASH_CS_LOW();
    333          
    334          	// Send "Write Enable" instruction 
    335          	SPI_Transfer(WREN);
    336          
    337          	// Deselect the FLASH: Chip Select high 
    338          	SPI_FLASH_CS_HIGH();
    339          }
    340          
    341          void SPI_FLASH_WaitForWriteEnd(void)
    342          {
    343          	unsigned char FLASH_Status = 0;
    344          
    345          	// Select the FLASH: Chip Select low 
    346          	SPI_FLASH_CS_LOW();
    347          
    348          	// Send "Read Status Register" instruction 
    349          	SPI_Transfer(RDSR);
    350              
    351          	// Loop as long as the memory is busy with a write cycle 
    352            
    353          	do
    354          	{
    355          		// Send a dummy byte to generate the clock needed by the FLASH and put the value of the status register in FLASH_Status variable 
    356          		FLASH_Status = SPI_Transfer(Dummy_Byte);
    357          
    358          	} while((FLASH_Status & WIP_Flag) == SET); // Write in progress 
    359          
    360          	// Deselect the FLASH: Chip Select high 
    361          
    362          	SPI_FLASH_CS_HIGH();
    363          }
    364          
    365          
    366          unsigned short MakeCrc16(unsigned char *data, unsigned short nLen)
    367          {
    368              unsigned short i = 0;
    369              unsigned short crc16 = 0;
    370              
    371              while (nLen--)
    372              {
    373                  crc16 = Crc16Table[((crc16 ^ data[i]) & 0xff)] ^ (crc16 >> 8);
    374                  i++;
    375              }
    376              
    377              return(crc16);
    378          }
    379          
    380          void M25P32_Init(void)
    381          {
    382          	SPI_FLASH_CS_HIGH();
    383          	
    384          	SPI_FLASH_HOLD_DISABLE();
    385          
    386          	SPI_FLASH_WP_DISABLE();
    387          }
    388          uint8_t temp1024[1024];
    389          
    390          uint8_t temp_cmp[1024];
    391          
    392          
    393          void STM32_Update(unsigned char cmd, unsigned char FactoryInitFlag)
    394          {
    395          
    396          	u16 i=0;
    397          	unsigned long temp_address;
    398          	if(FactoryInitFlag == 1)
    399          	{
    400          		switch(cmd)
    401          		{
    402          			case FILE_WRITE_ENABLE :
    403          				if(Change_UART4_for_Download == 0)
    404          				{
    405          					SPI_FLASH_SectorErase(Sector_10);
    406          					Change_UART4_for_Download = 1;
    407          					CMD_ACK_SendToExynos(FILE_WRITE_ENABLE); 
    408          
    409          					// can serial disable
    410          					//USART_Cmd(Serial_COM2, DISABLE);
    411          				}
    412          				else
    413          				{
    414          					temp_address = Sector_10 + (WL9FM_USART_FILE_DATA.Bin_Data.index  *1024);
    415          					File_Write_to_SFLAH(temp_address);
    416          				}
    417          				break;
    418          
    419          			case FILE_VERIFY :
    420          
    421          				if(Change_UART4_for_Download == 0)
    422          				{
    423          					Change_UART4_for_Download = 1;
    424          					CMD_ACK_SendToExynos(FILE_VERIFY);
    425          				}
    426          				else
    427          				{
    428          					temp_address = Sector_10 + (WL9FM_USART_FILE_DATA.Bin_Data.index  * 1024);
    429          					Read_File_From_SFLAH(temp_address);
    430          				}
    431          				break;
    432          
    433          			case FILE_WRITE_FINISH :
    434          				SPI_FLASH_SectorErase(Sector_61);
    435          				SPI_FLASH_SectorErase(Sector_62);
    436          
    437          				fatoryinit_enable_code[4]=WL9FM_USART_FILE_DATA.Bin_Data.index;
    438          				fatoryinit_enable_code[5]=WL9FM_USART_FILE_DATA.Bin_Data.index>>8;
    439          				SPI_FLASH_PageWrite(fatoryinit_enable_code,Sector_61,6);
    440          				SPI_FLASH_PageWrite(fatoryinit_enable_code,Sector_62,6);
    441          				SPI_FLASH_BufferRead(temp3,Sector_62,6);
    442          				Change_UART4_for_Download=0;
    443          				CMD_ACK_SendToExynos(FILE_WRITE_FINISH);
    444          
    445          				// can serial disable
    446          				//USART_Cmd(Serial_COM2, ENABLE);
    447          				
    448          				break;	
    449          
    450          				
    451          		}
    452          
    453          	}
    454          	else
    455          	{
    456          		switch(cmd)
    457          		{
    458          			case FILE_WRITE_ENABLE :
    459          				if(Change_UART4_for_Download == 0)
    460          				{
    461          					SPI_FLASH_SectorErase(Sector_1);
    462          					Change_UART4_for_Download = 1;
    463          					CMD_ACK_SendToExynos(FILE_WRITE_ENABLE); 
    464          
    465          					// can serial disable
    466          					//USART_Cmd(Serial_COM2, DISABLE);
    467          				}
    468          				else
    469          				{
    470          					temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  *1024);
    471          					File_Write_to_SFLAH(temp_address);
    472          				}
    473          				break;
    474          
    475          			case FILE_VERIFY :
    476          
    477          				if(Change_UART4_for_Download == 0)
    478          				{
    479          					Change_UART4_for_Download = 1;
    480          					CMD_ACK_SendToExynos(FILE_VERIFY);
    481          				}
    482          				else
    483          				{
    484          					temp_address = Sector_1 + (WL9FM_USART_FILE_DATA.Bin_Data.index  * 1024);
    485          					Read_File_From_SFLAH(temp_address);
    486          				}
    487          				break;
    488          
    489          			case FILE_WRITE_FINISH :
    490          				SPI_FLASH_SectorErase(Sector_63);
    491          
    492          				download_enable_code[4]=WL9FM_USART_FILE_DATA.Bin_Data.index;
    493          				download_enable_code[5]=WL9FM_USART_FILE_DATA.Bin_Data.index>>8;
    494          				SPI_FLASH_PageWrite(download_enable_code,Sector_63,6);
    495          				SPI_FLASH_BufferRead(temp3,Sector_63,6);
    496          				Change_UART4_for_Download=0;
    497          				CMD_ACK_SendToExynos(FILE_WRITE_FINISH);
    498          
    499          				// can serial disable
    500          				//USART_Cmd(Serial_COM2, ENABLE);
    501          				
    502          				break;					
    503          		}
    504          	}
    505          	
    506          }
    507          
    508          void ACK_NACK_SendToExynos(uint8_t data)
    509          {
    510          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    511          
    512          	ValueBuffer[0] = 0x02;				//	STX
    513          	ValueBuffer[1] = WL9FM_USART_FILE_DATA.Bin_Data.index ;			//	index L
    514          	ValueBuffer[2] = WL9FM_USART_FILE_DATA.Bin_Data.index>>8  ; 	//	index H
    515          	ValueBuffer[Serial_COM4_TxSize-1] = data;				//	ETX
    516          	
    517          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    518          }
    519          
    520          void CMD_ACK_SendToExynos(uint8_t data)
    521          {
    522          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    523          
    524          	ValueBuffer[0] = 0x02;				//	STX
    525          	ValueBuffer[1] = DOWNRES;			//	KeyValue Command, 0x4B
    526          	ValueBuffer[2] = data;   			//	Key Value HexCode, 
    527          	ValueBuffer[Serial_COM4_TxSize-1] = 0x03;				//	ETX
    528          	
    529          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    530          }
    531          
    532          
    533          void File_Write_to_SFLAH(unsigned long addr)
    534          {
    535          	uint16_t	temp_crc;
    536          	uint8_t i=0;
    537          	
    538          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    539          
    540          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    541          	{
    542          		ACK_NACK_SendToExynos(ACK);
    543          
    544          		for(i=0;i<4;i++)
    545          		{
    546          			SPI_FLASH_PageWrite(&WL9FM_USART_FILE_DATA.Bin_Data.data[i*256],addr+(i<<8),256);
    547          		}
    548                          
    549                          
    550                          SPI_FLASH_BufferRead(temp1024,addr,1024);
    551                          
    552          
    553          		if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    554          	}
    555          	else
    556          	{
    557          		ACK_NACK_SendToExynos(NAK);
    558          	}
    559          }
    560          
    561          uint16_t	temp_crc;
    562          
    563          void Read_File_From_SFLAH(unsigned long addr)
    564          {
    565          		
    566          	temp_crc = MakeCrc16(WL9FM_USART_FILE_DATA.Bin_Data.data, 1024);
    567          
    568          	//if(memcmp(temp_crc,WL9FM_USART_FILE_DATA.Bin_Data.CRC_data,1)==0)
    569          
    570          	if(temp_crc == WL9FM_USART_FILE_DATA.Bin_Data.CRC_data)
    571          	{
    572          		
    573          
    574          		memset(temp1024,0xff,1024);
    575          		
    576          		SPI_FLASH_BufferRead(temp1024,addr,1024);
    577          
    578          		if(memcmp(temp1024,WL9FM_USART_FILE_DATA.Bin_Data.data,1024)==0)
    579          		{
    580          
    581          			if(Change_UART4_for_Download==2)	Change_UART4_for_Download=0;
    582          
    583          			ACK_NACK_SendToExynos(ACK);
    584          		}
    585          		else
    586          			ACK_NACK_SendToExynos(NAK);
    587          	}
    588          	else
    589          	{
    590          		ACK_NACK_SendToExynos(NAK);
    591          	}
    592          }
    593          
    594          void CMD_DUMMY_SendToExynos(uint8_t data)
    595          {
    596          	uint8_t ValueBuffer[Serial_COM4_TxSize];
    597          
    598          	ValueBuffer[0] = 0x02;				//	STX
    599          	ValueBuffer[1] = DUMMYCMD;			//	DUMMYCMD
    600          	ValueBuffer[2] = data;   			//	Data
    601          	ValueBuffer[3] = 0x03;				//	ETX
    602          	
    603          	USARTx_EXYNOS(COM4, (char *)ValueBuffer);	
    604          }
    605          
    606          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ACK_NACK_SendToExynos
        16   -> USARTx_EXYNOS
      16   CMD_ACK_SendToExynos
        16   -> USARTx_EXYNOS
      16   CMD_DUMMY_SendToExynos
        16   -> USARTx_EXYNOS
      16   File_Write_to_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_BufferRead
        16   -> SPI_FLASH_PageWrite
       8   M25P32_Init
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
       4   MakeCrc16
      16   Read_File_From_SFLAH
         0   -> ACK_NACK_SendToExynos
        16   -> MakeCrc16
        16   -> SPI_FLASH_BufferRead
        16   -> __aeabi_memset4
        16   -> memcmp
      32   SPI_FLASH_BufferRead
        32   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        32   -> GPIO_WriteBit
        32   -> SPI_Transfer
      24   SPI_FLASH_BufferWrite
         0   -> SPI_FLASH_PageWrite
        24   -> SPI_FLASH_PageWrite
       8   SPI_FLASH_BulkErase
         8   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_WriteEnable
         8   -> SPI_Transfer
      32   SPI_FLASH_PageWrite
        32   -> GPIO_ReadInputDataBit
        32   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        32   -> SPI_FLASH_WriteEnable
        32   -> SPI_Transfer
       0   SPI_FLASH_ReadByte
         0   -> SPI_Transfer
      24   SPI_FLASH_ReadID
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
      16   SPI_FLASH_SectorErase
        16   -> GPIO_WriteBit
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
        16   -> SPI_Transfer
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   SPI_FLASH_StartReadSequence
         8   -> GPIO_WriteBit
         0   -> SPI_Transfer
         8   -> SPI_Transfer
      24   SPI_FLASH_WaitForWriteEnd
        24   -> GPIO_ReadInputDataBit
         0   -> GPIO_WriteBit
        24   -> GPIO_WriteBit
        24   -> SPI_Transfer
       8   SPI_FLASH_WriteEnable
         0   -> GPIO_WriteBit
         8   -> GPIO_WriteBit
         8   -> SPI_Transfer
      24   SPI_Transfer
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_WriteBit
       8   STM32_Update
         0   -> CMD_ACK_SendToExynos
         0   -> File_Write_to_SFLAH
         0   -> Read_File_From_SFLAH
         8   -> SPI_FLASH_BufferRead
         8   -> SPI_FLASH_PageWrite
         8   -> SPI_FLASH_SectorErase


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       8  ?Subroutine0
      16  ?Subroutine1
      30  ACK_NACK_SendToExynos
      22  CMD_ACK_SendToExynos
      26  CMD_DUMMY_SendToExynos
     512  Crc16Table
     128  File_Write_to_SFLAH
       2  Index_temp
      42  M25P32_Init
      38  MakeCrc16
      94  Read_File_From_SFLAH
     142  SPI_FLASH_BufferRead
     156  SPI_FLASH_BufferWrite
      42  SPI_FLASH_BulkErase
     150  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
      66  SPI_FLASH_ReadID
      66  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      46  SPI_FLASH_StartReadSequence
     102  SPI_FLASH_WaitForWriteEnd
      26  SPI_FLASH_WriteEnable
      84  SPI_Transfer
     292  STM32_Update
    1052  download_enable_code
          fatoryinit_enable_code
          Change_UART4_for_Download
          temp_crc
          temp3
          temp1024
    1024  temp_cmp

 
 1 026 bytes in section .bss
 1 052 bytes in section .data
 2 158 bytes in section .text
 
 2 158 bytes of CODE memory
 2 078 bytes of DATA memory

Errors: none
Warnings: 1
