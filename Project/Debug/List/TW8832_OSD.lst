###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      12/May/2016  10:40:44 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Platform\TaeHa - ECS\SRC\TW8832_OSD.c          #
#    Command line =  "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Platform\TaeHa - ECS\SRC\TW8832_OSD.c" -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN "D:\Project\[SVN] ECS-RD12-16 -  #
#                    WL9F Monitor - STM32_APP\Project\Debug\List\" -o         #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\Debug\Obj\" --debug --endian=little    #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "D:\Project\[SVN]   #
#                    ECS-RD12-16 - WL9F Monitor -                             #
#                    STM32_APP\Project\..\Platform\COMMON\INC\" -I            #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\..\Platform\TaeHa - ECS\INC\" -I       #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\..\Libraries\CMSIS\Device\ST\STM32F4xx #
#                    \Include\" -I "D:\Project\[SVN] ECS-RD12-16 - WL9F       #
#                    Monitor - STM32_APP\Project\..\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\inc\" -Oh --use_c++_inline -I "C:\Program    #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Project\Debug\List\TW8832_OSD.lst              #
#    Object file  =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Project\Debug\Obj\TW8832_OSD.o                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor - STM32_APP\Platform\TaeHa - ECS\SRC\TW8832_OSD.c
      1          /**
      2            ******************************************************************************
      3            * @file    TW8832_OSD.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   TW8832_OSD.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          
     29          uc8		FontOsdWinBase[]  = { FONTWIN1_ST, FONTWIN2_ST, FONTWIN3_ST, FONTWIN4_ST };
     30          vuc8 	SpiOsdWinBase[2]  = { SPI_WIN0_ST, SPI_WIN1_ST };
     31          vuc8 	SPI_MODE_OFFSET[] = {30,21,26,38,22,28,37};
     32          
     33          #if 0
     34          uc8 decimal_font[10][4] =
     35          {
     36          	{ 0,  1,  2,  3},
     37          	{ 4,  5,  6,  7},
     38          	{ 8,  9, 10, 11},
     39          	{12, 13, 14, 15},
     40          	{16, 17, 18, 19},
     41          	{20, 21, 22, 23},
     42          	{24, 25, 26, 27},
     43          	{28, 29, 30, 31},
     44          	{32, 33, 34, 35},
     45          	{36, 37, 38, 39}
     46          };
     47          u8 RPM_dec0=0, RPM_dec1=0, RPM_dec2=0, RPM_dec3=0;
     48          u8 temp_RPM_dec0=99, temp_RPM_dec1=99, temp_RPM_dec2=99, temp_RPM_dec3=99;
     49          
     50          u8 C_dec0=0, C_dec1=0, C_dec2=0, C_dec3=0;
     51          u8 temp_C_dec0=99, temp_C_dec1=99, temp_C_dec2=99, temp_C_dec3=99;
     52          
     53          u8 H_dec0=0, H_dec1=0, H_dec2=0, H_dec3=0;
     54          u8 temp_H_dec0=99, temp_H_dec1=99, temp_H_dec2=99, temp_H_dec3=99;
     55          #endif
     56          
     57          /* Private function prototypes -----------------------------------------------*/
     58          /* Private functions ---------------------------------------------------------*/
     59          //=============================================================================
     60          //		OSD Window Setup
     61          //=============================================================================
     62          /*	
     63          	SPI OSD DE delay calculation 
     64          	HDE       = REG(0x210[7:0])
     65          	Mixing    = REG(0x400[1:1]){0,3}
     66          	PCLKO     = REG(0x20d[1:0])
     67          	SPI_MODE  = REG(0x480[2:0]){30,21,26,38,22,28,37}
     68          	CLK_DELAY = REG(0x481[4:4])
     69          
     70          	result = HDE + Mixing + PCLKO - (SPI_MODE + CLK_DELAY)
     71          */ 
     72          void SpiOsdWinEnable(u8 winno, u8 en)
     73          {
     74          	u8  index;
     75          	u8  dat;
     76          	u16 temp;
     77          
     78          	//
     79          	WriteTW8832( 0xff, 2 );
     80          	temp = ReadTW8832( 0x10 );			//	HDE
     81          	temp  += (ReadTW8832( 0x0d ) & 3);	// 	PCLKO
     82          	WriteTW8832( 0xff, 4 );
     83          
     84          	if ( ReadTW8832( 0x00 ) & 2 ) 		// 	Check Mixing		
     85          	{			
     86          		temp += 3;
     87          	}
     88          	temp -= SPI_MODE_OFFSET[ ReadTW8832( 0x80 ) & 7 ];
     89          
     90          	if ( ReadTW8832( 0x81 ) & 0x10 ) 
     91          	{
     92          		temp--;
     93          	}
     94          	WriteTW8832( 0x0F, temp );   		// Write SPI OSD DE value
     95          		
     96          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_ENABLE;
     97          	WriteTW8832( 0xff, SPI_OSD_PAGE );
     98          	dat = ReadTW8832(index);
     99          
    100          	if( en ) WriteTW8832(index, dat | 0x01);
    101          	else     WriteTW8832(index, dat & 0xfe);
    102          }
    103          	 
    104          void SpiOsdWinBufferMem(u8 winno, u32 start)
    105          {
    106          	u8 index;
    107          	
    108          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_BUFFERSTART;
    109          	//Printf("\nWinno: %bd, SpiOsdWinBase: %bd", winno, SpiOsdWinBase[winno] );
    110          	//Printf("\nOSD buffer set to reg: %02bx, address:%02bx %02bx %02bx", index, (u8)(start>>16), (u8)(start>>8), (u8)(start) );
    111          
    112          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    113          	WriteTW8832(index++, (u8)(start>>16));
    114          	WriteTW8832(index++, (u8)(start>>8));
    115          	WriteTW8832(index++, (u8)start);
    116          
    117          }
    118          
    119          void SpiOsdWinBufferSizeXY (u8 winno, u16 x, u16 y)
    120          {
    121          	u8 index;
    122          
    123          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_DISPSIZE;
    124          	//Printf("\nSpiOsdWinBufferSizeXY to reg: %02bx, x:%d y:%d", index, x, y );
    125          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    126          	WriteTW8832(index++, x>>8);
    127          	WriteTW8832(index++, x);
    128          	WriteTW8832(index++, y>>8);
    129          	WriteTW8832(index,   y);
    130          }
    131          		
    132          void SpiOsdWinBufferOffsetXY (u8 winno, u16 x, u16 y)
    133          {
    134          	u8 index;
    135          
    136          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_DISPOFFSET;
    137          	//Printf("\nSpiOsdWinBufferOffsetXY to reg: %02bx, x:%d y:%d", index, x, y );
    138          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    139          	WriteTW8832(index++, (u8)(x>>8));
    140          	WriteTW8832(index++, (u8)x);
    141          	WriteTW8832(index++, (u8)(y>>8));
    142          	WriteTW8832(index,   (u8)y);
    143          }
    144          		
    145          void SpiOsdWinScreen(u8 winno, u16 x, u16 y, u16 w, u16 h)
    146          {
    147          	u8 index;
    148          
    149          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_SCREEN;
    150          	//Printf("\nSpiOsdWinScreen to reg: %02bx, x:%d y:%d, w:%d h:%d", index, x, y, w, h );
    151          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    152          	WriteTW8832(index++, (u8)(x>>8));
    153          	WriteTW8832(index++, (u8)x);
    154          	WriteTW8832(index++, (u8)(y>>8));
    155          	WriteTW8832(index++, (u8)y);
    156          	WriteTW8832(index++, (u8)(w>>8));
    157          	WriteTW8832(index++, (u8)w);
    158          	WriteTW8832(index++, (u8)(h>>8));
    159          	WriteTW8832(index,   (u8)h);
    160          }
    161          
    162          //=============================================================================
    163          //		OSD Window Functions
    164          //=============================================================================
    165          
    166          void SpiOsdWaitVBlank(u8 cnt)
    167          {
    168          	u8 i;
    169          
    170           	WriteTW8832( 0xff, SPI_OSD_PAGE );
    171          	for(i=0; i<cnt; i++) {
    172          		WriteTW8832( 0x08, 0x20 );
    173          		while( (ReadTW8832(0x08) & 0x20)==0 );	
    174          	}
    175          }
    176          
    177          //=============================================================================
    178          //		Load LUT
    179          //=============================================================================
    180          void SpiOsdLoadLUT( u32	address, u32 DMA_size )
    181          {
    182          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    183          
    184          	//--- SPI-OSD config
    185          	WriteTW8832( 0x10, 0xc0 );    			// 	LUT Write Mode, En
    186          	WriteTW8832( 0x11, 0x00 );    			//	LUT addr
    187          	
    188          	//--- SPI-DMA mode
    189          	
    190          	WriteTW8832( 0x83, 0x85 );
    191          	WriteTW8832( 0x84, 0x00 );
    192          	           
    193          	WriteTW8832( 0x8a, 0x0b ); 				// 	SPI Command=R
    194          	WriteTW8832( 0x8b, (u8)(address>>16) ); // 	SPI Addr
    195          	WriteTW8832( 0x8c, (u8)(address>>8) );
    196          	WriteTW8832( 0x8d, (u8)(address) ); 	//	00
    197          	          
    198          	WriteTW8832( 0x86, 0x00 ); 				// 	04 // DMA dest.
    199          	WriteTW8832( 0x87, 0x00 ); 				// 	12
    200          
    201              WriteTW8832( 0x9a, (u8)(DMA_size>>16) );//	DMA size
    202          	WriteTW8832( 0x88, (u8)(DMA_size>>8) );
    203          	WriteTW8832( 0x89, (u8)(DMA_size) );
    204              
    205          	//WriteTW8832( 0x9a, 0x00 );//	DMA size
    206          	//WriteTW8832( 0x88, 0x04 );
    207          	//WriteTW8832( 0x89, 0x00 );
    208          	
    209          	WriteTW8832( 0x84, 0x01 ); 	//	DMA Start
    210          
    211          	//Printf("\r---> LUT Write ");
    212          }
    213          
    214          //=============================================================================
    215          //		SpiOsdWinAlpha( u8 winno, u8 alpha )
    216          //=============================================================================
    217          void SpiOsdWinAlpha( u8 winno, u8 alpha )
    218          {
    219          	u8	index;
    220          
    221          	index = SpiOsdWinBase[winno];
    222          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    223          
    224          	if ( alpha ) {
    225          		WriteTW8832( index, ( ReadTW8832( 0x20 ) & 0xDF ) | 0x10 );	// en Alpha & Global
    226          	}
    227          	else {
    228          		WriteTW8832( index, ( ReadTW8832( 0x20 ) & 0xCF ) );			// dis Alpha & Global
    229          	}
    230          	index = SpiOsdWinBase[winno] + 0x14;
    231          	WriteTW8832( index, alpha );
    232          }
    233          
    234          //=============================================================================
    235          //		SpiOsdWinAlpha( u8 winno, u8 alpha )
    236          //=============================================================================
    237          void	SpiOsdPixelAlpha( u8 winno, u8 alpha )
    238          {
    239          	u8	index;
    240          
    241          	index = SpiOsdWinBase[winno];
    242          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    243          
    244          	if ( alpha ) {
    245          		WriteTW8832( index, ReadTW8832( 0x20 ) | 0x30 );				// en Alpha & Global
    246          	}
    247          	else {
    248          		WriteTW8832( index, ( ReadTW8832( 0x20 ) & 0xCF ) );			// dis Alpha & Global
    249          	}
    250          	index = SpiOsdWinBase[winno] + 0x14;
    251          	WriteTW8832( index, alpha );
    252          }
    253          
    254          //=============================================================================
    255          //		Animation
    256          //=============================================================================
    257          void SpiOsdAnimation(u8 winno, u8 mode, u8 FrameH, u8 FrameV, u8 Duration)
    258          {
    259          	u8 index;
    260          	u8 temp;
    261          	
    262          	temp = SpiOsdWinBase[winno];
    263          	index = SpiOsdWinBase[winno] + SPI_OSDWIN_ANIMATION;
    264          	WriteTW8832( 0xff, SPI_OSD_PAGE );
    265          	WriteTW8832(index++, FrameH);
    266          	WriteTW8832(index++, FrameV);
    267          	WriteTW8832(index, Duration);
    268          
    269          	//WriteTW8832( SpiOsdWinBase[winno], ( ReadTW8832( SpiOsdWinBase[winno]) & 0x3f ) | (mode <<6) );
    270          	WriteTW8832( temp, ( ReadTW8832( SpiOsdWinBase[winno]) & 0x3f ) | (mode <<6) );
    271          
    272          }
    273          
    274          
    275          //=============================================================================
    276          //		void FontOsdWinEnable(u8 winno, u8 en)
    277          //=============================================================================
    278          /*	
    279          	SPI OSD DE delay calculation 
    280          	HDE    = REG(0x210[7:0])
    281          	Mixing = REG(0x400[1:1])
    282          
    283          	result = HDE - ( Mixing +41 )
    284          */ 
    285          void FontOsdWinEnable(u8 winno, u8 en)
    286          {
    287          	u8 index;
    288          	u8 dat;
    289          	u16 temp;
    290          
    291          	index = FontOsdWinBase[winno] + FONTWIN_ENABLE;
    292          
    293          	WriteTW8832( 0xff, 2 );
    294          	temp = ReadTW8832( 0x10 );				// HDE
    295          	WriteTW8832( 0xff, 4 );
    296          	if ( ReadTW8832( 0x00 ) & 2 ) 			// Check Mixing
    297          	{			
    298          		temp--;
    299          	}
    300          	temp -= 41;
    301          	
    302          	WriteTW8832( 0xff, FONT_OSD_PAGE );
    303          
    304          	WriteTW8832( 0x03, temp );   			// Write FONT OSD DE value
    305          
    306          	dat = ReadTW8832(index);
    307          	if( en ) WriteTW8832(index, dat | 0x80);
    308          	else     WriteTW8832(index, dat & 0x7F);
    309          }
    310          	 
    311          //=============================================================================
    312          //		void FontOsdWinAlpha(u8 winno, u8 color, u8 alpha)
    313          //=============================================================================
    314          void FontOsdWinAlpha(u8 winno, u8 color, u8 alpha)
    315          {
    316          	u8	index = FontOsdWinBase[winno] + FONT_ALPHA;
    317          
    318          	WriteTW8832( 0xff, FONT_OSD_PAGE );
    319          
    320          	WriteTW8832( index, ( color <<4 ) + alpha );	 		// first select color
    321          	WriteTW8832( index, ( color <<4 ) + alpha );			// second write alpha value
    322          }
    323          
    324          //=============================================================================
    325          //		void FontOsdWinScreen(u8 winno, u16 x, u16 y, u8 w, u8 h, u8 zoomH, u8 zoomV)
    326          //=============================================================================
    327          void FontOsdWinScreen(u8 winno, u16 x, u16 y, u8 w, u8 h, u8 zoomH, u8 zoomV)
    328          {
    329          	u8 index, temp;
    330          
    331          	index = FontOsdWinBase[winno];
    332          	
    333          	WriteTW8832( 0xff, FONT_OSD_PAGE );
    334          	temp = zoomH*4 + zoomV;
    335          	temp += (ReadTW8832( index ) & 0xf0);
    336          	WriteTW8832( index, temp );				// write Zoom value
    337          	
    338          	temp = x >> 8;
    339          	temp <<= 4;
    340          	temp += ( y >> 8 );
    341          	WriteTW8832( index+2,  temp );			// upper bit for position x, y
    342          	WriteTW8832( index+3, x );				// position x
    343          	WriteTW8832( index+4, y );				// position y
    344          	WriteTW8832( index+5, h );
    345          	WriteTW8832( index+6, w );
    346          }
    347          //=============================================================================
    348          //				   void FontDMA( void )
    349          //=============================================================================
    350          void FontDMA( void )
    351          {
    352          
    353          	WriteTW8832( 0xff, 0x03 );
    354          	WriteTW8832( 0x00, 0x03 ); //bypass
    355          	WriteTW8832( 0x04, 0x0d ); //Font RAM access
    356          	WriteTW8832( 0x09, 0x00 ); //Font Addr
    357          	
    358          	WriteTW8832( 0xff, 0x04 );
    359          	WriteTW8832( 0x83, 0x05 ); //e4
    360          	
    361          	WriteTW8832( 0x86, 0x00 ); // DMA Page Register
    362          	WriteTW8832( 0x87, 0x00 ); // DMA Index Register
    363          	
    364          	WriteTW8832( 0x8a, 0x0b );
    365          	WriteTW8832( 0x8b, 0x00 ); // Serial Flash Memory Address
    366          	WriteTW8832( 0x8c, 0x00 ); // Serial Flash Memory Address
    367          	WriteTW8832( 0x8d, 0x00 ); // Serial Flash Memory Address
    368          	
    369          	WriteTW8832( 0x9a, 0x00 );
    370          	WriteTW8832( 0x88, 0x10 );
    371          	WriteTW8832( 0x89, 0xe0 );
    372          	
    373          	WriteTW8832( 0x84, 0x01 ); //DMA Start
    374          	TimeDelay_msec(10);
    375          	
    376          	//WriteTW8832( 0xff, 0x03 );
    377          	//WriteTW8832( 0x04, 0x0c ); //Display RAM Access Mode
    378          }
    379          //=============================================================================
    380          
    381          //	사용하지 않는 코드 삭제 
    382          #if 0
    383          //=============================================================================
    384          //		void FontDemo( void )
    385          //=============================================================================
    386          void RPM_Display(u16 RPM_Value)
    387          {
    388              RPM_dec0 = RPM_Value/1000;
    389              RPM_dec1 = (RPM_Value%1000)/100;
    390              RPM_dec2 = (RPM_Value%100)/10;
    391              RPM_dec3 = RPM_Value%10;
    392              
    393              if((temp_RPM_dec0 != RPM_dec0) & (RPM_Value > 999)){
    394              	temp_RPM_dec0 = RPM_dec0 = RPM_Value/1000;                
    395              	WriteTW8832( 0x06, 0x00 );                 // OSD Display Ram Addr
    396              	WriteTW8832( 0x07, decimal_font[RPM_dec0][0]); // FontRam Addr
    397              	WriteTW8832( 0x06, 0x01 );                            
    398              	WriteTW8832( 0x07, decimal_font[RPM_dec0][1] );
    399              	WriteTW8832( 0x06, 0x08 );                            
    400              	WriteTW8832( 0x07, decimal_font[RPM_dec0][2] );
    401              	WriteTW8832( 0x06, 0x09 );                           
    402              	WriteTW8832( 0x07, decimal_font[RPM_dec0][3] );
    403              }
    404              else if((temp_RPM_dec0 != RPM_dec0) & (RPM_dec0 == 0 ) & (RPM_Value < 999)){
    405              	temp_RPM_dec0 = RPM_dec0 = RPM_Value/1000;
    406          		WriteTW8832( 0x06, 0x00 );                 // OSD Display Ram Addr
    407          	    WriteTW8832( 0x07, 40); // FontRam Addr
    408          	    WriteTW8832( 0x06, 0x01 );                            
    409          	    WriteTW8832( 0x07, 40 );
    410          	    WriteTW8832( 0x06, 0x08 );                            
    411          	    WriteTW8832( 0x07, 40);
    412          	    WriteTW8832( 0x06, 0x09 );                           
    413          	    WriteTW8832( 0x07, 40 );
    414              }
    415          
    416              if((temp_RPM_dec1 != RPM_dec1) & (RPM_Value > 99)){
    417              	temp_RPM_dec1 = RPM_dec1 = (RPM_Value%1000)/100;                
    418          	    WriteTW8832( 0x06, 0x02 );                 // OSD Display Ram Addr
    419          	    WriteTW8832( 0x07, decimal_font[RPM_dec1][0]); // FontRam Addr
    420          	    WriteTW8832( 0x06, 0x03 );                            
    421          	    WriteTW8832( 0x07, decimal_font[RPM_dec1][1]); 
    422          	    WriteTW8832( 0x06, 0x0a );                            
    423          	    WriteTW8832( 0x07, decimal_font[RPM_dec1][2]); 
    424          	    WriteTW8832( 0x06, 0x0b );                            
    425          	    WriteTW8832( 0x07, decimal_font[RPM_dec1][3]); 
    426              }
    427              else if((temp_RPM_dec1 != RPM_dec1) & (RPM_dec1 == 0 ) & (RPM_Value < 99)){
    428              	temp_RPM_dec1 = RPM_dec1 = (RPM_Value%1000)/100;                
    429          		WriteTW8832( 0x06, 0x02 );                 // OSD Display Ram Addr
    430          	    WriteTW8832( 0x07, 40); // FontRam Addr
    431          	    WriteTW8832( 0x06, 0x03 );                            
    432          	    WriteTW8832( 0x07, 40 );
    433          	    WriteTW8832( 0x06, 0x0a );                            
    434          	    WriteTW8832( 0x07, 40);
    435          	    WriteTW8832( 0x06, 0x0b );                           
    436          	    WriteTW8832( 0x07, 40 );
    437              }
    438              
    439              if((temp_RPM_dec2 != RPM_dec2) & (RPM_Value > 9)){
    440              	temp_RPM_dec2 = RPM_dec2 = (RPM_Value%100)/10;
    441          	    WriteTW8832( 0x06, 0x04 );                 // OSD Display Ram Addr
    442          	    WriteTW8832( 0x07, decimal_font[RPM_dec2][0]); // FontRam Addr
    443          	    WriteTW8832( 0x06, 0x05 );                            
    444          	    WriteTW8832( 0x07, decimal_font[RPM_dec2][1]); 
    445          	    WriteTW8832( 0x06, 0x0c );                            
    446          	    WriteTW8832( 0x07, decimal_font[RPM_dec2][2]); 
    447          	    WriteTW8832( 0x06, 0x0d );                            
    448          	    WriteTW8832( 0x07, decimal_font[RPM_dec2][3]); 
    449              }
    450              else if((temp_RPM_dec2 != RPM_dec2) & (RPM_dec2 == 0 ) & (RPM_Value < 9)){
    451              	temp_RPM_dec2 = RPM_dec2 = (RPM_Value%100)/10;
    452          		WriteTW8832( 0x06, 0x04 );                 // OSD Display Ram Addr
    453          	    WriteTW8832( 0x07, 40); // FontRam Addr
    454          	    WriteTW8832( 0x06, 0x05 );                            
    455          	    WriteTW8832( 0x07, 40 );
    456          	    WriteTW8832( 0x06, 0x0c );                            
    457          	    WriteTW8832( 0x07, 40);
    458          	    WriteTW8832( 0x06, 0x0d );                           
    459          	    WriteTW8832( 0x07, 40 );
    460              }
    461          
    462              if(temp_RPM_dec3 != RPM_dec3){
    463              	temp_RPM_dec3 = RPM_dec3 = RPM_Value%10;
    464          	    WriteTW8832( 0x06, 0x06 );                 // OSD Display Ram Addr
    465          	    WriteTW8832( 0x07, decimal_font[RPM_dec3][0]); // FontRam Addr
    466          	    WriteTW8832( 0x06, 0x07 );                            
    467          	    WriteTW8832( 0x07, decimal_font[RPM_dec3][1]); 
    468          	    WriteTW8832( 0x06, 0x0e );                            
    469          	    WriteTW8832( 0x07, decimal_font[RPM_dec3][2]); 
    470          	    WriteTW8832( 0x06, 0x0f );                            
    471          	    WriteTW8832( 0x07, decimal_font[RPM_dec3][3]); 
    472              }
    473                          
    474              //WriteTW8832( 0xff, 0x03 );
    475              //WriteTW8832( 0x04, 0x0C );// Display RAM Access Mode
    476              
    477          }
    478          
    479          
    480          //=============================================================================
    481          //		void FontDemo( void )
    482          //=============================================================================
    483          void Hyd_TEMP_Display(u16 TEMP_Value)
    484          {
    485              H_dec0 = TEMP_Value/1000;
    486              H_dec1 = (TEMP_Value%1000)/100;
    487              H_dec2 = (TEMP_Value%100)/10;
    488              H_dec3 = TEMP_Value%10;
    489          
    490              if((temp_H_dec0 != H_dec0) & (TEMP_Value > 999)){
    491              	temp_H_dec0 = H_dec0 = TEMP_Value/1000;  
    492          	    WriteTW8832( 0x06, 0x00 + FONT_WIN1_OSDADDR_OFFSET );     // OSD Display Ram Addr
    493          	    WriteTW8832( 0x07, decimal_font[H_dec0][0]);                // FontRam Addr
    494          	    WriteTW8832( 0x06, 0x01 + FONT_WIN1_OSDADDR_OFFSET );                            
    495          	    WriteTW8832( 0x07, decimal_font[H_dec0][1] );
    496          	    WriteTW8832( 0x06, 0x09 + FONT_WIN1_OSDADDR_OFFSET );                            
    497          	    WriteTW8832( 0x07, decimal_font[H_dec0][2] );
    498          	    WriteTW8832( 0x06, 0x0a + FONT_WIN1_OSDADDR_OFFSET );                           
    499          	    WriteTW8832( 0x07, decimal_font[H_dec0][3] );
    500          	}
    501              else if((temp_H_dec0 != H_dec0) & (H_dec0 == 0 ) & (TEMP_Value < 999)){
    502              	temp_H_dec0 = H_dec0 = TEMP_Value/1000;  
    503          		WriteTW8832( 0x06, 0x00 + FONT_WIN1_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    504          	    WriteTW8832( 0x07, 40); // FontRam Addr
    505          	    WriteTW8832( 0x06, 0x01 + FONT_WIN1_OSDADDR_OFFSET );                            
    506          	    WriteTW8832( 0x07, 40 );
    507          	    WriteTW8832( 0x06, 0x09 + FONT_WIN1_OSDADDR_OFFSET );                            
    508          	    WriteTW8832( 0x07, 40);
    509          	    WriteTW8832( 0x06, 0x0a + FONT_WIN1_OSDADDR_OFFSET );                           
    510          	    WriteTW8832( 0x07, 40 );
    511              }
    512              
    513              if((temp_H_dec1 != H_dec1) & (TEMP_Value > 99)){
    514              	temp_H_dec1 = H_dec1 = TEMP_Value%1000/100;  
    515          	    WriteTW8832( 0x06, 0x02 + FONT_WIN1_OSDADDR_OFFSET );   // OSD Display Ram Addr
    516          	    WriteTW8832( 0x07, decimal_font[H_dec1][0]);                        // FontRam Addr
    517          	    WriteTW8832( 0x06, 0x03 + FONT_WIN1_OSDADDR_OFFSET );                            
    518          	    WriteTW8832( 0x07, decimal_font[H_dec1][1]); 
    519          	    WriteTW8832( 0x06, 0x0b + FONT_WIN1_OSDADDR_OFFSET );                            
    520          	    WriteTW8832( 0x07, decimal_font[H_dec1][2]); 
    521          	    WriteTW8832( 0x06, 0x0c + FONT_WIN1_OSDADDR_OFFSET );                            
    522          	    WriteTW8832( 0x07, decimal_font[H_dec1][3]); 
    523          	}
    524              else if((temp_H_dec1 != H_dec1) & (H_dec1 == 0 ) & (TEMP_Value < 99)){
    525              	temp_H_dec1 = H_dec1 = TEMP_Value%1000/100;  
    526          		WriteTW8832( 0x06, 0x02 + FONT_WIN1_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    527          	    WriteTW8832( 0x07, 40); // FontRam Addr
    528          	    WriteTW8832( 0x06, 0x03 + FONT_WIN1_OSDADDR_OFFSET );                            
    529          	    WriteTW8832( 0x07, 40 );
    530          	    WriteTW8832( 0x06, 0x0b + FONT_WIN1_OSDADDR_OFFSET );                            
    531          	    WriteTW8832( 0x07, 40);
    532          	    WriteTW8832( 0x06, 0x0c + FONT_WIN1_OSDADDR_OFFSET );                           
    533          	    WriteTW8832( 0x07, 40 );
    534              }
    535              
    536              if((temp_H_dec2 != H_dec2) & (TEMP_Value > 9)){
    537              	temp_H_dec2 = H_dec2 = TEMP_Value%100/10;  
    538          	    WriteTW8832( 0x06, 0x04 + FONT_WIN1_OSDADDR_OFFSET );   // OSD Display Ram Addr
    539          	    WriteTW8832( 0x07, decimal_font[H_dec2][0]);                        // FontRam Addr
    540          	    WriteTW8832( 0x06, 0x05 + FONT_WIN1_OSDADDR_OFFSET );                            
    541          	    WriteTW8832( 0x07, decimal_font[H_dec2][1]); 
    542          	    WriteTW8832( 0x06, 0x0d + FONT_WIN1_OSDADDR_OFFSET );                            
    543          	    WriteTW8832( 0x07, decimal_font[H_dec2][2]); 
    544          	    WriteTW8832( 0x06, 0x0e + FONT_WIN1_OSDADDR_OFFSET );                            
    545          	    WriteTW8832( 0x07, decimal_font[H_dec2][3]); 
    546          
    547          	    WriteTW8832( 0x06, 0x06 + FONT_WIN1_OSDADDR_OFFSET );  //Blank                            
    548          	    WriteTW8832( 0x07, 40 ); 
    549          	    WriteTW8832( 0x06, 0x0f + FONT_WIN1_OSDADDR_OFFSET );                            
    550          	    WriteTW8832( 0x07, 41 ); 
    551              }
    552              else if((temp_H_dec2 != H_dec2) & (H_dec2 == 0 ) & (TEMP_Value < 9)){
    553              	temp_H_dec2 = H_dec2 = TEMP_Value%100/10;  
    554          		WriteTW8832( 0x06, 0x04 + FONT_WIN1_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    555          	    WriteTW8832( 0x07, 40); // FontRam Addr
    556          	    WriteTW8832( 0x06, 0x05 + FONT_WIN1_OSDADDR_OFFSET );                            
    557          	    WriteTW8832( 0x07, 40 );
    558          	    WriteTW8832( 0x06, 0x0d + FONT_WIN1_OSDADDR_OFFSET );                            
    559          	    WriteTW8832( 0x07, 40);
    560          	    WriteTW8832( 0x06, 0x0e + FONT_WIN1_OSDADDR_OFFSET );                           
    561          	    WriteTW8832( 0x07, 40 );
    562          	    WriteTW8832( 0x06, 0x06 + FONT_WIN1_OSDADDR_OFFSET );  //Blank                            
    563          	    WriteTW8832( 0x07, 40 ); 
    564          	    WriteTW8832( 0x06, 0x0f + FONT_WIN1_OSDADDR_OFFSET );                            
    565          	    WriteTW8832( 0x07, 41 ); 
    566              }
    567              
    568              if(temp_H_dec3 != H_dec3){
    569              	temp_H_dec3= H_dec3 = TEMP_Value%10;  
    570          	    WriteTW8832( 0x06, 0x07 + FONT_WIN1_OSDADDR_OFFSET );   // OSD Display Ram Addr
    571          	    WriteTW8832( 0x07, decimal_font[H_dec3][0]);                        // FontRam Addr
    572          	    WriteTW8832( 0x06, 0x08 + FONT_WIN1_OSDADDR_OFFSET );                            
    573          	    WriteTW8832( 0x07, decimal_font[H_dec3][1]); 
    574          	    WriteTW8832( 0x06, 0x10 + FONT_WIN1_OSDADDR_OFFSET );                            
    575          	    WriteTW8832( 0x07, decimal_font[H_dec3][2]); 
    576          	    WriteTW8832( 0x06, 0x11 + FONT_WIN1_OSDADDR_OFFSET );                            
    577          	    WriteTW8832( 0x07, decimal_font[H_dec3][3]); 
    578              }
    579              //WriteTW8832( 0x04, 0x0C );// Display RAM Access Mode
    580          }
    581          
    582          //=============================================================================
    583          //		void FontDemo( void )
    584          //=============================================================================
    585          void Cool_TEMP_Display(u16 TEMP_Value)
    586          {
    587              C_dec0 = TEMP_Value/1000;
    588              C_dec1 = (TEMP_Value%1000)/100;
    589              C_dec2 = (TEMP_Value%100)/10;
    590              C_dec3 = TEMP_Value%10;
    591              
    592              if((temp_C_dec0 != C_dec0) & (TEMP_Value > 999)){
    593              	temp_C_dec0 = C_dec0 = TEMP_Value/1000;
    594          	    WriteTW8832( 0x06, 0x00 + FONT_WIN2_OSDADDR_OFFSET );     // OSD Display Ram Addr
    595          	    WriteTW8832( 0x07, decimal_font[C_dec0][0]);                        // FontRam Addr
    596          	    WriteTW8832( 0x06, 0x01 + FONT_WIN2_OSDADDR_OFFSET );                            
    597          	    WriteTW8832( 0x07, decimal_font[C_dec0][1] );
    598          	    WriteTW8832( 0x06, 0x09 + FONT_WIN2_OSDADDR_OFFSET );                            
    599          	    WriteTW8832( 0x07, decimal_font[C_dec0][2] );
    600          	    WriteTW8832( 0x06, 0x0a + FONT_WIN2_OSDADDR_OFFSET );                           
    601          	    WriteTW8832( 0x07, decimal_font[C_dec0][3] );
    602          	}
    603              else if((temp_C_dec0 != C_dec0) & (C_dec0 == 0 ) & (TEMP_Value < 999)){
    604          	    temp_C_dec0 = C_dec0 = TEMP_Value/1000;  
    605          	    WriteTW8832( 0x06, 0x00 + FONT_WIN2_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    606          	    WriteTW8832( 0x07, 40); // FontRam Addr
    607          	    WriteTW8832( 0x06, 0x01 + FONT_WIN2_OSDADDR_OFFSET );                            
    608          	    WriteTW8832( 0x07, 40 );
    609          	    WriteTW8832( 0x06, 0x09 + FONT_WIN2_OSDADDR_OFFSET );                            
    610          	    WriteTW8832( 0x07, 40);
    611          	    WriteTW8832( 0x06, 0x0a + FONT_WIN2_OSDADDR_OFFSET );                           
    612          	    WriteTW8832( 0x07, 40 );
    613              }
    614              
    615              if((temp_C_dec1 != C_dec1) & (TEMP_Value > 99)){
    616          	    temp_C_dec1 = C_dec1 = TEMP_Value%1000/100;
    617          	    WriteTW8832( 0x06, 0x02 + FONT_WIN2_OSDADDR_OFFSET );   // OSD Display Ram Addr
    618          	    WriteTW8832( 0x07, decimal_font[C_dec1][0]);                        // FontRam Addr
    619          	    WriteTW8832( 0x06, 0x03 + FONT_WIN2_OSDADDR_OFFSET );                            
    620          	    WriteTW8832( 0x07, decimal_font[C_dec1][1]); 
    621          	    WriteTW8832( 0x06, 0x0b + FONT_WIN2_OSDADDR_OFFSET );                            
    622          	    WriteTW8832( 0x07, decimal_font[C_dec1][2]); 
    623          	    WriteTW8832( 0x06, 0x0c + FONT_WIN2_OSDADDR_OFFSET );                            
    624          	    WriteTW8832( 0x07, decimal_font[C_dec1][3]); 
    625          	}
    626              else if((temp_C_dec1 != C_dec1) & (C_dec1 == 0 ) & (TEMP_Value < 99)){
    627          	    temp_C_dec1 = C_dec1 = TEMP_Value%1000/100; 
    628          	    WriteTW8832( 0x06, 0x02 + FONT_WIN2_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    629          	    WriteTW8832( 0x07, 40); // FontRam Addr
    630          	    WriteTW8832( 0x06, 0x03 + FONT_WIN2_OSDADDR_OFFSET );                            
    631          	    WriteTW8832( 0x07, 40 );
    632          	    WriteTW8832( 0x06, 0x0b + FONT_WIN2_OSDADDR_OFFSET );                            
    633          	    WriteTW8832( 0x07, 40);
    634          	    WriteTW8832( 0x06, 0x0c + FONT_WIN2_OSDADDR_OFFSET );                           
    635          	    WriteTW8832( 0x07, 40 );
    636              }
    637              
    638              if((temp_C_dec2 != C_dec2) & (TEMP_Value > 9)){
    639          	    temp_C_dec2 = C_dec2 = TEMP_Value%100/10;
    640          	    WriteTW8832( 0x06, 0x04 + FONT_WIN2_OSDADDR_OFFSET );   // OSD Display Ram Addr
    641          	    WriteTW8832( 0x07, decimal_font[C_dec2][0]);                        // FontRam Addr
    642          	    WriteTW8832( 0x06, 0x05 + FONT_WIN2_OSDADDR_OFFSET );                            
    643          	    WriteTW8832( 0x07, decimal_font[C_dec2][1]); 
    644          	    WriteTW8832( 0x06, 0x0d + FONT_WIN2_OSDADDR_OFFSET );                            
    645          	    WriteTW8832( 0x07, decimal_font[C_dec2][2]); 
    646          	    WriteTW8832( 0x06, 0x0e + FONT_WIN2_OSDADDR_OFFSET );                            
    647          	    WriteTW8832( 0x07, decimal_font[C_dec2][3]); 
    648          
    649          	    WriteTW8832( 0x06, 0x06 + FONT_WIN2_OSDADDR_OFFSET ); //Blank                            
    650          	    WriteTW8832( 0x07, 40 ); 
    651          	    WriteTW8832( 0x06, 0x0f + FONT_WIN2_OSDADDR_OFFSET );                            
    652          	    WriteTW8832( 0x07, 41 ); 
    653          	}
    654              else if((temp_C_dec2 != C_dec2) & (C_dec2 == 0 ) & (TEMP_Value < 9)){
    655          	    temp_C_dec2 = C_dec2 = TEMP_Value%100/10; 
    656          	    WriteTW8832( 0x06, 0x04 + FONT_WIN2_OSDADDR_OFFSET );                 // OSD Display Ram Addr
    657          	    WriteTW8832( 0x07, 40); // FontRam Addr
    658          	    WriteTW8832( 0x06, 0x05 + FONT_WIN2_OSDADDR_OFFSET );                            
    659          	    WriteTW8832( 0x07, 40 );
    660          	    WriteTW8832( 0x06, 0x0d + FONT_WIN2_OSDADDR_OFFSET );                            
    661          	    WriteTW8832( 0x07, 40);
    662          	    WriteTW8832( 0x06, 0x0e + FONT_WIN2_OSDADDR_OFFSET );                           
    663          	    WriteTW8832( 0x07, 40 );
    664          	    //WriteTW8832( 0x06, 0x06 + FONT_WIN2_OSDADDR_OFFSET ); //Blank                            
    665          	    //WriteTW8832( 0x07, 40 ); 
    666          	    //WriteTW8832( 0x06, 0x0f + FONT_WIN2_OSDADDR_OFFSET );                            
    667          	    //WriteTW8832( 0x07, 40 ); 
    668              }
    669          
    670              if(temp_C_dec3 != C_dec3){
    671          	    temp_C_dec3 = C_dec3 = TEMP_Value%10;
    672          	    WriteTW8832( 0x06, 0x06 + FONT_WIN2_OSDADDR_OFFSET );   // OSD Display Ram Addr
    673          	    WriteTW8832( 0x07, decimal_font[C_dec3][0]);                        // FontRam Addr
    674          	    WriteTW8832( 0x06, 0x07 + FONT_WIN2_OSDADDR_OFFSET );                            
    675          	    WriteTW8832( 0x07, decimal_font[C_dec3][1]); 
    676          	    WriteTW8832( 0x06, 0x0f + FONT_WIN2_OSDADDR_OFFSET );                            
    677          	    WriteTW8832( 0x07, decimal_font[C_dec3][2]); 
    678          	    WriteTW8832( 0x06, 0x10 + FONT_WIN2_OSDADDR_OFFSET );                            
    679          	    WriteTW8832( 0x07, decimal_font[C_dec3][3]);     
    680          		WriteTW8832( 0x06, 0x11 + FONT_WIN2_OSDADDR_OFFSET );                            
    681          	    WriteTW8832( 0x07, 40);   
    682          		WriteTW8832( 0x06, 0x08 + FONT_WIN2_OSDADDR_OFFSET );                            
    683          	    WriteTW8832( 0x07, 40);  
    684          	}
    685          
    686              //WriteTW8832( 0x04, 0x0C );// Display RAM Access Mode
    687          }
    688          #endif
    689          
    690          //=============================================================================
    691          //		void FontDisplay( void )
    692          //=============================================================================
    693          void FontDisplay( void )
    694          {
    695          	//u8	i;
    696          	
    697          	//--- Window1 Setting
    698              FontOsdWinScreen( 0,  88, 16, 8, 2, 0, 0 );
    699              FontOsdWinScreen( 1, 198, 430, 9, 2, 0, 0 );
    700              FontOsdWinScreen( 2, 628, 430, 9, 2, 0, 0 );
    701            
    702              
    703          	WriteTW8832( 0xff, 0x03 );
    704          	/*
    705          	WriteTW8832( 0x17, 0x00 );
    706          	WriteTW8832( 0x18, 0x00 );
    707          	WriteTW8832( 0x19, 0x00 );
    708          	WriteTW8832( 0x1A, 0x00 );
    709          	WriteTW8832( 0x1B, 0x00 );
    710          	WriteTW8832( 0x1C, 0x00 );
    711          	WriteTW8832( 0x1D, 0x00 );
    712          	WriteTW8832( 0x1E, 0x00 );
    713          	WriteTW8832( 0x1F, 0x00 );
    714              */
    715              WriteTW8832( 0x17, 0x00 );
    716              WriteTW8832( 0x27, 0x00 );
    717              WriteTW8832( 0x37, 0x00 );
    718              WriteTW8832( 0x1F, 0x00 );    // OSD Display RAM Start Addr of OSD Window 1
    719              WriteTW8832( 0x2F, 0x10 );    // OSD Display RAM Start Addr of OSD Window 2
    720              WriteTW8832( 0x3F, 0x22 );    // OSD Display RAM Start Addr of OSD Window 3
    721              
    722          	//--- Write Display RAM
    723          	WriteTW8832( 0x0b, 0xff ); // multi-font start
    724          
    725          	WriteTW8832( 0x00, 0x03 ); // bypass OSD/Font RAM
    726          	WriteTW8832( 0x04, 0x0c ); // Auto Inc.
    727          	WriteTW8832( 0x08, 0x0f ); // Attr Font & Background Color
    728          
    729          	TimeDelay_msec(3);
    730          	WriteTW8832( 0x11, 0x0f ); // Alpha Blending
    731          	TimeDelay_msec(3);
    732              WriteTW8832( 0x21, 0x0f ); // Alpha Blending
    733              TimeDelay_msec(3);
    734              WriteTW8832( 0x31, 0x0f ); // Alpha Blending
    735          	TimeDelay_msec(3);
    736          
    737          	WriteTW8832( 0x11, 0x0f ); // Alpha Blending
    738          	TimeDelay_msec(3);
    739              WriteTW8832( 0x21, 0x0f ); // Alpha Blending
    740              TimeDelay_msec(3);
    741              WriteTW8832( 0x31, 0x0f ); // Alpha Blending
    742          	TimeDelay_msec(3);
    743          }
    744          
    745          
    746          //=============================================================================
    747          //		void FontDemo( void )
    748          //=============================================================================
    749          void FontDemo( void )
    750          {
    751          	FontDMA();
    752          	FontDisplay();
    753          	FontOsdWinEnable( 0, 1 );
    754              FontOsdWinEnable( 1, 1 );
    755              FontOsdWinEnable( 2, 1 );
    756          }
    757          
    758          
    759          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FontDMA
         0   -> TimeDelay_msec
         8   -> WriteTW8832
       8   FontDemo
         8   -> FontDMA
         8   -> FontDisplay
         0   -> FontOsdWinEnable
         8   -> FontOsdWinEnable
      16   FontDisplay
        16   -> FontOsdWinScreen
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> WriteTW8832
      16   FontOsdWinAlpha
         0   -> WriteTW8832
        16   -> WriteTW8832
      16   FontOsdWinEnable
        16   -> ReadTW8832
         0   -> WriteTW8832
        16   -> WriteTW8832
      32   FontOsdWinScreen
        32   -> ReadTW8832
         0   -> WriteTW8832
        32   -> WriteTW8832
      40   SpiOsdAnimation
        40   -> ReadTW8832
         0   -> WriteTW8832
        40   -> WriteTW8832
      16   SpiOsdLoadLUT
         0   -> WriteTW8832
        16   -> WriteTW8832
      24   SpiOsdPixelAlpha
        24   -> ReadTW8832
         0   -> WriteTW8832
        24   -> WriteTW8832
       8   SpiOsdWaitVBlank
         8   -> ReadTW8832
         8   -> WriteTW8832
      24   SpiOsdWinAlpha
        24   -> ReadTW8832
         0   -> WriteTW8832
        24   -> WriteTW8832
      16   SpiOsdWinBufferMem
         0   -> WriteTW8832
        16   -> WriteTW8832
      16   SpiOsdWinBufferOffsetXY
         0   -> WriteTW8832
        16   -> WriteTW8832
      16   SpiOsdWinBufferSizeXY
         0   -> WriteTW8832
        16   -> WriteTW8832
      24   SpiOsdWinEnable
        24   -> ReadTW8832
         0   -> WriteTW8832
        24   -> WriteTW8832
      24   SpiOsdWinScreen
         0   -> WriteTW8832
        24   -> WriteTW8832


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       6  ??Subroutine2_0
      46  ?Subroutine0
       8  ?Subroutine1
     140  FontDMA
      36  FontDemo
     258  FontDisplay
      40  FontOsdWinAlpha
       4  FontOsdWinBase
      88  FontOsdWinEnable
     116  FontOsdWinScreen
      90  SpiOsdAnimation
     138  SpiOsdLoadLUT
      60  SpiOsdPixelAlpha
      38  SpiOsdWaitVBlank
      64  SpiOsdWinAlpha
      12  SpiOsdWinBase
          SPI_MODE_OFFSET
      52  SpiOsdWinBufferMem
      12  SpiOsdWinBufferOffsetXY
      14  SpiOsdWinBufferSizeXY
     132  SpiOsdWinEnable
     104  SpiOsdWinScreen

 
    12 bytes in section .data
 1 450 bytes in section .text
 
 1 450 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
