###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      21/Dec/2017  14:06:17 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pla #
#                    tform\TaeHa - ECS\SRC\CAN_Control.c                      #
#    Command line =  "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pl #
#                    atform\TaeHa - ECS\SRC\CAN_Control.c" -D                 #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN D:\GIT\WLF_MONITOR\ECS_MS12_02_W #
#                    LF_MONITOR_STM32_APP\Project\Debug\List\ -o              #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\ --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Platform\COMMON\INC\ -I                          #
#                    "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pr #
#                    oject\..\Platform\TaeHa - ECS\INC\" -I                   #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\ -I  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\ -Oh    #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\List\CAN_Control.lst                          #
#    Object file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\CAN_Control.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Platform\TaeHa - ECS\SRC\CAN_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    UART_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   UART_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          #pragma pack(1)
     26          struct st_CAN_Message
     27          {	
     28          	unsigned char Priority;
     29          	unsigned char Data_Page;
     30          	unsigned char PDU_Format;	
     31          	unsigned char PDU_Specific;		// 50
     32          	unsigned char Source_Address;	// 52
     33          };
     34          #pragma pack()
     35          
     36          
     37          #pragma pack(1)
     38          typedef struct
     39          {
     40          	u8 Control;
     41          	u16 TotMsgSize;
     42          	u8 TotPacketNum;
     43          	u8 Reserved;
     44          	u16 pgn_low;
     45          	u8 pgn_high;
     46          } TP_CM;
     47          #pragma pack()
     48          
     49          
     50          
     51          struct st_CAN_Message Identifier;
     52          TP_CM* tp_cm_bam;
     53          
     54          /* Private define ------------------------------------------------------------*/
     55          
     56          /*
     57          #define RX_MSG69		0x01
     58          #define RX_MSG69_M		0x02
     59          #define RX_MSG145		0x04
     60          #define RX_MSG161		0x08
     61          #define RX_MSG162		0x10
     62          #define RX_MSG163		0x20
     63          #define RX_MSG251		0x40
     64          #define RX_MSG252		0x80
     65          #define RX_MSG202		0x100
     66          #define RX_MSG253		0x200
     67          #define RX_MSG203		0x400
     68          
     69          #define RX_MSG239		0x800
     70          #define RX_MSG247		0x1000
     71          
     72          #define RX_MSG174		0x2000
     73          #define RX_MSG239_121	0x4000
     74          */
     75          #define RX_MSG11	0x01
     76          #define RX_MSG12	0x02
     77          #define RX_MSG21	0x04
     78          #define RX_MSG23	0x08
     79          #define RX_MSG61	0x10
     80          #define RX_MSG62	0x20
     81          #define RX_MSG101	0x40
     82          #define RX_MSG104	0x80
     83          #define RX_MSG105	0x100
     84          #define RX_MSG109	0x200
     85          #define RX_MSG121	0x400
     86          #define RX_MSG123	0x800
     87          #define RX_MSG201	0x1000
     88          #define RX_MSG203	0x2000
     89          	
     90          	
     91          #define RX_MSG47	0x4000
     92          	
     93          #define RX_MSG145	0x8000
     94          #define RX_MSG247	0x10000
     95          
     96          struct st_CAN_Message_Ring_Buffer_Tx_Single CAN_Message_Ring_Buffer_Tx_Single;
     97          struct st_CAN_Message_Ring_Buffer_Rx_Single CAN_Message_Ring_Buffer_Rx_Single;
     98          
     99          #define UART2_Tx_BUF_SIZE		17
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          u8 tmpBuf[8];
    103          
    104          u8 as_data_len;
    105          u8 tmpbuf_AS[13];
    106          u8 check_as_data_len = 0;
    107          
    108          
    109          u8 Uart2_RxMsg_Save_Data1[8];
    110          u8 Uart2_RxMsg_Save_Data2[8];
    111          u8 Uart2_RxMsg_AS_Phone_Data[8];
    112          u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    113          
    114          u8 Uart2_RxMsg_Single_46[8];
    115          u8 Uart2_RxMsg_Single_69[8];
    116          u8 Uart2_RxMsg_Multi_69[21];
    117          u8 Uart2_RxMsg_Single_160[8];
    118          u8 Uart2_RxMsg_Multi_161[16];
    119          u8 Uart2_RxMsg_Single_162[8];
    120          u8 Uart2_RxMsg_Single_163[8];
    121          u8 Uart2_RxMsg_Single_174[8];
    122          u8 Uart2_RxMsg_Single_251[8];
    123          u8 Uart2_RxMsg_Single_252[8];
    124          u8 Uart2_RxMsg_Single_253[8];
    125          u8 Uart2_RxMsg_Single_239[8];
    126          u8 Uart2_RxMsg_Single_247[8];
    127          u8 Uart2_RxMsg_Single_239_121[8];
    128          
    129          //61184
    130          u8 Uart2_RxMsg_Single_11[8];
    131          u8 Uart2_RxMsg_Single_12[8];
    132          u8 Uart2_RxMsg_Single_21[8];
    133          u8 Uart2_RxMsg_Multi_23[13];
    134          u8 Uart2_RxMsg_Single_61[8];
    135          u8 Uart2_RxMsg_Single_62[8];
    136          u8 Uart2_RxMsg_Single_101[8];
    137          u8 Uart2_RxMsg_Single_104[8];
    138          u8 Uart2_RxMsg_Single_105[8];
    139          u8 Uart2_RxMsg_Single_109[8];
    140          u8 Uart2_RxMsg_Single_121[8];
    141          u8 Uart2_RxMsg_Single_123[8];
    142          u8 Uart2_RxMsg_Single_201[8];
    143          u8 Uart2_RxMsg_Single_203[8];
    144          //0xFFxx
    145          u8 Uart2_RxMsg_Single_47[8];
    146          u8 Uart2_RxMsg_Multi_145[22];
    147          u8 Uart2_RxMsg_Single_247[8];
    148          
    149          
    150          
    151          u8 McuInfoData1[79];
    152          u8 MachineBasicInformation[78];
    153          u8 tmpMcuInfoData[78];
    154          
    155          
    156          u8 T_Packet_No = 0;
    157          u8 flag_skip_multi_packet = 0;
    158          u8 RecvMachInfo = 0;
    159          u8 TotalRequestCnt = 0;
    160          u8 CompareAsterisk = 0;
    161          
    162          u32 Flag_SerialRxMsg = 0;
    163          u8 tp_cm_bam_TotPacketNum = 0;
    164          
    165          extern u8 CanRecvCnt;
    166          extern u16 TotMsgSize;
    167          
    168          extern u16 Flag_1Sec_MachInfo;
    169          extern u8 MachInfoTotalPacketNum;
    170          extern u8 MoniInfoTotalPacketNum;
    171          extern u8 MachInfoSendCnt;
    172          extern u8 MoniInfoSendCnt;
    173          extern u8 MultiPacketSendOrder;
    174          extern u8 MoniInfoData[21];
    175          extern u8 DiffMachInfo;
    176          extern u8 SerialMsgRTC[16];
    177          extern u8 RTSFlag_61184;
    178          extern u8 CTSFlag_61184;
    179          extern u8 RecvTotalPacket_61184;
    180          extern u8 ACK_Multi_61184[8];
    181          extern u8 RMCU_CTSFlag_61184;
    182          extern u8 RMCU_RecvTotalPacket_61184;
    183          extern u8 RMCU_ACK_Multi_61184[8];
    184          
    185          
    186          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    187          extern Realy_Control rx_Realy_Control;
    188          extern EHCU_Status rx_EHCU_Status;
    189          
    190          extern unsigned long long SerialTXIndex;
    191          
    192          // ++, 141118 sys3215
    193          extern u8 Flag_ESL;
    194          extern u8 Seed_request;
    195          extern u8 Seed_received;
    196          extern u8 ESL_CTS_received;
    197          extern u8 ESL_ACK_received;
    198          extern u8 Password_Certification_Result;
    199          // -- , 141118 sys3215
    200          
    201          
    202          // ++, 150204 sys3215
    203          extern u8 Input_Key_Value,Key_Status;
    204          // --, 150204 sys3215
    205          
    206          /* Private function prototypes -----------------------------------------------*/
    207          /* Private functions ---------------------------------------------------------*/
    208          /**
    209            * @brief  CAN1, CAN2 Initialize 
    210            * @param  
    211            * @retval None
    212            */
    213          void CAN_COMInit(void)
    214          {
    215          	CAN_InitTypeDef        CAN_InitStructure;
    216          	CAN_InitTypeDef        CAN_InitStructure2;
    217          	CAN_FilterInitTypeDef  CAN_FilterInitStructure;
    218          	NVIC_InitTypeDef        NVIC_InitStructure;
    219          
    220          	DebugMsg_printf("++ CAN1, CAN2 Initialize START\r\n");
    221          
    222          	CAN_DeInit(CAN1);
    223          	CAN_DeInit(CAN2);
    224          	CAN_StructInit(&CAN_InitStructure);
    225          
    226          	CAN_InitStructure.CAN_TTCM = DISABLE;
    227          
    228          	//++, 150318 sys
    229          	CAN_InitStructure.CAN_ABOM = ENABLE;
    230          	//CAN_InitStructure.CAN_ABOM = DISABLE;
    231          	//--, 150318 sys
    232          	
    233          	CAN_InitStructure.CAN_AWUM = DISABLE;
    234          	CAN_InitStructure.CAN_NART = DISABLE;
    235          	CAN_InitStructure.CAN_RFLM = DISABLE;
    236          	CAN_InitStructure.CAN_TXFP = DISABLE;
    237          	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
    238          	CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    239          	CAN_InitStructure.CAN_BS1 = CAN_BS1_16tq;
    240          	CAN_InitStructure.CAN_BS2 = CAN_BS2_4tq;  
    241          	CAN_InitStructure.CAN_Prescaler = 4;   // 2:1M, 4:500k, 8:250k. 16:125k
    242          	CAN_Init(CAN1, &CAN_InitStructure);
    243          
    244          
    245          	CAN_InitStructure2.CAN_TTCM = DISABLE;
    246          	//CAN_InitStructure2.CAN_ABOM = ENABLE;
    247          	CAN_InitStructure2.CAN_ABOM = DISABLE;
    248          	CAN_InitStructure2.CAN_AWUM = DISABLE;
    249          	CAN_InitStructure2.CAN_NART = DISABLE;
    250          	CAN_InitStructure2.CAN_RFLM = DISABLE;
    251          	CAN_InitStructure2.CAN_TXFP = DISABLE;
    252          	CAN_InitStructure2.CAN_Mode = CAN_Mode_Normal;
    253          	CAN_InitStructure2.CAN_SJW = CAN_SJW_1tq;
    254          	CAN_InitStructure2.CAN_BS1 = CAN_BS1_16tq;
    255          	CAN_InitStructure2.CAN_BS2 = CAN_BS2_4tq;  
    256          	CAN_InitStructure2.CAN_Prescaler = 8;   // 2:1M, 4:500k, 8:250k. 16:125k
    257          	CAN_Init(CAN2, &CAN_InitStructure2);
    258          
    259          	//CAN_FilterInitStructure.CAN_FilterNumber = 0;
    260          	CAN_FilterInitStructure.CAN_FilterNumber = 0;
    261          	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    262          	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    263          	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
    264          	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
    265          	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
    266          	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
    267          	//CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
    268          	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    269          	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    270          	CAN_FilterInit(&CAN_FilterInitStructure);
    271          
    272          	// 부팅시 EEPROM Data를 Main CPU에 올리고 나서 ENABLE시킨다.
    273          	//CAN_ITConfig(CAN_IT_FMP0, ENABLE);		
    274          
    275          	//  Enable the CAN1_RX0_IRQn  Interrupt
    276          	NVIC_InitStructure.NVIC_IRQChannel                   = CAN1_RX0_IRQn;
    277          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    278          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    279          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    280          	NVIC_Init(&NVIC_InitStructure);
    281          
    282          
    283          	
    284          	//CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);		
    285          	
    286              DebugMsg_printf("++ CAN1, CAN2 Initialize END\r\n");
    287          }
    288          
    289          
    290          
    291          
    292          void WL9F_CAN_Variables_Init(void)
    293          {
    294          	check_as_data_len = 0;
    295          	Flag_SerialRxMsg = 0;
    296          
    297          	Identifier.Priority = 6;
    298          	Identifier.Data_Page = 0;
    299          	Identifier.PDU_Format = 255;	
    300          	Identifier.Source_Address = 40;		
    301          
    302          	flag_skip_multi_packet = 0;
    303          	TotMsgSize = 0;
    304          	RecvMachInfo = 0;
    305          	TotalRequestCnt = 0;
    306          	CompareAsterisk = 0;
    307          	CanRecvCnt = 0;
    308          
    309          
    310          
    311          	tp_cm_bam = (TP_CM*)&tmpBuf[0];
    312          	
    313          	memset((u8*)&Uart2_RxMsg_Save_Data1[0], 0xff, sizeof(Uart2_RxMsg_Save_Data1));
    314          	memset((u8*)&Uart2_RxMsg_Save_Data2[0], 0xff, sizeof(Uart2_RxMsg_Save_Data2));
    315          	memset((u8*)&Uart2_RxMsg_AS_Phone_Data[0], 0xff, sizeof(Uart2_RxMsg_AS_Phone_Data));
    316          	memset((u8*)&Uart2_RxMsg_Smk_Reg_Eli[0], 0xff, sizeof(Uart2_RxMsg_Smk_Reg_Eli));	
    317          	memset((u8*)&Uart2_RxMsg_Single_46[0], 0xff, sizeof(Uart2_RxMsg_Single_46));
    318          	memset((u8*)&Uart2_RxMsg_Single_69[0], 0xff, sizeof(Uart2_RxMsg_Single_69));
    319          	memset((u8*)&Uart2_RxMsg_Single_160[0], 0xff, sizeof(Uart2_RxMsg_Single_160));
    320          	memset((u8*)&Uart2_RxMsg_Single_162[0], 0xff, sizeof(Uart2_RxMsg_Single_162));
    321          	Uart2_RxMsg_Single_162[4] = 0;		// Monitor Switch Status
    322          	memset((u8*)&Uart2_RxMsg_Single_163[0], 0xff, sizeof(Uart2_RxMsg_Single_163));
    323          	memset((u8*)&Uart2_RxMsg_Single_174[0], 0xff, sizeof(Uart2_RxMsg_Single_174));
    324          	memset((u8*)&Uart2_RxMsg_Single_251[0], 0xff, sizeof(Uart2_RxMsg_Single_251));
    325          	memset((u8*)&Uart2_RxMsg_Single_252[0], 0xff, sizeof(Uart2_RxMsg_Single_252));
    326          	memset((u8*)&Uart2_RxMsg_Single_253[0], 0xff, sizeof(Uart2_RxMsg_Single_253));
    327          
    328          	memset((u8*)&Uart2_RxMsg_Single_239[0], 0xff, sizeof(Uart2_RxMsg_Single_239));
    329          
    330          	memset((u8*)&Uart2_RxMsg_Single_239_121[0], 0xff, sizeof(Uart2_RxMsg_Single_239_121));
    331          
    332          	
    333          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    334          
    335          	
    336          	memset((u8*)&Uart2_RxMsg_Multi_161[0], 0xff, sizeof(Uart2_RxMsg_Multi_161));
    337          	memset((u8*)&Uart2_RxMsg_Multi_69[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    338          
    339          
    340          
    341          
    342          	memset((u8*)&Uart2_RxMsg_Single_11[0], 0xff, sizeof(Uart2_RxMsg_Single_11));
    343          	memset((u8*)&Uart2_RxMsg_Single_12[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    344          	memset((u8*)&Uart2_RxMsg_Single_21[0], 0xff, sizeof(Uart2_RxMsg_Single_21));
    345          	memset((u8*)&Uart2_RxMsg_Multi_23[0], 0xff, sizeof(Uart2_RxMsg_Multi_23));
    346          	memset((u8*)&Uart2_RxMsg_Single_61[0], 0xff, sizeof(Uart2_RxMsg_Single_61));
    347          	memset((u8*)&Uart2_RxMsg_Single_62[0], 0xff, sizeof(Uart2_RxMsg_Single_62));
    348          	memset((u8*)&Uart2_RxMsg_Single_101[0], 0xff, sizeof(Uart2_RxMsg_Single_101));
    349          	memset((u8*)&Uart2_RxMsg_Single_104[0], 0xff, sizeof(Uart2_RxMsg_Single_104));
    350          	memset((u8*)&Uart2_RxMsg_Single_105[0], 0xff, sizeof(Uart2_RxMsg_Single_105));
    351          	memset((u8*)&Uart2_RxMsg_Single_109[0], 0xff, sizeof(Uart2_RxMsg_Single_109));
    352          	memset((u8*)&Uart2_RxMsg_Single_121[0], 0xff, sizeof(Uart2_RxMsg_Single_121));
    353          	memset((u8*)&Uart2_RxMsg_Single_123[0], 0xff, sizeof(Uart2_RxMsg_Single_123));
    354          	memset((u8*)&Uart2_RxMsg_Single_201[0], 0xff, sizeof(Uart2_RxMsg_Single_201));
    355          	memset((u8*)&Uart2_RxMsg_Single_203[0], 0xff, sizeof(Uart2_RxMsg_Single_203));
    356          	memset((u8*)&Uart2_RxMsg_Single_47[0], 0xff, sizeof(Uart2_RxMsg_Single_47));
    357          	memset((u8*)&Uart2_RxMsg_Multi_145[0], 0xff, sizeof(Uart2_RxMsg_Multi_145));
    358          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    359          
    360          
    361          
    362          	memset((u8*)&rx_Realy_Control, 0xff, sizeof(rx_Realy_Control));
    363          
    364          
    365          	memset((u8*)&SerialMsgRTC[0], 0xA5, 2);
    366          	memset((u8*)&SerialMsgRTC[2], 0xF0, 2);
    367          }
    368          
    369          u8 can_data_temp[255];
    370          u8 old_can_data;
    371          
    372          void Write_CAN_Single(struct st_CAN_Message1 Message)
    373          {
    374          	if(Message.PDU_Specific != 47)  // 비주기 테이터 
    375          	{
    376          		memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    377          		
    378          		if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    379          			CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    380          	}
    381          	else  // 주기 데이터  PS = 47
    382          	{
    383          		if(Message.PDU_Specific == 47)
    384          			memcpy(&Uart2_RxMsg_Single_47,&Message.Data,8);
    385          	}
    386          }
    387          
    388          void Write_UART_Single(void)
    389          {
    390          	static unsigned short Tx_Rountine_Count_UART;
    391          
    392          	/*
    393          	if((++Tx_Rountine_Count_UART%3)==0)
    394          	{
    395          		Tx_Rountine_Count_UART = 0;
    396          		if (CAN_Message_Ring_Buffer_Rx_Single.Head != CAN_Message_Ring_Buffer_Rx_Single.Tail)
    397          		{
    398          			int i;
    399          			u8 UARTTxMessage[17];
    400          			memcpy(&UARTTxMessage[0],(u8*)&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Tail],17);
    401          			for(i = 0; i < 17; i++)
    402          				USARTx_PutChar(2,(uint8_t)UARTTxMessage[i]);
    403          			//	USART_SendData(USART2, UARTTxMessage[i]);	 
    404           			
    405          			SerialTXIndex++;
    406          			if (++(CAN_Message_Ring_Buffer_Rx_Single.Tail) >= MAX_CAN_RX_DATA_SINGLE)
    407          				CAN_Message_Ring_Buffer_Rx_Single.Tail = 0;
    408          		}
    409          
    410          	}
    411          	*/
    412          
    413          	if((++Tx_Rountine_Count_UART%5)==0)
    414          	{
    415          		Tx_Rountine_Count_UART = 0;
    416          		if (CAN_Message_Ring_Buffer_Rx_Single.Head != CAN_Message_Ring_Buffer_Rx_Single.Tail)
    417          		{
    418          			int i;
    419          			//u8 UARTTxMessage[17];
    420          
    421          			DMA_UART_SendFrame(&Uart2_SerialTxMsg[0],(u8*)&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Tail],17);
    422          			
    423          			SerialTXIndex++;
    424          			if (++(CAN_Message_Ring_Buffer_Rx_Single.Tail) >= MAX_CAN_RX_DATA_SINGLE)
    425          				CAN_Message_Ring_Buffer_Rx_Single.Tail = 0;
    426          		}
    427          
    428          	}
    429          
    430          }
    431          
    432          
    433          void SetCanID(u8 PF, u8 PS, u8 Priority)
    434          {
    435          	if(PF != 0)
    436          		Identifier.PDU_Format = PF;	
    437          
    438          	if(PS != 0)
    439          		Identifier.PDU_Specific = PS;	
    440          
    441          	if(Priority != 0)
    442          		Identifier.Priority = Priority;	
    443          }
    444          
    445          void CAN_TX_Data(u8* Data)
    446          {
    447          	//u8 TransmitMailbox;
    448          	CanTxMsg TxMessage;
    449          	
    450          	TxMessage.ExtId=((unsigned long)(Identifier.Priority) << 26)+((unsigned long)(Identifier.Data_Page) << 24)+((unsigned long)(Identifier.PDU_Format) << 16)
    451          				                      + ((unsigned long)(Identifier.PDU_Specific) << 8) + ((unsigned long)(Identifier.Source_Address) << 0) ;
    452          			
    453          	TxMessage.IDE = CAN_ID_EXT;
    454          	TxMessage.RTR = CAN_RTR_DATA;
    455          	TxMessage.DLC = 8;
    456          
    457          	memcpy((u8*)&TxMessage.Data[0], (u8*)&Data[0], 8);
    458          
    459          	
    460          	CAN_Transmit(CAN1,&TxMessage);
    461          }
    462          u8 can_status;
    463          u8 can_status_buf[100];
    464          u8 can_tx_error_count;
    465          
    466          void CAN_TX(void)
    467          {
    468          	CanTxMsg TxMessage;
    469          	unsigned char i;
    470          	static unsigned short Tx_Rountine_Count_CAN;
    471          
    472          	
    473          	if((++Tx_Rountine_Count_CAN%2)==0)
    474          	{
    475          		if (CAN_Message_Ring_Buffer_Tx_Single.Head != CAN_Message_Ring_Buffer_Tx_Single.Tail)
    476          		{
    477          			
    478          			TxMessage.ExtId = (CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Priority<<24)+
    479          							(CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].PDU_Format<<16)+
    480          							(CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].PDU_Specific<<8)+
    481          							CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Source_Address;
    482          			TxMessage.IDE = CAN_ID_EXT;
    483          			TxMessage.RTR = CAN_RTR_DATA;
    484          			TxMessage.DLC = 8;
    485          
    486          			
    487          			for (i = 0; i < 8; i++)
    488          			{
    489          				TxMessage.Data[i] = CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Data[i];
    490          			}
    491          
    492          			can_status = CAN_Transmit(CAN1,&TxMessage);
    493          			
    494          
    495          							
    496          			if(can_status !=CAN_TxStatus_NoMailBox)
    497          			{
    498          				if (++(CAN_Message_Ring_Buffer_Tx_Single.Tail) >= MAX_CAN_TX_DATA_SINGLE)
    499          					CAN_Message_Ring_Buffer_Tx_Single.Tail = 0;
    500          			}
    501          			else
    502          			{
    503          				can_status_buf[can_tx_error_count++] = can_status;
    504          				if(can_tx_error_count>100)	can_tx_error_count=0;
    505          			}
    506          
    507          
    508          		}
    509          		
    510          	}
    511          
    512          
    513          	 //if(Tx_Rountine_Count_CAN++ > 500)
    514          	 //{
    515          	//		Tx_Rountine_Count_CAN = 0;
    516          	 //}
    517                 	
    518          }
    519          
    520          void CAN_RX(CanRxMsg RxMessage)
    521          {
    522          	
    523          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_STX = 0x02;
    524          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_ID = 0xF5;
    525          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_LEN = 0x08;
    526          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_SAVE_DATA = 0x00;
    527          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_ETX = 0x03;
    528          
    529          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].Rx_ExtID = RxMessage.ExtId;
    530          
    531          	memcpy(&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0],&RxMessage.Data[0],8);
    532          		
    533          	
    534          
    535          
    536          	// ++, 141118 sys3215
    537          	if(Flag_ESL==1)
    538          	{
    539          		if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].Rx_ExtID == 0x18EF2847)
    540          		{
    541          			if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0]==0x16) // seed received
    542          			{
    543          				Seed_received=1;
    544          			}
    545          			else if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0]==0x18) // password valid status
    546          			{
    547          				if((CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[1] & 0x01)==0x01)
    548          					Password_Certification_Result=1;
    549          				else
    550          					Password_Certification_Result=0;
    551          			}
    552          		}
    553          		if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].Rx_ExtID == 0x1CEC2847)
    554          		{
    555          			if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0]==0x11) // CTS
    556          			{
    557          				ESL_CTS_received=1;
    558          			}
    559          			else if(CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0]==0x13) // ACK
    560          			{
    561          				ESL_ACK_received=1;
    562          			}
    563          		}
    564          	}
    565                  
    566          	if (++(CAN_Message_Ring_Buffer_Rx_Single.Head) >= MAX_CAN_RX_DATA_SINGLE)
    567          		CAN_Message_Ring_Buffer_Rx_Single.Head = 0;
    568          // --, 141118 sys3215
    569          }
    570          void MonitorStatus_CAN_TX(void)
    571          {
    572          	struct st_CAN_Message1 Send_Message;
    573          
    574          
    575          	Send_Message.Priority = 0x18;
    576          	Send_Message.PDU_Format = 0xFF;		// 255
    577          	Send_Message.PDU_Specific = 0x2F;	// 47
    578          	Send_Message.Source_Address = 0x28;
    579          	memcpy(&Send_Message.Data,&Uart2_RxMsg_Single_47,8);
    580          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Send_Message,12);
    581          
    582          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    583          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    584          	//if( (Uart2_RxMsg_Single_47[4] & 0x10 ) == 0x10 )
    585          	//{
    586          	//	if( WL9FM_BUZZER.Status == 0 )
    587          	//		Uart2_RxMsg_Single_47[4] = Uart2_RxMsg_Single_47[4] & 0xCF;
    588          	//}
    589          }
    590          
    591          // ++,141118 sys3215
    592          void Seed_Request_CAN_TX(void)
    593          {
    594          	struct st_CAN_Message1 Send_Message;
    595          
    596          	Send_Message.Priority = 0x18;
    597          	Send_Message.PDU_Format = 0xEF;		
    598          	Send_Message.PDU_Specific = 0x47;	
    599          	Send_Message.Source_Address = 0x28;
    600          	memset(&Send_Message.Data,0xff,8);
    601          	Send_Message.Data[0]=21;
    602          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Send_Message,12);
    603          
    604          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    605          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    606          }
    607          
    608          void SendMultiPacketRTS_ESL(void)
    609          {
    610          	struct st_CAN_Message1 Message;
    611          	
    612          	u8 _Temp[8];
    613          
    614          	Message.Priority = 0x1c;
    615          	Message.PDU_Format = 0xEC;
    616          	Message.PDU_Specific = 0x47;
    617          	Message.Source_Address = 0x28;
    618          
    619          	_Temp[0] = 0x10;
    620          	_Temp[1] = 0x0d;
    621          	_Temp[2] = 0;
    622          	_Temp[3] = 2;
    623          	_Temp[4] = 0xFF;
    624          	_Temp[5] = 0;
    625          	_Temp[6] = 0xef;
    626          	_Temp[7] = 0x00;
    627          
    628          	memcpy((void *)&Message.Data[0],(void *)&_Temp, sizeof(_Temp));
    629          
    630          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    631          
    632          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    633          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    634          	
    635          }
    636          
    637          // ++, 150204 sys3215
    638          void CAN_TX_Key_Status(void)
    639          {
    640          	struct st_CAN_Message1 Message;
    641          	
    642          	u8 _Temp[8];
    643          
    644          	Message.Priority = 0x18;
    645          	Message.PDU_Format = 0xEF;
    646          	Message.PDU_Specific = 0x47;
    647          	Message.Source_Address = 0x28;
    648          
    649          	_Temp[0] = 0x01;
    650          	_Temp[1] = 0xFF;
    651          	_Temp[2] = Key_Status;
    652          	_Temp[3] = 0xFF;
    653          	_Temp[4] = 0xFF;
    654          	_Temp[5] = 0xFF;
    655          	_Temp[6] = 0xFF;
    656          	_Temp[7] = 0xFF;
    657          
    658          	if(Input_Key_Value)
    659          	{
    660          		memcpy((void *)&Message.Data[0],(void *)&_Temp, sizeof(_Temp));
    661          
    662          		memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    663          
    664          		if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    665          			CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    666          	}
    667          }
    668          // --, 150204 sys3215
    669          
    670          
    671          void SendMultiPacketData_ESL(void)
    672          {
    673          	struct st_CAN_Message1 Message;
    674          	
    675          	u8 _Temp[8];
    676          
    677          	Message.Priority = 0x1c;
    678          	Message.PDU_Format = 0xEB;
    679          	Message.PDU_Specific = 0x47;
    680          	Message.Source_Address = 0x28;
    681          
    682          	_Temp[0] = 0x01;
    683          	_Temp[1] = 0x17;
    684          	_Temp[2] = 0xf8;
    685          	_Temp[3] = 0xff;
    686          	_Temp[4] = 0xFF;
    687          	_Temp[5] = 0xff;
    688          	_Temp[6] = 0xff;
    689          	_Temp[7] = 0xff;
    690          
    691          	memcpy((void *)&Message.Data[0],(void *)&_Temp, sizeof(_Temp));
    692          
    693          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    694          
    695          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    696          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    697          
    698          	_Temp[0] = 0x02;
    699          	_Temp[1] = 0xff;
    700          	_Temp[2] = 0xff;
    701          	_Temp[3] = 0xff;
    702          	_Temp[4] = 0xFF;
    703          	_Temp[5] = 0xff;
    704          	_Temp[6] = 0xff;
    705          	_Temp[7] = 0xff;
    706          
    707          	memcpy((void *)&Message.Data[0],(void *)&_Temp, sizeof(_Temp));
    708          
    709          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    710          
    711          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    712          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    713          	
    714          }
    715          // --,141118 sys3215
    716          
    717          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   CAN_COMInit
        56   -> CAN_DeInit
        56   -> CAN_FilterInit
        56   -> CAN_Init
        56   -> CAN_StructInit
        56   -> NVIC_Init
      24   CAN_RX
        24   -> __aeabi_memcpy
      32   CAN_TX
        32   -> CAN_Transmit
      24   CAN_TX_Data
        24   -> CAN_Transmit
        24   -> __aeabi_memcpy
      28   CAN_TX_Key_Status
        28   -> __aeabi_memcpy
      20   MonitorStatus_CAN_TX
        20   -> __aeabi_memcpy
      20   Seed_Request_CAN_TX
        20   -> __aeabi_memcpy
        20   -> __aeabi_memset4
      36   SendMultiPacketData_ESL
        36   -> __aeabi_memcpy
      28   SendMultiPacketRTS_ESL
        28   -> __aeabi_memcpy
       0   SetCanID
      16   WL9F_CAN_Variables_Init
         0   -> __aeabi_memset
        16   -> __aeabi_memset
        16   -> __aeabi_memset4
        16   -> memset
      20   Write_CAN_Single
        20   -> __aeabi_memcpy
       8   Write_UART_Single
         8   -> DMA_UART_SendFrame
       8   memset
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       6  ?Subroutine0
     180  CAN_COMInit
    4340  CAN_Message_Ring_Buffer_Rx_Single
    3072  CAN_Message_Ring_Buffer_Tx_Single
          Uart2_RxMsg_Single_47
     212  CAN_RX
     156  CAN_TX
      80  CAN_TX_Data
     118  CAN_TX_Key_Status
     344  Identifier
          Uart2_RxMsg_Single_162
          check_as_data_len
          flag_skip_multi_packet
          RecvMachInfo
          TotalRequestCnt
          CompareAsterisk
          tp_cm_bam
          Flag_SerialRxMsg
          tmpBuf
          Uart2_RxMsg_Save_Data1
          Uart2_RxMsg_Save_Data2
          Uart2_RxMsg_AS_Phone_Data
          Uart2_RxMsg_Smk_Reg_Eli
          Uart2_RxMsg_Single_46
          Uart2_RxMsg_Single_69
          Uart2_RxMsg_Multi_69
          Uart2_RxMsg_Single_160
          Uart2_RxMsg_Multi_161
          Uart2_RxMsg_Single_163
          Uart2_RxMsg_Single_174
          Uart2_RxMsg_Single_251
          Uart2_RxMsg_Single_252
          Uart2_RxMsg_Single_253
          Uart2_RxMsg_Single_239
          Uart2_RxMsg_Single_239_121
          Uart2_RxMsg_Single_11
          Uart2_RxMsg_Single_12
          Uart2_RxMsg_Single_21
          Uart2_RxMsg_Multi_23
          Uart2_RxMsg_Single_61
          Uart2_RxMsg_Single_62
          Uart2_RxMsg_Single_101
          Uart2_RxMsg_Single_104
          Uart2_RxMsg_Single_105
          Uart2_RxMsg_Single_109
          Uart2_RxMsg_Single_121
          Uart2_RxMsg_Single_123
          Uart2_RxMsg_Single_201
          Uart2_RxMsg_Single_203
          Uart2_RxMsg_Multi_145
          Uart2_RxMsg_Single_247
      80  MachineBasicInformation
      80  McuInfoData1
      72  MonitorStatus_CAN_TX
      80  Seed_Request_CAN_TX
     170  SendMultiPacketData_ESL
     120  SendMultiPacketRTS_ESL
      26  SetCanID
       1  T_Packet_No
       2  Tx_Rountine_Count_UART
     520  WL9F_CAN_Variables_Init
      64  Write_CAN_Single
      98  Write_UART_Single
       1  as_data_len
     256  can_data_temp
     106  can_status
          can_tx_error_count
          can_status_buf
          Tx_Rountine_Count_CAN
      20  memset
       1  old_can_data
      80  tmpMcuInfoData
      16  tmpbuf_AS
       1  tp_cm_bam_TotPacketNum

 
 8 380 bytes in section .bss
 2 014 bytes in section .text
 
 1 994 bytes of CODE memory (+ 20 bytes shared)
 8 380 bytes of DATA memory

Errors: none
Warnings: 1
