###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      30/Apr/2014  15:34:16 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\CAN_Control.c                                    #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa -         #
#                    ECS\SRC\CAN_Control.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\ -o    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\        #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\CAN_Co #
#                    ntrol.lst                                                #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\CAN_Con #
#                    trol.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Platform\TaeHa - ECS\SRC\CAN_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    UART_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   UART_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          #pragma pack(1)
     26          struct st_CAN_Message
     27          {	
     28          	unsigned char Priority;
     29          	unsigned char Data_Page;
     30          	unsigned char PDU_Format;	
     31          	unsigned char PDU_Specific;		// 50
     32          	unsigned char Source_Address;	// 52
     33          };
     34          #pragma pack()
     35          
     36          
     37          #pragma pack(1)
     38          typedef struct
     39          {
     40          	u8 Control;
     41          	u16 TotMsgSize;
     42          	u8 TotPacketNum;
     43          	u8 Reserved;
     44          	u16 pgn_low;
     45          	u8 pgn_high;
     46          } TP_CM;
     47          #pragma pack()
     48          
     49          
     50          
     51          struct st_CAN_Message Identifier;
     52          TP_CM* tp_cm_bam;
     53          
     54          /* Private define ------------------------------------------------------------*/
     55          
     56          /*
     57          #define RX_MSG69		0x01
     58          #define RX_MSG69_M		0x02
     59          #define RX_MSG145		0x04
     60          #define RX_MSG161		0x08
     61          #define RX_MSG162		0x10
     62          #define RX_MSG163		0x20
     63          #define RX_MSG251		0x40
     64          #define RX_MSG252		0x80
     65          #define RX_MSG202		0x100
     66          #define RX_MSG253		0x200
     67          #define RX_MSG203		0x400
     68          
     69          #define RX_MSG239		0x800
     70          #define RX_MSG247		0x1000
     71          
     72          #define RX_MSG174		0x2000
     73          #define RX_MSG239_121	0x4000
     74          */
     75          #define RX_MSG11	0x01
     76          #define RX_MSG12	0x02
     77          #define RX_MSG21	0x04
     78          #define RX_MSG23	0x08
     79          #define RX_MSG61	0x10
     80          #define RX_MSG62	0x20
     81          #define RX_MSG101	0x40
     82          #define RX_MSG104	0x80
     83          #define RX_MSG105	0x100
     84          #define RX_MSG109	0x200
     85          #define RX_MSG121	0x400
     86          #define RX_MSG123	0x800
     87          #define RX_MSG201	0x1000
     88          #define RX_MSG203	0x2000
     89          	
     90          	
     91          #define RX_MSG47	0x4000
     92          	
     93          #define RX_MSG145	0x8000
     94          #define RX_MSG247	0x10000
     95          
     96          
     97          
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          u8 tmpBuf[8];
    101          
    102          u8 as_data_len;
    103          u8 tmpbuf_AS[13];
    104          u8 check_as_data_len = 0;
    105          
    106          
    107          u8 Uart2_RxMsg_Save_Data1[8];
    108          u8 Uart2_RxMsg_Save_Data2[8];
    109          u8 Uart2_RxMsg_AS_Phone_Data[8];
    110          u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    111          
    112          u8 Uart2_RxMsg_Single_46[8];
    113          u8 Uart2_RxMsg_Single_69[8];
    114          u8 Uart2_RxMsg_Multi_69[21];
    115          u8 Uart2_RxMsg_Single_160[8];
    116          u8 Uart2_RxMsg_Multi_161[16];
    117          u8 Uart2_RxMsg_Single_162[8];
    118          u8 Uart2_RxMsg_Single_163[8];
    119          u8 Uart2_RxMsg_Single_174[8];
    120          u8 Uart2_RxMsg_Single_251[8];
    121          u8 Uart2_RxMsg_Single_252[8];
    122          u8 Uart2_RxMsg_Single_253[8];
    123          u8 Uart2_RxMsg_Single_239[8];
    124          u8 Uart2_RxMsg_Single_247[8];
    125          u8 Uart2_RxMsg_Single_239_121[8];
    126          
    127          //61184
    128          u8 Uart2_RxMsg_Single_11[8];
    129          u8 Uart2_RxMsg_Single_12[8];
    130          u8 Uart2_RxMsg_Single_21[8];
    131          u8 Uart2_RxMsg_Multi_23[13];
    132          u8 Uart2_RxMsg_Single_61[8];
    133          u8 Uart2_RxMsg_Single_62[8];
    134          u8 Uart2_RxMsg_Single_101[8];
    135          u8 Uart2_RxMsg_Single_104[8];
    136          u8 Uart2_RxMsg_Single_105[8];
    137          u8 Uart2_RxMsg_Single_109[8];
    138          u8 Uart2_RxMsg_Single_121[8];
    139          u8 Uart2_RxMsg_Single_123[8];
    140          u8 Uart2_RxMsg_Single_201[8];
    141          u8 Uart2_RxMsg_Single_203[8];
    142          //0xFFxx
    143          u8 Uart2_RxMsg_Single_47[8];
    144          u8 Uart2_RxMsg_Multi_145[13];
    145          u8 Uart2_RxMsg_Single_247[8];
    146          
    147          
    148          
    149          u8 McuInfoData1[79];
    150          u8 MachineBasicInformation[78];
    151          u8 tmpMcuInfoData[78];
    152          
    153          
    154          u8 T_Packet_No = 0;
    155          u8 flag_skip_multi_packet = 0;
    156          u8 RecvMachInfo = 0;
    157          u8 TotalRequestCnt = 0;
    158          u8 CompareAsterisk = 0;
    159          
    160          u32 Flag_SerialRxMsg = 0;
    161          u8 tp_cm_bam_TotPacketNum = 0;
    162          
    163          extern u8 CanRecvCnt;
    164          extern u16 TotMsgSize;
    165          
    166          extern u16 Flag_1Sec_MachInfo;
    167          extern u16 Flag_1Sec_MoniInfo;
    168          extern u8 MachInfoTotalPacketNum;
    169          extern u8 MoniInfoTotalPacketNum;
    170          extern u8 MachInfoSendCnt;
    171          extern u8 MoniInfoSendCnt;
    172          extern u8 MultiPacketSendOrder;
    173          extern u8 MoniInfoData[21];
    174          extern u8 DiffMachInfo;
    175          extern u8 SerialMsgRTC[16];
    176          extern u8 RTSFlag_61184;
    177          extern u8 CTSFlag_61184;
    178          extern u8 RecvTotalPacket_61184;
    179          extern u8 ACK_Multi_61184[8];
    180          
    181          
    182          extern Realy_Control rx_Realy_Control;
    183          extern EHCU_Status rx_EHCU_Status;
    184          /* Private function prototypes -----------------------------------------------*/
    185          /* Private functions ---------------------------------------------------------*/
    186          /**
    187            * @brief  CAN1, CAN2 Initialize 
    188            * @param  
    189            * @retval None
    190            */
    191          void CAN_COMInit(void)
    192          {
    193          	CAN_InitTypeDef        CAN_InitStructure;
    194          	CAN_FilterInitTypeDef  CAN_FilterInitStructure;
    195          	NVIC_InitTypeDef        NVIC_InitStructure;
    196          
    197          	DebugMsg_printf("++ CAN1, CAN2 Initialize START\r\n");
    198          
    199          	CAN_DeInit(CAN1);
    200          	CAN_DeInit(CAN2);
    201          	CAN_StructInit(&CAN_InitStructure);
    202          
    203          	CAN_InitStructure.CAN_TTCM = DISABLE;
    204          	//CAN_InitStructure.CAN_ABOM = ENABLE;
    205          	CAN_InitStructure.CAN_ABOM = DISABLE;
    206          	CAN_InitStructure.CAN_AWUM = DISABLE;
    207          	CAN_InitStructure.CAN_NART = DISABLE;
    208          	CAN_InitStructure.CAN_RFLM = DISABLE;
    209          	CAN_InitStructure.CAN_TXFP = DISABLE;
    210          	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
    211          	CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    212          	CAN_InitStructure.CAN_BS1 = CAN_BS1_14tq;
    213          	CAN_InitStructure.CAN_BS2 = CAN_BS2_6tq;  
    214          	CAN_InitStructure.CAN_Prescaler = 8;   // 2:1M, 4:500k, 8:250k. 16:125k
    215          	CAN_Init(CAN1, &CAN_InitStructure);
    216          	CAN_Init(CAN2, &CAN_InitStructure);
    217          
    218          	//CAN_FilterInitStructure.CAN_FilterNumber = 0;
    219          	CAN_FilterInitStructure.CAN_FilterNumber = 0;
    220          	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    221          	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    222          	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
    223          	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
    224          	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
    225          	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
    226          	//CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
    227          	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    228          	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    229          	CAN_FilterInit(&CAN_FilterInitStructure);
    230          
    231          	// 부팅시 EEPROM Data를 Main CPU에 올리고 나서 ENABLE시킨다.
    232          	//CAN_ITConfig(CAN_IT_FMP0, ENABLE);		
    233          
    234          	//  Enable the CAN1_RX0_IRQn  Interrupt
    235          	NVIC_InitStructure.NVIC_IRQChannel                   = CAN1_RX0_IRQn;
    236          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    237          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    238          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    239          	NVIC_Init(&NVIC_InitStructure);
    240          
    241          
    242          	
    243          	//CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);		
    244          	
    245              DebugMsg_printf("++ CAN1, CAN2 Initialize END\r\n");
    246          }
    247          
    248          
    249          
    250          
    251          void WL9F_CAN_Variables_Init(void)
    252          {
    253          	check_as_data_len = 0;
    254          	Flag_SerialRxMsg = 0;
    255          
    256          	Identifier.Priority = 6;
    257          	Identifier.Data_Page = 0;
    258          	Identifier.PDU_Format = 255;	
    259          	Identifier.Source_Address = 40;		
    260          
    261          	flag_skip_multi_packet = 0;
    262          	TotMsgSize = 0;
    263          	RecvMachInfo = 0;
    264          	TotalRequestCnt = 0;
    265          	CompareAsterisk = 0;
    266          	CanRecvCnt = 0;
    267          
    268          
    269          
    270          	tp_cm_bam = (TP_CM*)&tmpBuf[0];
    271          	
    272          	memset((u8*)&Uart2_RxMsg_Save_Data1[0], 0xff, sizeof(Uart2_RxMsg_Save_Data1));
    273          	memset((u8*)&Uart2_RxMsg_Save_Data2[0], 0xff, sizeof(Uart2_RxMsg_Save_Data2));
    274          	memset((u8*)&Uart2_RxMsg_AS_Phone_Data[0], 0xff, sizeof(Uart2_RxMsg_AS_Phone_Data));
    275          	memset((u8*)&Uart2_RxMsg_Smk_Reg_Eli[0], 0xff, sizeof(Uart2_RxMsg_Smk_Reg_Eli));	
    276          	memset((u8*)&Uart2_RxMsg_Single_46[0], 0xff, sizeof(Uart2_RxMsg_Single_46));
    277          	memset((u8*)&Uart2_RxMsg_Single_69[0], 0xff, sizeof(Uart2_RxMsg_Single_69));
    278          	memset((u8*)&Uart2_RxMsg_Single_160[0], 0xff, sizeof(Uart2_RxMsg_Single_160));
    279          	memset((u8*)&Uart2_RxMsg_Single_162[0], 0xff, sizeof(Uart2_RxMsg_Single_162));
    280          	Uart2_RxMsg_Single_162[4] = 0;		// Monitor Switch Status
    281          	memset((u8*)&Uart2_RxMsg_Single_163[0], 0xff, sizeof(Uart2_RxMsg_Single_163));
    282          	memset((u8*)&Uart2_RxMsg_Single_174[0], 0xff, sizeof(Uart2_RxMsg_Single_174));
    283          	memset((u8*)&Uart2_RxMsg_Single_251[0], 0xff, sizeof(Uart2_RxMsg_Single_251));
    284          	memset((u8*)&Uart2_RxMsg_Single_252[0], 0xff, sizeof(Uart2_RxMsg_Single_252));
    285          	memset((u8*)&Uart2_RxMsg_Single_253[0], 0xff, sizeof(Uart2_RxMsg_Single_253));
    286          
    287          	memset((u8*)&Uart2_RxMsg_Single_239[0], 0xff, sizeof(Uart2_RxMsg_Single_239));
    288          
    289          	memset((u8*)&Uart2_RxMsg_Single_239_121[0], 0xff, sizeof(Uart2_RxMsg_Single_239_121));
    290          
    291          	
    292          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    293          
    294          	
    295          	memset((u8*)&Uart2_RxMsg_Multi_161[0], 0xff, sizeof(Uart2_RxMsg_Multi_161));
    296          	memset((u8*)&Uart2_RxMsg_Multi_69[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    297          
    298          
    299          
    300          
    301          	memset((u8*)&Uart2_RxMsg_Single_11[0], 0xff, sizeof(Uart2_RxMsg_Single_11));
    302          	memset((u8*)&Uart2_RxMsg_Single_12[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    303          	memset((u8*)&Uart2_RxMsg_Single_21[0], 0xff, sizeof(Uart2_RxMsg_Single_21));
    304          	memset((u8*)&Uart2_RxMsg_Multi_23[0], 0xff, sizeof(Uart2_RxMsg_Multi_23));
    305          	memset((u8*)&Uart2_RxMsg_Single_61[0], 0xff, sizeof(Uart2_RxMsg_Single_61));
    306          	memset((u8*)&Uart2_RxMsg_Single_62[0], 0xff, sizeof(Uart2_RxMsg_Single_62));
    307          	memset((u8*)&Uart2_RxMsg_Single_101[0], 0xff, sizeof(Uart2_RxMsg_Single_101));
    308          	memset((u8*)&Uart2_RxMsg_Single_104[0], 0xff, sizeof(Uart2_RxMsg_Single_104));
    309          	memset((u8*)&Uart2_RxMsg_Single_105[0], 0xff, sizeof(Uart2_RxMsg_Single_105));
    310          	memset((u8*)&Uart2_RxMsg_Single_109[0], 0xff, sizeof(Uart2_RxMsg_Single_109));
    311          	memset((u8*)&Uart2_RxMsg_Single_121[0], 0xff, sizeof(Uart2_RxMsg_Single_121));
    312          	memset((u8*)&Uart2_RxMsg_Single_123[0], 0xff, sizeof(Uart2_RxMsg_Single_123));
    313          	memset((u8*)&Uart2_RxMsg_Single_201[0], 0xff, sizeof(Uart2_RxMsg_Single_201));
    314          	memset((u8*)&Uart2_RxMsg_Single_203[0], 0xff, sizeof(Uart2_RxMsg_Single_203));
    315          	memset((u8*)&Uart2_RxMsg_Single_47[0], 0xff, sizeof(Uart2_RxMsg_Single_47));
    316          	memset((u8*)&Uart2_RxMsg_Multi_145[0], 0xff, sizeof(Uart2_RxMsg_Multi_145));
    317          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    318          
    319          
    320          
    321          	memset((u8*)&rx_Realy_Control, 0xff, sizeof(rx_Realy_Control));
    322          
    323          
    324          	memset((u8*)&SerialMsgRTC[0], 0xA5, 2);
    325          	memset((u8*)&SerialMsgRTC[2], 0xF0, 2);
    326          }
    327          
    328          void SetCanID(u8 PF, u8 PS, u8 Priority)
    329          {
    330          	if(PF != 0)
    331          		Identifier.PDU_Format = PF;	
    332          
    333          	if(PS != 0)
    334          		Identifier.PDU_Specific = PS;	
    335          
    336          	if(Priority != 0)
    337          		Identifier.Priority = Priority;	
    338          }
    339          
    340          void CAN_TX_Data(u8* Data)
    341          {
    342          	//u8 TransmitMailbox;
    343          	CanTxMsg TxMessage;
    344          	
    345          	TxMessage.ExtId=((unsigned long)(Identifier.Priority) << 26)+((unsigned long)(Identifier.Data_Page) << 24)+((unsigned long)(Identifier.PDU_Format) << 16)
    346          				                      + ((unsigned long)(Identifier.PDU_Specific) << 8) + ((unsigned long)(Identifier.Source_Address) << 0) ;
    347          			
    348          	TxMessage.IDE = CAN_ID_EXT;
    349          	TxMessage.RTR = CAN_RTR_DATA;
    350          	TxMessage.DLC = 8;
    351          
    352          	memcpy((u8*)&TxMessage.Data[0], (u8*)&Data[0], 8);
    353          
    354          	
    355          	CAN_Transmit(CAN1,&TxMessage);
    356          }
    357          
    358          void SendTP_CM_BAM_MultiPacket_161(void)
    359          {
    360          	// TP.CM_BAM
    361          	SetCanID(236, 255, 7);
    362          
    363          	tp_cm_bam->Control = 32;	// Control Byte
    364          	
    365          	tp_cm_bam->TotMsgSize = 10;
    366          
    367          	tp_cm_bam->TotPacketNum = 2;
    368          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    369          
    370          	tp_cm_bam->Reserved = 0xff;
    371          
    372          	tp_cm_bam->pgn_low = 0xFFA1;
    373          	tp_cm_bam->pgn_high = 0;
    374          
    375          	CAN_TX_Data(&tmpBuf[0]);
    376          }
    377          
    378          void SendMultiPacketData_161(u8 packet_no)
    379          {
    380          	u8 tmpBuf1[8];
    381          	
    382          	SetCanID(235, 255, 7);
    383          
    384          	tmpBuf1[0] = packet_no;
    385          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_161[(packet_no-1)*7], 7);
    386          	CAN_TX_Data(&tmpBuf1[0]);
    387          }
    388          
    389          void SendTP_CM_BAM_MultiPacket_61184_23(void)
    390          {
    391          	// TP.CM_BAM
    392          	SetCanID(236, 71, 7);
    393          
    394          	tp_cm_bam->Control = 16;	// Control Byte
    395          	
    396          	tp_cm_bam->TotMsgSize = 13;
    397          
    398          	tp_cm_bam->TotPacketNum = 2;
    399          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    400          
    401          	tp_cm_bam->Reserved = 0xff;
    402          
    403          	tp_cm_bam->pgn_low = 0xEF00;
    404          	tp_cm_bam->pgn_high = 00;
    405          
    406          	CAN_TX_Data(&tmpBuf[0]);
    407          
    408          }
    409          void SendMultiPacketData_61184_23(u8 packet_no)
    410          {
    411          	u8 tmpBuf1[8];
    412          	
    413          	SetCanID(235, 71, 7);
    414          
    415          	tmpBuf1[0] = packet_no;
    416          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_23[(packet_no-1)*7], 7);
    417          	CAN_TX_Data(&tmpBuf1[0]);
    418          
    419          }
    420          void SendTP_CM_BAM_MultiPacket_145(void)
    421          {
    422          	// TP.CM_BAM
    423          	SetCanID(236, 255, 7);
    424          
    425          	tp_cm_bam->Control = 32;	// Control Byte
    426          	
    427          	tp_cm_bam->TotMsgSize = 13;
    428          
    429          	tp_cm_bam->TotPacketNum = 2;
    430          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    431          
    432          	tp_cm_bam->Reserved = 0xff;
    433          
    434          	tp_cm_bam->pgn_low = 0xFF91;
    435          	tp_cm_bam->pgn_high = 0;
    436          
    437          	CAN_TX_Data(&tmpBuf[0]);
    438          }
    439          void SendMultiPacketData_145(u8 packet_no)
    440          {
    441          	u8 tmpBuf1[8];
    442          	
    443          	SetCanID(235, 255, 7);
    444          
    445          	tmpBuf1[0] = packet_no;
    446          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_145[(packet_no-1)*7], 7);
    447          	CAN_TX_Data(&tmpBuf1[0]);
    448          }
    449          
    450          void Send_CTS_61184(u8* Arr)
    451          {
    452          	SetCanID(236, 71, 7);
    453          	tmpBuf[0] = 17;	// Control Byte;l
    454          	tmpBuf[1] = Arr[3];
    455          	tmpBuf[2] = 1;
    456          	tmpBuf[3] = 0xFF;
    457          	tmpBuf[4] = 0xFF;
    458          	tmpBuf[5] = Arr[5];
    459          	tmpBuf[6] = Arr[6];
    460          	tmpBuf[7] = Arr[7];
    461          
    462          	CAN_TX_Data(&tmpBuf[0]);
    463          	
    464          }
    465          
    466          void Send_ACK_61184(u8* Arr)
    467          {
    468          	SetCanID(236, 71, 7);
    469          	tmpBuf[0] = 19;	// Control Byte;l
    470          	tmpBuf[1] = Arr[1];
    471          	tmpBuf[2] = Arr[2];
    472          	tmpBuf[3] = Arr[3];
    473          	tmpBuf[4] = Arr[4];
    474          	tmpBuf[5] = Arr[5];
    475          	tmpBuf[6] = Arr[6];
    476          	tmpBuf[7] = Arr[7];
    477          
    478          	CAN_TX_Data(&tmpBuf[0]);
    479          }
    480          
    481          void CheckASDataLen(void)
    482          {
    483          	u8 i;
    484          
    485          	as_data_len = 0;
    486          	memset((u8*)&tmpbuf_AS[0], 0x2A, 13);
    487          
    488          	for(i = 0 ; i < 12 ; i+=2)
    489          	{
    490          		tmpbuf_AS[i] = Uart2_RxMsg_AS_Phone_Data[i/2] & 0x0F;
    491          		tmpbuf_AS[i+1] = (Uart2_RxMsg_AS_Phone_Data[i/2] & 0xF0) >> 4;
    492          	}
    493          
    494          
    495          	for(i = 0 ; i < 12 ; i++)
    496          	{
    497          		if(tmpbuf_AS[i] != 0x0F)
    498          		{
    499          			tmpbuf_AS[i] += 0x30;
    500          			as_data_len++;
    501          		}
    502          		else
    503          		{
    504          			tmpbuf_AS[i] = 0x2A;
    505          			break;
    506          		}
    507          		
    508          	}
    509          
    510          	check_as_data_len = 1;
    511          }
    512          
    513          void SendTP_CM_BAM_MultiPacket_202_AS(void)
    514          {
    515          	// TP.CM_BAM
    516          	SetCanID(236, 255, 7);
    517          
    518          	tp_cm_bam->Control = 32;	// Control Byte
    519          	
    520          	tp_cm_bam->TotMsgSize = as_data_len;
    521          
    522          	tp_cm_bam->TotPacketNum = 2;
    523          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    524          
    525          	tp_cm_bam->Reserved = 0xff;
    526          
    527          	//tp_cm_bam->pgn_low = 0xEC00;
    528          	tp_cm_bam->pgn_low = 0xFF91;
    529          	tp_cm_bam->pgn_high = 0;
    530          
    531          	CAN_TX_Data(&tmpBuf[0]);
    532          }
    533          
    534          void SendMultiPacketData_202_AS(u8 packet_no)
    535          {
    536          	u8 tmpBuf1[8];
    537          	
    538          	SetCanID(235, 255, 7);
    539          
    540          	tmpBuf1[0] = packet_no;
    541          	memcpy(&tmpBuf1[1], &tmpbuf_AS[(packet_no-1)*7], 7);
    542          	CAN_TX_Data(&tmpBuf1[0]);
    543          }
    544          
    545          void RequestMachBasicInfo(void)
    546          {
    547          	u8 Request[8];
    548          
    549          	SetCanID(255, 251, 6);
    550          	
    551          	if(RecvMachInfo != 1)
    552          	{
    553          		if(++TotalRequestCnt <= 10)
    554          		{
    555          			Request[0] = 60;		// PS
    556          			Request[1] = 255;		// PF
    557          			CAN_TX_Data(&Request[0]);
    558          		}
    559          	}
    560          }
    561          
    562          void CompareMachBasicInfo(void)
    563          {
    564          	u8 i;
    565          
    566          	if((RecvMachInfo == 1) && (DiffMachInfo == 0))
    567          	{
    568          		for(i = 0 ; i < TotMsgSize ; i++)
    569          		{
    570          			if(McuInfoData1[i+1] != MachineBasicInformation[i])
    571          			{
    572          				memcpy(&McuInfoData1[1] , &MachineBasicInformation[0], TotMsgSize);
    573          
    574          				
    575          				if(McuInfoData1[0] == 0xff)
    576          					McuInfoData1[0] = 0;
    577          				else
    578          					McuInfoData1[0] += 1;
    579          
    580          				tmpMcuInfoData[0] = McuInfoData1[0];
    581          				
    582          				switch(tmpMcuInfoData[0])
    583          				{
    584          					case 0 :
    585          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    586          						memset(&tmpMcuInfoData[5] , 0xff, 12);
    587          						break;
    588          					case 1 :
    589          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    590          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    591          						memset(&tmpMcuInfoData[9] , 0xff, 8);
    592          						break;
    593          					case 2 :
    594          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    595          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    596          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    597          						memset(&tmpMcuInfoData[13] , 0xff, 4);
    598          						break;
    599          					case 3 :
    600          						memcpy(&tmpMcuInfoData[13] , &tmpMcuInfoData[9], 4);		
    601          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    602          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    603          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    604          						break;
    605          					default :
    606          						memcpy(&tmpMcuInfoData[13] , &tmpMcuInfoData[9], 4);		
    607          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    608          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    609          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    610          						break;							
    611          				}
    612          
    613          				
    614          				if(tmpMcuInfoData[0] > 250)
    615          					tmpMcuInfoData[0] = 250;
    616          				DiffMachInfo = 1;
    617          				
    618          				return;
    619          			}
    620          
    621          			if(MachineBasicInformation[i] == 0x2A)		//Asterisk
    622          			{
    623          				if(++CompareAsterisk >= 3)
    624          				{	
    625          					DiffMachInfo = 0;
    626          					return;
    627          				}
    628          			}
    629          		}
    630          	}
    631          }
    632          
    633          
    634          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   CAN_COMInit
        48   -> CAN_DeInit
        48   -> CAN_FilterInit
        48   -> CAN_Init
        48   -> CAN_StructInit
        48   -> NVIC_Init
      24   CAN_TX_Data
        24   -> CAN_Transmit
        24   -> __aeabi_memcpy
      12   CheckASDataLen
        12   -> __aeabi_memset4
      20   CompareMachBasicInfo
        20   -> __aeabi_memcpy
        20   -> __aeabi_memset
      16   RequestMachBasicInfo
        16   -> CAN_TX_Data
        16   -> SetCanID
      16   SendMultiPacketData_145
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_161
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_202_AS
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_61184_23
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
       8   SendTP_CM_BAM_MultiPacket_145
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_161
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_202_AS
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_61184_23
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   Send_ACK_61184
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   Send_CTS_61184
         0   -> CAN_TX_Data
         8   -> SetCanID
       0   SetCanID
      16   WL9F_CAN_Variables_Init
         0   -> __aeabi_memset
        16   -> memset
       8   memset
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      16  ??Subroutine3_0
      22  ?Subroutine0
      20  ?Subroutine1
      18  ?Subroutine2
     142  CAN_COMInit
      80  CAN_TX_Data
     132  CheckASDataLen
     300  CompareMachBasicInfo
     240  McuInfoData1
          MachineBasicInformation
          tmpMcuInfoData
      56  RequestMachBasicInfo
      32  SendMultiPacketData_145
      32  SendMultiPacketData_161
      30  SendMultiPacketData_202_AS
      30  SendMultiPacketData_61184_23
      26  SendTP_CM_BAM_MultiPacket_145
      50  SendTP_CM_BAM_MultiPacket_161
      24  SendTP_CM_BAM_MultiPacket_202_AS
      48  SendTP_CM_BAM_MultiPacket_61184_23
      34  Send_ACK_61184
      34  Send_CTS_61184
      26  SetCanID
       1  T_Packet_No
     514  WL9F_CAN_Variables_Init
      20  memset
     344  tmpBuf
          Identifier
          Uart2_RxMsg_Single_162
          as_data_len
          check_as_data_len
          flag_skip_multi_packet
          RecvMachInfo
          TotalRequestCnt
          CompareAsterisk
          tp_cm_bam_TotPacketNum
          Uart2_RxMsg_AS_Phone_Data
          tp_cm_bam
          Flag_SerialRxMsg
          Uart2_RxMsg_Save_Data1
          Uart2_RxMsg_Save_Data2
          Uart2_RxMsg_Smk_Reg_Eli
          Uart2_RxMsg_Single_46
          Uart2_RxMsg_Single_69
          Uart2_RxMsg_Multi_69
          Uart2_RxMsg_Single_160
          Uart2_RxMsg_Multi_161
          Uart2_RxMsg_Single_163
          Uart2_RxMsg_Single_174
          Uart2_RxMsg_Single_251
          Uart2_RxMsg_Single_252
          Uart2_RxMsg_Single_253
          Uart2_RxMsg_Single_239
          Uart2_RxMsg_Single_239_121
          Uart2_RxMsg_Single_11
          Uart2_RxMsg_Single_12
          Uart2_RxMsg_Single_21
          Uart2_RxMsg_Multi_23
          Uart2_RxMsg_Single_61
          Uart2_RxMsg_Single_62
          Uart2_RxMsg_Single_101
          Uart2_RxMsg_Single_104
          Uart2_RxMsg_Single_105
          Uart2_RxMsg_Single_109
          Uart2_RxMsg_Single_121
          Uart2_RxMsg_Single_123
          Uart2_RxMsg_Single_201
          Uart2_RxMsg_Single_203
          Uart2_RxMsg_Single_47
          Uart2_RxMsg_Multi_145
          Uart2_RxMsg_Single_247
      16  tmpbuf_AS

 
   601 bytes in section .bss
 1 726 bytes in section .text
 
 1 706 bytes of CODE memory (+ 20 bytes shared)
   601 bytes of DATA memory

Errors: none
Warnings: none
