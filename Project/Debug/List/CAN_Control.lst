###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      01/Sep/2014  20:45:19 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -      #
#                    ECS\SRC\CAN_Control.c                                    #
#    Command line =  "C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa -     #
#                    ECS\SRC\CAN_Control.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\   #
#                    -o C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\ #
#                     --debug --endian=little --cpu=Cortex-M4 -e              #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Pl #
#                    atform\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP_DM #
#                    A\Project\..\Platform\TaeHa - ECS\INC\" -I               #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    CMSIS\Device\ST\STM32F4xx\Include\ -I                    #
#                    C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\..\Libraries\ #
#                    STM32F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I  #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\List\CA #
#                    N_Control.lst                                            #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Project\Debug\Obj\CAN #
#                    _Control.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP_DMA\Platform\TaeHa - ECS\SRC\CAN_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    UART_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   UART_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          #pragma pack(1)
     26          struct st_CAN_Message
     27          {	
     28          	unsigned char Priority;
     29          	unsigned char Data_Page;
     30          	unsigned char PDU_Format;	
     31          	unsigned char PDU_Specific;		// 50
     32          	unsigned char Source_Address;	// 52
     33          };
     34          #pragma pack()
     35          
     36          
     37          #pragma pack(1)
     38          typedef struct
     39          {
     40          	u8 Control;
     41          	u16 TotMsgSize;
     42          	u8 TotPacketNum;
     43          	u8 Reserved;
     44          	u16 pgn_low;
     45          	u8 pgn_high;
     46          } TP_CM;
     47          #pragma pack()
     48          
     49          
     50          
     51          struct st_CAN_Message Identifier;
     52          TP_CM* tp_cm_bam;
     53          
     54          /* Private define ------------------------------------------------------------*/
     55          
     56          /*
     57          #define RX_MSG69		0x01
     58          #define RX_MSG69_M		0x02
     59          #define RX_MSG145		0x04
     60          #define RX_MSG161		0x08
     61          #define RX_MSG162		0x10
     62          #define RX_MSG163		0x20
     63          #define RX_MSG251		0x40
     64          #define RX_MSG252		0x80
     65          #define RX_MSG202		0x100
     66          #define RX_MSG253		0x200
     67          #define RX_MSG203		0x400
     68          
     69          #define RX_MSG239		0x800
     70          #define RX_MSG247		0x1000
     71          
     72          #define RX_MSG174		0x2000
     73          #define RX_MSG239_121	0x4000
     74          */
     75          #define RX_MSG11	0x01
     76          #define RX_MSG12	0x02
     77          #define RX_MSG21	0x04
     78          #define RX_MSG23	0x08
     79          #define RX_MSG61	0x10
     80          #define RX_MSG62	0x20
     81          #define RX_MSG101	0x40
     82          #define RX_MSG104	0x80
     83          #define RX_MSG105	0x100
     84          #define RX_MSG109	0x200
     85          #define RX_MSG121	0x400
     86          #define RX_MSG123	0x800
     87          #define RX_MSG201	0x1000
     88          #define RX_MSG203	0x2000
     89          	
     90          	
     91          #define RX_MSG47	0x4000
     92          	
     93          #define RX_MSG145	0x8000
     94          #define RX_MSG247	0x10000
     95          
     96          struct st_CAN_Message_Ring_Buffer_Tx_Single CAN_Message_Ring_Buffer_Tx_Single;
     97          struct st_CAN_Message_Ring_Buffer_Rx_Single CAN_Message_Ring_Buffer_Rx_Single;
     98          
     99          #define UART2_Tx_BUF_SIZE		17
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          u8 tmpBuf[8];
    103          
    104          u8 as_data_len;
    105          u8 tmpbuf_AS[13];
    106          u8 check_as_data_len = 0;
    107          
    108          
    109          u8 Uart2_RxMsg_Save_Data1[8];
    110          u8 Uart2_RxMsg_Save_Data2[8];
    111          u8 Uart2_RxMsg_AS_Phone_Data[8];
    112          u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    113          
    114          u8 Uart2_RxMsg_Single_46[8];
    115          u8 Uart2_RxMsg_Single_69[8];
    116          u8 Uart2_RxMsg_Multi_69[21];
    117          u8 Uart2_RxMsg_Single_160[8];
    118          u8 Uart2_RxMsg_Multi_161[16];
    119          u8 Uart2_RxMsg_Single_162[8];
    120          u8 Uart2_RxMsg_Single_163[8];
    121          u8 Uart2_RxMsg_Single_174[8];
    122          u8 Uart2_RxMsg_Single_251[8];
    123          u8 Uart2_RxMsg_Single_252[8];
    124          u8 Uart2_RxMsg_Single_253[8];
    125          u8 Uart2_RxMsg_Single_239[8];
    126          u8 Uart2_RxMsg_Single_247[8];
    127          u8 Uart2_RxMsg_Single_239_121[8];
    128          
    129          //61184
    130          u8 Uart2_RxMsg_Single_11[8];
    131          u8 Uart2_RxMsg_Single_12[8];
    132          u8 Uart2_RxMsg_Single_21[8];
    133          u8 Uart2_RxMsg_Multi_23[13];
    134          u8 Uart2_RxMsg_Single_61[8];
    135          u8 Uart2_RxMsg_Single_62[8];
    136          u8 Uart2_RxMsg_Single_101[8];
    137          u8 Uart2_RxMsg_Single_104[8];
    138          u8 Uart2_RxMsg_Single_105[8];
    139          u8 Uart2_RxMsg_Single_109[8];
    140          u8 Uart2_RxMsg_Single_121[8];
    141          u8 Uart2_RxMsg_Single_123[8];
    142          u8 Uart2_RxMsg_Single_201[8];
    143          u8 Uart2_RxMsg_Single_203[8];
    144          //0xFFxx
    145          u8 Uart2_RxMsg_Single_47[8];
    146          u8 Uart2_RxMsg_Multi_145[22];
    147          u8 Uart2_RxMsg_Single_247[8];
    148          
    149          
    150          
    151          u8 McuInfoData1[79];
    152          u8 MachineBasicInformation[78];
    153          u8 tmpMcuInfoData[78];
    154          
    155          
    156          u8 T_Packet_No = 0;
    157          u8 flag_skip_multi_packet = 0;
    158          u8 RecvMachInfo = 0;
    159          u8 TotalRequestCnt = 0;
    160          u8 CompareAsterisk = 0;
    161          
    162          u32 Flag_SerialRxMsg = 0;
    163          u8 tp_cm_bam_TotPacketNum = 0;
    164          
    165          extern u8 CanRecvCnt;
    166          extern u16 TotMsgSize;
    167          
    168          extern u16 Flag_1Sec_MachInfo;
    169          extern u8 MachInfoTotalPacketNum;
    170          extern u8 MoniInfoTotalPacketNum;
    171          extern u8 MachInfoSendCnt;
    172          extern u8 MoniInfoSendCnt;
    173          extern u8 MultiPacketSendOrder;
    174          extern u8 MoniInfoData[21];
    175          extern u8 DiffMachInfo;
    176          extern u8 SerialMsgRTC[16];
    177          extern u8 RTSFlag_61184;
    178          extern u8 CTSFlag_61184;
    179          extern u8 RecvTotalPacket_61184;
    180          extern u8 ACK_Multi_61184[8];
    181          extern u8 RMCU_CTSFlag_61184;
    182          extern u8 RMCU_RecvTotalPacket_61184;
    183          extern u8 RMCU_ACK_Multi_61184[8];
    184          
    185          
    186          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    187          extern Realy_Control rx_Realy_Control;
    188          extern EHCU_Status rx_EHCU_Status;
    189          
    190          extern unsigned long long SerialTXIndex;
    191          /* Private function prototypes -----------------------------------------------*/
    192          /* Private functions ---------------------------------------------------------*/
    193          /**
    194            * @brief  CAN1, CAN2 Initialize 
    195            * @param  
    196            * @retval None
    197            */
    198          void CAN_COMInit(void)
    199          {
    200          	CAN_InitTypeDef        CAN_InitStructure;
    201          	CAN_InitTypeDef        CAN_InitStructure2;
    202          	CAN_FilterInitTypeDef  CAN_FilterInitStructure;
    203          	NVIC_InitTypeDef        NVIC_InitStructure;
    204          
    205          	DebugMsg_printf("++ CAN1, CAN2 Initialize START\r\n");
    206          
    207          	CAN_DeInit(CAN1);
    208          	CAN_DeInit(CAN2);
    209          	CAN_StructInit(&CAN_InitStructure);
    210          
    211          	CAN_InitStructure.CAN_TTCM = DISABLE;
    212          	//CAN_InitStructure.CAN_ABOM = ENABLE;
    213          	CAN_InitStructure.CAN_ABOM = DISABLE;
    214          	CAN_InitStructure.CAN_AWUM = DISABLE;
    215          	CAN_InitStructure.CAN_NART = DISABLE;
    216          	CAN_InitStructure.CAN_RFLM = DISABLE;
    217          	CAN_InitStructure.CAN_TXFP = DISABLE;
    218          	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
    219          	CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    220          	CAN_InitStructure.CAN_BS1 = CAN_BS1_14tq;
    221          	CAN_InitStructure.CAN_BS2 = CAN_BS2_6tq;  
    222          	CAN_InitStructure.CAN_Prescaler = 4;   // 2:1M, 4:500k, 8:250k. 16:125k
    223          	CAN_Init(CAN1, &CAN_InitStructure);
    224          
    225          
    226          	CAN_InitStructure2.CAN_TTCM = DISABLE;
    227          	//CAN_InitStructure2.CAN_ABOM = ENABLE;
    228          	CAN_InitStructure2.CAN_ABOM = DISABLE;
    229          	CAN_InitStructure2.CAN_AWUM = DISABLE;
    230          	CAN_InitStructure2.CAN_NART = DISABLE;
    231          	CAN_InitStructure2.CAN_RFLM = DISABLE;
    232          	CAN_InitStructure2.CAN_TXFP = DISABLE;
    233          	CAN_InitStructure2.CAN_Mode = CAN_Mode_Normal;
    234          	CAN_InitStructure2.CAN_SJW = CAN_SJW_1tq;
    235          	CAN_InitStructure2.CAN_BS1 = CAN_BS1_14tq;
    236          	CAN_InitStructure2.CAN_BS2 = CAN_BS2_6tq;  
    237          	CAN_InitStructure2.CAN_Prescaler = 8;   // 2:1M, 4:500k, 8:250k. 16:125k
    238          	CAN_Init(CAN2, &CAN_InitStructure2);
    239          
    240          	//CAN_FilterInitStructure.CAN_FilterNumber = 0;
    241          	CAN_FilterInitStructure.CAN_FilterNumber = 0;
    242          	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    243          	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    244          	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
    245          	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
    246          	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
    247          	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
    248          	//CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
    249          	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    250          	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    251          	CAN_FilterInit(&CAN_FilterInitStructure);
    252          
    253          	// 부팅시 EEPROM Data를 Main CPU에 올리고 나서 ENABLE시킨다.
    254          	//CAN_ITConfig(CAN_IT_FMP0, ENABLE);		
    255          
    256          	//  Enable the CAN1_RX0_IRQn  Interrupt
    257          	NVIC_InitStructure.NVIC_IRQChannel                   = CAN1_RX0_IRQn;
    258          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    259          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    260          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    261          	NVIC_Init(&NVIC_InitStructure);
    262          
    263          
    264          	
    265          	//CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);		
    266          	
    267              DebugMsg_printf("++ CAN1, CAN2 Initialize END\r\n");
    268          }
    269          
    270          
    271          
    272          
    273          void WL9F_CAN_Variables_Init(void)
    274          {
    275          	check_as_data_len = 0;
    276          	Flag_SerialRxMsg = 0;
    277          
    278          	Identifier.Priority = 6;
    279          	Identifier.Data_Page = 0;
    280          	Identifier.PDU_Format = 255;	
    281          	Identifier.Source_Address = 40;		
    282          
    283          	flag_skip_multi_packet = 0;
    284          	TotMsgSize = 0;
    285          	RecvMachInfo = 0;
    286          	TotalRequestCnt = 0;
    287          	CompareAsterisk = 0;
    288          	CanRecvCnt = 0;
    289          
    290          
    291          
    292          	tp_cm_bam = (TP_CM*)&tmpBuf[0];
    293          	
    294          	memset((u8*)&Uart2_RxMsg_Save_Data1[0], 0xff, sizeof(Uart2_RxMsg_Save_Data1));
    295          	memset((u8*)&Uart2_RxMsg_Save_Data2[0], 0xff, sizeof(Uart2_RxMsg_Save_Data2));
    296          	memset((u8*)&Uart2_RxMsg_AS_Phone_Data[0], 0xff, sizeof(Uart2_RxMsg_AS_Phone_Data));
    297          	memset((u8*)&Uart2_RxMsg_Smk_Reg_Eli[0], 0xff, sizeof(Uart2_RxMsg_Smk_Reg_Eli));	
    298          	memset((u8*)&Uart2_RxMsg_Single_46[0], 0xff, sizeof(Uart2_RxMsg_Single_46));
    299          	memset((u8*)&Uart2_RxMsg_Single_69[0], 0xff, sizeof(Uart2_RxMsg_Single_69));
    300          	memset((u8*)&Uart2_RxMsg_Single_160[0], 0xff, sizeof(Uart2_RxMsg_Single_160));
    301          	memset((u8*)&Uart2_RxMsg_Single_162[0], 0xff, sizeof(Uart2_RxMsg_Single_162));
    302          	Uart2_RxMsg_Single_162[4] = 0;		// Monitor Switch Status
    303          	memset((u8*)&Uart2_RxMsg_Single_163[0], 0xff, sizeof(Uart2_RxMsg_Single_163));
    304          	memset((u8*)&Uart2_RxMsg_Single_174[0], 0xff, sizeof(Uart2_RxMsg_Single_174));
    305          	memset((u8*)&Uart2_RxMsg_Single_251[0], 0xff, sizeof(Uart2_RxMsg_Single_251));
    306          	memset((u8*)&Uart2_RxMsg_Single_252[0], 0xff, sizeof(Uart2_RxMsg_Single_252));
    307          	memset((u8*)&Uart2_RxMsg_Single_253[0], 0xff, sizeof(Uart2_RxMsg_Single_253));
    308          
    309          	memset((u8*)&Uart2_RxMsg_Single_239[0], 0xff, sizeof(Uart2_RxMsg_Single_239));
    310          
    311          	memset((u8*)&Uart2_RxMsg_Single_239_121[0], 0xff, sizeof(Uart2_RxMsg_Single_239_121));
    312          
    313          	
    314          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    315          
    316          	
    317          	memset((u8*)&Uart2_RxMsg_Multi_161[0], 0xff, sizeof(Uart2_RxMsg_Multi_161));
    318          	memset((u8*)&Uart2_RxMsg_Multi_69[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    319          
    320          
    321          
    322          
    323          	memset((u8*)&Uart2_RxMsg_Single_11[0], 0xff, sizeof(Uart2_RxMsg_Single_11));
    324          	memset((u8*)&Uart2_RxMsg_Single_12[0], 0xff, sizeof(Uart2_RxMsg_Multi_69));
    325          	memset((u8*)&Uart2_RxMsg_Single_21[0], 0xff, sizeof(Uart2_RxMsg_Single_21));
    326          	memset((u8*)&Uart2_RxMsg_Multi_23[0], 0xff, sizeof(Uart2_RxMsg_Multi_23));
    327          	memset((u8*)&Uart2_RxMsg_Single_61[0], 0xff, sizeof(Uart2_RxMsg_Single_61));
    328          	memset((u8*)&Uart2_RxMsg_Single_62[0], 0xff, sizeof(Uart2_RxMsg_Single_62));
    329          	memset((u8*)&Uart2_RxMsg_Single_101[0], 0xff, sizeof(Uart2_RxMsg_Single_101));
    330          	memset((u8*)&Uart2_RxMsg_Single_104[0], 0xff, sizeof(Uart2_RxMsg_Single_104));
    331          	memset((u8*)&Uart2_RxMsg_Single_105[0], 0xff, sizeof(Uart2_RxMsg_Single_105));
    332          	memset((u8*)&Uart2_RxMsg_Single_109[0], 0xff, sizeof(Uart2_RxMsg_Single_109));
    333          	memset((u8*)&Uart2_RxMsg_Single_121[0], 0xff, sizeof(Uart2_RxMsg_Single_121));
    334          	memset((u8*)&Uart2_RxMsg_Single_123[0], 0xff, sizeof(Uart2_RxMsg_Single_123));
    335          	memset((u8*)&Uart2_RxMsg_Single_201[0], 0xff, sizeof(Uart2_RxMsg_Single_201));
    336          	memset((u8*)&Uart2_RxMsg_Single_203[0], 0xff, sizeof(Uart2_RxMsg_Single_203));
    337          	memset((u8*)&Uart2_RxMsg_Single_47[0], 0xff, sizeof(Uart2_RxMsg_Single_47));
    338          	memset((u8*)&Uart2_RxMsg_Multi_145[0], 0xff, sizeof(Uart2_RxMsg_Multi_145));
    339          	memset((u8*)&Uart2_RxMsg_Single_247[0], 0xff, sizeof(Uart2_RxMsg_Single_247));
    340          
    341          
    342          
    343          	memset((u8*)&rx_Realy_Control, 0xff, sizeof(rx_Realy_Control));
    344          
    345          
    346          	memset((u8*)&SerialMsgRTC[0], 0xA5, 2);
    347          	memset((u8*)&SerialMsgRTC[2], 0xF0, 2);
    348          }
    349          
    350          u8 can_data_temp[255];
    351          u8 old_can_data;
    352          
    353          void Write_CAN_Single(struct st_CAN_Message1 Message)
    354          {
    355          	if(Message.PDU_Specific != 47)  // 비주기 테이터 
    356          	{
    357          		memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Message,12);
    358          		
    359          		if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    360          			CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    361          	}
    362          	else  // 주기 데이터  PS = 47
    363          	{
    364          		if(Message.PDU_Specific == 47)
    365          			memcpy(&Uart2_RxMsg_Single_47,&Message.Data,8);
    366          	}
    367          }
    368          
    369          void Write_UART_Single(void)
    370          {
    371          	static unsigned short Tx_Rountine_Count_UART;
    372          
    373          	/*
    374          	if((++Tx_Rountine_Count_UART%3)==0)
    375          	{
    376          		Tx_Rountine_Count_UART = 0;
    377          		if (CAN_Message_Ring_Buffer_Rx_Single.Head != CAN_Message_Ring_Buffer_Rx_Single.Tail)
    378          		{
    379          			int i;
    380          			u8 UARTTxMessage[17];
    381          			memcpy(&UARTTxMessage[0],(u8*)&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Tail],17);
    382          			for(i = 0; i < 17; i++)
    383          				USARTx_PutChar(2,(uint8_t)UARTTxMessage[i]);
    384          			//	USART_SendData(USART2, UARTTxMessage[i]);	 
    385           			
    386          			SerialTXIndex++;
    387          			if (++(CAN_Message_Ring_Buffer_Rx_Single.Tail) >= MAX_CAN_RX_DATA_SINGLE)
    388          				CAN_Message_Ring_Buffer_Rx_Single.Tail = 0;
    389          		}
    390          
    391          	}
    392          	*/
    393          
    394          	if((++Tx_Rountine_Count_UART%5)==0)
    395          	{
    396          		Tx_Rountine_Count_UART = 0;
    397          		if (CAN_Message_Ring_Buffer_Rx_Single.Head != CAN_Message_Ring_Buffer_Rx_Single.Tail)
    398          		{
    399          			int i;
    400          			//u8 UARTTxMessage[17];
    401          
    402          			DMA_UART_SendFrame(&Uart2_SerialTxMsg[0],(u8*)&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Tail],17);
    403          			
    404          			SerialTXIndex++;
    405          			if (++(CAN_Message_Ring_Buffer_Rx_Single.Tail) >= MAX_CAN_RX_DATA_SINGLE)
    406          				CAN_Message_Ring_Buffer_Rx_Single.Tail = 0;
    407          		}
    408          
    409          	}
    410          
    411          }
    412          
    413          
    414          void SetCanID(u8 PF, u8 PS, u8 Priority)
    415          {
    416          	if(PF != 0)
    417          		Identifier.PDU_Format = PF;	
    418          
    419          	if(PS != 0)
    420          		Identifier.PDU_Specific = PS;	
    421          
    422          	if(Priority != 0)
    423          		Identifier.Priority = Priority;	
    424          }
    425          
    426          void CAN_TX_Data(u8* Data)
    427          {
    428          	//u8 TransmitMailbox;
    429          	CanTxMsg TxMessage;
    430          	
    431          	TxMessage.ExtId=((unsigned long)(Identifier.Priority) << 26)+((unsigned long)(Identifier.Data_Page) << 24)+((unsigned long)(Identifier.PDU_Format) << 16)
    432          				                      + ((unsigned long)(Identifier.PDU_Specific) << 8) + ((unsigned long)(Identifier.Source_Address) << 0) ;
    433          			
    434          	TxMessage.IDE = CAN_ID_EXT;
    435          	TxMessage.RTR = CAN_RTR_DATA;
    436          	TxMessage.DLC = 8;
    437          
    438          	memcpy((u8*)&TxMessage.Data[0], (u8*)&Data[0], 8);
    439          
    440          	
    441          	CAN_Transmit(CAN1,&TxMessage);
    442          }
    443          u8 can_status;
    444          u8 can_status_buf[100];
    445          u8 can_tx_error_count;
    446          
    447          void CAN_TX(void)
    448          {
    449          	CanTxMsg TxMessage;
    450          	unsigned char i;
    451          	static unsigned short Tx_Rountine_Count_CAN;
    452          
    453          	
    454          	if((++Tx_Rountine_Count_CAN%2)==0)
    455          	{
    456          		if (CAN_Message_Ring_Buffer_Tx_Single.Head != CAN_Message_Ring_Buffer_Tx_Single.Tail)
    457          		{
    458          			
    459          			TxMessage.ExtId = (CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Priority<<24)+
    460          							(CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].PDU_Format<<16)+
    461          							(CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].PDU_Specific<<8)+
    462          							CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Source_Address;
    463          			TxMessage.IDE = CAN_ID_EXT;
    464          			TxMessage.RTR = CAN_RTR_DATA;
    465          			TxMessage.DLC = 8;
    466          
    467          			
    468          			for (i = 0; i < 8; i++)
    469          			{
    470          				TxMessage.Data[i] = CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Tail].Data[i];
    471          			}
    472          
    473          			can_status = CAN_Transmit(CAN1,&TxMessage);
    474          			
    475          
    476          							
    477          			if(can_status !=CAN_TxStatus_NoMailBox)
    478          			{
    479          				if (++(CAN_Message_Ring_Buffer_Tx_Single.Tail) >= MAX_CAN_TX_DATA_SINGLE)
    480          					CAN_Message_Ring_Buffer_Tx_Single.Tail = 0;
    481          			}
    482          			else
    483          			{
    484          				can_status_buf[can_tx_error_count++] = can_status;
    485          				if(can_tx_error_count>100)	can_tx_error_count=0;
    486          			}
    487          
    488          
    489          		}
    490          		
    491          	}
    492          
    493          
    494          	 //if(Tx_Rountine_Count_CAN++ > 500)
    495          	 //{
    496          	//		Tx_Rountine_Count_CAN = 0;
    497          	 //}
    498                 	
    499          }
    500          
    501          void CAN_RX(CanRxMsg RxMessage)
    502          {
    503          	
    504          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_STX = 0x02;
    505          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_ID = 0xF5;
    506          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_LEN = 0x08;
    507          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_SAVE_DATA = 0x00;
    508          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_ETX = 0x03;
    509          
    510          	CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].Rx_ExtID = RxMessage.ExtId;
    511          
    512          	memcpy(&CAN_Message_Ring_Buffer_Rx_Single.Message[CAN_Message_Ring_Buffer_Rx_Single.Head].RX_DATA[0],&RxMessage.Data[0],8);
    513          		
    514          	
    515          	if (++(CAN_Message_Ring_Buffer_Rx_Single.Head) >= MAX_CAN_RX_DATA_SINGLE)
    516          		CAN_Message_Ring_Buffer_Rx_Single.Head = 0;
    517          
    518          	
    519          }
    520          void MonitorStatus_CAN_TX(void)
    521          {
    522          	struct st_CAN_Message1 Send_Message;
    523          
    524          
    525          	Send_Message.Priority = 0x18;
    526          	Send_Message.PDU_Format = 0xFF;		// 255
    527          	Send_Message.PDU_Specific = 0x2F;	// 47
    528          	Send_Message.Source_Address = 0x28;
    529          	memcpy(&Send_Message.Data,&Uart2_RxMsg_Single_47,8);
    530          	memcpy(&CAN_Message_Ring_Buffer_Tx_Single.Message[CAN_Message_Ring_Buffer_Tx_Single.Head],&Send_Message,12);
    531          
    532          	if (++(CAN_Message_Ring_Buffer_Tx_Single.Head) >= MAX_CAN_TX_DATA_SINGLE)
    533          		CAN_Message_Ring_Buffer_Tx_Single.Head = 0;
    534          	//if( (Uart2_RxMsg_Single_47[4] & 0x10 ) == 0x10 )
    535          	//{
    536          	//	if( WL9FM_BUZZER.Status == 0 )
    537          	//		Uart2_RxMsg_Single_47[4] = Uart2_RxMsg_Single_47[4] & 0xCF;
    538          	//}
    539          }
    540          
    541          
    542          
    543          void SendTP_CM_BAM_MultiPacket_161(void)
    544          {
    545          	// TP.CM_BAM
    546          	SetCanID(236, 255, 7);
    547          
    548          	tp_cm_bam->Control = 32;	// Control Byte
    549          	
    550          	tp_cm_bam->TotMsgSize = 10;
    551          
    552          	tp_cm_bam->TotPacketNum = 2;
    553          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    554          
    555          	tp_cm_bam->Reserved = 0xff;
    556          
    557          	tp_cm_bam->pgn_low = 0xFFA1;
    558          	tp_cm_bam->pgn_high = 0;
    559          
    560          	CAN_TX_Data(&tmpBuf[0]);
    561          }
    562          
    563          void SendMultiPacketData_161(u8 packet_no)
    564          {
    565          	u8 tmpBuf1[8];
    566          	
    567          	SetCanID(235, 255, 7);
    568          
    569          	tmpBuf1[0] = packet_no;
    570          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_161[(packet_no-1)*7], 7);
    571          	CAN_TX_Data(&tmpBuf1[0]);
    572          }
    573          
    574          void SendTP_CM_BAM_MultiPacket_61184_23(void)
    575          {
    576          	// TP.CM_BAM
    577          	SetCanID(236, 71, 7);
    578          
    579          	tp_cm_bam->Control = 16;	// Control Byte
    580          	
    581          	tp_cm_bam->TotMsgSize = 13;
    582          
    583          	tp_cm_bam->TotPacketNum = 2;
    584          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    585          
    586          	tp_cm_bam->Reserved = 0xff;
    587          
    588          	tp_cm_bam->pgn_low = 0xEF00;
    589          	tp_cm_bam->pgn_high = 00;
    590          
    591          	CAN_TX_Data(&tmpBuf[0]);
    592          
    593          }
    594          void SendMultiPacketData_61184_23(u8 packet_no)
    595          {
    596          	u8 tmpBuf1[8];
    597          	
    598          	SetCanID(235, 71, 7);
    599          
    600          	tmpBuf1[0] = packet_no;
    601          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_23[(packet_no-1)*7], 7);
    602          	CAN_TX_Data(&tmpBuf1[0]);
    603          
    604          }
    605          void SendTP_CM_BAM_MultiPacket_145(void)
    606          {
    607          	int Asterisk = 0;
    608          	for(int i = 0; i < 22; i++)
    609          	{
    610          		if(Uart2_RxMsg_Multi_145[i] == 0x2A)
    611          		{
    612          			break;
    613          		}
    614          		else
    615          		{
    616          			Asterisk++;
    617          		}
    618          	}
    619          	// TP.CM_BAM
    620          	SetCanID(236, 255, 7);
    621          
    622          	tp_cm_bam->Control = 32;	// Control Byte
    623          	
    624          	tp_cm_bam->TotMsgSize = Asterisk + 1;
    625          
    626          	if((tp_cm_bam->TotMsgSize % 7) == 0)
    627          	{
    628          		tp_cm_bam->TotPacketNum = tp_cm_bam->TotMsgSize / 7;
    629          	}
    630          	else
    631          	{
    632          		tp_cm_bam->TotPacketNum = (tp_cm_bam->TotMsgSize / 7) + 1;
    633          	}
    634          
    635          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    636          
    637          	tp_cm_bam->Reserved = 0xff;
    638          
    639          	tp_cm_bam->pgn_low = 0xFF91;
    640          	tp_cm_bam->pgn_high = 0;
    641          
    642          	CAN_TX_Data(&tmpBuf[0]);
    643          }
    644          void SendMultiPacketData_145(u8 packet_no)
    645          {
    646          	u8 tmpBuf1[8];
    647          	
    648          	SetCanID(235, 255, 7);
    649          
    650          	tmpBuf1[0] = packet_no;
    651          	memcpy(&tmpBuf1[1], &Uart2_RxMsg_Multi_145[(packet_no-1)*7], 7);
    652          	CAN_TX_Data(&tmpBuf1[0]);
    653          }
    654          
    655          void Send_CTS_61184(u8* Arr, u8 SA)
    656          {
    657          	SetCanID(236, SA, 7);
    658          	tmpBuf[0] = 17;	// Control Byte;l
    659          	tmpBuf[1] = Arr[3];
    660          	tmpBuf[2] = 1;
    661          	tmpBuf[3] = 0xFF;
    662          	tmpBuf[4] = 0xFF;
    663          	tmpBuf[5] = Arr[5];
    664          	tmpBuf[6] = Arr[6];
    665          	tmpBuf[7] = Arr[7];
    666          
    667          	CAN_TX_Data(&tmpBuf[0]);
    668          	
    669          }
    670          
    671          void Send_ACK_61184(u8* Arr, u8 SA)
    672          {
    673          	SetCanID(236, SA, 7);
    674          	tmpBuf[0] = 19;	// Control Byte;l
    675          	tmpBuf[1] = Arr[1];
    676          	tmpBuf[2] = Arr[2];
    677          	tmpBuf[3] = Arr[3];
    678          	tmpBuf[4] = Arr[4];
    679          	tmpBuf[5] = Arr[5];
    680          	tmpBuf[6] = Arr[6];
    681          	tmpBuf[7] = Arr[7];
    682          
    683          	CAN_TX_Data(&tmpBuf[0]);
    684          }
    685          
    686          void CheckASDataLen(void)
    687          {
    688          	u8 i;
    689          
    690          	as_data_len = 0;
    691          	memset((u8*)&tmpbuf_AS[0], 0x2A, 13);
    692          
    693          	for(i = 0 ; i < 12 ; i+=2)
    694          	{
    695          		tmpbuf_AS[i] = Uart2_RxMsg_AS_Phone_Data[i/2] & 0x0F;
    696          		tmpbuf_AS[i+1] = (Uart2_RxMsg_AS_Phone_Data[i/2] & 0xF0) >> 4;
    697          	}
    698          
    699          
    700          	for(i = 0 ; i < 12 ; i++)
    701          	{
    702          		if(tmpbuf_AS[i] != 0x0F)
    703          		{
    704          			tmpbuf_AS[i] += 0x30;
    705          			as_data_len++;
    706          		}
    707          		else
    708          		{
    709          			tmpbuf_AS[i] = 0x2A;
    710          			break;
    711          		}
    712          		
    713          	}
    714          
    715          	check_as_data_len = 1;
    716          }
    717          
    718          void SendTP_CM_BAM_MultiPacket_202_AS(void)
    719          {
    720          	// TP.CM_BAM
    721          	SetCanID(236, 255, 7);
    722          
    723          	tp_cm_bam->Control = 32;	// Control Byte
    724          	
    725          	tp_cm_bam->TotMsgSize = as_data_len;
    726          
    727          	tp_cm_bam->TotPacketNum = 2;
    728          	tp_cm_bam_TotPacketNum = tp_cm_bam->TotPacketNum;
    729          
    730          	tp_cm_bam->Reserved = 0xff;
    731          
    732          	//tp_cm_bam->pgn_low = 0xEC00;
    733          	tp_cm_bam->pgn_low = 0xFF91;
    734          	tp_cm_bam->pgn_high = 0;
    735          
    736          	CAN_TX_Data(&tmpBuf[0]);
    737          }
    738          
    739          void SendMultiPacketData_202_AS(u8 packet_no)
    740          {
    741          	u8 tmpBuf1[8];
    742          	
    743          	SetCanID(235, 255, 7);
    744          
    745          	tmpBuf1[0] = packet_no;
    746          	memcpy(&tmpBuf1[1], &tmpbuf_AS[(packet_no-1)*7], 7);
    747          	CAN_TX_Data(&tmpBuf1[0]);
    748          }
    749          
    750          void RequestMachBasicInfo(void)
    751          {
    752          	u8 Request[8];
    753          
    754          	SetCanID(255, 251, 6);
    755          	
    756          	if(RecvMachInfo != 1)
    757          	{
    758          		if(++TotalRequestCnt <= 10)
    759          		{
    760          			Request[0] = 60;		// PS
    761          			Request[1] = 255;		// PF
    762          			CAN_TX_Data(&Request[0]);
    763          		}
    764          	}
    765          }
    766          
    767          void CompareMachBasicInfo(void)
    768          {
    769          	u8 i;
    770          
    771          	if((RecvMachInfo == 1) && (DiffMachInfo == 0))
    772          	{
    773          		for(i = 0 ; i < TotMsgSize ; i++)
    774          		{
    775          			if(McuInfoData1[i+1] != MachineBasicInformation[i])
    776          			{
    777          				memcpy(&McuInfoData1[1] , &MachineBasicInformation[0], TotMsgSize);
    778          
    779          				
    780          				if(McuInfoData1[0] == 0xff)
    781          					McuInfoData1[0] = 0;
    782          				else
    783          					McuInfoData1[0] += 1;
    784          
    785          				tmpMcuInfoData[0] = McuInfoData1[0];
    786          				
    787          				switch(tmpMcuInfoData[0])
    788          				{
    789          					case 0 :
    790          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    791          						memset(&tmpMcuInfoData[5] , 0xff, 12);
    792          						break;
    793          					case 1 :
    794          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    795          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    796          						memset(&tmpMcuInfoData[9] , 0xff, 8);
    797          						break;
    798          					case 2 :
    799          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    800          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    801          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    802          						memset(&tmpMcuInfoData[13] , 0xff, 4);
    803          						break;
    804          					case 3 :
    805          						memcpy(&tmpMcuInfoData[13] , &tmpMcuInfoData[9], 4);		
    806          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    807          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    808          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    809          						break;
    810          					default :
    811          						memcpy(&tmpMcuInfoData[13] , &tmpMcuInfoData[9], 4);		
    812          						memcpy(&tmpMcuInfoData[9] , &tmpMcuInfoData[5], 4);		
    813          						memcpy(&tmpMcuInfoData[5] , &tmpMcuInfoData[1], 4);		
    814          						memcpy(&tmpMcuInfoData[1] , &McuInfoData1[1], 4);	
    815          						break;							
    816          				}
    817          
    818          				
    819          				if(tmpMcuInfoData[0] > 250)
    820          					tmpMcuInfoData[0] = 250;
    821          				DiffMachInfo = 1;
    822          				
    823          				return;
    824          			}
    825          
    826          			if(MachineBasicInformation[i] == 0x2A)		//Asterisk
    827          			{
    828          				if(++CompareAsterisk >= 3)
    829          				{	
    830          					DiffMachInfo = 0;
    831          					return;
    832          				}
    833          			}
    834          		}
    835          	}
    836          }
    837          
    838          
    839          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   CAN_COMInit
        56   -> CAN_DeInit
        56   -> CAN_FilterInit
        56   -> CAN_Init
        56   -> CAN_StructInit
        56   -> NVIC_Init
      24   CAN_RX
        24   -> __aeabi_memcpy
      32   CAN_TX
        32   -> CAN_Transmit
      24   CAN_TX_Data
        24   -> CAN_Transmit
        24   -> __aeabi_memcpy
      12   CheckASDataLen
        12   -> __aeabi_memset4
      20   CompareMachBasicInfo
        20   -> __aeabi_memcpy
        20   -> __aeabi_memset
      20   MonitorStatus_CAN_TX
        20   -> __aeabi_memcpy
      16   RequestMachBasicInfo
        16   -> CAN_TX_Data
        16   -> SetCanID
      16   SendMultiPacketData_145
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_161
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_202_AS
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendMultiPacketData_61184_23
        16   -> CAN_TX_Data
        16   -> SetCanID
        16   -> __aeabi_memcpy
      16   SendTP_CM_BAM_MultiPacket_145
         0   -> CAN_TX_Data
        16   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_161
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_202_AS
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   SendTP_CM_BAM_MultiPacket_61184_23
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   Send_ACK_61184
         0   -> CAN_TX_Data
         8   -> SetCanID
       8   Send_CTS_61184
         0   -> CAN_TX_Data
         8   -> SetCanID
       0   SetCanID
      16   WL9F_CAN_Variables_Init
         0   -> __aeabi_memset
        16   -> __aeabi_memset
        16   -> __aeabi_memset4
        16   -> memset
      20   Write_CAN_Single
        20   -> __aeabi_memcpy
       8   Write_UART_Single
         8   -> DMA_UART_SendFrame
       8   memset
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       6  ?Subroutine0
      20  ?Subroutine1
      16  ?Subroutine2
      18  ?Subroutine3
     172  CAN_COMInit
    4340  CAN_Message_Ring_Buffer_Rx_Single
    3064  CAN_Message_Ring_Buffer_Tx_Single
     124  CAN_RX
     158  CAN_TX
      80  CAN_TX_Data
     130  CheckASDataLen
     300  CompareMachBasicInfo
       8  Identifier
     240  McuInfoData1
          MachineBasicInformation
          tmpMcuInfoData
      74  MonitorStatus_CAN_TX
      56  RequestMachBasicInfo
      32  SendMultiPacketData_145
      34  SendMultiPacketData_161
      30  SendMultiPacketData_202_AS
      30  SendMultiPacketData_61184_23
     116  SendTP_CM_BAM_MultiPacket_145
      50  SendTP_CM_BAM_MultiPacket_161
      48  SendTP_CM_BAM_MultiPacket_202_AS
      48  SendTP_CM_BAM_MultiPacket_61184_23
      32  Send_ACK_61184
      32  Send_CTS_61184
      26  SetCanID
       1  T_Packet_No
       2  Tx_Rountine_Count_UART
     518  WL9F_CAN_Variables_Init
      64  Write_CAN_Single
      98  Write_UART_Single
     256  can_data_temp
     106  can_status
          can_tx_error_count
          can_status_buf
          Tx_Rountine_Count_CAN
      20  memset
       1  old_can_data
     344  tmpBuf
          Uart2_RxMsg_Single_162
          as_data_len
          check_as_data_len
          flag_skip_multi_packet
          RecvMachInfo
          TotalRequestCnt
          CompareAsterisk
          tp_cm_bam_TotPacketNum
          Uart2_RxMsg_AS_Phone_Data
          Uart2_RxMsg_Multi_145
          tp_cm_bam
          Flag_SerialRxMsg
          Uart2_RxMsg_Save_Data1
          Uart2_RxMsg_Save_Data2
          Uart2_RxMsg_Smk_Reg_Eli
          Uart2_RxMsg_Single_46
          Uart2_RxMsg_Single_69
          Uart2_RxMsg_Multi_69
          Uart2_RxMsg_Single_160
          Uart2_RxMsg_Multi_161
          Uart2_RxMsg_Single_163
          Uart2_RxMsg_Single_174
          Uart2_RxMsg_Single_251
          Uart2_RxMsg_Single_252
          Uart2_RxMsg_Single_253
          Uart2_RxMsg_Single_239
          Uart2_RxMsg_Single_239_121
          Uart2_RxMsg_Single_11
          Uart2_RxMsg_Single_12
          Uart2_RxMsg_Single_21
          Uart2_RxMsg_Multi_23
          Uart2_RxMsg_Single_61
          Uart2_RxMsg_Single_62
          Uart2_RxMsg_Single_101
          Uart2_RxMsg_Single_104
          Uart2_RxMsg_Single_105
          Uart2_RxMsg_Single_109
          Uart2_RxMsg_Single_121
          Uart2_RxMsg_Single_123
          Uart2_RxMsg_Single_201
          Uart2_RxMsg_Single_203
          Uart2_RxMsg_Single_47
          Uart2_RxMsg_Single_247
      16  tmpbuf_AS

 
 8 378 bytes in section .bss
 2 404 bytes in section .text
 
 2 384 bytes of CODE memory (+ 20 bytes shared)
 8 378 bytes of DATA memory

Errors: none
Warnings: 1
