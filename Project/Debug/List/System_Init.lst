###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      06/Mar/2013  19:53:58 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\System_Init.c                                    #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\System_Init.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\System #
#                    _Init.lst                                                #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\System_ #
#                    Init.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\System_Init.c
      1          /**
      2            ******************************************************************************
      3            * @file    System_Init.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   System_Init.c module
      8            *
      9            * Project Name       : WL9F Display APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Display_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Display_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          /* Private function prototypes -----------------------------------------------*/
     29          /* Private functions ---------------------------------------------------------*/
     30          
     31          void Init_RTC(void)
     32          {
     33              WL9FM_RTC.Year   = 0;
     34          	WL9FM_RTC.Month  = 1;
     35          	WL9FM_RTC.Date   = 1;
     36          	WL9FM_RTC.Day    = 1;
     37          	WL9FM_RTC.Hour   = 12;
     38          	WL9FM_RTC.Minute = 0;
     39          	WL9FM_RTC.Second = 0;
     40          
     41          	WRITE_RTC(WL9FM_RTC);
     42          }
     43          
     44          void InitE2PROM(void)
     45          {
     46          	u8 i;
     47          	u8 tmpBuf1[8];
     48          	u8 tmpBuf2[8];
     49          	u8 tmpBuf3[8];
     50          	u8 tmpBuf4[21];
     51          	
     52          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
     53          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
     54          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
     55          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
     56          
     57          	SaveE2PROM1->WorkLoad 				= 0;
     58          	SaveE2PROM1->testWorkLoad 			= 0;
     59          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
     60          	SaveE2PROM1->DispType	 			= 0;
     61          	SaveE2PROM1->InfoViewPriority 		= 0;
     62          	SaveE2PROM1->UnitPressure 			= 0;
     63          	SaveE2PROM1->Reserved0 				= 0;
     64          	SaveE2PROM1->Lang 					= 0;
     65          	SaveE2PROM1->ManualBackLight 		= 7;
     66          	SaveE2PROM1->AutoBackLight 			= 0;
     67          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
     68          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
     69          	SaveE2PROM1->InfoViewCnt 			= 2;
     70          	SaveE2PROM1->HR_Start 				= 0;
     71          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
     72          	SaveE2PROM1->ActiveCamNum 			= 1;
     73          	SaveE2PROM1->FirstCam 				= 0;
     74          	SaveE2PROM1->SecondCam 				= 1;
     75          	SaveE2PROM1->ThirdCam 				= 2;
     76          	SaveE2PROM1->Reserved1 				= 0;
     77          
     78          	SaveE2PROM2->LightMode 				= 0;
     79          	SaveE2PROM2->JobTimeView 			= 0;
     80          	SaveE2PROM2->OdoMeterView 			= 0;
     81          	SaveE2PROM2->JobOdoSelect 			= 0;
     82          	SaveE2PROM2->LightLowTime 			= 8;
     83          	SaveE2PROM2->LightUpperTime 		= 16;
     84          	SaveE2PROM2->AutoLightDay 			= 0;
     85          	SaveE2PROM2->AutoLightNight 		= 0;
     86          	SaveE2PROM2->Reserved1 				= 0;
     87          
     88          	SaveE2PROM3->Phone_1  				= 0;
     89          	SaveE2PROM3->Phone_2  				= 8;
     90          	SaveE2PROM3->Phone_3  				= 0;
     91          	SaveE2PROM3->Phone_4  				= 5;
     92          	SaveE2PROM3->Phone_5  				= 5;
     93          	SaveE2PROM3->Phone_6  				= 5;
     94          	SaveE2PROM3->Phone_7  				= 8;
     95          	SaveE2PROM3->Phone_8  				= 2;
     96          	SaveE2PROM3->Phone_9  				= 7;
     97          	SaveE2PROM3->Phone_10 				= 2;
     98          	SaveE2PROM3->Phone_11 				= 0xf;
     99          	SaveE2PROM3->Phone_12 				= 0xf;
    100          
    101          #if 1	// Monitor Change History - temp
    102          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    103          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    104          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    105          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    106          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    107          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    108          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    109          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    110          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    111          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    112          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    113          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    114          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    115          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    116          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    117          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    118          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    119          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    120          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    121          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    122          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    123          #endif
    124          
    125          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    126          
    127          	EEPROM_Write(0, 0);	// tmp
    128          	EEPROM_Write(0, 0);	// tmp
    129          	EEPROM_Write(0, 0);	// tmp
    130          
    131          	for(i = 0 ; i < 8 ; i++)
    132          	{
    133          		EEPROM_Write(i+8, tmpBuf1[i]);
    134          		TimeDelay_msec(5);
    135          		EEPROM_Write(i+16, tmpBuf2[i]);
    136          		TimeDelay_msec(5);
    137          		EEPROM_Write(i+24, tmpBuf3[i]);
    138          		TimeDelay_msec(5);
    139          	}
    140          
    141          	SerialPutString("Initialize : 30 %%\n\r");
    142          	
    143          #if 1	// Monitor Change History - temp
    144          	for(i = 0 ; i < 21 ; i++)
    145          	{
    146          		EEPROM_Write(i+50, tmpBuf4[i]);
    147          		TimeDelay_msec(5);
    148          	}
    149          #endif
    150          
    151          	for(i = 0 ; i < 79 ; i++)
    152          	{
    153          		EEPROM_Write(i+100, 0xff);
    154          		TimeDelay_msec(5);
    155          	}
    156          
    157          	SerialPutString("Initialize : 60 %%\n\r");
    158          
    159          	for(i = 0 ; i < 30 ; i++)
    160          	{
    161          		EEPROM_Write(i+200, 0xff);
    162          		TimeDelay_msec(5);
    163          	}
    164          
    165          	for(i = 0 ; i < 29 ; i++)
    166          	{
    167          		EEPROM_Write(i+230, 0xff);
    168          		TimeDelay_msec(5);
    169          	}
    170          
    171          	SerialPutString("Initialize : 95 %%\n\r");
    172          	Init_RTC();
    173          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    174          }
    175          
    176          /**
    177            * @brief  Clock Setting.
    178            * @param  None
    179            * @retval None
    180            */
    181          void RCC_Configuration(void)
    182          {
    183          	RCC_ClocksTypeDef RCC_Clocks;
    184          
    185            	//	SysTick end of count event each 1ms
    186            	RCC_GetClocksFreq(&RCC_Clocks);
    187          
    188          	//	SysTick Timer을 사용하려면, 아래의 설정을 해야되고, 아래의 설정값은 1msec 설정이다.
    189          	#if 1		
    190          	//	Setup SysTick Timer for 1 msec interrupts
    191          	if (SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000))
    192          	{ 
    193          	    /* Capture error */ 
    194              	while (1);
    195            	}
    196          	#endif
    197          	
    198          	RCC_ClockSecuritySystemCmd(ENABLE);
    199          
    200          /**
    201            * @brief  Enables or disables the AHB1 peripheral clock.
    202            * @note   After reset, the peripheral clock (used for registers read/write access)
    203            *         is disabled and the application software has to enable this clock before 
    204            *         using it.   
    205            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
    206            *          This parameter can be any combination of the following values:
    207            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
    208            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
    209            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
    210            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
    211            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
    212            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
    213            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
    214            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
    215            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
    216            *            @arg RCC_AHB1Periph_CRC:         CRC clock
    217            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
    218            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
    219            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
    220            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
    221            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
    222            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
    223            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
    224            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
    225            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
    226            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
    227            * @param  NewState: new state of the specified peripheral clock.
    228            *          This parameter can be: ENABLE or DISABLE.
    229            * @retval None
    230            */
    231          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    232          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    233          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    234          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    235          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    236          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);	
    237          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    238          
    239          /**
    240            * @brief  Enables or disables the AHB2 peripheral clock.
    241            * @note   After reset, the peripheral clock (used for registers read/write access)
    242            *         is disabled and the application software has to enable this clock before 
    243            *         using it. 
    244            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
    245            *          This parameter can be any combination of the following values:
    246            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
    247            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
    248            *            @arg RCC_AHB2Periph_HASH:   HASH clock
    249            *            @arg RCC_AHB2Periph_RNG:    RNG clock
    250            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
    251            * @param  NewState: new state of the specified peripheral clock.
    252            *          This parameter can be: ENABLE or DISABLE.
    253            * @retval None
    254            */
    255          	//RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
    256          
    257          /**
    258            * @brief  Enables or disables the AHB3 peripheral clock.
    259            * @note   After reset, the peripheral clock (used for registers read/write access)
    260            *         is disabled and the application software has to enable this clock before 
    261            *         using it. 
    262            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
    263            *          This parameter must be: RCC_AHB3Periph_FSMC
    264            * @param  NewState: new state of the specified peripheral clock.
    265            *          This parameter can be: ENABLE or DISABLE.
    266            * @retval None
    267            */
    268          	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    269          
    270          /**
    271            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
    272            * @note   After reset, the peripheral clock (used for registers read/write access)
    273            *         is disabled and the application software has to enable this clock before 
    274            *         using it. 
    275            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
    276            *          This parameter can be any combination of the following values:
    277            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
    278            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
    279            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
    280            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
    281            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
    282            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
    283            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
    284            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
    285            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
    286            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
    287            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
    288            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
    289            *            @arg RCC_APB1Periph_USART2: USART2 clock
    290            *            @arg RCC_APB1Periph_USART3: USART3 clock
    291            *            @arg RCC_APB1Periph_UART4:  UART4 clock
    292            *            @arg RCC_APB1Periph_UART5:  UART5 clock
    293            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
    294            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
    295            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
    296            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
    297            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
    298            *            @arg RCC_APB1Periph_PWR:    PWR clock
    299            *            @arg RCC_APB1Periph_DAC:    DAC clock
    300            * @param  NewState: new state of the specified peripheral clock.
    301            *          This parameter can be: ENABLE or DISABLE.
    302            * @retval None
    303            */
    304          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2  , ENABLE);
    305          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    306          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4 , ENABLE);
    307          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2  , ENABLE);
    308          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1  , ENABLE);
    309          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2  , ENABLE);
    310          
    311          /**
    312            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
    313            * @note   After reset, the peripheral clock (used for registers read/write access)
    314            *         is disabled and the application software has to enable this clock before 
    315            *         using it.
    316            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
    317            *          This parameter can be any combination of the following values:
    318            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
    319            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
    320            *            @arg RCC_APB2Periph_USART1: USART1 clock
    321            *            @arg RCC_APB2Periph_USART6: USART6 clock
    322            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
    323            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
    324            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
    325            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
    326            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
    327            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
    328            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
    329            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
    330            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
    331            * @param  NewState: new state of the specified peripheral clock.
    332            *          This parameter can be: ENABLE or DISABLE.
    333            * @retval None
    334            */
    335          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
    336          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    337          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    338          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
    339          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
    340          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
    341          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    342          }
    343          
    344          /* Private functions ---------------------------------------------------------*/
    345          /**
    346            * @brief  NVIC Setting.
    347            * @param  Configures Vector Table base location.
    348            * @retval None
    349            */
    350          void NVIC_Configuration(void)
    351          {
    352          	//	Set the Vector Table base location at 0x08004000
    353              NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x4000);   
    354          }
    355          
    356          /* Private functions ---------------------------------------------------------*/
    357          /**
    358            * @brief  GPIO Setting.
    359            * @param  Configures the different GPIO ports.
    360            * @retval None
    361            */
    362          void GPIO_Configuration(void)
    363          {
    364              GPIO_InitTypeDef GPIO_InitStructure;
    365          
    366          
    367              //  Configure UART1 pins: DEBUG_UART1TX, DEBUG_UART1RX 
    368              //  UART1은 Debugging으로 사용한다. 이미 설정되어 있음.
    369              #if 0
    370          
    371              GPIO_InitStructure.GPIO_Pin   = DEBUG_UART1TX | DEBUG_UART1RX;
    372              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    373            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    374            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    375              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    376              GPIO_Init(DEBUG_UART1_PORT, &GPIO_InitStructure);
    377          
    378          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1TX_PinSource, GPIO_AF_USART1);
    379          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1RX_PinSource, GPIO_AF_USART1);
    380          	
    381              #endif    
    382             
    383              //  CAN1_TX, CAN1_RX
    384              GPIO_InitStructure.GPIO_Pin   = CAN1_TX | CAN1_RX;
    385              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    386            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    387            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    388              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    389              GPIO_Init(CAN1_PORT, &GPIO_InitStructure);
    390          	GPIO_PinAFConfig(CAN1_PORT, CAN1_TX_PinSource, GPIO_AF_CAN1);
    391          	GPIO_PinAFConfig(CAN1_PORT, CAN1_RX_PinSource, GPIO_AF_CAN1);
    392          
    393              //  CAN2_TX, CAN2_RX
    394              GPIO_InitStructure.GPIO_Pin   = CAN2_TX | CAN2_RX;
    395              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    396            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    397            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    398              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    399              GPIO_Init(CAN2_PORT, &GPIO_InitStructure);
    400          	GPIO_PinAFConfig(CAN2_PORT, CAN2_TX_PinSource, GPIO_AF_CAN2);
    401          	GPIO_PinAFConfig(CAN2_PORT, CAN2_RX_PinSource, GPIO_AF_CAN2);
    402          
    403          	//	STM32 UART2 <-> EXYNOS UART1
    404              GPIO_InitStructure.GPIO_Pin   = UART2TX_EXYNOS1 | UART2RX_EXYNOS1;
    405              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    406            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    407            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    408              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    409              GPIO_Init(UART2_EXYNOS1_PORT, &GPIO_InitStructure);
    410          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2TX_EXYNOS1_PinSource, GPIO_AF_USART2);
    411          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2RX_EXYNOS1_PinSource, GPIO_AF_USART2);
    412          
    413          	//	STM32 UART4 <-> EXYNOS UART3
    414              GPIO_InitStructure.GPIO_Pin   = UART4TX_EXYNOS3 | UART4RX_EXYNOS3;
    415              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    416            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    417            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    418              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    419              GPIO_Init(UART4_EXYNOS3_PORT, &GPIO_InitStructure);
    420          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4TX_EXYNOS3_PinSource, GPIO_AF_USART2);
    421          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4RX_EXYNOS3_PinSource, GPIO_AF_USART2);
    422          	
    423          	//  EXYNOS PWR_CTRL -> GPIO Output
    424              GPIO_InitStructure.GPIO_Pin   = EXYNOS_PWR_CTRL;
    425              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    426            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    427            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    428              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    429              GPIO_Init(EXYNOS_PWR_CTRL_PORT, &GPIO_InitStructure);
    430          
    431          	//  EXYNOS PMIC_CTRL -> GPIO Output
    432              GPIO_InitStructure.GPIO_Pin   = EXYNOS_PMIC_CTRL;
    433              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    434            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    435            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    436              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    437              GPIO_Init(EXYNOS_PMIC_CTRL_PORT, &GPIO_InitStructure);
    438          
    439          	//	Serial Flash -> STM32 Update (SPI1)
    440              GPIO_InitStructure.GPIO_Pin   = SFLASH_SPI1_CS | SFLASH_SPI1_SCK | SFLASH_SPI1_MISO | SFLASH_SPI1_MOSI;
    441              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    442            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    443            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    444              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    445              GPIO_Init(SFLASH_SPI1_PORT, &GPIO_InitStructure);
    446          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_CS_PinSource, GPIO_AF_SPI1);
    447          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_SCK_PinSource, GPIO_AF_SPI1);
    448          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_MISO_PinSource, GPIO_AF_SPI1);
    449          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_MOSI_PinSource, GPIO_AF_SPI1);
    450          
    451              GPIO_InitStructure.GPIO_Pin   = SFLASH_HOLD | SFLASH_WP;
    452              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    453            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    454            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    455              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    456              GPIO_Init(SFLASH_PORT, &GPIO_InitStructure);
    457          	
    458          	//	TW8832 -> I2C2
    459              GPIO_InitStructure.GPIO_Pin   = TW8832_I2C2_SCL | TW8832_I2C2_SDA;
    460              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    461            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    462            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    463              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    464              GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);
    465          	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SCL_PinSource, GPIO_AF_I2C2);
    466          	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SDA_PinSource, GPIO_AF_I2C2);
    467          
    468          	//	TW8832 SPI2 Control/Serial Flash(OSD)
    469              GPIO_InitStructure.GPIO_Pin   = TW8832_SFLASH_SPI2_CS | TW8832_SFLASH_SPI2_SCK | TW8832_SFLASH_SPI2_MISO | TW8832_SFLASH_SPI2_MOSI;
    470              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    471            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    472            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    473              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    474              GPIO_Init(TW8832_SFLASH_SPI2_PORT, &GPIO_InitStructure);
    475          	GPIO_PinAFConfig(TW8832_SFLASH_SPI2_PORT, TW8832_SFLASH_SPI2_CS_PinSource, GPIO_AF_SPI2);
    476          	GPIO_PinAFConfig(TW8832_SFLASH_SPI2_PORT, TW8832_SFLASH_SPI2_SCK_PinSource, GPIO_AF_SPI2);
    477          	GPIO_PinAFConfig(TW8832_SFLASH_SPI2_PORT, TW8832_SFLASH_SPI2_MISO_PinSource, GPIO_AF_SPI2);
    478          	GPIO_PinAFConfig(TW8832_SFLASH_SPI2_PORT, TW8832_SFLASH_SPI2_MOSI_PinSource, GPIO_AF_SPI2);
    479          
    480          	//	Hardware Version -> ADC
    481              GPIO_InitStructure.GPIO_Pin   = HW_VERSION;
    482              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;   
    483            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    484              GPIO_Init(HW_VERSION_PORT, &GPIO_InitStructure);
    485          
    486          	//	KeySwitch -> GPIO Input
    487              GPIO_InitStructure.GPIO_Pin   = KeySW0 | KeySW1 | KeySW2 | KeySW3 | KeySW4;
    488              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    489            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    490            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    491              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    492              GPIO_Init(KeySWx_PORT, &GPIO_InitStructure);
    493          
    494          	//  POWER_IGMON -> GPIO Input
    495              GPIO_InitStructure.GPIO_Pin   = PWR_IGMON;
    496              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    497            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    498            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    499              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    500              GPIO_Init(PWR_IGMON_PORT, &GPIO_InitStructure);
    501          	
    502          	//  POWER_CTRL -> GPIO Output
    503              GPIO_InitStructure.GPIO_Pin   = PWR_CTRL;
    504              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    505            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    506            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    507              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    508              GPIO_Init(PWR_CTRL_PORT, &GPIO_InitStructure);
    509          
    510          	//  LCDPWR_CTRL -> GPIO Output
    511              GPIO_InitStructure.GPIO_Pin   = LCDPWR_CTRL;
    512              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    513            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    514            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    515              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    516              GPIO_Init(LCDPWR_PORT, &GPIO_InitStructure);
    517          
    518          	//  FW_UPDATE -> GPIO Input
    519              GPIO_InitStructure.GPIO_Pin   = FW_UPDATE;
    520              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    521            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    522            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    523              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    524              GPIO_Init(FW_UPDATE_PORT, &GPIO_InitStructure);
    525          	
    526          	//	LCDBL_PWM -> PWM
    527              GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    528              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    529            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    530            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    531              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    532              GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    533          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    534          
    535          	//  LCDBL_CTRL -> GPIO Output
    536              GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    537              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    538            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    539            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    540              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    541              GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    542          	
    543          	//  LCD_STM32 -> GPIO Output
    544              GPIO_InitStructure.GPIO_Pin   = LCD_STM32;
    545              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    546            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    547            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    548              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    549              GPIO_Init(LCD_STM32_PORT, &GPIO_InitStructure);
    550          
    551          	//  LCD_EXYNOS -> GPIO Output
    552              GPIO_InitStructure.GPIO_Pin   = LCD_EXYNOS;
    553              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    554            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    555            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    556              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    557              GPIO_Init(LCD_EXYNOS_PORT, &GPIO_InitStructure);
    558          
    559          	//  BUZZER_CTRL -> GPIO Output
    560              GPIO_InitStructure.GPIO_Pin   = BUZZER_CTRL;
    561              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    562            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    563            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    564              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    565              GPIO_Init(BUZZER_PORT, &GPIO_InitStructure);
    566          
    567          	//  LED_CTRL -> GPIO Output
    568              GPIO_InitStructure.GPIO_Pin   = LED_CTRL;
    569              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    570            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    571            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    572              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    573              GPIO_Init(LED_PORT, &GPIO_InitStructure);
    574          
    575          	//  FM31X4(EEPROM) -> GPIO Output
    576          	//  GPIO로 I2C1 사용
    577              //  Alternate Function 사용안함
    578              GPIO_InitStructure.GPIO_Pin   = FM31X4_I2C1_SCL | FM31X4_I2C1_SDA;
    579              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    580            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    581            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    582              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    583              GPIO_Init(FM31X4_I2C1_PORT, &GPIO_InitStructure);
    584          	
    585          	//  TW2835 -> GPIO Output
    586              GPIO_InitStructure.GPIO_Pin   = TW2835_IRQ| TW2835_HALE | TW2835_HSPB;
    587              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    588            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    589            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    590              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    591              GPIO_Init(TW2835_PORT, &GPIO_InitStructure);
    592          
    593          	//  DPRAM -> GPIO Output
    594              GPIO_InitStructure.GPIO_Pin   = DPRAM_INT | DPRAM_ADVL;
    595              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    596            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    597            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    598              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    599              GPIO_Init(DPRAM_PORT, &GPIO_InitStructure);
    600          
    601          	//  CAMERA nRESET -> GPIO Output
    602              GPIO_InitStructure.GPIO_Pin   = CAMERA_nRESET;
    603              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    604            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    605            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    606              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    607              GPIO_Init(CAMERA_nRESET_PORT, &GPIO_InitStructure);
    608          
    609          
    610              // 	FSMC Data Line
    611              //  D15 ~ D0 : D15  D14  D13 D12  D11  D10  D9   D8   D7   D6  D5  D4  D3  D2  D1   D0   
    612              //             PD10 PD9  PD8 PE15 PE14 PE13 PE12 PE11 PE10 PE9 PE8 PE7 PD1 PD0 PD15 PD14
    613              
    614              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10| GPIO_Pin_9  | GPIO_Pin_8 | GPIO_Pin_1 |
    615                                              GPIO_Pin_0 | GPIO_Pin_15 | GPIO_Pin_14;
    616              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    617            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    618          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    619              GPIO_Init(GPIOD, &GPIO_InitStructure);
    620          
    621          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
    622          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9 , GPIO_AF_FSMC);
    623          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8 , GPIO_AF_FSMC);
    624          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1 , GPIO_AF_FSMC);
    625          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0 , GPIO_AF_FSMC);
    626          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
    627          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);	
    628            
    629              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12 |
    630                                              GPIO_Pin_11 | GPIO_Pin_10 | GPIO_Pin_9  |
    631                                              GPIO_Pin_8  | GPIO_Pin_7;
    632              GPIO_Init(GPIOE, &GPIO_InitStructure);
    633          
    634          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);
    635          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
    636          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
    637          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
    638          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);
    639          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
    640          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);	
    641          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);	
    642          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);	
    643          	
    644              //  FSMC Address Line
    645              //  A25 ~ A10 : A25  A24   A23  A22  A21  A20  A19  A18  A17  A16  A15 A14 A13 A12 A11 A10
    646              //              PG14 PG13  PE2  PE6  PE5  PE4  PE3  PD13 PD12 PD11 PG5 PG4 PG3 PG2 PG1 PG0           
    647              //  A9  ~ A0  : A9   A8   A7   A6   A5  A4  A3  A2  A1  A0
    648              //              PF15 PF14 PF13 PF12 PF5 PF4 PF3 PF2 PF1 PF0
    649          
    650              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12 |
    651                                              GPIO_Pin_5  | GPIO_Pin_4  | GPIO_Pin_3  | GPIO_Pin_2  |
    652                                              GPIO_Pin_1  | GPIO_Pin_0;
    653              GPIO_Init(GPIOF, &GPIO_InitStructure);
    654          
    655          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource15, GPIO_AF_FSMC);
    656          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
    657          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
    658          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource12, GPIO_AF_FSMC);
    659          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource5 , GPIO_AF_FSMC);
    660          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource4 , GPIO_AF_FSMC);
    661          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource3 , GPIO_AF_FSMC);	
    662          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource2 , GPIO_AF_FSMC);	
    663          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource1 , GPIO_AF_FSMC);	
    664          	GPIO_PinAFConfig(GPIOF, GPIO_PinSource0 , GPIO_AF_FSMC);
    665          	
    666              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_5 |
    667                                              GPIO_Pin_4  | GPIO_Pin_3  | GPIO_Pin_2 |
    668              	                            GPIO_Pin_1  | GPIO_Pin_0;
    669              GPIO_Init(GPIOG, &GPIO_InitStructure);
    670          
    671          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_FSMC);
    672          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_FSMC);
    673          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource5 , GPIO_AF_FSMC);
    674          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource4 , GPIO_AF_FSMC);
    675          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource3 , GPIO_AF_FSMC);	
    676          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource2 , GPIO_AF_FSMC);	
    677          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource1 , GPIO_AF_FSMC);	
    678          	GPIO_PinAFConfig(GPIOG, GPIO_PinSource0 , GPIO_AF_FSMC);
    679              
    680              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_12 | GPIO_Pin_11;
    681              GPIO_Init(GPIOD, &GPIO_InitStructure);
    682          
    683          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);	
    684          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);	
    685          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
    686          
    687              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_6 | GPIO_Pin_5 | GPIO_Pin_4 | GPIO_Pin_3;
    688              GPIO_Init(GPIOE, &GPIO_InitStructure);
    689          
    690          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource2, GPIO_AF_FSMC);
    691          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource6, GPIO_AF_FSMC);
    692          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5, GPIO_AF_FSMC);
    693          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4, GPIO_AF_FSMC);
    694          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource3, GPIO_AF_FSMC);	
    695          
    696              //  nCLK, nOE, nWE, nWait
    697              GPIO_InitStructure.GPIO_Pin = FSMC_nOE | FSMC_nWE | FSMC_nWAIT | FSMC_nCLK;
    698              GPIO_Init(FSMC_PORT, &GPIO_InitStructure);
    699          
    700          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nOE_PinSource  , GPIO_AF_FSMC);
    701          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWE_PinSource  , GPIO_AF_FSMC);
    702          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWAIT_PinSource, GPIO_AF_FSMC);
    703          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nCLK_PinSource , GPIO_AF_FSMC);
    704          
    705              //  nBL0, nBL1
    706              GPIO_InitStructure.GPIO_Pin = FSMC_nBL0 | FSMC_nBL1;
    707              GPIO_Init(FSMC_nBL_PORT, &GPIO_InitStructure);
    708          
    709          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL0_PinSource  , GPIO_AF_FSMC);
    710          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL1_PinSource  , GPIO_AF_FSMC);
    711              
    712              // NE1, NE2, NE3, NE4 configuration
    713              GPIO_InitStructure.GPIO_Pin = FSMC_nNE1;
    714              GPIO_Init(FSMC_nNE1_PORT, &GPIO_InitStructure);
    715          
    716          	GPIO_PinAFConfig(FSMC_nNE1_PORT, FSMC_nNE1_PinSource  , GPIO_AF_FSMC);
    717          	
    718              GPIO_InitStructure.GPIO_Pin = FSMC_nNE2;
    719              GPIO_Init(FSMC_nNE2_PORT, &GPIO_InitStructure);    
    720          
    721          	GPIO_PinAFConfig(FSMC_nNE2_PORT, FSMC_nNE2_PinSource  , GPIO_AF_FSMC);
    722              
    723              GPIO_InitStructure.GPIO_Pin = FSMC_nNE3;
    724              GPIO_Init(FSMC_nNE3_PORT, &GPIO_InitStructure);
    725          
    726          	GPIO_PinAFConfig(FSMC_nNE3_PORT, FSMC_nNE3_PinSource  , GPIO_AF_FSMC);
    727              
    728              GPIO_InitStructure.GPIO_Pin = FSMC_nNE4;
    729              GPIO_Init(FSMC_nNE4_PORT, &GPIO_InitStructure);    
    730          
    731          	GPIO_PinAFConfig(FSMC_nNE4_PORT, FSMC_nNE4_PinSource  , GPIO_AF_FSMC);
    732          
    733              //  사용하지 않는 GPIO Pin은 Output -> Low 상태로 만들어 놓는다.
    734              GPIO_Configuration_NotUsed();
    735          }
    736          
    737          /**
    738            * @brief  GPIO Setting.
    739            * @param  Configures the different GPIO ports. (사용하지 않는 GPIO는 Output Low 상태로 만든다.)
    740            * @retval None
    741            */
    742          void GPIO_Configuration_NotUsed(void)
    743          {
    744              GPIO_InitTypeDef GPIO_InitStructure;
    745          
    746          	//  PC2
    747              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
    748              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    749            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    750            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    751              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    752              GPIO_Init(GPIOC, &GPIO_InitStructure);
    753          
    754          	//  PC8
    755              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_8;
    756              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    757            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    758            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    759              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    760              GPIO_Init(GPIOC, &GPIO_InitStructure);
    761          
    762          	//  PB7
    763              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
    764              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    765            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    766            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    767              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    768              GPIO_Init(GPIOB, &GPIO_InitStructure);
    769          
    770          	//  PC15
    771              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15;
    772              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    773            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    774            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    775              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    776              GPIO_Init(GPIOC, &GPIO_InitStructure);
    777          	
    778              GPIO_ResetBits(GPIOC, GPIO_Pin_2);
    779              GPIO_ResetBits(GPIOC, GPIO_Pin_8);
    780              GPIO_ResetBits(GPIOC, GPIO_Pin_15);
    781              GPIO_ResetBits(GPIOB, GPIO_Pin_7);	
    782          }
    783          
    784          /**
    785            * @brief  Hardware, Software System Configuration.
    786            * @param  None
    787            * @retval None
    788            */
    789          void System_Configuration(void)
    790          {
    791          	RCC_Configuration();		    // 	Configure the system clocks
    792          	NVIC_Configuration();		    //	NVIC Configuration
    793          	GPIO_Configuration();		    // 	Configure the GPIO ports
    794          }
    795          
    796          void System_Initialize(void)
    797          {
    798          	//  PWR_CTRL -> BootLoader에서는 Sub Power Enable을 Off 
    799              GPIO_ResetBits(PWR_CTRL_PORT, PWR_CTRL);   	//	24V Power Enable 
    800                                                          //  Set   : Power Enable On
    801                                                          //  Reset : Power Enable Off    	
    802          
    803              //  LCDPWR_CTRL -> BootLoader에서는 VLCD12 Power Enable을 Off 
    804              GPIO_ResetBits(LCDPWR_PORT, LCDPWR_CTRL);  	//	LCD Power Enable 
    805                                                          //  Set   : LCD Power Enable 
    806                                                          //  Reset : LCD Power Disable	
    807          	// 	Exynos-4412에서 컨트롤 한다.
    808          	#if 0
    809          	//  BootLoader Bootting시에, BackLight는 All Off 상태로 만든다.
    810              GPIO_ResetBits(LCDBL_PORT, LCDBL_CTRL);	    //	LCD BackLight Power On/Off (LCDBL_CTRL)
    811                                                         	//  Set   : BackLight Power On
    812                                                         	//  Reset : BackLight Power Off			
    813                                                         	
    814              GPIO_ResetBits(LCDBL_PORT, LCDBL_PWM);		//	LCD BackLight PWM, Brightness Adjust (LCDBL_PWM)
    815                                                          //  Default Set                                               	
    816          	#endif                                               	
    817          
    818              GPIO_ResetBits(BUZZER_PORT, BUZZER_CTRL);	//	BUZZER Off
    819                                                          //  Set   : BUZZER On
    820                                                          //  Reset : BUZZER Off
    821            
    822              GPIO_ResetBits(LED_PORT, LED_CTRL);			//	LED Enable Off
    823                                                          //  Set   : LED Enable  -> On
    824                                                          //  Reset : LED Disable -> Off
    825          
    826              GPIO_ResetBits(EXYNOS_PWR_CTRL_PORT, EXYNOS_PWR_CTRL);	//	Exynos-4412 Power On/Off
    827                                                          			//  Set   : Exynos-4412 -> Power On
    828                                                          			//  Reset : Exynos-4412 -> Power Off
    829                                                          			
    830              GPIO_ResetBits(EXYNOS_PMIC_CTRL_PORT, EXYNOS_PMIC_CTRL);	//	Exynos-4412 PMIC On/Off
    831                                                          				//  PMIC On  : Low -> High
    832                                                          				//       Off : Low -> High
    833          
    834              GPIO_SetBits(LCD_EXYNOS_PORT, LCD_EXYNOS);	//	Exynos-4412 LCD Display
    835                                                          //  Set   : HI-Z
    836                                                          //  Reset : Display
    837          	                                                				
    838              GPIO_ResetBits(LCD_STM32_PORT, LCD_STM32);	//	STM32 LCD Display
    839                                                          //  Set   : HI-Z
    840                                                          //  Reset : Display
    841          	
    842          	GPIO_ResetBits(CAMERA_nRESET_PORT, CAMERA_nRESET);	//	CAMERA nRESET
    843          		                                                //  Set   : On
    844                  		                                        //  Reset : Off												
    845          }
    846          
    847          void System_Variable_Init(void)
    848          {
    849          	memset((void *)(&WL9FM_TIME),       	0x0, sizeof(WL9F_TIME_DATA));
    850              memset((void *)(&WL9FM_RTC),            0x0, sizeof(WL9F_DATA_RTC));	
    851          }
    852          
    853          void WL9F_System_Init_Start(void)
    854          {
    855          
    856          }
    857          /*********(C) COPYRIGHT 2013 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
    858          
    859          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   GPIO_Configuration
        48   -> GPIO_Configuration_NotUsed
        48   -> GPIO_Init
        48   -> GPIO_PinAFConfig
      24   GPIO_Configuration_NotUsed
        24   -> GPIO_Init
        24   -> GPIO_ResetBits
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
        16   -> __aeabi_memcpy
       0   NVIC_Configuration
         0   -> NVIC_SetVectorTable
      24   RCC_Configuration
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_AHB3PeriphClockCmd
        24   -> RCC_APB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
        24   -> RCC_ClockSecuritySystemCmd
        24   -> RCC_GetClocksFreq
       8   System_Configuration
         0   -> GPIO_Configuration
         8   -> NVIC_SetVectorTable
         8   -> RCC_Configuration
      16   System_Initialize
         0   -> GPIO_ResetBits
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       4   System_Variable_Init
         0   -> __aeabi_memclr
         4   -> __aeabi_memclr4
       0   WL9F_System_Init_Start


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
    1862  GPIO_Configuration
     196  GPIO_Configuration_NotUsed
     470  InitE2PROM
      50  Init_RTC
      12  NVIC_Configuration
     226  RCC_Configuration
      26  System_Configuration
      94  System_Initialize
      22  System_Variable_Init
       2  WL9F_System_Init_Start

 
 3 020 bytes in section .text
 
 3 020 bytes of CODE memory

Errors: none
Warnings: none
