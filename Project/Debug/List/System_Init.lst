###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:35 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\System_Init.c                                    #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\System_Init.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\System #
#                    _Init.lst                                                #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\System_ #
#                    Init.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\System_Init.c
      1          /**
      2            ******************************************************************************
      3            * @file    System_Init.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   System_Init.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          /* Private function prototypes -----------------------------------------------*/
     29          /* Private functions ---------------------------------------------------------*/
     30          
     31          
     32          /**
     33            * @brief  Clock Setting.
     34            * @param  None
     35            * @retval None
     36            */
     37          void RCC_Configuration(void)
     38          {
     39          	RCC_ClocksTypeDef RCC_Clocks;
     40          
     41            	//	SysTick end of count event each 1ms
     42            	RCC_GetClocksFreq(&RCC_Clocks);
     43          
     44          	//	SysTick Timer을 사용하려면, 아래의 설정을 해야되고, 아래의 설정값은 1msec 설정이다.
     45          	#if 1		
     46          	//	Setup SysTick Timer for 1 msec interrupts
     47          	if (SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000))
     48          	{ 
     49          	    /* Capture error */ 
     50              	while (1);
     51            	}
     52          	#endif
     53          	
     54          	RCC_ClockSecuritySystemCmd(ENABLE);
     55          
     56          /**
     57            * @brief  Enables or disables the AHB1 peripheral clock.
     58            * @note   After reset, the peripheral clock (used for registers read/write access)
     59            *         is disabled and the application software has to enable this clock before 
     60            *         using it.   
     61            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
     62            *          This parameter can be any combination of the following values:
     63            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
     64            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
     65            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
     66            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
     67            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
     68            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
     69            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
     70            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
     71            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
     72            *            @arg RCC_AHB1Periph_CRC:         CRC clock
     73            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
     74            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
     75            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
     76            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
     77            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
     78            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
     79            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
     80            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
     81            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
     82            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
     83            * @param  NewState: new state of the specified peripheral clock.
     84            *          This parameter can be: ENABLE or DISABLE.
     85            * @retval None
     86            */
     87          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
     88          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
     89          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
     90          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
     91          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
     92          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);	
     93          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
     94          
     95          /**
     96            * @brief  Enables or disables the AHB2 peripheral clock.
     97            * @note   After reset, the peripheral clock (used for registers read/write access)
     98            *         is disabled and the application software has to enable this clock before 
     99            *         using it. 
    100            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
    101            *          This parameter can be any combination of the following values:
    102            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
    103            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
    104            *            @arg RCC_AHB2Periph_HASH:   HASH clock
    105            *            @arg RCC_AHB2Periph_RNG:    RNG clock
    106            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
    107            * @param  NewState: new state of the specified peripheral clock.
    108            *          This parameter can be: ENABLE or DISABLE.
    109            * @retval None
    110            */
    111          	//RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
    112          
    113          /**
    114            * @brief  Enables or disables the AHB3 peripheral clock.
    115            * @note   After reset, the peripheral clock (used for registers read/write access)
    116            *         is disabled and the application software has to enable this clock before 
    117            *         using it. 
    118            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
    119            *          This parameter must be: RCC_AHB3Periph_FSMC
    120            * @param  NewState: new state of the specified peripheral clock.
    121            *          This parameter can be: ENABLE or DISABLE.
    122            * @retval None
    123            */
    124          	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    125          
    126          /**
    127            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
    128            * @note   After reset, the peripheral clock (used for registers read/write access)
    129            *         is disabled and the application software has to enable this clock before 
    130            *         using it. 
    131            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
    132            *          This parameter can be any combination of the following values:
    133            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
    134            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
    135            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
    136            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
    137            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
    138            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
    139            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
    140            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
    141            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
    142            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
    143            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
    144            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
    145            *            @arg RCC_APB1Periph_USART2: USART2 clock
    146            *            @arg RCC_APB1Periph_USART3: USART3 clock
    147            *            @arg RCC_APB1Periph_UART4:  UART4 clock
    148            *            @arg RCC_APB1Periph_UART5:  UART5 clock
    149            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
    150            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
    151            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
    152            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
    153            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
    154            *            @arg RCC_APB1Periph_PWR:    PWR clock
    155            *            @arg RCC_APB1Periph_DAC:    DAC clock
    156            * @param  NewState: new state of the specified peripheral clock.
    157            *          This parameter can be: ENABLE or DISABLE.
    158            * @retval None
    159            */
    160          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4  , ENABLE);
    161          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5  , ENABLE);
    162          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2  , ENABLE);
    163          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    164          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4 , ENABLE);
    165          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
    166          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1  , ENABLE);
    167          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2  , ENABLE);
    168          
    169          /**
    170            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
    171            * @note   After reset, the peripheral clock (used for registers read/write access)
    172            *         is disabled and the application software has to enable this clock before 
    173            *         using it.
    174            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
    175            *          This parameter can be any combination of the following values:
    176            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
    177            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
    178            *            @arg RCC_APB2Periph_USART1: USART1 clock
    179            *            @arg RCC_APB2Periph_USART6: USART6 clock
    180            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
    181            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
    182            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
    183            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
    184            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
    185            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
    186            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
    187            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
    188            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
    189            * @param  NewState: new state of the specified peripheral clock.
    190            *          This parameter can be: ENABLE or DISABLE.
    191            * @retval None
    192            */
    193          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8  , ENABLE);
    194          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    195          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    196          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
    197          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
    198          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1  , ENABLE);
    199          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    200          }
    201          
    202          /* Private functions ---------------------------------------------------------*/
    203          /**
    204            * @brief  NVIC Setting.
    205            * @param  Configures Vector Table base location.
    206            * @retval None
    207            */
    208          void NVIC_Configuration(void)
    209          {
    210          	//	Set the Vector Table base location at 0x08004000
    211              NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x4000);   
    212          }
    213          
    214          /* Private functions ---------------------------------------------------------*/
    215          /**
    216            * @brief  GPIO Setting.
    217            * @param  Configures the different GPIO ports.
    218            * @retval None
    219            */
    220          void GPIO_Configuration(void)
    221          {
    222              GPIO_InitTypeDef GPIO_InitStructure;
    223          
    224          
    225              //  Configure UART1 pins: DEBUG_UART1TX, DEBUG_UART1RX 
    226              //  UART1은 Debugging으로 사용한다. 이미 설정되어 있음.
    227              #if 0
    228          
    229              GPIO_InitStructure.GPIO_Pin   = DEBUG_UART1TX | DEBUG_UART1RX;
    230              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    231            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    232            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    233              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    234              GPIO_Init(DEBUG_UART1_PORT, &GPIO_InitStructure);
    235          
    236          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1TX_PinSource, GPIO_AF_USART1);
    237          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1RX_PinSource, GPIO_AF_USART1);
    238          	
    239              #endif    
    240             
    241              //  CAN1_TX, CAN1_RX
    242              GPIO_InitStructure.GPIO_Pin   = CAN1_TX | CAN1_RX;
    243              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    244            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    245            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    246              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    247              GPIO_Init(CAN1_PORT, &GPIO_InitStructure);
    248          	GPIO_PinAFConfig(CAN1_PORT, CAN1_TX_PinSource, GPIO_AF_CAN1);
    249          	GPIO_PinAFConfig(CAN1_PORT, CAN1_RX_PinSource, GPIO_AF_CAN1);
    250          
    251              //  CAN2_TX, CAN2_RX
    252              GPIO_InitStructure.GPIO_Pin   = CAN2_TX | CAN2_RX;
    253              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    254            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    255            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    256              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    257              GPIO_Init(CAN2_PORT, &GPIO_InitStructure);
    258          	GPIO_PinAFConfig(CAN2_PORT, CAN2_TX_PinSource, GPIO_AF_CAN2);
    259          	GPIO_PinAFConfig(CAN2_PORT, CAN2_RX_PinSource, GPIO_AF_CAN2);
    260          
    261          	//	STM32 UART2 <-> EXYNOS UART1
    262          	GPIO_InitStructure.GPIO_Pin   = UART2TX_EXYNOS1 | UART2RX_EXYNOS1;
    263          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    264          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    265          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    266          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    267          	GPIO_Init(UART2_EXYNOS1_PORT, &GPIO_InitStructure);
    268          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2TX_EXYNOS1_PinSource, GPIO_AF_USART2);
    269          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2RX_EXYNOS1_PinSource, GPIO_AF_USART2);
    270          
    271          	//	TW8832 -> I2C2
    272          	//  GPIO로 I2C2 사용
    273              //  Alternate Function 사용안함
    274          	#if 0
    275          	GPIO_InitStructure.GPIO_Pin   = TW8832_I2C2_SCL | TW8832_I2C2_SDA;
    276              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    277            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    278            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    279              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    280              GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);
    281          	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SCL_PinSource, GPIO_AF_I2C2);
    282          	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SDA_PinSource, GPIO_AF_I2C2);
    283          	#else
    284          	GPIO_InitStructure.GPIO_Pin   = TW8832_I2C2_SCL | TW8832_I2C2_SDA;
    285              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    286            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    287            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    288              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    289              GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);
    290          	#endif
    291          
    292          	//	STM32 UART4 <-> EXYNOS UART3
    293          	GPIO_InitStructure.GPIO_Pin   = UART4TX_EXYNOS3 | UART4RX_EXYNOS3;
    294          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    295          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    296          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    297          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    298          	GPIO_Init(UART4_EXYNOS3_PORT, &GPIO_InitStructure);
    299          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4TX_EXYNOS3_PinSource, GPIO_AF_UART4);
    300          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4RX_EXYNOS3_PinSource, GPIO_AF_UART4);
    301          	
    302          	//  EXYNOS PWR_CTRL -> GPIO Output
    303              GPIO_InitStructure.GPIO_Pin   = EXYNOS_PWR_CTRL;
    304              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    305            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    306            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    307              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    308              GPIO_Init(EXYNOS_PWR_CTRL_PORT, &GPIO_InitStructure);
    309          
    310          	//  EXYNOS PMIC_CTRL -> GPIO Output
    311              GPIO_InitStructure.GPIO_Pin   = EXYNOS_PMIC_CTRL;
    312              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    313            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    314            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    315              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    316              GPIO_Init(EXYNOS_PMIC_CTRL_PORT, &GPIO_InitStructure);
    317          
    318          	//	Serial Flash -> STM32 Update (SPI1)
    319              GPIO_InitStructure.GPIO_Pin   = SFLASH_SPI1_CS | SFLASH_SPI1_SCK | SFLASH_SPI1_MISO | SFLASH_SPI1_MOSI;
    320              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    321            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    322            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    323              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    324              GPIO_Init(SFLASH_SPI1_PORT, &GPIO_InitStructure);
    325          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_CS_PinSource, GPIO_AF_SPI1);
    326          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_SCK_PinSource, GPIO_AF_SPI1);
    327          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_MISO_PinSource, GPIO_AF_SPI1);
    328          	GPIO_PinAFConfig(SFLASH_SPI1_PORT, SFLASH_SPI1_MOSI_PinSource, GPIO_AF_SPI1);
    329          
    330              GPIO_InitStructure.GPIO_Pin   = SFLASH_HOLD | SFLASH_WP;
    331              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    332            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    333            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    334              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    335              GPIO_Init(SFLASH_PORT, &GPIO_InitStructure);
    336          
    337          	//	LAMP GPIO (Serial Data -> Parallel Data
    338              GPIO_InitStructure.GPIO_Pin   = LAMP_CLR | LAMP_SLCLK | LAMP_SCLK | LAMP_SDATA;
    339              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    340            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    341            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    342              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    343              GPIO_Init(LAMP_PORT, &GPIO_InitStructure);
    344          
    345          	//	Hardware Version -> ADC
    346              GPIO_InitStructure.GPIO_Pin   = HW_VERSION;
    347              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;   
    348            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    349          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    350              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    351          	GPIO_Init(HW_VERSION_PORT, &GPIO_InitStructure);
    352          
    353          	//	KeySwitch Matrix -> GPIO Output
    354          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    355          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    356          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    357          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    358          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    359          	GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    360          
    361          	//	KeySwitch Matrix -> GPIO Input
    362          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    363          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    364          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    365          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    366          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    367          	GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    368          
    369          	//  POWER_IGMON -> GPIO Input
    370              GPIO_InitStructure.GPIO_Pin   = PWR_IGMON;
    371              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    372            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    373            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    374              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    375              GPIO_Init(PWR_IGMON_PORT, &GPIO_InitStructure);
    376          	
    377          	//  POWER_CTRL -> GPIO Output
    378              GPIO_InitStructure.GPIO_Pin   = PWR_CTRL;
    379              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    380            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    381            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    382              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    383              GPIO_Init(PWR_CTRL_PORT, &GPIO_InitStructure);
    384          
    385          	//  LCDPWR_CTRL -> GPIO Output
    386              GPIO_InitStructure.GPIO_Pin   = LCDPWR_CTRL;
    387              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    388            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    389            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    390              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    391              GPIO_Init(LCDPWR_PORT, &GPIO_InitStructure);
    392          
    393          	//  FW_UPDATE -> GPIO Input
    394              GPIO_InitStructure.GPIO_Pin   = FW_UPDATE;
    395              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    396            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    397            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    398              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    399              GPIO_Init(FW_UPDATE_PORT, &GPIO_InitStructure);
    400          	
    401          	//	LCDBL_PWM -> PWM
    402              GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    403              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    404            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    405            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    406              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    407              GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    408          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    409          
    410          	//  LCDBL_CTRL -> GPIO Output
    411              GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    412              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    413            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    414            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    415              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    416              GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    417          	
    418          	//  LCD_STM32 -> GPIO Output
    419              GPIO_InitStructure.GPIO_Pin   = LCD_STM32;
    420              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    421            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    422            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    423              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    424              GPIO_Init(LCD_STM32_PORT, &GPIO_InitStructure);
    425          
    426          	//  LCD_EXYNOS -> GPIO Output
    427              GPIO_InitStructure.GPIO_Pin   = LCD_EXYNOS;
    428              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    429            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    430            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    431              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    432              GPIO_Init(LCD_EXYNOS_PORT, &GPIO_InitStructure);
    433          
    434          	//  BUZZER_CTRL -> GPIO Output
    435              GPIO_InitStructure.GPIO_Pin   = BUZZER_CTRL;
    436              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    437            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    438            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    439              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    440              GPIO_Init(BUZZER_PORT, &GPIO_InitStructure);
    441          
    442          	//  LED_CTRL -> GPIO Output
    443              GPIO_InitStructure.GPIO_Pin   = LED_CTRL;
    444              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    445            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    446            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    447              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    448              GPIO_Init(LED_PORT, &GPIO_InitStructure);
    449          
    450          	//  FM31X4(EEPROM) -> GPIO Output
    451          	//  GPIO로 I2C1 사용
    452              //  Alternate Function 사용안함
    453              GPIO_InitStructure.GPIO_Pin   = FM31X4_I2C1_SCL | FM31X4_I2C1_SDA;
    454              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    455            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    456            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    457              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    458              GPIO_Init(FM31X4_I2C1_PORT, &GPIO_InitStructure);
    459          	
    460          	//  TW2835 -> GPIO Output
    461              GPIO_InitStructure.GPIO_Pin   = TW2835_IRQ| TW2835_HALE | TW2835_HSPB;
    462              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    463            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    464            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    465              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    466              GPIO_Init(TW2835_CTRLPORT, &GPIO_InitStructure);
    467          
    468              GPIO_InitStructure.GPIO_Pin   = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | TW2835_D5 | TW2835_D6 | TW2835_D7;
    469              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    470            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    471            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    472              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    473              GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);	
    474          
    475              GPIO_InitStructure.GPIO_Pin   = TW2835_CSB0 | TW2835_CSB1 | TW2835_nWE | TW2835_nOE;
    476              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    477            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    478            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    479              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    480              GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    481          
    482          	//  DPRAM INT -> GPIO Output
    483              GPIO_InitStructure.GPIO_Pin   = DPRAM_INT;
    484              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    485            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    486            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    487              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    488              GPIO_Init(DPRAM_PORT, &GPIO_InitStructure);
    489          
    490          	//  CAMERA nRESET -> GPIO Output
    491              GPIO_InitStructure.GPIO_Pin   = CAMERA_nRESET;
    492              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    493            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    494            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    495              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    496              GPIO_Init(CAMERA_nRESET_PORT, &GPIO_InitStructure);
    497          
    498          
    499              // 	FSMC Data Line
    500              //  D15 ~ D0 : D15  D14  D13 D12  D11  D10  D9   D8   D7   D6  D5  D4  D3  D2  D1   D0   
    501              //             PD10 PD9  PD8 PE15 PE14 PE13 PE12 PE11 PE10 PE9 PE8 PE7 PD1 PD0 PD15 PD14
    502              
    503              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10| GPIO_Pin_9  | GPIO_Pin_8 | GPIO_Pin_1 |
    504                                              GPIO_Pin_0 | GPIO_Pin_15 | GPIO_Pin_14;
    505              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    506            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    507          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    508              GPIO_Init(GPIOD, &GPIO_InitStructure);
    509          
    510          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
    511          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9 , GPIO_AF_FSMC);
    512          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8 , GPIO_AF_FSMC);
    513          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1 , GPIO_AF_FSMC);
    514          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0 , GPIO_AF_FSMC);
    515          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
    516          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);	
    517            
    518              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12 |
    519                                              GPIO_Pin_11 | GPIO_Pin_10 | GPIO_Pin_9  |
    520                                              GPIO_Pin_8  | GPIO_Pin_7;
    521              GPIO_Init(GPIOE, &GPIO_InitStructure);
    522          
    523          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);
    524          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
    525          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
    526          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
    527          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);
    528          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
    529          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);	
    530          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);	
    531          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);	
    532          
    533              //  nCLK, nOE, nWE, nWait
    534              GPIO_InitStructure.GPIO_Pin = FSMC_nOE | FSMC_nWE | FSMC_nWAIT | FSMC_nCLK;
    535              GPIO_Init(FSMC_PORT, &GPIO_InitStructure);
    536          
    537          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nOE_PinSource  , GPIO_AF_FSMC);
    538          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWE_PinSource  , GPIO_AF_FSMC);
    539          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWAIT_PinSource, GPIO_AF_FSMC);
    540          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nCLK_PinSource , GPIO_AF_FSMC);
    541          
    542              //  nBL0, nBL1
    543              GPIO_InitStructure.GPIO_Pin = FSMC_nBL0 | FSMC_nBL1;
    544              GPIO_Init(FSMC_nBL_PORT, &GPIO_InitStructure);
    545          
    546          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL0_PinSource  , GPIO_AF_FSMC);
    547          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL1_PinSource  , GPIO_AF_FSMC);
    548             
    549          	//	nADV
    550              GPIO_InitStructure.GPIO_Pin = FSMC_nADV;
    551          	GPIO_PinAFConfig(FSMC_ADVPORT, FSMC_nADV_PinSource  , GPIO_AF_FSMC);
    552              GPIO_Init(FSMC_ADVPORT, &GPIO_InitStructure);
    553          
    554              // NE1 configuration
    555              GPIO_InitStructure.GPIO_Pin = FSMC_nNE1;
    556              GPIO_Init(FSMC_nNE1_PORT, &GPIO_InitStructure);
    557          
    558          	GPIO_PinAFConfig(FSMC_nNE1_PORT, FSMC_nNE1_PinSource  , GPIO_AF_FSMC);
    559          
    560              //  사용하지 않는 GPIO Pin은 Output -> Low 상태로 만들어 놓는다.
    561              GPIO_Configuration_NotUsed();
    562          }
    563          
    564          /**
    565            * @brief  GPIO Setting.
    566            * @param  Configures the different GPIO ports. (사용하지 않는 GPIO는 Output Low 상태로 만든다.)
    567            * @retval None
    568            */
    569          void GPIO_Configuration_NotUsed(void)
    570          {
    571              GPIO_InitTypeDef GPIO_InitStructure;
    572          
    573          	//  PC0, PC1, PC2, PC8, PC14
    574              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_8 | GPIO_Pin_14;
    575              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    576            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    577            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    578              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    579              GPIO_Init(GPIOC, &GPIO_InitStructure);
    580          
    581          	//  PF3, PF4, PF5, PF6, PF7, PF8, PF9
    582              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
    583              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    584            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    585            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    586              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    587              GPIO_Init(GPIOF, &GPIO_InitStructure);
    588          
    589          	//  PG8, PG9
    590              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_8 | GPIO_Pin_9;
    591              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    592            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    593            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    594              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    595              GPIO_Init(GPIOG, &GPIO_InitStructure);
    596          	
    597          	//  PE2, PE3, PE4, PE5
    598              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
    599              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    600            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    601            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    602              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    603              GPIO_Init(GPIOE, &GPIO_InitStructure);
    604          
    605              GPIO_ResetBits(GPIOC, GPIO_Pin_0);
    606              GPIO_ResetBits(GPIOC, GPIO_Pin_1);
    607              GPIO_ResetBits(GPIOC, GPIO_Pin_2);
    608              GPIO_ResetBits(GPIOC, GPIO_Pin_8);
    609              GPIO_ResetBits(GPIOC, GPIO_Pin_14);
    610          	
    611              GPIO_ResetBits(GPIOF, GPIO_Pin_3);
    612              GPIO_ResetBits(GPIOF, GPIO_Pin_4);
    613              GPIO_ResetBits(GPIOF, GPIO_Pin_5);
    614              GPIO_ResetBits(GPIOF, GPIO_Pin_6);
    615              GPIO_ResetBits(GPIOF, GPIO_Pin_7);
    616              GPIO_ResetBits(GPIOF, GPIO_Pin_8);
    617              GPIO_ResetBits(GPIOF, GPIO_Pin_9);
    618          
    619              GPIO_ResetBits(GPIOG, GPIO_Pin_8);
    620              GPIO_ResetBits(GPIOG, GPIO_Pin_9);	
    621          	
    622              GPIO_ResetBits(GPIOE, GPIO_Pin_2);	
    623              GPIO_ResetBits(GPIOE, GPIO_Pin_3);	
    624              GPIO_ResetBits(GPIOE, GPIO_Pin_4);	
    625              GPIO_ResetBits(GPIOE, GPIO_Pin_5);	
    626          }
    627          
    628          /**
    629            * @brief  Hardware, Software System Configuration.
    630            * @param  None
    631            * @retval None
    632            */
    633          void System_Configuration(void)
    634          {
    635          	RCC_Configuration();		    // 	Configure the system clocks
    636          	NVIC_Configuration();		    //	NVIC Configuration
    637          	GPIO_Configuration();		    // 	Configure the GPIO ports
    638          
    639          }
    640          
    641          void System_Initialize(void)
    642          {
    643          	//  PWR_CTRL -> BootLoader에서는 Sub Power Enable을 Off 
    644              GPIO_ResetBits(PWR_CTRL_PORT, PWR_CTRL);   	//	24V Power Enable 
    645                                                          //  Set   : Power Enable On
    646                                                          //  Reset : Power Enable Off    	
    647          
    648              //  LCDPWR_CTRL -> BootLoader에서는 VLCD12 Power Enable을 Off 
    649              GPIO_ResetBits(LCDPWR_PORT, LCDPWR_CTRL);  	//	LCD Power Enable 
    650                                                          //  Set   : LCD Power Enable 
    651                                                          //  Reset : LCD Power Disable	
    652          
    653          	//  BootLoader Bootting시에, LCDBL는 Off 상태로 만든다.
    654              GPIO_ResetBits(LCDBL_PORT, LCDBL_CTRL);	    //	LCD BackLight Power On/Off (LCDBL_CTRL)
    655                                                         	//  Set   : BackLight Power On
    656                                                         	//  Reset : BackLight Power Off			
    657                                                         	
    658              GPIO_ResetBits(BUZZER_PORT, BUZZER_CTRL);	//	BUZZER Off
    659                                                          //  Set   : BUZZER On
    660                                                          //  Reset : BUZZER Off
    661            
    662              GPIO_ResetBits(LED_PORT, LED_CTRL);			//	LED Enable Off
    663                                                          //  Set   : LED Enable  -> On
    664                                                          //  Reset : LED Disable -> Off
    665          
    666              GPIO_ResetBits(EXYNOS_PWR_CTRL_PORT, EXYNOS_PWR_CTRL);	//	Exynos-4412 Power On/Off
    667                                                          			//  Set   : Exynos-4412 -> Power On
    668                                                          			//  Reset : Exynos-4412 -> Power Off
    669                                                          			
    670              GPIO_ResetBits(EXYNOS_PMIC_CTRL_PORT, EXYNOS_PMIC_CTRL);	//	Exynos-4412 PMIC On/Off
    671                                                          				//  PMIC On  : Low -> High
    672                                                          				//       Off : Low -> High
    673          
    674              GPIO_SetBits(LCD_EXYNOS_PORT, LCD_EXYNOS);	//	Exynos-4412 LCD Display
    675                                                          //  Set   : HI-Z
    676                                                          //  Reset : Display
    677          	                                                				
    678              GPIO_ResetBits(LCD_STM32_PORT, LCD_STM32);	//	STM32 LCD Display
    679                                                          //  Set   : HI-Z
    680                                                          //  Reset : Display
    681          	
    682          	GPIO_ResetBits(CAMERA_nRESET_PORT, CAMERA_nRESET);	//	CAMERA nRESET
    683          		                                                //  Set   : On
    684                  		                                        //  Reset : Off												
    685          }
    686          
    687          void System_Variable_Init(void)
    688          {
    689          	memset((void *)(&WL9FM_TIME),       	0x0, sizeof(WL9FM_TIME_DATA));
    690          	memset((void *)(&WL9FM_RTC),            0x0, sizeof(WL9FM_DATA_RTC));	
    691          	memset((void *)(&WL9FM_BUZZER),         0x0, sizeof(WL9FM_BUZZER_DATA));	
    692          	memset((void *)(&WL9FM_LCDBL),          0x0, sizeof(WL9FM_LCDBL_DATA));	
    693          
    694          	WL9F_CAN_Buffer_Init();
    695          	WL9F_CAN_Variables_Init();
    696          }
    697          
    698          /*********(C) COPYRIGHT 2013 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
    699          
    700          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   GPIO_Configuration
        32   -> GPIO_Configuration_NotUsed
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
      32   GPIO_Configuration_NotUsed
        32   -> GPIO_Init
        32   -> GPIO_ResetBits
       0   NVIC_Configuration
         0   -> NVIC_SetVectorTable
      24   RCC_Configuration
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_AHB3PeriphClockCmd
        24   -> RCC_APB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
        24   -> RCC_ClockSecuritySystemCmd
        24   -> RCC_GetClocksFreq
       8   System_Configuration
         0   -> GPIO_Configuration
         8   -> NVIC_SetVectorTable
         8   -> RCC_Configuration
      16   System_Initialize
         0   -> GPIO_ResetBits
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       8   System_Variable_Init
         8   -> WL9F_CAN_Buffer_Init
         0   -> WL9F_CAN_Variables_Init
         8   -> __aeabi_memclr
         8   -> __aeabi_memclr4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
    1554  GPIO_Configuration
     322  GPIO_Configuration_NotUsed
      12  NVIC_Configuration
     232  RCC_Configuration
      24  System_Configuration
     102  System_Initialize
      46  System_Variable_Init

 
 2 344 bytes in section .text
 
 2 344 bytes of CODE memory

Errors: none
Warnings: none
