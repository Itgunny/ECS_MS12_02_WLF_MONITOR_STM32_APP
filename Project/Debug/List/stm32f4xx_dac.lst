###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      12/Aug/2015  06:54:18 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Lib #
#                    raries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c    #
#    Command line =  "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Li #
#                    braries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c"  #
#                    -D USE_STDPERIPH_DRIVER -D STM32F4XX -D                  #
#                    USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN "C:\Tools\IAR  #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\Debug\Li #
#                    st\" -o "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monito #
#                    r_APP\Project\Debug\Obj\" --debug --endian=little        #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\IAR       #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\COMMON\INC\" -I "C:\Tools\IAR                        #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\TaeHa - ECS\INC\" -I "C:\Tools\IAR                   #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Libra #
#                    ries\CMSIS\Device\ST\STM32F4xx\Include\" -I              #
#                    "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pr #
#                    oject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -Oh  #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\List\stm32f4xx_dac.lst                        #
#    Object file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\Obj\stm32f4xx_dac.o                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7             * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           - DAC channels configuration: trigger, output buffer, data format
     10            *           - DMA management      
     11            *           - Interrupts and flags management
     12            *
     13            *  @verbatim
     14            *    
     15            *          ===================================================================
     16            *                             DAC Peripheral features
     17            *          ===================================================================
     18            *          
     19            *          DAC Channels
     20            *          =============  
     21            *          The device integrates two 12-bit Digital Analog Converters that can 
     22            *          be used independently or simultaneously (dual mode):
     23            *            1- DAC channel1 with DAC_OUT1 (PA4) as output
     24            *            1- DAC channel2 with DAC_OUT2 (PA5) as output
     25            *
     26            *          DAC Triggers
     27            *          =============
     28            *          Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     29            *          and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
     30            *          using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
     31            *   
     32            *         Digital to Analog conversion can be triggered by:
     33            *             1- External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     34            *                The used pin (GPIOx_Pin9) must be configured in input mode.
     35            *
     36            *             2- Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
     37            *                (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     38            *                The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     39            *
     40            *             3- Software using DAC_Trigger_Software
     41            *
     42            *          DAC Buffer mode feature
     43            *          ========================  
     44            *          Each DAC channel integrates an output buffer that can be used to 
     45            *          reduce the output impedance, and to drive external loads directly
     46            *          without having to add an external operational amplifier.
     47            *          To enable, the output buffer use  
     48            *              DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     49            *          
     50            *          Refer to the device datasheet for more details about output 
     51            *          impedance value with and without output buffer.
     52            *          
     53            *          DAC wave generation feature
     54            *          =============================      
     55            *          Both DAC channels can be used to generate
     56            *             1- Noise wave using DAC_WaveGeneration_Noise
     57            *             2- Triangle wave using DAC_WaveGeneration_Triangle
     58            *        
     59            *          Wave generation can be disabled using DAC_WaveGeneration_None
     60            *
     61            *          DAC data format
     62            *          ================   
     63            *          The DAC data format can be:
     64            *             1- 8-bit right alignment using DAC_Align_8b_R
     65            *             2- 12-bit left alignment using DAC_Align_12b_L
     66            *             3- 12-bit right alignment using DAC_Align_12b_R
     67            *
     68            *          DAC data value to voltage correspondence  
     69            *          ========================================  
     70            *          The analog output voltage on each DAC channel pin is determined
     71            *          by the following equation: 
     72            *          DAC_OUTx = VREF+ * DOR / 4095
     73            *          with  DOR is the Data Output Register
     74            *                VEF+ is the input voltage reference (refer to the device datasheet)
     75            *          e.g. To set DAC_OUT1 to 0.7V, use
     76            *            DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     77            *          Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     78            *
     79            *          DMA requests 
     80            *          =============    
     81            *          A DMA1 request can be generated when an external trigger (but not
     82            *          a software trigger) occurs if DMA1 requests are enabled using
     83            *          DAC_DMACmd()
     84            *          DMA1 requests are mapped as following:
     85            *             1- DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
     86            *                               already configured
     87            *             2- DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
     88            *                               already configured
     89            *
     90            *          ===================================================================      
     91            *                              How to use this driver 
     92            *          ===================================================================          
     93            *            - DAC APB clock must be enabled to get write access to DAC
     94            *              registers using
     95            *              RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
     96            *            - Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
     97            *            - Configure the DAC channel using DAC_Init() function
     98            *            - Enable the DAC channel using DAC_Cmd() function
     99            * 
    100            *  @endverbatim
    101            *    
    102            ******************************************************************************
    103            * @attention
    104            *
    105            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    106            *
    107            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    108            * You may not use this file except in compliance with the License.
    109            * You may obtain a copy of the License at:
    110            *
    111            *        http://www.st.com/software_license_agreement_liberty_v2
    112            *
    113            * Unless required by applicable law or agreed to in writing, software 
    114            * distributed under the License is distributed on an "AS IS" BASIS, 
    115            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    116            * See the License for the specific language governing permissions and
    117            * limitations under the License.
    118            *
    119            ******************************************************************************
    120            */ 
    121          
    122          
    123          /* Includes ------------------------------------------------------------------*/
    124          #include "stm32f4xx_dac.h"
    125          #include "stm32f4xx_rcc.h"
    126          
    127          /** @addtogroup STM32F4xx_StdPeriph_Driver
    128            * @{
    129            */
    130          
    131          /** @defgroup DAC 
    132            * @brief DAC driver modules
    133            * @{
    134            */ 
    135          
    136          /* Private typedef -----------------------------------------------------------*/
    137          /* Private define ------------------------------------------------------------*/
    138          
    139          /* CR register Mask */
    140          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    141          
    142          /* DAC Dual Channels SWTRIG masks */
    143          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    144          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    145          
    146          /* DHR registers offsets */
    147          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    148          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    149          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    150          
    151          /* DOR register offset */
    152          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    153          
    154          /* Private macro -------------------------------------------------------------*/
    155          /* Private variables ---------------------------------------------------------*/
    156          /* Private function prototypes -----------------------------------------------*/
    157          /* Private functions ---------------------------------------------------------*/
    158          
    159          /** @defgroup DAC_Private_Functions
    160            * @{
    161            */
    162          
    163          /** @defgroup DAC_Group1 DAC channels configuration
    164           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    165           *
    166          @verbatim   
    167           ===============================================================================
    168                    DAC channels configuration: trigger, output buffer, data format
    169           ===============================================================================  
    170          
    171          @endverbatim
    172            * @{
    173            */
    174          
    175          /**
    176            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    177            * @param  None
    178            * @retval None
    179            */
    180          void DAC_DeInit(void)
    181          {
    182            /* Enable DAC reset state */
    183            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
    184            /* Release DAC from reset state */
    185            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
    186          }
    187          
    188          /**
    189            * @brief  Initializes the DAC peripheral according to the specified parameters
    190            *         in the DAC_InitStruct.
    191            * @param  DAC_Channel: the selected DAC channel. 
    192            *          This parameter can be one of the following values:
    193            *            @arg DAC_Channel_1: DAC Channel1 selected
    194            *            @arg DAC_Channel_2: DAC Channel2 selected
    195            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
    196            *         the configuration information for the  specified DAC channel.
    197            * @retval None
    198            */
    199          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    200          {
    201            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    202          
    203            /* Check the DAC parameters */
    204            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
    205            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
    206            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
    207            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
    208          
    209          /*---------------------------- DAC CR Configuration --------------------------*/
    210            /* Get the DAC CR value */
    211            tmpreg1 = DAC->CR;
    212            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    213            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
    214            /* Configure for the selected DAC channel: buffer output, trigger, 
    215               wave generation, mask/amplitude for wave generation */
    216            /* Set TSELx and TENx bits according to DAC_Trigger value */
    217            /* Set WAVEx bits according to DAC_WaveGeneration value */
    218            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    219            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    220            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    221                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
    222                       DAC_InitStruct->DAC_OutputBuffer);
    223            /* Calculate CR register value depending on DAC_Channel */
    224            tmpreg1 |= tmpreg2 << DAC_Channel;
    225            /* Write to DAC CR */
    226            DAC->CR = tmpreg1;
    227          }
    228          
    229          /**
    230            * @brief  Fills each DAC_InitStruct member with its default value.
    231            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
    232            *         be initialized.
    233            * @retval None
    234            */
    235          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    236          {
    237          /*--------------- Reset DAC init structure parameters values -----------------*/
    238            /* Initialize the DAC_Trigger member */
    239            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
    240            /* Initialize the DAC_WaveGeneration member */
    241            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
    242            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    243            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
    244            /* Initialize the DAC_OutputBuffer member */
    245            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
    246          }
    247          
    248          /**
    249            * @brief  Enables or disables the specified DAC channel.
    250            * @param  DAC_Channel: The selected DAC channel. 
    251            *          This parameter can be one of the following values:
    252            *            @arg DAC_Channel_1: DAC Channel1 selected
    253            *            @arg DAC_Channel_2: DAC Channel2 selected
    254            * @param  NewState: new state of the DAC channel. 
    255            *          This parameter can be: ENABLE or DISABLE.
    256            * @note   When the DAC channel is enabled the trigger source can no more be modified.
    257            * @retval None
    258            */
    259          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    260          {
    261            /* Check the parameters */
    262            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    263            assert_param(IS_FUNCTIONAL_STATE(NewState));
    264          
    265            if (NewState != DISABLE)
    266            {
    267              /* Enable the selected DAC channel */
    268              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
    269            }
    270            else
    271            {
    272              /* Disable the selected DAC channel */
    273              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
    274            }
    275          }
    276          
    277          /**
    278            * @brief  Enables or disables the selected DAC channel software trigger.
    279            * @param  DAC_Channel: The selected DAC channel. 
    280            *          This parameter can be one of the following values:
    281            *            @arg DAC_Channel_1: DAC Channel1 selected
    282            *            @arg DAC_Channel_2: DAC Channel2 selected
    283            * @param  NewState: new state of the selected DAC channel software trigger.
    284            *          This parameter can be: ENABLE or DISABLE.
    285            * @retval None
    286            */
    287          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    288          {
    289            /* Check the parameters */
    290            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
    292          
    293            if (NewState != DISABLE)
    294            {
    295              /* Enable software trigger for the selected DAC channel */
    296              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
    297            }
    298            else
    299            {
    300              /* Disable software trigger for the selected DAC channel */
    301              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
    302            }
    303          }
    304          
    305          /**
    306            * @brief  Enables or disables simultaneously the two DAC channels software triggers.
    307            * @param  NewState: new state of the DAC channels software triggers.
    308            *          This parameter can be: ENABLE or DISABLE.
    309            * @retval None
    310            */
    311          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_FUNCTIONAL_STATE(NewState));
    315          
    316            if (NewState != DISABLE)
    317            {
    318              /* Enable software trigger for both DAC channels */
    319              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
    320            }
    321            else
    322            {
    323              /* Disable software trigger for both DAC channels */
    324              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
    325            }
    326          }
    327          
    328          /**
    329            * @brief  Enables or disables the selected DAC channel wave generation.
    330            * @param  DAC_Channel: The selected DAC channel. 
    331            *          This parameter can be one of the following values:
    332            *            @arg DAC_Channel_1: DAC Channel1 selected
    333            *            @arg DAC_Channel_2: DAC Channel2 selected
    334            * @param  DAC_Wave: specifies the wave type to enable or disable.
    335            *          This parameter can be one of the following values:
    336            *            @arg DAC_Wave_Noise: noise wave generation
    337            *            @arg DAC_Wave_Triangle: triangle wave generation
    338            * @param  NewState: new state of the selected DAC channel wave generation.
    339            *          This parameter can be: ENABLE or DISABLE.  
    340            * @retval None
    341            */
    342          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    343          {
    344            /* Check the parameters */
    345            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    346            assert_param(IS_DAC_WAVE(DAC_Wave)); 
    347            assert_param(IS_FUNCTIONAL_STATE(NewState));
    348          
    349            if (NewState != DISABLE)
    350            {
    351              /* Enable the selected wave generation for the selected DAC channel */
    352              DAC->CR |= DAC_Wave << DAC_Channel;
    353            }
    354            else
    355            {
    356              /* Disable the selected wave generation for the selected DAC channel */
    357              DAC->CR &= ~(DAC_Wave << DAC_Channel);
    358            }
    359          }
    360          
    361          /**
    362            * @brief  Set the specified data holding register value for DAC channel1.
    363            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    364            *          This parameter can be one of the following values:
    365            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    366            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    367            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    368            * @param  Data: Data to be loaded in the selected data holding register.
    369            * @retval None
    370            */
    371          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    372          {  
    373            __IO uint32_t tmp = 0;
    374            
    375            /* Check the parameters */
    376            assert_param(IS_DAC_ALIGN(DAC_Align));
    377            assert_param(IS_DAC_DATA(Data));
    378            
    379            tmp = (uint32_t)DAC_BASE; 
    380            tmp += DHR12R1_OFFSET + DAC_Align;
    381          
    382            /* Set the DAC channel1 selected data holding register */
    383            *(__IO uint32_t *) tmp = Data;
    384          }
    385          
    386          /**
    387            * @brief  Set the specified data holding register value for DAC channel2.
    388            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    389            *          This parameter can be one of the following values:
    390            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    391            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    392            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    393            * @param  Data: Data to be loaded in the selected data holding register.
    394            * @retval None
    395            */
    396          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    397          {
    398            __IO uint32_t tmp = 0;
    399          
    400            /* Check the parameters */
    401            assert_param(IS_DAC_ALIGN(DAC_Align));
    402            assert_param(IS_DAC_DATA(Data));
    403            
    404            tmp = (uint32_t)DAC_BASE;
    405            tmp += DHR12R2_OFFSET + DAC_Align;
    406          
    407            /* Set the DAC channel2 selected data holding register */
    408            *(__IO uint32_t *)tmp = Data;
    409          }
    410          
    411          /**
    412            * @brief  Set the specified data holding register value for dual channel DAC.
    413            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    414            *          This parameter can be one of the following values:
    415            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    416            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    417            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    418            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
    419            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
    420            * @note   In dual mode, a unique register access is required to write in both
    421            *          DAC channels at the same time.
    422            * @retval None
    423            */
    424          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    425          {
    426            uint32_t data = 0, tmp = 0;
    427            
    428            /* Check the parameters */
    429            assert_param(IS_DAC_ALIGN(DAC_Align));
    430            assert_param(IS_DAC_DATA(Data1));
    431            assert_param(IS_DAC_DATA(Data2));
    432            
    433            /* Calculate and set dual DAC data holding register value */
    434            if (DAC_Align == DAC_Align_8b_R)
    435            {
    436              data = ((uint32_t)Data2 << 8) | Data1; 
    437            }
    438            else
    439            {
    440              data = ((uint32_t)Data2 << 16) | Data1;
    441            }
    442            
    443            tmp = (uint32_t)DAC_BASE;
    444            tmp += DHR12RD_OFFSET + DAC_Align;
    445          
    446            /* Set the dual DAC selected data holding register */
    447            *(__IO uint32_t *)tmp = data;
    448          }
    449          
    450          /**
    451            * @brief  Returns the last data output value of the selected DAC channel.
    452            * @param  DAC_Channel: The selected DAC channel. 
    453            *          This parameter can be one of the following values:
    454            *            @arg DAC_Channel_1: DAC Channel1 selected
    455            *            @arg DAC_Channel_2: DAC Channel2 selected
    456            * @retval The selected DAC channel data output value.
    457            */
    458          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    459          {
    460            __IO uint32_t tmp = 0;
    461            
    462            /* Check the parameters */
    463            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    464            
    465            tmp = (uint32_t) DAC_BASE ;
    466            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
    467            
    468            /* Returns the DAC channel data output register value */
    469            return (uint16_t) (*(__IO uint32_t*) tmp);
    470          }
    471          /**
    472            * @}
    473            */
    474          
    475          /** @defgroup DAC_Group2 DMA management functions
    476           *  @brief   DMA management functions
    477           *
    478          @verbatim   
    479           ===============================================================================
    480                                    DMA management functions
    481           ===============================================================================  
    482          
    483          @endverbatim
    484            * @{
    485            */
    486          
    487          /**
    488            * @brief  Enables or disables the specified DAC channel DMA request.
    489            * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
    490            *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
    491            * @param  DAC_Channel: The selected DAC channel. 
    492            *          This parameter can be one of the following values:
    493            *            @arg DAC_Channel_1: DAC Channel1 selected
    494            *            @arg DAC_Channel_2: DAC Channel2 selected
    495            * @param  NewState: new state of the selected DAC channel DMA request.
    496            *          This parameter can be: ENABLE or DISABLE.
    497            * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
    498            *          already configured.
    499            * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
    500            *          already configured.    
    501            * @retval None
    502            */
    503          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    504          {
    505            /* Check the parameters */
    506            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    507            assert_param(IS_FUNCTIONAL_STATE(NewState));
    508          
    509            if (NewState != DISABLE)
    510            {
    511              /* Enable the selected DAC channel DMA request */
    512              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
    513            }
    514            else
    515            {
    516              /* Disable the selected DAC channel DMA request */
    517              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
    518            }
    519          }
    520          /**
    521            * @}
    522            */
    523          
    524          /** @defgroup DAC_Group3 Interrupts and flags management functions
    525           *  @brief   Interrupts and flags management functions
    526           *
    527          @verbatim   
    528           ===============================================================================
    529                             Interrupts and flags management functions
    530           ===============================================================================  
    531          
    532          @endverbatim
    533            * @{
    534            */
    535          
    536          /**
    537            * @brief  Enables or disables the specified DAC interrupts.
    538            * @param  DAC_Channel: The selected DAC channel. 
    539            *          This parameter can be one of the following values:
    540            *            @arg DAC_Channel_1: DAC Channel1 selected
    541            *            @arg DAC_Channel_2: DAC Channel2 selected
    542            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    543            *          This parameter can be the following values:
    544            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    545            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    546            *         acknowledgement for the first external trigger is received (first request).
    547            * @param  NewState: new state of the specified DAC interrupts.
    548            *          This parameter can be: ENABLE or DISABLE.
    549            * @retval None
    550            */ 
    551          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    552          {
    553            /* Check the parameters */
    554            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    555            assert_param(IS_FUNCTIONAL_STATE(NewState));
    556            assert_param(IS_DAC_IT(DAC_IT)); 
    557          
    558            if (NewState != DISABLE)
    559            {
    560              /* Enable the selected DAC interrupts */
    561              DAC->CR |=  (DAC_IT << DAC_Channel);
    562            }
    563            else
    564            {
    565              /* Disable the selected DAC interrupts */
    566              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
    567            }
    568          }
    569          
    570          /**
    571            * @brief  Checks whether the specified DAC flag is set or not.
    572            * @param  DAC_Channel: The selected DAC channel. 
    573            *          This parameter can be one of the following values:
    574            *            @arg DAC_Channel_1: DAC Channel1 selected
    575            *            @arg DAC_Channel_2: DAC Channel2 selected
    576            * @param  DAC_FLAG: specifies the flag to check. 
    577            *          This parameter can be only of the following value:
    578            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
    579            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    580            *         acknowledgement for the first external trigger is received (first request).
    581            * @retval The new state of DAC_FLAG (SET or RESET).
    582            */
    583          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    584          {
    585            FlagStatus bitstatus = RESET;
    586            /* Check the parameters */
    587            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    588            assert_param(IS_DAC_FLAG(DAC_FLAG));
    589          
    590            /* Check the status of the specified DAC flag */
    591            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
    592            {
    593              /* DAC_FLAG is set */
    594              bitstatus = SET;
    595            }
    596            else
    597            {
    598              /* DAC_FLAG is reset */
    599              bitstatus = RESET;
    600            }
    601            /* Return the DAC_FLAG status */
    602            return  bitstatus;
    603          }
    604          
    605          /**
    606            * @brief  Clears the DAC channel's pending flags.
    607            * @param  DAC_Channel: The selected DAC channel. 
    608            *          This parameter can be one of the following values:
    609            *            @arg DAC_Channel_1: DAC Channel1 selected
    610            *            @arg DAC_Channel_2: DAC Channel2 selected
    611            * @param  DAC_FLAG: specifies the flag to clear. 
    612            *          This parameter can be of the following value:
    613            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
    614            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    615            *         acknowledgement for the first external trigger is received (first request).                           
    616            * @retval None
    617            */
    618          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    619          {
    620            /* Check the parameters */
    621            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    622            assert_param(IS_DAC_FLAG(DAC_FLAG));
    623          
    624            /* Clear the selected DAC flags */
    625            DAC->SR = (DAC_FLAG << DAC_Channel);
    626          }
    627          
    628          /**
    629            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    630            * @param  DAC_Channel: The selected DAC channel. 
    631            *          This parameter can be one of the following values:
    632            *            @arg DAC_Channel_1: DAC Channel1 selected
    633            *            @arg DAC_Channel_2: DAC Channel2 selected
    634            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    635            *          This parameter can be the following values:
    636            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    637            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    638            *         acknowledgement for the first external trigger is received (first request).
    639            * @retval The new state of DAC_IT (SET or RESET).
    640            */
    641          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    642          {
    643            ITStatus bitstatus = RESET;
    644            uint32_t enablestatus = 0;
    645            
    646            /* Check the parameters */
    647            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    648            assert_param(IS_DAC_IT(DAC_IT));
    649          
    650            /* Get the DAC_IT enable bit status */
    651            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
    652            
    653            /* Check the status of the specified DAC interrupt */
    654            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
    655            {
    656              /* DAC_IT is set */
    657              bitstatus = SET;
    658            }
    659            else
    660            {
    661              /* DAC_IT is reset */
    662              bitstatus = RESET;
    663            }
    664            /* Return the DAC_IT status */
    665            return  bitstatus;
    666          }
    667          
    668          /**
    669            * @brief  Clears the DAC channel's interrupt pending bits.
    670            * @param  DAC_Channel: The selected DAC channel. 
    671            *          This parameter can be one of the following values:
    672            *            @arg DAC_Channel_1: DAC Channel1 selected
    673            *            @arg DAC_Channel_2: DAC Channel2 selected
    674            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    675            *          This parameter can be the following values:
    676            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    677            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    678            *         acknowledgement for the first external trigger is received (first request).                           
    679            * @retval None
    680            */
    681          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    685            assert_param(IS_DAC_IT(DAC_IT)); 
    686          
    687            /* Clear the selected DAC interrupt pending bits */
    688            DAC->SR = (DAC_IT << DAC_Channel);
    689          }
    690          
    691          /**
    692            * @}
    693            */
    694          
    695          /**
    696            * @}
    697            */
    698          
    699          /**
    700            * @}
    701            */
    702          
    703          /**
    704            * @}
    705            */
    706          
    707          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DAC_ClearFlag
        16   -> assert_failed
      16   DAC_ClearITPendingBit
        16   -> assert_failed
      16   DAC_Cmd
        16   -> assert_failed
      16   DAC_DMACmd
        16   -> assert_failed
       8   DAC_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       8   DAC_DualSoftwareTriggerCmd
         8   -> assert_failed
      16   DAC_GetDataOutputValue
        16   -> assert_failed
      16   DAC_GetFlagStatus
        16   -> assert_failed
      16   DAC_GetITStatus
        16   -> assert_failed
      16   DAC_ITConfig
        16   -> assert_failed
      16   DAC_Init
        16   -> assert_failed
      16   DAC_SetChannel1Data
        16   -> assert_failed
      16   DAC_SetChannel2Data
        16   -> assert_failed
      24   DAC_SetDualChannelData
        24   -> assert_failed
      16   DAC_SoftwareTriggerCmd
        16   -> assert_failed
       0   DAC_StructInit
      16   DAC_WaveGenerationCmd
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     112  ?<Constant "C:\\Tools\\IAR Systems\\...">
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
      12  ?Subroutine0
      10  ?Subroutine1
      44  DAC_ClearFlag
      42  DAC_ClearITPendingBit
      72  DAC_Cmd
      72  DAC_DMACmd
      26  DAC_DeInit
      42  DAC_DualSoftwareTriggerCmd
      52  DAC_GetDataOutputValue
      64  DAC_GetFlagStatus
      70  DAC_GetITStatus
      86  DAC_ITConfig
     212  DAC_Init
      62  DAC_SetChannel1Data
      60  DAC_SetChannel2Data
      82  DAC_SetDualChannelData
      72  DAC_SoftwareTriggerCmd
      12  DAC_StructInit
      90  DAC_WaveGenerationCmd

 
 1 310 bytes in section .text
 
 1 310 bytes of CODE memory

Errors: none
Warnings: none
