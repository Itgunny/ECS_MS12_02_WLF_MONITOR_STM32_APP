###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      07/Apr/2015  14:09:51 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Lib #
#                    raries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c   #
#    Command line =  "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Li #
#                    braries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c" #
#                     -D USE_STDPERIPH_DRIVER -D STM32F4XX -D                 #
#                    USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN "C:\Tools\IAR  #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\Debug\Li #
#                    st\" -o "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monito #
#                    r_APP\Project\Debug\Obj\" --debug --endian=little        #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\IAR       #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\COMMON\INC\" -I "C:\Tools\IAR                        #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Platf #
#                    orm\TaeHa - ECS\INC\" -I "C:\Tools\IAR                   #
#                    Systems\Workspace_WL9F\WL_F_Monitor_APP\Project\..\Libra #
#                    ries\CMSIS\Device\ST\STM32F4xx\Include\" -I              #
#                    "C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pr #
#                    oject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -Oh  #
#                    --use_c++_inline -I "C:\Tools\IAR Systems\Embedded       #
#                    Workbench 6.5\arm\CMSIS\Include\"                        #
#    List file    =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\List\stm32f4xx_hash.lst                       #
#    Object file  =  C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Pro #
#                    ject\Debug\Obj\stm32f4xx_hash.o                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Workspace_WL9F\WL_F_Monitor_APP\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the HASH / HMAC Processor (HASH) peripheral:           
      9            *           - Initialization and Configuration functions
     10            *           - Message Digest generation functions
     11            *           - context swapping functions   
     12            *           - DMA interface function       
     13            *           - Interrupts and flags management       
     14            *         
     15            *  @verbatim
     16            *                               
     17            *          ===================================================================      
     18            *                                   How to use this driver
     19            *          ===================================================================
     20            *          HASH operation : 
     21            *          ----------------                   
     22            *         1. Enable the HASH controller clock using 
     23            *            RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH, ENABLE) function.
     24            *           
     25            *         2. Initialise the HASH using HASH_Init() function. 
     26            *               
     27            *         3 . Reset the HASH processor core, so that the HASH will be ready 
     28            *             to compute he message digest of a new message by using 
     29            *             HASH_Reset() function.
     30            *
     31            *         4. Enable the HASH controller using the HASH_Cmd() function. 
     32            *                
     33            *         5. if using DMA for Data input transfer, Activate the DMA Request 
     34            *            using HASH_DMACmd() function 
     35            *                    
     36            *         6. if DMA is not used for data transfer, use HASH_DataIn() function 
     37            *            to enter data to IN FIFO.
     38            *             
     39            *          
     40            *         7. Configure the Number of valid bits in last word of the message 
     41            *            using HASH_SetLastWordValidBitsNbr() function.
     42            *             
     43            *         8. if the message length is not an exact multiple of 512 bits, 
     44            *            then the function HASH_StartDigest() must be called to 
     45            *            launch the computation of the final digest.     
     46            *             
     47            *         9. Once computed, the digest can be read using HASH_GetDigest() 
     48            *            function.         
     49            *                   
     50            *        10. To control HASH events you can use one of the following 
     51            *              two methods:
     52            *               a- Check on HASH flags using the HASH_GetFlagStatus() function.  
     53            *               b- Use HASH interrupts through the function HASH_ITConfig() at 
     54            *                  initialization phase and HASH_GetITStatus() function into 
     55            *                  interrupt routines in hashing phase.
     56            *          After checking on a flag you should clear it using HASH_ClearFlag()
     57            *          function. And after checking on an interrupt event you should 
     58            *          clear it using HASH_ClearITPendingBit() function.     
     59            *                     
     60            *        11. Save and restore hash processor context using 
     61            *            HASH_SaveContext() and HASH_RestoreContext() functions.     
     62            *              
     63            *
     64            *            
     65            *          HMAC operation : 
     66            *          ----------------  
     67            *          The HMAC algorithm is used for message authentication, by 
     68            *          irreversibly binding the message being processed to a key chosen 
     69            *          by the user. 
     70            *          For HMAC specifications, refer to "HMAC: keyed-hashing for message 
     71            *          authentication, H. Krawczyk, M. Bellare, R. Canetti, February 1997"
     72            *          
     73            *          Basically, the HMAC algorithm consists of two nested hash operations:
     74            *          HMAC(message) = Hash[((key | pad) XOR 0x5C) | Hash(((key | pad) XOR 0x36) | message)]
     75            *          where:
     76            *          - "pad" is a sequence of zeroes needed to extend the key to the 
     77            *                  length of the underlying hash function data block (that is 
     78            *                  512 bits for both the SHA-1 and MD5 hash algorithms)
     79            *          - "|"   represents the concatenation operator 
     80            *          
     81            *         
     82            *         To compute the HMAC, four different phases are required:
     83            *                    
     84            *         1.  Initialise the HASH using HASH_Init() function to do HMAC 
     85            *             operation. 
     86            *                
     87            *         2.  The key (to be used for the inner hash function) is then given 
     88            *             to the core. This operation follows the same mechanism as the 
     89            *             one used to send the message in the hash operation (that is, 
     90            *             by HASH_DataIn() function and, finally, 
     91            *             HASH_StartDigest() function.
     92            *          
     93            *         3.  Once the last word has been entered and computation has started, 
     94            *             the hash processor elaborates the key. It is then ready to 
     95            *             accept the message text using the same mechanism as the one 
     96            *             used to send the message in the hash operation.
     97            *       
     98            *         4.  After the first hash round, the hash processor returns "ready" 
     99            *             to indicate that it is ready to receive the key to be used for 
    100            *             the outer hash function (normally, this key is the same as the 
    101            *             one used for the inner hash function). When the last word of 
    102            *             the key is entered and computation starts, the HMAC result is 
    103            *             made available using HASH_GetDigest() function.
    104            *               
    105            *              
    106            *  @endverbatim
    107            *         
    108            ******************************************************************************
    109            * @attention
    110            *
    111            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    112            *
    113            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    114            * You may not use this file except in compliance with the License.
    115            * You may obtain a copy of the License at:
    116            *
    117            *        http://www.st.com/software_license_agreement_liberty_v2
    118            *
    119            * Unless required by applicable law or agreed to in writing, software 
    120            * distributed under the License is distributed on an "AS IS" BASIS, 
    121            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    122            * See the License for the specific language governing permissions and
    123            * limitations under the License.
    124            *
    125            ******************************************************************************
    126            */
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f4xx_hash.h"
    130          #include "stm32f4xx_rcc.h"
    131          
    132          /** @addtogroup STM32F4xx_StdPeriph_Driver
    133            * @{
    134            */
    135          
    136          /** @defgroup HASH 
    137            * @brief HASH driver modules
    138            * @{
    139            */ 
    140          
    141          /* Private typedef -----------------------------------------------------------*/
    142          /* Private define ------------------------------------------------------------*/
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private variables ---------------------------------------------------------*/
    145          /* Private function prototypes -----------------------------------------------*/
    146          /* Private functions ---------------------------------------------------------*/ 
    147          
    148          /** @defgroup HASH_Private_Functions
    149            * @{
    150            */ 
    151          
    152          /** @defgroup HASH_Group1 Initialization and Configuration functions
    153           *  @brief    Initialization and Configuration functions 
    154           *
    155          @verbatim    
    156           ===============================================================================
    157                                Initialization and Configuration functions
    158           ===============================================================================  
    159            This section provides functions allowing to 
    160             - Initialize the HASH peripheral
    161             - Configure the HASH Processor 
    162                - MD5/SHA1, 
    163                - HASH/HMAC, 
    164                - datatype 
    165                - HMAC Key (if mode = HMAC)
    166             - Reset the HASH Processor 
    167             
    168          @endverbatim
    169            * @{
    170            */
    171            
    172          /**
    173            * @brief  Deinitializes the HASH peripheral registers to their default reset values
    174            * @param  None
    175            * @retval None
    176            */
    177          void HASH_DeInit(void)
    178          {
    179            /* Enable HASH reset state */
    180            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
    181            /* Release HASH from reset state */
    182            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
    183          }
    184          
    185          /**
    186            * @brief  Initializes the HASH peripheral according to the specified parameters
    187            *         in the HASH_InitStruct structure.
    188            * @note   the hash processor is reset when calling this function so that the
    189            *         HASH will be ready to compute the message digest of a new message.
    190            *         There is no need to call HASH_Reset() function.           
    191            * @param  HASH_InitStruct: pointer to a HASH_InitTypeDef structure that contains
    192            *         the configuration information for the HASH peripheral.
    193            * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
    194            *          if the algorithm mode is HMAC.       
    195            * @retval None
    196            */
    197          void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
    198          {
    199            /* Check the parameters */
    200            assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
    201            assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
    202            assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
    203            
    204            /* Configure the Algorithm used, algorithm mode and the datatype */
    205            HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
    206            HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
    207                         HASH_InitStruct->HASH_DataType | \
    208                         HASH_InitStruct->HASH_AlgoMode);
    209            
    210            /* if algorithm mode is HMAC, set the Key */  
    211            if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
    212            {
    213              assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
    214              HASH->CR &= ~HASH_CR_LKEY;
    215              HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
    216            }
    217          
    218            /* Reset the HASH processor core, so that the HASH will be ready to compute 
    219               the message digest of a new message */
    220            HASH->CR |= HASH_CR_INIT;  
    221          }
    222          
    223          /**
    224            * @brief  Fills each HASH_InitStruct member with its default value.
    225            * @param  HASH_InitStruct : pointer to a HASH_InitTypeDef structure which will
    226            *          be initialized.  
    227            *  @note  The default values set are : Processor mode is HASH, Algorithm selected is SHA1,
    228            *          Data type selected is 32b and HMAC Key Type is short key.  
    229            * @retval None
    230            */
    231          void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
    232          {
    233            /* Initialize the HASH_AlgoSelection member */
    234            HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
    235          
    236            /* Initialize the HASH_AlgoMode member */
    237            HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
    238          
    239            /* Initialize the HASH_DataType member */
    240            HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
    241          
    242            /* Initialize the HASH_HMACKeyType member */
    243            HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
    244          }
    245          
    246          /**
    247            * @brief  Resets the HASH processor core, so that the HASH will be ready
    248            *         to compute the message digest of a new message.
    249            * @note   Calling this function will clear the HASH_SR_DCIS (Digest calculation 
    250            *         completion interrupt status) bit corresponding to HASH_IT_DCI 
    251            *         interrupt and HASH_FLAG_DCIS flag. 
    252            * @param  None
    253            * @retval None
    254            */
    255          void HASH_Reset(void)
    256          {
    257            /* Reset the HASH processor core */
    258            HASH->CR |= HASH_CR_INIT;
    259          }
    260          /**
    261            * @}
    262            */
    263           
    264          /** @defgroup HASH_Group2 Message Digest generation functions
    265           *  @brief    Message Digest generation functions
    266           *
    267          @verbatim    
    268           ===============================================================================
    269                                Message Digest generation functions
    270           ===============================================================================  
    271            This section provides functions allowing the generation of message digest: 
    272            - Push data in the IN FIFO : using HASH_DataIn()
    273            - Get the number of words set in IN FIFO, use HASH_GetInFIFOWordsNbr()  
    274            - set the last word valid bits number using HASH_SetLastWordValidBitsNbr() 
    275            - start digest calculation : using HASH_StartDigest()
    276            - Get the Digest message : using HASH_GetDigest()
    277           
    278          @endverbatim
    279            * @{
    280            */
    281          
    282          
    283          /**
    284            * @brief  Configure the Number of valid bits in last word of the message
    285            * @param  ValidNumber: Number of valid bits in last word of the message.
    286            *           This parameter must be a number between 0 and 0x1F.
    287            *             - 0x00: All 32 bits of the last data written are valid
    288            *             - 0x01: Only bit [0] of the last data written is valid
    289            *             - 0x02: Only bits[1:0] of the last data written are valid
    290            *             - 0x03: Only bits[2:0] of the last data written are valid
    291            *             - ...
    292            *             - 0x1F: Only bits[30:0] of the last data written are valid    
    293            * @note   The Number of valid bits must be set before to start the message 
    294            *         digest competition (in Hash and HMAC) and key treatment(in HMAC).    
    295            * @retval None
    296            */
    297          void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
    298          {
    299            /* Check the parameters */
    300            assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
    301            
    302            /* Configure the Number of valid bits in last word of the message */
    303            HASH->STR &= ~(HASH_STR_NBW);
    304            HASH->STR |= ValidNumber;
    305          }
    306          
    307          /**
    308            * @brief  Writes data in the Data Input FIFO
    309            * @param  Data: new data of the message to be processed.
    310            * @retval None
    311            */
    312          void HASH_DataIn(uint32_t Data)
    313          {
    314            /* Write in the DIN register a new data */
    315            HASH->DIN = Data;
    316          }
    317          
    318          /**
    319            * @brief  Returns the number of words already pushed into the IN FIFO.
    320            * @param  None
    321            * @retval The value of words already pushed into the IN FIFO.
    322            */
    323          uint8_t HASH_GetInFIFOWordsNbr(void)
    324          {
    325            /* Return the value of NBW bits */
    326            return ((HASH->CR & HASH_CR_NBW) >> 8);
    327          }
    328          
    329          /**
    330            * @brief  Provides the message digest result.
    331            * @note   In MD5 mode, Data[4] filed of HASH_MsgDigest structure is not used
    332            *         and is read as zero.  
    333            * @param  HASH_MessageDigest: pointer to a HASH_MsgDigest structure which will 
    334            *         hold the message digest result 
    335            * @retval None
    336            */
    337          void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
    338          {
    339            /* Get the data field */
    340            HASH_MessageDigest->Data[0] = HASH->HR[0];
    341            HASH_MessageDigest->Data[1] = HASH->HR[1];
    342            HASH_MessageDigest->Data[2] = HASH->HR[2];
    343            HASH_MessageDigest->Data[3] = HASH->HR[3];
    344            HASH_MessageDigest->Data[4] = HASH->HR[4];
    345          }
    346          
    347          /**
    348            * @brief  Starts the message padding and calculation of the final message     
    349            * @param  None
    350            * @retval None
    351            */
    352          void HASH_StartDigest(void)
    353          {
    354            /* Start the Digest calculation */
    355            HASH->STR |= HASH_STR_DCAL;
    356          }
    357          /**
    358            * @}
    359            */
    360          
    361          /** @defgroup HASH_Group3 Context swapping functions
    362           *  @brief   Context swapping functions
    363           *
    364          @verbatim   
    365           ===============================================================================
    366                                       Context swapping functions
    367           ===============================================================================  
    368          
    369            This section provides functions allowing to save and store HASH Context
    370            
    371            It is possible to interrupt a HASH/HMAC process to perform another processing 
    372            with a higher priority, and to complete the interrupted process later on, when 
    373            the higher priority task is complete. To do so, the context of the interrupted 
    374            task must be saved from the HASH registers to memory, and then be restored 
    375            from memory to the HASH registers.
    376            
    377            1. To save the current context, use HASH_SaveContext() function
    378            2. To restore the saved context, use HASH_RestoreContext() function 
    379            
    380          
    381          @endverbatim
    382            * @{
    383            */
    384            
    385          /**
    386            * @brief  Save the Hash peripheral Context. 
    387            * @note   The context can be saved only when no block is currently being 
    388            *         processed. So user must wait for DINIS = 1 (the last block has been 
    389            *         processed and the input FIFO is empty) or NBW != 0 (the FIFO is not 
    390            *         full and no processing is ongoing).   
    391            * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
    392            *         the repository for current context.
    393            * @retval None
    394            */
    395          void HASH_SaveContext(HASH_Context* HASH_ContextSave)
    396          {
    397            uint8_t i = 0;
    398            
    399            /* save context registers */
    400            HASH_ContextSave->HASH_IMR = HASH->IMR;  
    401            HASH_ContextSave->HASH_STR = HASH->STR;      
    402            HASH_ContextSave->HASH_CR  = HASH->CR;     
    403            for(i=0; i<=50;i++)
    404            {
    405               HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
    406            }   
    407          }
    408          
    409          /**
    410            * @brief  Restore the Hash peripheral Context.  
    411            * @note   After calling this function, user can restart the processing from the
    412            *         point where it has been interrupted.  
    413            * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
    414            *         the repository for saved context.
    415            * @retval None
    416            */
    417          void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
    418          {
    419            uint8_t i = 0;
    420            
    421            /* restore context registers */
    422            HASH->IMR = HASH_ContextRestore->HASH_IMR;   
    423            HASH->STR = HASH_ContextRestore->HASH_STR;     
    424            HASH->CR = HASH_ContextRestore->HASH_CR;
    425            
    426            /* Initialize the hash processor */
    427            HASH->CR |= HASH_CR_INIT; 
    428            
    429             /* continue restoring context registers */     
    430            for(i=0; i<=50;i++)
    431            {
    432               HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
    433            }   
    434          }
    435          /**
    436            * @}
    437            */
    438          
    439          /** @defgroup HASH_Group4 HASH's DMA interface Configuration function
    440           *  @brief   HASH's DMA interface Configuration function 
    441           *
    442          @verbatim   
    443           ===============================================================================
    444                             HASH's DMA interface Configuration function
    445           ===============================================================================  
    446          
    447            This section provides functions allowing to configure the DMA interface for 
    448            HASH/ HMAC data input transfer.
    449             
    450            When the DMA mode is enabled (using the HASH_DMACmd() function), data can be 
    451            sent to the IN FIFO using the DMA peripheral.
    452          
    453          
    454          
    455          @endverbatim
    456            * @{
    457            */
    458            
    459          /**
    460            * @brief  Enables or disables the HASH DMA interface.
    461            * @note   The DMA is disabled by hardware after the end of transfer.
    462            * @param  NewState: new state of the selected HASH DMA transfer request.
    463            *          This parameter can be: ENABLE or DISABLE.
    464            * @retval None
    465            */
    466          void HASH_DMACmd(FunctionalState NewState)
    467          {
    468            /* Check the parameters */
    469            assert_param(IS_FUNCTIONAL_STATE(NewState));
    470          
    471            if (NewState != DISABLE)
    472            {
    473              /* Enable the HASH DMA request */
    474              HASH->CR |= HASH_CR_DMAE;
    475            }
    476            else
    477            {
    478              /* Disable the HASH DMA request */
    479              HASH->CR &= ~HASH_CR_DMAE;
    480            }
    481          }
    482          /**
    483            * @}
    484            */
    485          
    486          /** @defgroup HASH_Group5 Interrupts and flags management functions
    487           *  @brief   Interrupts and flags management functions
    488           *
    489          @verbatim   
    490           ===============================================================================
    491                             Interrupts and flags management functions
    492           ===============================================================================  
    493          
    494            This section provides functions allowing to configure the HASH Interrupts and 
    495            to get the status and clear flags and Interrupts pending bits.
    496            
    497            The HASH provides 2 Interrupts sources and 5 Flags:
    498            
    499            Flags :
    500            ---------- 
    501               1. HASH_FLAG_DINIS : set when 16 locations are free in the Data IN FIFO 
    502                                    which means that a  new block (512 bit) can be entered 
    503                                    into the input buffer.
    504                                    
    505               2. HASH_FLAG_DCIS :  set when Digest calculation is complete
    506                
    507               3. HASH_FLAG_DMAS :  set when HASH's DMA interface is enabled (DMAE=1) or 
    508                                    a transfer is ongoing.
    509                                    This Flag is cleared only by hardware.
    510                                     
    511               4. HASH_FLAG_BUSY :  set when The hash core is processing a block of data
    512                                    This Flag is cleared only by hardware. 
    513                                     
    514               5. HASH_FLAG_DINNE : set when Data IN FIFO is not empty which means that 
    515                                    the Data IN FIFO contains at least one word of data.
    516                                    This Flag is cleared only by hardware.
    517               
    518            Interrupts :
    519            ------------
    520              
    521             1. HASH_IT_DINI  : if enabled, this interrupt source is pending when 16 
    522                                locations are free in the Data IN FIFO  which means that 
    523                                a new block (512 bit) can be entered into the input buffer.
    524                                This interrupt source is cleared using 
    525                                HASH_ClearITPendingBit(HASH_IT_DINI) function.
    526             
    527             2. HASH_IT_DCI   : if enabled, this interrupt source is pending when Digest 
    528                                calculation is complete.
    529                                This interrupt source is cleared using 
    530                                HASH_ClearITPendingBit(HASH_IT_DCI) function.
    531          
    532            Managing the HASH controller events :
    533            ------------------------------------ 
    534            The user should identify which mode will be used in his application to manage 
    535            the HASH controller events: Polling mode or Interrupt mode.
    536            
    537            1.  In the Polling Mode it is advised to use the following functions:
    538                - HASH_GetFlagStatus() : to check if flags events occur. 
    539                - HASH_ClearFlag()     : to clear the flags events.
    540              
    541            2.  In the Interrupt Mode it is advised to use the following functions:
    542                - HASH_ITConfig()       : to enable or disable the interrupt source.
    543                - HASH_GetITStatus()    : to check if Interrupt occurs.
    544                - HASH_ClearITPendingBit() : to clear the Interrupt pending Bit 
    545                                          (corresponding Flag). 
    546          
    547          @endverbatim
    548            * @{
    549            */ 
    550            
    551          /**
    552            * @brief  Enables or disables the specified HASH interrupts.
    553            * @param  HASH_IT: specifies the HASH interrupt source to be enabled or disabled.
    554            *          This parameter can be any combination of the following values:
    555            *            @arg HASH_IT_DINI: Data Input interrupt
    556            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    557            * @param  NewState: new state of the specified HASH interrupt.
    558            *           This parameter can be: ENABLE or DISABLE.
    559            * @retval None
    560            */
    561          void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
    562          {
    563            /* Check the parameters */
    564            assert_param(IS_HASH_IT(HASH_IT));
    565            assert_param(IS_FUNCTIONAL_STATE(NewState));
    566          
    567            if (NewState != DISABLE)
    568            {
    569              /* Enable the selected HASH interrupt */
    570              HASH->IMR |= HASH_IT;
    571            }
    572            else
    573            {
    574              /* Disable the selected HASH interrupt */
    575              HASH->IMR &= (uint8_t) ~HASH_IT;
    576            }
    577          }
    578          
    579          /**
    580            * @brief  Checks whether the specified HASH flag is set or not.
    581            * @param  HASH_FLAG: specifies the HASH flag to check.
    582            *          This parameter can be one of the following values:
    583            *            @arg HASH_FLAG_DINIS: Data input interrupt status flag
    584            *            @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag
    585            *            @arg HASH_FLAG_BUSY: Busy flag
    586            *            @arg HASH_FLAG_DMAS: DMAS Status flag
    587            *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag
    588            * @retval The new state of HASH_FLAG (SET or RESET)
    589            */
    590          FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
    591          {
    592            FlagStatus bitstatus = RESET;
    593            uint32_t tempreg = 0;
    594          
    595            /* Check the parameters */
    596            assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
    597          
    598            /* check if the FLAG is in CR register */
    599            if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
    600            {
    601              tempreg = HASH->CR;
    602            }
    603            else /* The FLAG is in SR register */
    604            {
    605              tempreg = HASH->SR;
    606            }
    607          
    608            /* Check the status of the specified HASH flag */
    609            if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
    610            {
    611              /* HASH is set */
    612              bitstatus = SET;
    613            }
    614            else
    615            {
    616              /* HASH_FLAG is reset */
    617              bitstatus = RESET;
    618            }
    619          
    620            /* Return the HASH_FLAG status */
    621            return  bitstatus;
    622          }
    623          /**
    624            * @brief  Clears the HASH flags.
    625            * @param  HASH_FLAG: specifies the flag to clear. 
    626            *          This parameter can be any combination of the following values:
    627            *            @arg HASH_FLAG_DINIS: Data Input Flag
    628            *            @arg HASH_FLAG_DCIS: Digest Calculation Completion Flag                       
    629            * @retval None
    630            */
    631          void HASH_ClearFlag(uint16_t HASH_FLAG)
    632          {
    633            /* Check the parameters */
    634            assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
    635            
    636            /* Clear the selected HASH flags */
    637            HASH->SR = ~(uint32_t)HASH_FLAG;
    638          }
    639          /**
    640            * @brief  Checks whether the specified HASH interrupt has occurred or not.
    641            * @param  HASH_IT: specifies the HASH interrupt source to check.
    642            *          This parameter can be one of the following values:
    643            *            @arg HASH_IT_DINI: Data Input interrupt
    644            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    645            * @retval The new state of HASH_IT (SET or RESET).
    646            */
    647          ITStatus HASH_GetITStatus(uint8_t HASH_IT)
    648          {
    649            ITStatus bitstatus = RESET;
    650            uint32_t tmpreg = 0;
    651          
    652            /* Check the parameters */
    653            assert_param(IS_HASH_GET_IT(HASH_IT));  
    654          
    655          
    656            /* Check the status of the specified HASH interrupt */
    657            tmpreg =  HASH->SR;
    658          
    659            if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
    660            {
    661              /* HASH_IT is set */
    662              bitstatus = SET;
    663            }
    664            else
    665            {
    666              /* HASH_IT is reset */
    667              bitstatus = RESET;
    668            }
    669            /* Return the HASH_IT status */
    670            return bitstatus;
    671          }
    672          
    673          /**
    674            * @brief  Clears the HASH interrupt pending bit(s).
    675            * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.
    676            *          This parameter can be any combination of the following values:
    677            *            @arg HASH_IT_DINI: Data Input interrupt
    678            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    679            * @retval None
    680            */
    681          void HASH_ClearITPendingBit(uint8_t HASH_IT)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_HASH_IT(HASH_IT));
    685          
    686            /* Clear the selected HASH interrupt pending bit */
    687            HASH->SR = (uint8_t)~HASH_IT;
    688          }
    689          
    690          /**
    691            * @}
    692            */ 
    693          
    694          /**
    695            * @}
    696            */ 
    697          
    698          /**
    699            * @}
    700            */ 
    701          
    702          /**
    703            * @}
    704            */ 
    705          
    706          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HASH_ClearFlag
         8   -> assert_failed
       8   HASH_ClearITPendingBit
         8   -> assert_failed
       8   HASH_DMACmd
         8   -> assert_failed
       0   HASH_DataIn
       8   HASH_DeInit
         0   -> RCC_AHB2PeriphResetCmd
         8   -> RCC_AHB2PeriphResetCmd
       0   HASH_GetDigest
      16   HASH_GetFlagStatus
        16   -> assert_failed
      16   HASH_GetITStatus
        16   -> assert_failed
       0   HASH_GetInFIFOWordsNbr
      16   HASH_ITConfig
        16   -> assert_failed
      16   HASH_Init
        16   -> assert_failed
       0   HASH_Reset
       0   HASH_RestoreContext
       0   HASH_SaveContext
       8   HASH_SetLastWordValidBitsNbr
         8   -> assert_failed
       0   HASH_StartDigest
       0   HASH_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     112  ?<Constant "C:\\Tools\\IAR Systems\\...">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
      32  HASH_ClearFlag
      34  HASH_ClearITPendingBit
      42  HASH_DMACmd
       6  HASH_DataIn
      22  HASH_DeInit
      24  HASH_GetDigest
      58  HASH_GetFlagStatus
      44  HASH_GetITStatus
      12  HASH_GetInFIFOWordsNbr
      66  HASH_ITConfig
     152  HASH_Init
      12  HASH_Reset
      52  HASH_RestoreContext
      44  HASH_SaveContext
      38  HASH_SetLastWordValidBitsNbr
      12  HASH_StartDigest
      12  HASH_StructInit

 
 802 bytes in section .text
 
 802 bytes of CODE memory

Errors: none
Warnings: none
