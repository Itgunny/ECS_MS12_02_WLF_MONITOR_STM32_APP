###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      07/Apr/2014  17:52:47 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\src\stm32f4xx_spi.c                          #
#    Command line =  C:\Tools\WL9F\WL_F_Monitor_APP\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\src\stm32f4xx_spi.c -D USE_STDPERIPH_DRIVER  #
#                    -D STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT     #
#                    -lcN C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\  #
#                    -o C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\     #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Platfo #
#                    rm\COMMON\INC\ -I "C:\Tools\WL9F\WL_F_Monitor_APP\Projec #
#                    t\..\Platform\TaeHa - ECS\INC\" -I                       #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\CMSI #
#                    S\Device\ST\STM32F4xx\Include\ -I                        #
#                    C:\Tools\WL9F\WL_F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\ -Oh --use_c++_inline -I      #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\List\stm32f #
#                    4xx_spi.lst                                              #
#    Object file  =  C:\Tools\WL9F\WL_F_Monitor_APP\Project\Debug\Obj\stm32f4 #
#                    xx_spi.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WL_F_Monitor_APP\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *                    
     18            *          ===================================================================
     19            *                                 How to use this driver
     20            *          ===================================================================
     21            *    
     22            *          1. Enable peripheral clock using the following functions 
     23            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     24            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     25            *             RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3.
     26            *
     27            *          2. Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     28            *             function.
     29            *             In I2S mode, if an external clock source is used then the I2S CKIN pin GPIO
     30            *             clock should also be enabled.
     31            *
     32            *          3. Peripherals alternate function: 
     33            *                 - Connect the pin to the desired peripherals' Alternate 
     34            *                   Function (AF) using GPIO_PinAFConfig() function
     35            *                 - Configure the desired pin in alternate function by:
     36            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     37            *                 - Select the type, pull-up/pull-down and output speed via 
     38            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     39            *                 - Call GPIO_Init() function
     40            *              In I2S mode, if an external clock source is used then the I2S CKIN pin
     41            *              should be also configured in Alternate function Push-pull pull-up mode. 
     42            *        
     43            *          4. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     44            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     45            *             function.
     46            *             In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     47            *             frequency and Polarity using I2S_Init() function.
     48            *             For I2S mode, make sure that either:
     49            *              - I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), 
     50            *                RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
     51            *              or 
     52            *              - External clock source is configured using the function 
     53            *                RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the define constant
     54            *                I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
     55            *
     56            *          5. Enable the NVIC and the corresponding interrupt using the function 
     57            *             SPI_ITConfig() if you need to use interrupt mode. 
     58            *
     59            *          6. When using the DMA mode 
     60            *                   - Configure the DMA using DMA_Init() function
     61            *                   - Active the needed channel Request using SPI_I2S_DMACmd() function
     62            * 
     63            *          7. Enable the SPI using the SPI_Cmd() function or enable the I2S using
     64            *             I2S_Cmd().
     65            * 
     66            *          8. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     67            *
     68            *          9. Optionally, you can enable/configure the following parameters without
     69            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     70            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     71            *                is programmed as Data direction parameter using the SPI_Init() function
     72            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     73            *                using the SPI_BiDirectionalLineConfig() function.
     74            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     75            *                using the SPI_Init() function it can be possible to manage the 
     76            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     77            *              - Reconfigure the data size using the SPI_DataSizeConfig() function  
     78            *              - Enable or disable the SS output using the SPI_SSOutputCmd() function  
     79            *          
     80            *          10. To use the CRC Hardware calculation feature refer to the Peripheral 
     81            *              CRC hardware Calculation subsection.
     82            *   
     83            *
     84            *          It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
     85            *          peripheral is able to manage sending and receiving data simultaneously
     86            *          using two data lines. Each SPI peripheral has an extended block called I2Sxext
     87            *          (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
     88            *          The extension block is not a full SPI IP, it is used only as I2S slave to
     89            *          implement full duplex mode. The extension block uses the same clock sources
     90            *          as its master.          
     91            *          To configure I2S full duplex you have to:
     92            *            
     93            *          1. Configure SPIx in I2S mode (I2S_Init() function) as described above. 
     94            *           
     95            *          2. Call the I2S_FullDuplexConfig() function using the same strucutre passed to  
     96            *             I2S_Init() function.
     97            *            
     98            *          3. Call I2S_Cmd() for SPIx then for its extended block.
     99            *          
    100            *          4. To configure interrupts or DMA requests and to get/clear flag status, 
    101            *             use I2Sxext instance for the extension block.
    102            *             
    103            *          Functions that can be called with I2Sxext instances are:
    104            *          I2S_Cmd(), I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
    105            *          SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), SPI_I2S_ClearFlag(),
    106            *          SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
    107            *                 
    108            *          Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
    109            *            
    110            *          RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
    111            *          I2S_StructInit(&I2SInitStruct);
    112            *          I2SInitStruct.Mode = I2S_Mode_MasterTx;     
    113            *          I2S_Init(SPI3, &I2SInitStruct);
    114            *          I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
    115            *          I2S_Cmd(SPI3, ENABLE);
    116            *          I2S_Cmd(SPI3ext, ENABLE);
    117            *          ...
    118            *          while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
    119            *          {}
    120            *          SPI_I2S_SendData(SPI3, txdata[i]);
    121            *          ...  
    122            *          while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
    123            *          {}
    124            *          rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
    125            *          ...          
    126            *              
    127            *     
    128            * @note    In I2S mode: if an external clock is used as source clock for the I2S,  
    129            *          then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
    130            *          be enabled and set to the value of the source clock frequency (in Hz).
    131            * 
    132            * @note    In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
    133            *          just after calling the function SPI_Init().
    134            *
    135            *  @endverbatim  
    136            *                                  
    137            ******************************************************************************
    138            * @attention
    139            *
    140            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    141            *
    142            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    143            * You may not use this file except in compliance with the License.
    144            * You may obtain a copy of the License at:
    145            *
    146            *        http://www.st.com/software_license_agreement_liberty_v2
    147            *
    148            * Unless required by applicable law or agreed to in writing, software 
    149            * distributed under the License is distributed on an "AS IS" BASIS, 
    150            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    151            * See the License for the specific language governing permissions and
    152            * limitations under the License.
    153            *
    154            ******************************************************************************
    155            */ 
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32f4xx_spi.h"
    159          #include "stm32f4xx_rcc.h"
    160          
    161          /** @addtogroup STM32F4xx_StdPeriph_Driver
    162            * @{
    163            */
    164          
    165          /** @defgroup SPI 
    166            * @brief SPI driver modules
    167            * @{
    168            */ 
    169          
    170          /* Private typedef -----------------------------------------------------------*/
    171          /* Private define ------------------------------------------------------------*/
    172          
    173          /* SPI registers Masks */
    174          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    175          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    176          
    177          /* RCC PLLs masks */
    178          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    179          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    180          
    181          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    182          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    183          
    184          /* Private macro -------------------------------------------------------------*/
    185          /* Private variables ---------------------------------------------------------*/
    186          /* Private function prototypes -----------------------------------------------*/
    187          /* Private functions ---------------------------------------------------------*/
    188          
    189          /** @defgroup SPI_Private_Functions
    190            * @{
    191            */
    192          
    193          /** @defgroup SPI_Group1 Initialization and Configuration functions
    194           *  @brief   Initialization and Configuration functions 
    195           *
    196          @verbatim   
    197           ===============================================================================
    198                            Initialization and Configuration functions
    199           ===============================================================================  
    200          
    201            This section provides a set of functions allowing to initialize the SPI Direction,
    202            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    203            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    204            
    205            The SPI_Init() function follows the SPI configuration procedures for Master mode
    206            and Slave mode (details for these procedures are available in reference manual
    207            (RM0090)).
    208            
    209          @endverbatim
    210            * @{
    211            */
    212          
    213          /**
    214            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
    215            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    216            *         in SPI mode or 2 or 3 in I2S mode.   
    217            *         
    218            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are deinitialized
    219            *         when the relative I2S peripheral is deinitialized (the extended block's clock
    220            *         is managed by the I2S peripheral clock).
    221            *             
    222            * @retval None
    223            */
    224          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    225          {
    226            /* Check the parameters */
    227            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    228          
    229            if (SPIx == SPI1)
    230            {
    231              /* Enable SPI1 reset state */
    232              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    233              /* Release SPI1 from reset state */
    234              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
    235            }
    236            else if (SPIx == SPI2)
    237            {
    238              /* Enable SPI2 reset state */
    239              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    240              /* Release SPI2 from reset state */
    241              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
    242              }
    243            else
    244            {
    245              if (SPIx == SPI3)
    246              {
    247                /* Enable SPI3 reset state */
    248                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    249                /* Release SPI3 from reset state */
    250                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    251              }
    252            }
    253          }
    254          
    255          /**
    256            * @brief  Initializes the SPIx peripheral according to the specified 
    257            *         parameters in the SPI_InitStruct.
    258            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    259            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    260            *         contains the configuration information for the specified SPI peripheral.
    261            * @retval None
    262            */
    263          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    264          {
    265            uint16_t tmpreg = 0;
    266            
    267            /* check the parameters */
    268            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    269            
    270            /* Check the SPI parameters */
    271            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    272            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    273            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    274            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    275            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    276            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    277            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    278            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    279            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    280          
    281          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    282            /* Get the SPIx CR1 value */
    283            tmpreg = SPIx->CR1;
    284            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    285            tmpreg &= CR1_CLEAR_MASK;
    286            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    287               master/salve mode, CPOL and CPHA */
    288            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    289            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    290            /* Set LSBFirst bit according to SPI_FirstBit value */
    291            /* Set BR bits according to SPI_BaudRatePrescaler value */
    292            /* Set CPOL bit according to SPI_CPOL value */
    293            /* Set CPHA bit according to SPI_CPHA value */
    294            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    295                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    296                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    297                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    298            /* Write to SPIx CR1 */
    299            SPIx->CR1 = tmpreg;
    300          
    301            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    302            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
    303          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    304            /* Write to SPIx CRCPOLY */
    305            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
    306          }
    307          
    308          /**
    309            * @brief  Initializes the SPIx peripheral according to the specified 
    310            *         parameters in the I2S_InitStruct.
    311            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    312            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    313            *         contains the configuration information for the specified SPI peripheral
    314            *         configured in I2S mode.
    315            *           
    316            * @note   The function calculates the optimal prescaler needed to obtain the most 
    317            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    318            *         and the product configuration). But in case the prescaler value is greater 
    319            *         than 511, the default value (0x02) will be configured instead.    
    320            * 
    321            * @note   if an external clock is used as source clock for the I2S, then the define
    322            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
    323            *         to the value of the the source clock frequency (in Hz).
    324            *  
    325            * @retval None
    326            */
    327          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    328          {
    329            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
    330            uint32_t tmp = 0, i2sclk = 0;
    331          #ifndef I2S_EXTERNAL_CLOCK_VAL
    332            uint32_t pllm = 0, plln = 0, pllr = 0;
    333          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    334            
    335            /* Check the I2S parameters */
    336            assert_param(IS_SPI_23_PERIPH(SPIx));
    337            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    338            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    339            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    340            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    341            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    342            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    343          
    344          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    345            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    346            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
    347            SPIx->I2SPR = 0x0002;
    348            
    349            /* Get the I2SCFGR register value */
    350            tmpreg = SPIx->I2SCFGR;
    351            
    352            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    353            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
    354            {
    355              i2sodd = (uint16_t)0;
    356              i2sdiv = (uint16_t)2;   
    357            }
    358            /* If the requested audio frequency is not the default, compute the prescaler */
    359            else
    360            {
    361              /* Check the frame length (For the Prescaler computing) *******************/
    362              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    363              {
    364                /* Packet length is 16 bits */
    365                packetlength = 1;
    366              }
    367              else
    368              {
    369                /* Packet length is 32 bits */
    370                packetlength = 2;
    371              }
    372          
    373              /* Get I2S source Clock frequency  ****************************************/
    374                
    375              /* If an external I2S clock has to be used, this define should be set  
    376                 in the project configuration or in the stm32f4xx_conf.h file */
    377            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    378              /* Set external clock as I2S clock source */
    379              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    380              {
    381                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    382              }
    383              
    384              /* Set the I2S clock to the external clock  value */
    385              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    386          
    387            #else /* There is no define for External I2S clock source */
    388              /* Set PLLI2S as I2S clock source */
    389              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
    390              {
    391                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    392              }    
    393              
    394              /* Get the PLLI2SN value */
    395              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    396                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    397              
    398              /* Get the PLLI2SR value */
    399              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    400                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    401              
    402              /* Get the PLLM value */
    403              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
    404              
    405              /* Get the I2S source clock value */
    406              i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
    407            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    408              
    409              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    410              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    411              {
    412                /* MCLK output is enabled */
    413                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    414              }
    415              else
    416              {
    417                /* MCLK output is disabled */
    418                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    419              }
    420              
    421              /* Remove the flatting point */
    422              tmp = tmp / 10;  
    423                
    424              /* Check the parity of the divider */
    425              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
    426             
    427              /* Compute the i2sdiv prescaler */
    428              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
    429             
    430              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    431              i2sodd = (uint16_t) (i2sodd << 8);
    432            }
    433          
    434            /* Test if the divider is 1 or 0 or greater than 0xFF */
    435            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
    436            {
    437              /* Set the default values */
    438              i2sdiv = 2;
    439              i2sodd = 0;
    440            }
    441          
    442            /* Write to SPIx I2SPR register the computed value */
    443            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
    444           
    445            /* Configure the I2S with the SPI_InitStruct values */
    446            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    447                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    448                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    449           
    450            /* Write to SPIx I2SCFGR */  
    451            SPIx->I2SCFGR = tmpreg;
    452          }
    453          
    454          /**
    455            * @brief  Fills each SPI_InitStruct member with its default value.
    456            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    457            * @retval None
    458            */
    459          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    460          {
    461          /*--------------- Reset SPI init structure parameters values -----------------*/
    462            /* Initialize the SPI_Direction member */
    463            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    464            /* initialize the SPI_Mode member */
    465            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
    466            /* initialize the SPI_DataSize member */
    467            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
    468            /* Initialize the SPI_CPOL member */
    469            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
    470            /* Initialize the SPI_CPHA member */
    471            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
    472            /* Initialize the SPI_NSS member */
    473            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
    474            /* Initialize the SPI_BaudRatePrescaler member */
    475            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
    476            /* Initialize the SPI_FirstBit member */
    477            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
    478            /* Initialize the SPI_CRCPolynomial member */
    479            SPI_InitStruct->SPI_CRCPolynomial = 7;
    480          }
    481          
    482          /**
    483            * @brief  Fills each I2S_InitStruct member with its default value.
    484            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    485            * @retval None
    486            */
    487          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    488          {
    489          /*--------------- Reset I2S init structure parameters values -----------------*/
    490            /* Initialize the I2S_Mode member */
    491            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
    492            
    493            /* Initialize the I2S_Standard member */
    494            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
    495            
    496            /* Initialize the I2S_DataFormat member */
    497            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
    498            
    499            /* Initialize the I2S_MCLKOutput member */
    500            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
    501            
    502            /* Initialize the I2S_AudioFreq member */
    503            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
    504            
    505            /* Initialize the I2S_CPOL member */
    506            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
    507          }
    508          
    509          /**
    510            * @brief  Enables or disables the specified SPI peripheral.
    511            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    512            * @param  NewState: new state of the SPIx peripheral. 
    513            *          This parameter can be: ENABLE or DISABLE.
    514            * @retval None
    515            */
    516          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    517          {
    518            /* Check the parameters */
    519            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    520            assert_param(IS_FUNCTIONAL_STATE(NewState));
    521            if (NewState != DISABLE)
    522            {
    523              /* Enable the selected SPI peripheral */
    524              SPIx->CR1 |= SPI_CR1_SPE;
    525            }
    526            else
    527            {
    528              /* Disable the selected SPI peripheral */
    529              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
    530            }
    531          }
    532          
    533          /**
    534            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    535            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
    536            *         for full duplex mode).
    537            * @param  NewState: new state of the SPIx peripheral. 
    538            *         This parameter can be: ENABLE or DISABLE.
    539            * @retval None
    540            */
    541          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    542          {
    543            /* Check the parameters */
    544            assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
    545            assert_param(IS_FUNCTIONAL_STATE(NewState));
    546            
    547            if (NewState != DISABLE)
    548            {
    549              /* Enable the selected SPI peripheral (in I2S mode) */
    550              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
    551            }
    552            else
    553            {
    554              /* Disable the selected SPI peripheral in I2S mode */
    555              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
    556            }
    557          }
    558          
    559          /**
    560            * @brief  Configures the data size for the selected SPI.
    561            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    562            * @param  SPI_DataSize: specifies the SPI data size.
    563            *          This parameter can be one of the following values:
    564            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    565            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    566            * @retval None
    567            */
    568          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    569          {
    570            /* Check the parameters */
    571            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    572            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    573            /* Clear DFF bit */
    574            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
    575            /* Set new DFF bit value */
    576            SPIx->CR1 |= SPI_DataSize;
    577          }
    578          
    579          /**
    580            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    581            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    582            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    583            *          This parameter can be one of the following values:
    584            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    585            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    586            * @retval None
    587            */
    588          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    589          {
    590            /* Check the parameters */
    591            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    592            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    593            if (SPI_Direction == SPI_Direction_Tx)
    594            {
    595              /* Set the Tx only mode */
    596              SPIx->CR1 |= SPI_Direction_Tx;
    597            }
    598            else
    599            {
    600              /* Set the Rx only mode */
    601              SPIx->CR1 &= SPI_Direction_Rx;
    602            }
    603          }
    604          
    605          /**
    606            * @brief  Configures internally by software the NSS pin for the selected SPI.
    607            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    608            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    609            *          This parameter can be one of the following values:
    610            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    611            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    612            * @retval None
    613            */
    614          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    615          {
    616            /* Check the parameters */
    617            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    618            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    619            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
    620            {
    621              /* Set NSS pin internally by software */
    622              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
    623            }
    624            else
    625            {
    626              /* Reset NSS pin internally by software */
    627              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
    628            }
    629          }
    630          
    631          /**
    632            * @brief  Enables or disables the SS output for the selected SPI.
    633            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    634            * @param  NewState: new state of the SPIx SS output. 
    635            *          This parameter can be: ENABLE or DISABLE.
    636            * @retval None
    637            */
    638          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    639          {
    640            /* Check the parameters */
    641            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    642            assert_param(IS_FUNCTIONAL_STATE(NewState));
    643            if (NewState != DISABLE)
    644            {
    645              /* Enable the selected SPI SS output */
    646              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
    647            }
    648            else
    649            {
    650              /* Disable the selected SPI SS output */
    651              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
    652            }
    653          }
    654          
    655          /**
    656            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    657            *   
    658            * @note   This function can be called only after the SPI_Init() function has 
    659            *         been called. 
    660            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    661            *         are not taken into consideration and are configured by hardware
    662            *         respectively to the TI mode requirements.  
    663            * 
    664            * @param  SPIx: where x can be 1, 2 or 3 
    665            * @param  NewState: new state of the selected SPI TI communication mode.
    666            *          This parameter can be: ENABLE or DISABLE.
    667            * @retval None
    668            */
    669          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    670          {
    671            /* Check the parameters */
    672            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    673            assert_param(IS_FUNCTIONAL_STATE(NewState));
    674          
    675            if (NewState != DISABLE)
    676            {
    677              /* Enable the TI mode for the selected SPI peripheral */
    678              SPIx->CR2 |= SPI_CR2_FRF;
    679            }
    680            else
    681            {
    682              /* Disable the TI mode for the selected SPI peripheral */
    683              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
    684            }
    685          }
    686          
    687          /**
    688            * @brief  Configures the full duplex mode for the I2Sx peripheral using its
    689            *         extension I2Sxext according to the specified parameters in the 
    690            *         I2S_InitStruct.
    691            * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
    692            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    693            *         contains the configuration information for the specified I2S peripheral
    694            *         extension.
    695            * 
    696            * @note   The structure pointed by I2S_InitStruct parameter should be the same
    697            *         used for the master I2S peripheral. In this case, if the master is 
    698            *         configured as transmitter, the slave will be receiver and vice versa.
    699            *         Or you can force a different mode by modifying the field I2S_Mode to the
    700            *         value I2S_SlaveRx or I2S_SlaveTx indepedently of the master configuration.    
    701            *         
    702            * @note   The I2S full duplex extension can be configured in slave mode only.    
    703            *  
    704            * @retval None
    705            */
    706          void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
    707          {
    708            uint16_t tmpreg = 0, tmp = 0;
    709            
    710            /* Check the I2S parameters */
    711            assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
    712            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    713            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    714            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    715            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    716          
    717          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    718            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    719            I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
    720            I2Sxext->I2SPR = 0x0002;
    721            
    722            /* Get the I2SCFGR register value */
    723            tmpreg = I2Sxext->I2SCFGR;
    724            
    725            /* Get the mode to be configured for the extended I2S */
    726            if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
    727            {
    728              tmp = I2S_Mode_SlaveRx;
    729            }
    730            else
    731            {
    732              if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    733              {
    734                tmp = I2S_Mode_SlaveTx;
    735              }
    736            }
    737          
    738           
    739            /* Configure the I2S with the SPI_InitStruct values */
    740            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
    741                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    742                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    743           
    744            /* Write to SPIx I2SCFGR */  
    745            I2Sxext->I2SCFGR = tmpreg;
    746          }
    747          
    748          /**
    749            * @}
    750            */
    751          
    752          /** @defgroup SPI_Group2 Data transfers functions
    753           *  @brief   Data transfers functions
    754           *
    755          @verbatim   
    756           ===============================================================================
    757                                   Data transfers functions
    758           ===============================================================================  
    759          
    760            This section provides a set of functions allowing to manage the SPI data transfers
    761            
    762            In reception, data are received and then stored into an internal Rx buffer while 
    763            In transmission, data are first stored into an internal Tx buffer before being 
    764            transmitted.
    765          
    766            The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    767            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    768            can be done using SPI_I2S_SendData() function and stores the written data into 
    769            Tx buffer.
    770          
    771          @endverbatim
    772            * @{
    773            */
    774          
    775          /**
    776            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    777            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    778            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    779            * @retval The value of the received data.
    780            */
    781          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    782          {
    783            /* Check the parameters */
    784            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    785            
    786            /* Return the data in the DR register */
    787            return SPIx->DR;
    788          }
    789          
    790          /**
    791            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    792            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    793            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
    794            * @param  Data: Data to be transmitted.
    795            * @retval None
    796            */
    797          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    798          {
    799            /* Check the parameters */
    800            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    801            
    802            /* Write in the DR register the data to be sent */
    803            SPIx->DR = Data;
    804          }
    805          
    806          /**
    807            * @}
    808            */
    809          
    810          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    811           *  @brief   Hardware CRC Calculation functions
    812           *
    813          @verbatim   
    814           ===============================================================================
    815                                   Hardware CRC Calculation functions
    816           ===============================================================================  
    817          
    818            This section provides a set of functions allowing to manage the SPI CRC hardware 
    819            calculation
    820          
    821            SPI communication using CRC is possible through the following procedure:
    822               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    823                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    824                  function.
    825               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    826               3. Enable the SPI using the SPI_Cmd() function
    827               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    828                SPI_TransmitCRC() function to indicate that after transmission of the last 
    829                data, the CRC should be transmitted.
    830               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    831                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    832                  value. 
    833                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    834                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    835          
    836          @note It is advised not to read the calculated CRC values during the communication.
    837          
    838          @note When the SPI is in slave mode, be careful to enable CRC calculation only 
    839                when the clock is stable, that is, when the clock is in the steady state. 
    840                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    841                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    842                the value of the SPE bit.
    843          
    844          @note With high bitrate frequencies, be careful when transmitting the CRC.
    845                As the number of used CPU cycles has to be as low as possible in the CRC 
    846                transfer phase, it is forbidden to call software functions in the CRC 
    847                transmission sequence to avoid errors in the last data and CRC reception. 
    848                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    849                of the last data.
    850          
    851          @note For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    852                degradation of the SPI speed performance due to CPU accesses impacting the 
    853                SPI bandwidth.
    854          
    855          @note When the STM32F4xx is configured as slave and the NSS hardware mode is 
    856                used, the NSS pin needs to be kept low between the data phase and the CRC 
    857                phase.
    858          
    859          @note When the SPI is configured in slave mode with the CRC feature enabled, CRC
    860                calculation takes place even if a high level is applied on the NSS pin. 
    861                This may happen for example in case of a multi-slave environment where the 
    862                communication master addresses slaves alternately.
    863          
    864          @note Between a slave de-selection (high level on NSS) and a new slave selection 
    865                (low level on NSS), the CRC value should be cleared on both master and slave
    866                sides in order to resynchronize the master and slave for their respective 
    867                CRC calculation.
    868          
    869          @note To clear the CRC, follow the procedure below:
    870                  1. Disable SPI using the SPI_Cmd() function
    871                  2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    872                  3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    873                  4. Enable SPI using the SPI_Cmd() function.
    874          
    875          @endverbatim
    876            * @{
    877            */
    878          
    879          /**
    880            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    881            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    882            * @param  NewState: new state of the SPIx CRC value calculation.
    883            *          This parameter can be: ENABLE or DISABLE.
    884            * @retval None
    885            */
    886          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    887          {
    888            /* Check the parameters */
    889            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    890            assert_param(IS_FUNCTIONAL_STATE(NewState));
    891            if (NewState != DISABLE)
    892            {
    893              /* Enable the selected SPI CRC calculation */
    894              SPIx->CR1 |= SPI_CR1_CRCEN;
    895            }
    896            else
    897            {
    898              /* Disable the selected SPI CRC calculation */
    899              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
    900            }
    901          }
    902          
    903          /**
    904            * @brief  Transmit the SPIx CRC value.
    905            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    906            * @retval None
    907            */
    908          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    909          {
    910            /* Check the parameters */
    911            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    912            
    913            /* Enable the selected SPI CRC transmission */
    914            SPIx->CR1 |= SPI_CR1_CRCNEXT;
    915          }
    916          
    917          /**
    918            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    919            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    920            * @param  SPI_CRC: specifies the CRC register to be read.
    921            *          This parameter can be one of the following values:
    922            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    923            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    924            * @retval The selected CRC register value..
    925            */
    926          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    927          {
    928            uint16_t crcreg = 0;
    929            /* Check the parameters */
    930            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    931            assert_param(IS_SPI_CRC(SPI_CRC));
    932            if (SPI_CRC != SPI_CRC_Rx)
    933            {
    934              /* Get the Tx CRC register */
    935              crcreg = SPIx->TXCRCR;
    936            }
    937            else
    938            {
    939              /* Get the Rx CRC register */
    940              crcreg = SPIx->RXCRCR;
    941            }
    942            /* Return the selected CRC register */
    943            return crcreg;
    944          }
    945          
    946          /**
    947            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    948            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    949            * @retval The CRC Polynomial register value.
    950            */
    951          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    952          {
    953            /* Check the parameters */
    954            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    955            
    956            /* Return the CRC polynomial register */
    957            return SPIx->CRCPR;
    958          }
    959          
    960          /**
    961            * @}
    962            */
    963          
    964          /** @defgroup SPI_Group4 DMA transfers management functions
    965           *  @brief   DMA transfers management functions
    966            *
    967          @verbatim   
    968           ===============================================================================
    969                                   DMA transfers management functions
    970           ===============================================================================  
    971          
    972          @endverbatim
    973            * @{
    974            */
    975          
    976          /**
    977            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    978            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    979            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    980            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    981            *          This parameter can be any combination of the following values:
    982            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    983            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    984            * @param  NewState: new state of the selected SPI DMA transfer request.
    985            *          This parameter can be: ENABLE or DISABLE.
    986            * @retval None
    987            */
    988          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    989          {
    990            /* Check the parameters */
    991            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    992            assert_param(IS_FUNCTIONAL_STATE(NewState));
    993            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    994          
    995            if (NewState != DISABLE)
    996            {
    997              /* Enable the selected SPI DMA requests */
    998              SPIx->CR2 |= SPI_I2S_DMAReq;
    999            }
   1000            else
   1001            {
   1002              /* Disable the selected SPI DMA requests */
   1003              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   1004            }
   1005          }
   1006          
   1007          /**
   1008            * @}
   1009            */
   1010          
   1011          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1012           *  @brief   Interrupts and flags management functions
   1013            *
   1014          @verbatim   
   1015           ===============================================================================
   1016                                   Interrupts and flags management functions
   1017           ===============================================================================  
   1018          
   1019            This section provides a set of functions allowing to configure the SPI Interrupts 
   1020            sources and check or clear the flags or pending bits status.
   1021            The user should identify which mode will be used in his application to manage 
   1022            the communication: Polling mode, Interrupt mode or DMA mode. 
   1023              
   1024            Polling Mode
   1025            =============
   1026            In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1027               1. SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1028               2. SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1029               3. SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1030               4. SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1031               5. SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1032               6. SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1033               7. I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
   1034               8. I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1035               9. I2S_FLAG_CHSIDE: to indicate Channel Side.
   1036          
   1037          @note Do not use the BSY flag to handle each data transmission or reception.  It is
   1038                better to use the TXE and RXNE flags instead.
   1039          
   1040            In this Mode it is advised to use the following functions:
   1041               - FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1042               - void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1043          
   1044            Interrupt Mode
   1045            ===============
   1046            In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
   1047            and 7 pending bits: 
   1048            Pending Bits:
   1049            ------------- 
   1050               1. SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1051               2. SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1052               3. SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
   1053               4. SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
   1054               5. SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1055               6. I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
   1056               7. I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
   1057          
   1058            Interrupt Source:
   1059            -----------------
   1060               1. SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1061                                  interrupt.  
   1062               2. SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1063                                    empty interrupt.
   1064               3. SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1065          
   1066            In this Mode it is advised to use the following functions:
   1067               - void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1068               - ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1069               - void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1070          
   1071            DMA Mode
   1072            ========
   1073            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   1074               1. SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1075               2. SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1076          
   1077            In this Mode it is advised to use the following function:
   1078              - void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
   1079          
   1080          @endverbatim
   1081            * @{
   1082            */
   1083          
   1084          /**
   1085            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1086            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1087            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1088            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1089            *          This parameter can be one of the following values:
   1090            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1091            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1092            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1093            * @param  NewState: new state of the specified SPI interrupt.
   1094            *          This parameter can be: ENABLE or DISABLE.
   1095            * @retval None
   1096            */
   1097          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1098          {
   1099            uint16_t itpos = 0, itmask = 0 ;
   1100            
   1101            /* Check the parameters */
   1102            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1103            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1104            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   1105          
   1106            /* Get the SPI IT index */
   1107            itpos = SPI_I2S_IT >> 4;
   1108          
   1109            /* Set the IT mask */
   1110            itmask = (uint16_t)1 << (uint16_t)itpos;
   1111          
   1112            if (NewState != DISABLE)
   1113            {
   1114              /* Enable the selected SPI interrupt */
   1115              SPIx->CR2 |= itmask;
   1116            }
   1117            else
   1118            {
   1119              /* Disable the selected SPI interrupt */
   1120              SPIx->CR2 &= (uint16_t)~itmask;
   1121            }
   1122          }
   1123          
   1124          /**
   1125            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1126            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1127            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1128            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1129            *          This parameter can be one of the following values:
   1130            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1131            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1132            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1133            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1134            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1135            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1136            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1137            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1138            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1139            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1140            */
   1141          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1142          {
   1143            FlagStatus bitstatus = RESET;
   1144            /* Check the parameters */
   1145            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1146            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1147            
   1148            /* Check the status of the specified SPI flag */
   1149            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   1150            {
   1151              /* SPI_I2S_FLAG is set */
   1152              bitstatus = SET;
   1153            }
   1154            else
   1155            {
   1156              /* SPI_I2S_FLAG is reset */
   1157              bitstatus = RESET;
   1158            }
   1159            /* Return the SPI_I2S_FLAG status */
   1160            return  bitstatus;
   1161          }
   1162          
   1163          /**
   1164            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1165            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1166            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1167            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1168            *          This function clears only CRCERR flag.
   1169            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1170            *  
   1171            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1172            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1173            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1174            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1175            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1176            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1177            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1178            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1179            *  
   1180            * @retval None
   1181            */
   1182          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1183          {
   1184            /* Check the parameters */
   1185            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1186            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   1187              
   1188            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1189            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   1190          }
   1191          
   1192          /**
   1193            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1194            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1195            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1196            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1197            *          This parameter can be one of the following values:
   1198            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1199            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1200            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1201            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1202            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1203            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1204            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1205            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1206            */
   1207          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1208          {
   1209            ITStatus bitstatus = RESET;
   1210            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   1211          
   1212            /* Check the parameters */
   1213            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1214            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1215          
   1216            /* Get the SPI_I2S_IT index */
   1217            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1218          
   1219            /* Get the SPI_I2S_IT IT mask */
   1220            itmask = SPI_I2S_IT >> 4;
   1221          
   1222            /* Set the IT mask */
   1223            itmask = 0x01 << itmask;
   1224          
   1225            /* Get the SPI_I2S_IT enable bit status */
   1226            enablestatus = (SPIx->CR2 & itmask) ;
   1227          
   1228            /* Check the status of the specified SPI interrupt */
   1229            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   1230            {
   1231              /* SPI_I2S_IT is set */
   1232              bitstatus = SET;
   1233            }
   1234            else
   1235            {
   1236              /* SPI_I2S_IT is reset */
   1237              bitstatus = RESET;
   1238            }
   1239            /* Return the SPI_I2S_IT status */
   1240            return bitstatus;
   1241          }
   1242          
   1243          /**
   1244            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1245            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1246            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1247            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1248            *         This function clears only CRCERR interrupt pending bit.   
   1249            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1250            *   
   1251            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1252            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1253            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1254            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1255            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1256            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1257            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1258            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1259            *          the SPI).
   1260            * @retval None
   1261            */
   1262          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1263          {
   1264            uint16_t itpos = 0;
   1265            /* Check the parameters */
   1266            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1267            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   1268          
   1269            /* Get the SPI_I2S IT index */
   1270            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1271          
   1272            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1273            SPIx->SR = (uint16_t)~itpos;
   1274          }
   1275          
   1276          /**
   1277            * @}
   1278            */
   1279          
   1280          /**
   1281            * @}
   1282            */ 
   1283          
   1284          /**
   1285            * @}
   1286            */ 
   1287          
   1288          /**
   1289            * @}
   1290            */ 
   1291          
   1292          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2S_Cmd
        16   -> assert_failed
      16   I2S_FullDuplexConfig
        16   -> assert_failed
      24   I2S_Init
        24   -> assert_failed
       0   I2S_StructInit
      16   SPI_BiDirectionalLineConfig
        16   -> assert_failed
      16   SPI_CalculateCRC
        16   -> assert_failed
      16   SPI_Cmd
        16   -> assert_failed
      16   SPI_DataSizeConfig
        16   -> assert_failed
      16   SPI_GetCRC
        16   -> assert_failed
       8   SPI_GetCRCPolynomial
         8   -> assert_failed
      16   SPI_I2S_ClearFlag
        16   -> assert_failed
      16   SPI_I2S_ClearITPendingBit
        16   -> assert_failed
      16   SPI_I2S_DMACmd
        16   -> assert_failed
       8   SPI_I2S_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         0   -> assert_failed
      16   SPI_I2S_GetFlagStatus
        16   -> assert_failed
      16   SPI_I2S_GetITStatus
        16   -> assert_failed
      16   SPI_I2S_ITConfig
        16   -> assert_failed
       8   SPI_I2S_ReceiveData
         8   -> assert_failed
      16   SPI_I2S_SendData
        16   -> assert_failed
      16   SPI_Init
        16   -> assert_failed
      16   SPI_NSSInternalSoftwareConfig
        16   -> assert_failed
      16   SPI_SSOutputCmd
        16   -> assert_failed
       0   SPI_StructInit
      16   SPI_TIModeCmd
        16   -> assert_failed
       8   SPI_TransmitCRC
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      88  ?<Constant "C:\\Tools\\WL9F\\WL_F_Mo...">
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
      86  I2S_Cmd
     206  I2S_FullDuplexConfig
     390  I2S_Init
      20  I2S_StructInit
      82  SPI_BiDirectionalLineConfig
      72  SPI_CalculateCRC
      78  SPI_Cmd
      80  SPI_DataSizeConfig
      60  SPI_GetCRC
      36  SPI_GetCRCPolynomial
      68  SPI_I2S_ClearFlag
      78  SPI_I2S_ClearITPendingBit
     104  SPI_I2S_DMACmd
     106  SPI_I2S_DeInit
     108  SPI_I2S_GetFlagStatus
     116  SPI_I2S_GetITStatus
     114  SPI_I2S_ITConfig
      56  SPI_I2S_ReceiveData
      58  SPI_I2S_SendData
     316  SPI_Init
      82  SPI_NSSInternalSoftwareConfig
      78  SPI_SSOutputCmd
      24  SPI_StructInit
      78  SPI_TIModeCmd
      42  SPI_TransmitCRC

 
 2 658 bytes in section .text
 
 2 658 bytes of CODE memory

Errors: none
Warnings: none
