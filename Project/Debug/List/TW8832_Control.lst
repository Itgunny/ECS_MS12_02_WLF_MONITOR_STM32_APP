###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:38 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW8832_Control.c                                 #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\TW8832_Control.c" -D USE_STDPERIPH_DRIVER -D     #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\TW8832 #
#                    _Control.lst                                             #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\TW8832_ #
#                    Control.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\TW8832_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    TW8832_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   TW8832_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          u8 InitCVBSAll[] = 
     29          {
     30          	0x8a,0x00,	//	TW88I2CAddress,0,	
     31          	0xFF,0x00,	//	Page 00
     32          	0x02,0x20,
     33          	0x03,0xFF,
     34          	0x06,0x26,
     35          	0x07,0x02,
     36          	0x08,0x86,	// 	CVBS INPUT
     37          	0x09,0x00,
     38          	0x40,0x32,	//	BT.656 INPUT
     39          	0x41,0x00,
     40          	0x42,0x02,
     41          	0x43,0x10,
     42          	0x44,0xF0,
     43          	0x45,0x82,
     44          	0x46,0xD0,
     45          	0x47,0x00,	//	BT.656 INPUT
     46          	0x48,0x00,
     47          	0x49,0x41,
     48          	0x4A,0x04,
     49          	0xDB,0x05,
     50          	0xDC,0x00,
     51          	0xDD,0x80,
     52          	0xDE,0x00,
     53          	0xDF,0x80,
     54          	0xE0,0xF2,
     55          	0xE1,0x77,
     56          	0xE2,0x04,
     57          	0xE3,0x40,
     58          	0xE4,0x84,
     59          	0xE5,0x00,
     60          	0xE6,0x20,
     61          	0xE7,0x00,
     62          	0xE8,0xF2,
     63          	0xE9,0x06,
     64          	0xEA,0x04,
     65          	0xEB,0x5F,
     66          	0xEC,0x20,
     67          	0xED,0x40,
     68          	0xEE,0x20,
     69          	0xF6,0x81,
     70          	0xF7,0x16,
     71          	0xF8,0x01,
     72          	0xF9,0x2C,
     73          	0xFA,0x00,
     74          	0xFB,0x40,
     75          	0xFC,0x30,
     76          	0xFD,0x21,
     77          	
     78          	0xFF,0x01,	//	Page01
     79          	0x02,0x40,
     80          	0x04,0x00,
     81          	0x05,0x01,
     82          	0x06,0x00,
     83          	0x07,0x02,
     84          	0x08,0x01,  //0x15 --> 0x05
     85          	0x09,0xF0,
     86          	0x0A,0x2F,
     87          	0x0B,0xD0,
     88          	0x0C,0xCC,
     89          	0x10,0x00,
     90          	0x11,0x5C,
     91          	0x12,0x11,
     92          	0x13,0x80,
     93          	0x14,0x80,
     94          	0x15,0x00,
     95          	0x17,0x80,
     96          	0x18,0x44,
     97          	0x1C,0x0F,
     98          	0x1D,0x7F,
     99          	0x1E,0x00,
    100          	0x20,0x50,
    101          	0x21,0x22,
    102          	0x22,0xF0,
    103          	0x23,0xD8,
    104          	0x24,0xBC,
    105          	0x25,0xB8,
    106          	0x26,0x44,
    107          	0x27,0x38,
    108          	0x28,0x00,
    109          	0x29,0x00,
    110          	0x2A,0x78,
    111          	0x2B,0x44,
    112          	0x2C,0x30,
    113          	0x2D,0x14,
    114          	0x2E,0xA5,
    115          	0x2F,0xE0,
    116          	0x30,0x00,
    117          	0x33,0x05,
    118          	0x35,0x00,
    119          	0xC0,0x01,
    120          	0xC1,0xC7,
    121          	0xC2,0x01,
    122          	0xC3,0x03,
    123          	0xC4,0x5A,
    124          	0xC5,0x00,
    125          	0xC6,0x20,
    126          	0xC7,0x04,
    127          	0xC8,0x00,
    128          	0xC9,0x06,
    129          	0xCA,0x06,
    130          	0xCB,0x10,
    131          	0xCC,0x00,
    132          	0xCD,0x54,
    133          	0xD0,0x00,
    134          	0xD1,0xF0,
    135          	0xD2,0xF0,
    136          	0xD3,0xF0,
    137          	0xD4,0x00,
    138          	0xD5,0x00,
    139          	0xD6,0x10,
    140          	0xD7,0x70,
    141          	0xD8,0x00,
    142          	0xD9,0x04,
    143          	0xDA,0x80,
    144          	0xDB,0x80,
    145          	0xDC,0x20,
    146          	
    147          	0xFF,0x02,	//	Page02
    148          	0x01,0x00,
    149          	0x02,0x20,
    150          	0x03,0x00,
    151          	0x04,0x1c,     // 0x1c -->0x1d
    152          	0x05,0x7f,     // 0x00 --> 0x7f
    153          	0x06,0x0f,	// 0x0F -> 0x10
    154          	0x07,0xBF,
    155          	0x08,0x8F,
    156          	0x09,0x00,
    157          	0x0A,0x01,      
    158          	0x0B,0x63,
    159          	0x0C,0xD0,
    160          	0x0D,0x80,
    161          	0x0E,0x00,
    162          	0x0F,0x02,
    163          	0x10,0x90,   // 0x84 --> 0x96  H
    164          	0x11,0x20,   // 800 resolution H
    165          	0x12,0x03,
    166          	0x13,0x00,
    167          	0x14,0x04,
    168          	0x15,0x2C,
    169          	0x16,0xE0,  // 480 resolution V
    170          	0x17,0x01,
    171          	0x18,0x62,
    172          	0x19,0x00,
    173          	0x1A,0x00,
    174          	0x1B,0x00,
    175          	0x40,0x11,
    176          	0x41,0x0A,
    177          	0x42,0x05,
    178          	0x43,0x01,
    179          	0x44,0x64,
    180          	0x45,0xF4,
    181          	0x46,0x00,
    182          	0x47,0x0A,
    183          	0x48,0x36,
    184          	0x49,0x10,
    185          	0x4A,0x00,
    186          	0x4B,0x00,
    187          	0x4C,0x00,
    188          	0x4D,0x84,
    189          	0x4E,0x24,
    190          	0x80,0x20,	//	0x00,	HUE
    191          	0x81,0x80,
    192          	0x82,0x80,
    193          	0x83,0x80,
    194          	0x84,0x80,
    195          	0x85,0x80,
    196          	0x86,0x80,
    197          	0x87,0x80,
    198          	0x88,0x80,
    199          	0x89,0x80,
    200          	0x8A,0x80,
    201          	0x8B,0xDF,
    202          	0x8C,0x00,
    203          	0xB0,0x10,
    204          	0xB1,0x40,
    205          	0xB2,0x40,
    206          	0xB6,0x67,
    207          	0xB7,0x94,
    208          	0xBF,0x0E,	//	Souce Output
    209          	//0xBF,0x83,
    210          	0xE0,0x00,
    211          	0xE4,0x21,
    212          	0xF8,0x00,
    213          	0xF9,0x80,
    214          	
    215          	0xff, 0x04, //	Page 04
    216          	0x80, 0x15,
    217          	0xff, 0xff
    218          };
    219          
    220          /* Private function prototypes -----------------------------------------------*/
    221          /* Private functions ---------------------------------------------------------*/
    222          
    223          void NOP_TW8832(void)
    224          {
    225          	TimeDelay_usec(1);	
    226          }
    227          
    228          void TW8832_PortChange(unsigned char dir)
    229          {
    230          	unsigned short temp;
    231          	
    232          	GPIO_InitTypeDef GPIO_InitStructure;
    233          	
    234          	if (dir)// Output
    235          	{
    236          		temp = TW8832_I2C2_PORT->IDR;			//	GPIO_ReadInputData
    237          		temp = ((~(TW8832_I2C2_SDA)) & temp);
    238          		TW8832_I2C2_PORT->ODR = (temp);			//	GPIO_Write
    239          		
    240          		GPIO_InitStructure.GPIO_Pin   = TW8832_I2C2_SDA;
    241          		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
    242          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
    243          		GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);	
    244          	}
    245          	else	// Input
    246          	{	
    247          		temp = TW8832_I2C2_PORT->IDR;			//	GPIO_ReadInputData
    248          		temp = ((~(TW8832_I2C2_SDA)) & temp);
    249          		TW8832_I2C2_PORT->ODR = (temp);			//	GPIO_Write
    250          		
    251          		GPIO_InitStructure.GPIO_Pin  = TW8832_I2C2_SDA;
    252          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    253          		GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);	
    254          	}
    255          }
    256          
    257          void I2C2_Write(u8 WData)
    258          {
    259          	u8 i, j;
    260          
    261          	NOP_TW8832();
    262          
    263          	for (i = 0; i < 8; i++)
    264          	{
    265          		j = ( WData & 0x80 ) ? 1 : 0;
    266          		(j) ? GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA) : GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    267          		NOP_TW8832();
    268          		TW8832_SCL1;
    269          		NOP_TW8832();		
    270          		WData <<= 1;
    271          		TW8832_SCL0;
    272          		NOP_TW8832();
    273          	}
    274          
    275          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    276          	NOP_TW8832();
    277          	TW8832_SCL1;
    278          	NOP_TW8832();
    279          	TW8832_SCL0;
    280          }
    281          
    282          void I2C2_ByteWrite(u16 in_AddrVal, u8 in_DataVal)
    283          {
    284          	u16 tmp_index;
    285          
    286          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    287          	TW8832_SDAOUT;
    288          	// START
    289          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    290          	TW8832_SCL1;
    291          	NOP_TW8832();
    292          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    293          	NOP_TW8832();
    294          	TW8832_SCL0;
    295          	// END
    296          
    297          	I2C2_Write(TW8832_I2C_Addr);
    298          	I2C2_Write((u8)in_AddrVal);
    299          	I2C2_Write(in_DataVal);
    300          
    301          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    302          	NOP_TW8832();
    303          	TW8832_SCL1;
    304          	NOP_TW8832();
    305          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    306          
    307          	for (tmp_index = 0; tmp_index < 15000; tmp_index++);
    308          }
    309          u8 I2C2_Read(void)
    310          {
    311          	u8 i;
    312          	u8 RData;
    313          
    314          	NOP_TW8832();
    315          	TW8832_SCL0;
    316          	NOP_TW8832();
    317          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    318          	TW8832_SDAIN;
    319          
    320          	for ( i = 0; i < 8; i++ )
    321          	{
    322          		TW8832_SCL1;
    323          		NOP_TW8832();
    324          		NOP_TW8832();
    325          		RData = (RData << 1) | TW8832_SDA_READ;
    326          		TW8832_SCL0;
    327          		NOP_TW8832();
    328          		NOP_TW8832();
    329          	}
    330          	GPIO_ResetBits(TW8832_I2C2_PORT, GPIO_Pin_7);
    331          	TW8832_SDAOUT;
    332          	return (RData );
    333          }
    334          
    335          u8 I2C2_ByteRead(u16 in_AddrVal)
    336          {
    337          	u8 RData = 0;
    338          	u16 tmp_index;
    339          
    340          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    341          	TW8832_SDAOUT;
    342          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    343          	TW8832_SCL1;
    344          	NOP_TW8832();
    345          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    346          	NOP_TW8832();
    347          	TW8832_SCL0;
    348          
    349          	I2C2_Write(TW8832_I2C_Addr);
    350          	I2C2_Write((u8)in_AddrVal);
    351          
    352          	NOP_TW8832();
    353          	NOP_TW8832();
    354          
    355          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    356          	NOP_TW8832();
    357          	TW8832_SCL1;
    358          	NOP_TW8832();
    359          
    360          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    361          	NOP_TW8832();
    362          	TW8832_SCL0;
    363          
    364          	I2C2_Write(0x8b);
    365          
    366          	RData = I2C2_Read();
    367          
    368          	// NAK
    369          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    370          	NOP_TW8832();
    371          	TW8832_SCL1;
    372          	NOP_TW8832();
    373          	TW8832_SCL0;
    374          	NOP_TW8832();
    375          
    376          	// STOP
    377          	GPIO_ResetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    378          	NOP_TW8832();
    379          	TW8832_SCL1;
    380          	NOP_TW8832();
    381          	GPIO_SetBits(TW8832_I2C2_PORT, TW8832_I2C2_SDA);
    382          
    383          	for (tmp_index = 0; tmp_index < 15000; tmp_index++);
    384          	return (RData);
    385          }
    386          
    387          void WriteTW8832(u8 in_AddrVal, u8 in_DataVal)
    388          {
    389          	I2C2_ByteWrite(in_AddrVal, in_DataVal);
    390          	TimeDelay_usec(500);
    391          }
    392          
    393          u8 ReadTW8832(u8 in_AddrVal)
    394          {
    395          	u8 val;
    396          
    397          	val = I2C2_ByteRead(in_AddrVal);
    398          
    399          	return(val);
    400          }
    401          
    402          //=============================================================================
    403          //		WORD SetYCbCrContrast(WORD val)
    404          //=============================================================================
    405          u16 SetYCbCrContrast(u16 val)
    406          {
    407          	WriteTW8832( 0xff, SCALER_PAGE );
    408          	val *= 255;
    409          	val += 50;
    410          	val /= 100;
    411          	WriteTW8832( ContrastY, val );
    412          	val = ReadTW8832( ContrastY );
    413          	val *= 100;
    414          	val += 128;
    415          	val /= 255;
    416          
    417          	return (val);
    418          }
    419          
    420          //=============================================================================
    421          //		WORD SetYCbCrBright(WORD val)
    422          //=============================================================================
    423          u16 SetYCbCrBright(u16 val)
    424          {
    425          	WriteTW8832( 0xff, SCALER_PAGE );
    426          	val *= 255;
    427          	val += 50;
    428          	val /= 100;
    429          	WriteTW8832( BrightnessY, val );
    430          	val = ReadTW8832( BrightnessY );
    431          	val *= 100;
    432          	val += 128;
    433          	val /= 255;
    434          
    435          	return (val);
    436          }
    437          
    438          //=============================================================================
    439          //		WORD SetYCbCrSaturation(WORD val)
    440          //=============================================================================
    441          u16 SetYCbCrSaturation(u16 val)
    442          {
    443          	WriteTW8832( 0xff, SCALER_PAGE );
    444          	val *= 255;
    445          	val += 50;
    446          	val /= 100;
    447          	WriteTW8832( SaturationY, val );
    448          	WriteTW8832( SaturationY+1, val );
    449          	val = ReadTW8832( SaturationY );
    450          	val *= 100;
    451          	val += 128;
    452          	val /= 255;
    453          
    454          	return (val);
    455          }
    456          
    457          //=============================================================================
    458          //		BYTE	ChangeCVBS( void )
    459          //=============================================================================
    460          u8	ChangeCVBS( void )
    461          {
    462          #if 0
    463          	if ( InputMain == INPUT_CVBS ) return(0);
    464          	InputMain = INPUT_CVBS;
    465          
    466          	//SaveInputEE( InputMain );
    467          	//Freerun( 0 );
    468          
    469          	InitCVBSRegister( );
    470          
    471          	WriteTW8832( 0xff, DECODER_PAGE );
    472          	WriteTW8832( 0x02, 0x40 );
    473          
    474          	// Get Image control register value
    475          	SetYCbCrContrast( GetVideoDatafromEE( 0 ) );
    476          	SetYCbCrBright( GetVideoDatafromEE( 1 ) );
    477          	SetYCbCrSaturation( GetVideoDatafromEE( 2 ) );
    478          	//SetDecoderContrast( GetVideoDatafromEE( 3 ) );
    479          	SetYCbCrHUE( GetVideoDatafromEE( 4 ) );
    480          	SetYCbCrSharp( GetVideoDatafromEE( 5 ) );
    481          
    482          	TimeDelay_msec(10);
    483          
    484          	return( CheckAndSetDecoderScaler() );
    485          #endif
    486          
    487          	return 0;
    488          }
    489          
    490          //=============================================================================
    491          //		BYTE	CheckDecoderVDLOSS( BYTE n )
    492          //=============================================================================
    493          u8	CheckDecoderVDLOSS( u8 n )
    494          {
    495              u8	mode;
    496          
    497          	WriteTW8832( 0xff, DECODER_PAGE );		// set Decoder page
    498          	while (n--) 
    499          	{
    500          		mode = ReadTW8832( 0x01 );
    501          		if (( mode & 0x80 ) == 0 ) return ( 0 );
    502          		TimeDelay_msec(1);
    503          	}
    504          
    505          	return ( 1 );
    506          }
    507          
    508          //=============================================================================
    509          //		BYTE	CheckDecoderSTD( BYTE n )
    510          //=============================================================================
    511          u8	CheckDecoderSTD( u8 n )
    512          {
    513              u8	mode;
    514          
    515          	WriteTW8832( 0xff, DECODER_PAGE );		// set Decoder page
    516          	while (n--) 
    517          	{
    518          		mode = ReadTW8832( 0x1C );
    519          		if (( mode & 0x80 ) == 0 ) return ( mode );
    520          		TimeDelay_msec(1);
    521          	}
    522          
    523          	return ( 0x80 );
    524          }
    525          
    526          //=============================================================================
    527          //		BYTE	CheckAndSetDecoderScaler( void )
    528          //=============================================================================
    529          u8	CheckAndSetDecoderScaler( void )
    530          {
    531              u8	mode;
    532              //u32	vPeriod=0; 
    533              u32 vDelay=0;
    534          
    535          	if ( CheckDecoderVDLOSS(100) ) 
    536          	{
    537          		//Puts("\nCVBS VDLOSS");
    538          		//Freerun( 1 );
    539          		return( 1 );
    540          	}
    541          
    542          	if ( CheckDecoderSTD(100) == 0x80 ) return( 2 );
    543          
    544          	TimeDelay_msec(10);
    545          
    546          	WriteTW8832( 0xff, DECODER_PAGE );	// Set Decoder page
    547          	mode = ReadTW8832( 0x1c );
    548          	
    549          	//DebugMsg_printf( "\nInput mode %02bx", mode );
    550          
    551          	mode >>= 4;
    552          	if ( mode == 0 )		 //	NTSC
    553          	{				
    554          		//DebugMsg_printf( "\nInput Mode(NTSC) vScale:%02bx, vBack:%bd", ReadTW8832( 0x06 ), ReadTW8832( 0x15 ) );
    555          	}
    556          	else if ( mode == 1 )	//	PAL
    557          	{			 
    558          		WriteTW8832( 0x07, ( ReadTW8832( 0x07 ) | 0x10 ) );
    559          		WriteTW8832( 0x09, 32 );
    560          		WriteTW8832( 0x0a, 0x18 );					// change H-delay
    561          		//vPeriod = 275;							// NTSC line number
    562          		vDelay += 7; 		// 6 = ( 288-275 ) / 2
    563          		WriteTW8832( 0xff, SCALER_PAGE );
    564          		WriteTW8832( 0x06, 0x12 );					// set V scale
    565          		WriteTW8832( 0x05, 0xA2 );					// set V scale
    566          		WriteTW8832( 0x15, 0x30);					// set output V delay
    567          		//DebugMsg_printf( "\nInput Mode(PAL) vScale:%02bx, vBack:%bd", ReadTW8832( 0x06 ), ReadTW8832( 0x15 ) );
    568          	}
    569          	else {
    570          		//DebugMsg_printf( "\nInput Mode %bd does not support now", mode );
    571          		return(1);
    572          	}
    573          	
    574          	return(0);
    575          }
    576          
    577          //=============================================================================
    578          //		WORD SetYCbCrSharp(WORD val)
    579          //=============================================================================
    580          u16 SetYCbCrSharp(u16 val)
    581          {
    582              u8	i;
    583          
    584          	WriteTW8832( 0xff, SCALER_PAGE );
    585          
    586          	for (i=0; i<16; i++) 
    587          	{
    588          		if ( val == (Sharpness[i]+1) )
    589          		{
    590          			val = i+1;
    591          			break;
    592          		}
    593          		if ( Sharpness[i] == (val+1) )
    594          		{
    595          			val = i-1;
    596          			break;
    597          		}
    598          	}
    599          	WriteTW8832( SharpnessY, ((ReadTW8832( SharpnessY ) & 0xf0) + val) );
    600          	val = Sharpness[i];
    601          
    602          	return (val);
    603          }
    604          
    605          //=============================================================================
    606          //		WORD SetYCbCrHUE(WORD val)
    607          //=============================================================================
    608          u16 SetYCbCrHUE(u16 val)
    609          {
    610          	WriteTW8832( 0xff, SCALER_PAGE );
    611          	val *= 63;
    612          	val += 50;
    613          	val /= 100;
    614          	val += 0x20;
    615          	val &= 0x3F;
    616          	WriteTW8832( HueY, val );
    617          	val = ReadTW8832( HueY );
    618          	val += 0x20;
    619          	val &= 0x3F;
    620          	val *= 100;
    621          	val += 32;
    622          	val /= 63;
    623          
    624          	return (val);
    625          }
    626          
    627          //=============================================================================
    628          //				                                               
    629          //=============================================================================
    630          void I2C2DeviceInitialize(u8 *RegSet)
    631          {
    632          	u8 Addr, val;
    633                 
    634          	RegSet += 2;
    635          	
    636          	// 0xff, 0xff is end of data
    637          	while (( RegSet[0] != 0xFF ) || ( RegSet[1]!= 0xFF )) 
    638          	{			
    639          		Addr = *RegSet;
    640          		val = *(RegSet+1);
    641          		I2C2_ByteWrite(Addr, val);
    642          		RegSet+=2;
    643          	}
    644          
    645          	WriteTW8832(0xff, 0x00);	// Set page 0
    646          }
    647          
    648          
    649          void InitCVBSRegister( void )
    650          {
    651          	I2C2DeviceInitialize( InitCVBSAll );
    652          }
    653          
    654          
    655          /**\
    656            * @brief  None
    657            * @param  None
    658            * @retval None
    659            */
    660          void TW8832_Control_Init(void)
    661          {
    662          	DebugMsg_printf("++ TW8832_Control_Init (I2C2 & SPI2), ADC Initialize START\r\n");
    663          
    664          	InitCVBSRegister();
    665          
    666          	DebugMsg_printf("-- TW8832_Control_Init (I2C2 & SPI2), ADC Initialize END\r\n");
    667          }
    668          
    669          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ChangeCVBS
       8   CheckAndSetDecoderScaler
         8   -> CheckDecoderSTD
         8   -> CheckDecoderVDLOSS
         8   -> I2C2_ByteRead
         8   -> TimeDelay_msec
         8   -> WriteTW8832
       8   CheckDecoderSTD
         8   -> I2C2_ByteRead
         8   -> TimeDelay_msec
         8   -> WriteTW8832
       8   CheckDecoderVDLOSS
         8   -> I2C2_ByteRead
         8   -> TimeDelay_msec
         8   -> WriteTW8832
       8   I2C2DeviceInitialize
         8   -> I2C2_ByteWrite
         0   -> TimeDelay_usec
      16   I2C2_ByteRead
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> I2C2_Read
        16   -> I2C2_Write
        16   -> TW8832_PortChange
        16   -> TimeDelay_usec
      16   I2C2_ByteWrite
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> GPIO_SetBits
        16   -> I2C2_Write
        16   -> TW8832_PortChange
        16   -> TimeDelay_usec
      16   I2C2_Read
        16   -> GPIO_ReadInputDataBit
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> TW8832_PortChange
        16   -> TimeDelay_usec
      16   I2C2_Write
         0   -> GPIO_ResetBits
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> TimeDelay_usec
       0   InitCVBSRegister
         0   -> I2C2DeviceInitialize
       0   NOP_TW8832
         0   -> TimeDelay_usec
       0   ReadTW8832
         0   -> I2C2_ByteRead
       8   SetYCbCrBright
         8   -> I2C2_ByteRead
         8   -> WriteTW8832
       8   SetYCbCrContrast
         8   -> I2C2_ByteRead
         8   -> WriteTW8832
       8   SetYCbCrHUE
         8   -> I2C2_ByteRead
         8   -> I2C2_ByteWrite
         8   -> TimeDelay_usec
       8   SetYCbCrSaturation
         8   -> I2C2_ByteRead
         8   -> WriteTW8832
      16   SetYCbCrSharp
        16   -> I2C2_ByteRead
        16   -> I2C2_ByteWrite
        16   -> TimeDelay_usec
        16   -> WriteTW8832
       0   TW8832_Control_Init
         0   -> I2C2DeviceInitialize
      16   TW8832_PortChange
        16   -> GPIO_Init
       8   WriteTW8832
         8   -> I2C2_ByteWrite
         0   -> TimeDelay_usec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       8  ??Subroutine3_0
       8  ?Subroutine0
      16  ?Subroutine1
       4  ?Subroutine2
       4  ChangeCVBS
     124  CheckAndSetDecoderScaler
      42  CheckDecoderSTD
      44  CheckDecoderVDLOSS
      34  I2C2DeviceInitialize
     262  I2C2_ByteRead
     142  I2C2_ByteWrite
     128  I2C2_Read
     128  I2C2_Write
     368  InitCVBSAll
       2  InitCVBSRegister
       6  NOP_TW8832
       2  ReadTW8832
      36  SetYCbCrBright
      38  SetYCbCrContrast
      80  SetYCbCrHUE
      46  SetYCbCrSaturation
     104  SetYCbCrSharp
       2  TW8832_Control_Init
      62  TW8832_PortChange
      12  WriteTW8832

 
   368 bytes in section .data
 1 346 bytes in section .text
 
 1 346 bytes of CODE memory
   368 bytes of DATA memory

Errors: none
Warnings: none
