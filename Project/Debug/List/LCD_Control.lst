###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      07/Aug/2017  15:25:51 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pla #
#                    tform\TaeHa - ECS\SRC\LCD_Control.c                      #
#    Command line =  "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pl #
#                    atform\TaeHa - ECS\SRC\LCD_Control.c" -D                 #
#                    USE_STDPERIPH_DRIVER -D STM32F4XX -D USE_STM324xG_EVAL   #
#                    -D USE_FULL_ASSERT -lcN D:\GIT\WLF_MONITOR\ECS_MS12_02_W #
#                    LF_MONITOR_STM32_APP\Project\Debug\List\ -o              #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\ --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Platform\COMMON\INC\ -I                          #
#                    "D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pr #
#                    oject\..\Platform\TaeHa - ECS\INC\" -I                   #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\ -I  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\ -Oh    #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\List\LCD_Control.lst                          #
#    Object file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Pro #
#                    ject\Debug\Obj\LCD_Control.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_APP\Platform\TaeHa - ECS\SRC\LCD_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    LCD_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   LCD_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          
     29          /*
     30          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
     31          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
     32          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
     33          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
     34          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
     35          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
     36          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
     37          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
     38          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
     39          */
     40          //	이 값을 설정할 때, 회로적으로 Inverting 된다.
     41          //	100% -> 0%로 동작한다.
     42          const uint16_t LCDBL_PWMLEVEL[MaxBackLightLEVEL] =  
     43          {	
     44          	16638, 	//  0 Step :   0%
     45              14142, 	//  1 Step :  20%
     46              11646, 	//  2 Step :  30%
     47              9982, 	//  3 Step :  40%
     48              8319, 	//  4 Step :  50%
     49              6655, 	//  5 Step :  60%
     50              4991, 	//  6 Step :  70%
     51              3327, 	//  7 Step :  85%
     52          	0, 		//  8 Step : 100%
     53          }; 
     54          
     55          //  ++, kutelf, 131007
     56          unsigned char Camera_Mode = 0xFF;
     57          unsigned char Camera_CheckFlag = 1;
     58          unsigned char Camera_CheckCnt = 0;
     59          //  --, kutelf, 131007
     60          
     61          unsigned char AAVM_Mode = 0xFF;
     62          extern unsigned char AAVM_Icon_Index = 0xFF;
     63          extern unsigned char AAVM_Camera_Icon_Index = 0xFF;
     64          unsigned char AAVM_CheckFlag = 1;
     65          unsigned char AAVM_CheckCnt = 0;
     66          extern unsigned char AAVM_Menu_Flag = 0xFF;
     67          extern unsigned char AAVM_Warning_Front = 0xFF;
     68          extern unsigned char AAVM_Warning_Rear = 0xFF;
     69          extern unsigned char AAVM_Warning_Left = 0xFF;
     70          extern unsigned char AAVM_Warning_Right = 0xFF;
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          
     74          void LED_POWER_ONOFF(uint8_t BitData)
     75          {
     76              GPIO_WriteBit(LED_PORT, LED_CTRL, (BitAction) BitData);
     77          }
     78          
     79          void LCD_POWER_ONOFF(uint8_t BitData)
     80          {
     81              GPIO_WriteBit(LCDPWR_PORT, LCDPWR_CTRL, (BitAction) BitData);
     82          }
     83          
     84          void LCDBL_ONOFF(uint8_t BitData)
     85          {
     86              GPIO_WriteBit(LCDBL_PORT, LCDBL_CTRL, (BitAction) BitData);
     87          
     88          	WL9FM_LCDBL.OnOff = BitData;
     89          }
     90          
     91          /**
     92            * @brief  PWM Level Setting (LEVEL value를 받아서 설정한다.)
     93            * @param  pwm
     94            * @retval None
     95            */
     96          void LCDBL_PWM_LEVEL(uint8_t LEVEL)
     97          {
     98              //  PWM을 변경한 후에 항상 저장해 놓는다.
     99              WL9FM_LCDBL.PWM	  = LCDBL_PWMLEVEL[LEVEL];  
    100              WL9FM_LCDBL.LEVEL = LEVEL;
    101              LCDBL_PWM_CONTROL(WL9FM_LCDBL.PWM);
    102          }
    103          
    104          /**
    105            * @brief  PWM Value Setting (pwm value를 받아서, Pulse로 설정한다.)
    106            * @param  pwm
    107            * @retval None
    108            */
    109          void LCDBL_PWM_CONTROL(uint16_t PWM_VALUE)
    110          {
    111          	TIM_OCInitTypeDef  TIM_OCInitStructure;
    112          
    113          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
    114          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    115          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    116          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    117          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    118          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    119          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    120          
    121          	//	Channel 1 Configuration in PWM mode
    122          	TIM_OCInitStructure.TIM_Pulse = PWM_VALUE;
    123          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);					
    124          
    125          	// 	TIM8 counter enable
    126          	TIM_Cmd(TIM8, ENABLE);			
    127          
    128          	//	TIM8 Main Output Enable
    129          	TIM_CtrlPWMOutputs(TIM8, ENABLE);
    130          }
    131          
    132          void LCDBL_Init(void)
    133          {
    134          	DebugMsg_printf("++ LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize START\r\n");
    135          
    136          	/* TIM8 Configuration ---------------------------------------------------
    137          	Generate 7 PWM signals with 4 different duty cycles:
    138          	TIM8 input clock (TIM8CLK) is set to 2 * APB2 clock (PCLK2), since APB2 
    139          	prescaler is different from 1.   
    140          	TIM8CLK = 2 * PCLK2  
    141          	PCLK2 = HCLK / 2 
    142          	=> TIM8CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
    143          	TIM8CLK = SystemCoreClock, Prescaler = 0, TIM8 counter clock = SystemCoreClock
    144          	SystemCoreClock is set to 168 MHz for STM32F4xx devices
    145          
    146          	The objective is to generate 7 PWM signal at 17.57 KHz:
    147          	- TIM8_Period = (SystemCoreClock / 17570) - 1
    148          	The channel 1 and channel 1N duty cycle is set to 50%
    149          	The channel 2 and channel 2N duty cycle is set to 37.5%
    150          	The channel 3 and channel 3N duty cycle is set to 25%
    151          	The channel 4 duty cycle is set to 12.5%
    152          	The Timer pulse is calculated as follows:
    153          	- ChannelxPulse = DutyCycle * (TIM8_Period - 1) / 100
    154             
    155             Note: 
    156              SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
    157              Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
    158              function to update SystemCoreClock variable value. Otherwise, any configuration
    159              based on this variable will be incorrect. 
    160            ----------------------------------------------------------------------- */
    161            
    162            	TIM_TimeBaseInitTypeDef  	TIM_TimeBaseStructure;
    163            	TIM_OCInitTypeDef  			TIM_OCInitStructure;
    164          
    165          	uint16_t TimerPeriod  = 0;
    166          	
    167          	//	PWM Frequency : 500Hz (Mitsubishi 7" LCD)
    168          	TimerPeriod = (SystemCoreClock / 250 ) - 1;
    169          #if 0
    170          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
    171          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
    172          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
    173          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
    174          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
    175          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
    176          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
    177          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
    178          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
    179          #endif
    180          
    181              //  LCDBL GPIO는 System_Init.c 에서 설정
    182          #if 0
    183          	GPIO_InitTypeDef GPIO_InitStructure;
    184          
    185          	//	LCDBL_PWM -> PWM
    186          	GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    187          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    188          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    189          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    190          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    191          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    192          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    193          
    194          	//  LCDBL_CTRL -> GPIO Output
    195          	GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    196          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    197          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    198          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    199          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    200          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    201          
    202          #endif
    203          	
    204          	TIM_TimeBaseStructure.TIM_Prescaler         = 16;
    205          	TIM_TimeBaseStructure.TIM_CounterMode 	    = TIM_CounterMode_Up;
    206          	TIM_TimeBaseStructure.TIM_Period 			= TimerPeriod;
    207          	TIM_TimeBaseStructure.TIM_ClockDivision     = 0;
    208          	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    209          
    210          	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
    211          
    212          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
    213          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    214          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    215          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    216          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    217          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    218          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    219          
    220          	//	Channel 1 Configuration in PWM mode
    221          	TIM_OCInitStructure.TIM_Pulse = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    222          
    223          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
    224          
    225          	// 	TIM8 counter enable
    226          	TIM_Cmd(TIM8, ENABLE);
    227          
    228          	// 	TIM8 Main Output Enable
    229          	TIM_CtrlPWMOutputs(TIM8, ENABLE);		
    230          
    231          	DebugMsg_printf("-- LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize END\r\n");
    232          
    233          	TimeDelay_msec(1000); 
    234          
    235          	WL9FM_LCDBL.LEVEL = DefaultLCDBLLEVEL;
    236          	WL9FM_LCDBL.PWM   = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    237          }
    238          
    239          void LCD_Display_Change(uint8_t BitData)
    240          {
    241          	//	Display Buffer를 변경하는 것이기 때문에
    242          	//	표시하고자 하는 것을 하기 전에, 다른 것을 먼저 High-Z 상태로 만든다. 
    243          	if (BitData == STM32F4_DISPLAY)
    244          	{
    245          	    GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_RESET);
    246          		TimeDelay_msec(10); 
    247          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_SET);
    248          	}
    249          	else
    250          	{
    251          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_RESET);
    252          		TimeDelay_msec(10); 
    253          		GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_SET);
    254          	}
    255          }
    256          
    257          //  ++, kutelf, 131007
    258          //	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
    259          //	상태를 체크하여, Video가 없으면 No Video 띄워준다.
    260          void cam_mode_check(void)
    261          {
    262          	CheckCamera_Input(Camera_Mode);		
    263          }
    264          	
    265          void cam_mode_change(u8 Mode)
    266          {
    267          	if(Mode == 0xFF)
    268          	{
    269          		LCD_Display_Change(EXYNOS_DISPLAY);
    270          	}
    271          	else
    272          	{
    273          		CameraMode(Mode, 1);
    274          		LCD_Display_Change(STM32F4_DISPLAY);
    275          	}
    276          	
    277          	
    278          }
    279          // ++, 160812 cjg
    280          void aavm_mode_check(void)
    281          {
    282                    CheckAAVM_Input(AAVM_Mode);
    283          }
    284          void aavm_mode_change(u8 Mode)
    285          {
    286                    if(Mode == 0xFF)
    287                    {
    288                            LCD_Display_Change(EXYNOS_DISPLAY);
    289                    }
    290                    else
    291                    {
    292                            AAVMMode(Mode, 1);
    293                            LCD_Display_Change(STM32F4_DISPLAY);
    294                    }
    295          }
    296          
    297          // --, 160812 cjg
    298          
    299          
    300          
    301          
    302          //  --, kutelf, 131007
    303          
    304          /**\
    305            * @brief  None
    306            * @param  None
    307            * @retval None
    308            */
    309          void LCD_Control_Init(void)
    310          {
    311          	TimeDelay_msec(3000); 
    312          	LCD_Display_Change(EXYNOS_DISPLAY);
    313          	//LCD_Display_Change(STM32F4_DISPLAY);
    314          	LCDBL_Init();	
    315          	LCDBL_ONOFF(LCDBL_ON);	//  LCDBL Power On!!!
    316          			//	LCDBL PWM 설정 
    317          	
    318          	//LCD_Display_Change(STM32F4_DISPLAY);
    319          }
    320          
    321          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   LCDBL_Init
        48   -> TIM_Cmd
        48   -> TIM_CtrlPWMOutputs
        48   -> TIM_OC1Init
        48   -> TIM_TimeBaseInit
        48   -> TimeDelay_msec
       8   LCDBL_ONOFF
         8   -> GPIO_WriteBit
      32   LCDBL_PWM_CONTROL
        32   -> TIM_Cmd
        32   -> TIM_CtrlPWMOutputs
        32   -> TIM_OC1Init
       0   LCDBL_PWM_LEVEL
         0   -> LCDBL_PWM_CONTROL
       8   LCD_Control_Init
         8   -> GPIO_WriteBit
         8   -> LCDBL_Init
         8   -> LCD_Display_Change
         8   -> TimeDelay_msec
      16   LCD_Display_Change
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TimeDelay_msec
       0   LCD_POWER_ONOFF
         0   -> GPIO_WriteBit
       0   LED_POWER_ONOFF
         0   -> GPIO_WriteBit
       8   aavm_mode_change
         8   -> AAVMMode
         0   -> LCD_Display_Change
       0   aavm_mode_check
         0   -> CheckAAVM_Input
       8   cam_mode_change
         8   -> CameraMode
         0   -> LCD_Display_Change
       0   cam_mode_check
         0   -> CheckCamera_Input


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       6  ?Subroutine0
       1  AAVM_Camera_Icon_Index
       1  AAVM_CheckCnt
       1  AAVM_CheckFlag
       1  AAVM_Icon_Index
       1  AAVM_Menu_Flag
       1  AAVM_Mode
       1  AAVM_Warning_Front
       1  AAVM_Warning_Left
       1  AAVM_Warning_Rear
       1  AAVM_Warning_Right
       1  Camera_CheckCnt
       1  Camera_CheckFlag
       1  Camera_Mode
     146  LCDBL_Init
      20  LCDBL_ONOFF
      20  LCDBL_PWMLEVEL
      80  LCDBL_PWM_CONTROL
      16  LCDBL_PWM_LEVEL
      38  LCD_Control_Init
      72  LCD_Display_Change
      10  LCD_POWER_ONOFF
      12  LED_POWER_ONOFF
      18  aavm_mode_change
       8  aavm_mode_check
      20  cam_mode_change
       8  cam_mode_check

 
   2 bytes in section .bss
  11 bytes in section .data
 506 bytes in section .text
 
 506 bytes of CODE memory
  13 bytes of DATA memory

Errors: none
Warnings: none
