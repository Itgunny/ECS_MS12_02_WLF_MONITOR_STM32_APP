###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      16/May/2013  10:07:34 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\LCD_Control.c                                    #
#    Command line =  "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa -          #
#                    ECS\SRC\LCD_Control.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\" -o   #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\"       #
#                    --debug --endian=little --cpu=Cortex-M4 -e               #
#                    --fpu=VFPv4_sp --dlib_config "C:\Tools\IAR               #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Tools\IAR Systems\Embedded Workbench         #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\COMMO #
#                    N\INC\" -I "C:\Tools\IAR Systems\Embedded Workbench      #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Platform\TaeHa #
#                     - ECS\INC\" -I "C:\Tools\IAR Systems\Embedded           #
#                    Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libr #
#                    aries\CMSIS\Device\ST\STM32F4xx\Include\" -I             #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\..\Libraries\STM3 #
#                    2F4xx_StdPeriph_Driver\inc\" -Oh --use_c++_inline -I     #
#                    "C:\Tools\IAR Systems\Embedded Workbench                 #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\List\LCD_Co #
#                    ntrol.lst                                                #
#    Object file  =  C:\Tools\IAR Systems\Embedded Workbench                  #
#                    6.5\WorkSpace\WL9F_Monitor_APP\Project\Debug\Obj\LCD_Con #
#                    trol.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\IAR Systems\Embedded Workbench 6.5\WorkSpace\WL9F_Monitor_APP\Platform\TaeHa - ECS\SRC\LCD_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    LCD_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   LCD_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          
     29          /*
     30          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
     31          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
     32          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
     33          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
     34          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
     35          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
     36          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
     37          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
     38          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
     39          */
     40          //	이 값을 설정할 때, 회로적으로 Inverting 된다.
     41          //	100% -> 0%로 동작한다.
     42          const uint16_t LCDBL_PWMLEVEL[MaxBackLightLEVEL] =  
     43          {	
     44          	16638, 	//  0 Step :   0%
     45              14142, 	//  1 Step :  20%
     46              11646, 	//  2 Step :  30%
     47              9982, 	//  3 Step :  40%
     48              8319, 	//  4 Step :  50%
     49              6655, 	//  5 Step :  60%
     50              4991, 	//  6 Step :  70%
     51              3327, 	//  7 Step :  85%
     52          	0, 		//  8 Step : 100%
     53          }; 
     54          
     55          unsigned char CAM_Mode=0;
     56          /* Private function prototypes -----------------------------------------------*/
     57          /* Private functions ---------------------------------------------------------*/
     58          
     59          void LED_POWER_ONOFF(uint8_t BitData)
     60          {
     61              GPIO_WriteBit(LED_PORT, LED_CTRL, (BitAction) BitData);
     62          }
     63          
     64          void LCD_POWER_ONOFF(uint8_t BitData)
     65          {
     66              GPIO_WriteBit(LCDPWR_PORT, LCDPWR_CTRL, (BitAction) BitData);
     67          }
     68          
     69          void LCDBL_ONOFF(uint8_t BitData)
     70          {
     71              GPIO_WriteBit(LCDBL_PORT, LCDBL_CTRL, (BitAction) BitData);
     72          
     73          	WL9FM_LCDBL.OnOff = BitData;
     74          }
     75          
     76          /**
     77            * @brief  PWM Level Setting (LEVEL value를 받아서 설정한다.)
     78            * @param  pwm
     79            * @retval None
     80            */
     81          void LCDBL_PWM_LEVEL(uint8_t LEVEL)
     82          {
     83              //  PWM을 변경한 후에 항상 저장해 놓는다.
     84              WL9FM_LCDBL.PWM	  = LCDBL_PWMLEVEL[LEVEL];  
     85              WL9FM_LCDBL.LEVEL = LEVEL;
     86              LCDBL_PWM_CONTROL(WL9FM_LCDBL.PWM);
     87          }
     88          
     89          /**
     90            * @brief  PWM Value Setting (pwm value를 받아서, Pulse로 설정한다.)
     91            * @param  pwm
     92            * @retval None
     93            */
     94          void LCDBL_PWM_CONTROL(uint16_t PWM_VALUE)
     95          {
     96          	TIM_OCInitTypeDef  TIM_OCInitStructure;
     97          
     98          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
     99          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    100          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    101          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    102          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    103          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    104          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    105          
    106          	//	Channel 1 Configuration in PWM mode
    107          	TIM_OCInitStructure.TIM_Pulse = PWM_VALUE;
    108          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);					
    109          
    110          	// 	TIM8 counter enable
    111          	TIM_Cmd(TIM8, ENABLE);			
    112          
    113          	//	TIM8 Main Output Enable
    114          	TIM_CtrlPWMOutputs(TIM8, ENABLE);
    115          }
    116          
    117          void LCDBL_Init(void)
    118          {
    119          	DebugMsg_printf("++ LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize START\r\n");
    120          
    121          	/* TIM8 Configuration ---------------------------------------------------
    122          	Generate 7 PWM signals with 4 different duty cycles:
    123          	TIM8 input clock (TIM8CLK) is set to 2 * APB2 clock (PCLK2), since APB2 
    124          	prescaler is different from 1.   
    125          	TIM8CLK = 2 * PCLK2  
    126          	PCLK2 = HCLK / 2 
    127          	=> TIM8CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
    128          	TIM8CLK = SystemCoreClock, Prescaler = 0, TIM8 counter clock = SystemCoreClock
    129          	SystemCoreClock is set to 168 MHz for STM32F4xx devices
    130          
    131          	The objective is to generate 7 PWM signal at 17.57 KHz:
    132          	- TIM8_Period = (SystemCoreClock / 17570) - 1
    133          	The channel 1 and channel 1N duty cycle is set to 50%
    134          	The channel 2 and channel 2N duty cycle is set to 37.5%
    135          	The channel 3 and channel 3N duty cycle is set to 25%
    136          	The channel 4 duty cycle is set to 12.5%
    137          	The Timer pulse is calculated as follows:
    138          	- ChannelxPulse = DutyCycle * (TIM8_Period - 1) / 100
    139             
    140             Note: 
    141              SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
    142              Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
    143              function to update SystemCoreClock variable value. Otherwise, any configuration
    144              based on this variable will be incorrect. 
    145            ----------------------------------------------------------------------- */
    146            
    147            	TIM_TimeBaseInitTypeDef  	TIM_TimeBaseStructure;
    148            	TIM_OCInitTypeDef  			TIM_OCInitStructure;
    149          
    150          	uint16_t TimerPeriod  = 0;
    151          	
    152          	//	PWM Frequency : 500Hz (Mitsubishi 7" LCD)
    153          	TimerPeriod = (SystemCoreClock / 250 ) - 1;
    154          #if 0
    155          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
    156          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
    157          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
    158          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
    159          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
    160          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
    161          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
    162          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
    163          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
    164          #endif
    165          
    166              //  LCDBL GPIO는 System_Init.c 에서 설정
    167          #if 0
    168          	GPIO_InitTypeDef GPIO_InitStructure;
    169          
    170          	//	LCDBL_PWM -> PWM
    171          	GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    172          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    173          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    174          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    175          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    176          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    177          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    178          
    179          	//  LCDBL_CTRL -> GPIO Output
    180          	GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    181          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    182          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    183          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    184          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    185          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    186          
    187          #endif
    188          	
    189          	TIM_TimeBaseStructure.TIM_Prescaler         = 16;
    190          	TIM_TimeBaseStructure.TIM_CounterMode 	    = TIM_CounterMode_Up;
    191          	TIM_TimeBaseStructure.TIM_Period 			= TimerPeriod;
    192          	TIM_TimeBaseStructure.TIM_ClockDivision     = 0;
    193          	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    194          
    195          	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
    196          
    197          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
    198          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    199          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    200          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    201          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    202          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    203          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    204          
    205          	//	Channel 1 Configuration in PWM mode
    206          	TIM_OCInitStructure.TIM_Pulse = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    207          
    208          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
    209          
    210          	// 	TIM8 counter enable
    211          	TIM_Cmd(TIM8, ENABLE);
    212          
    213          	// 	TIM8 Main Output Enable
    214          	TIM_CtrlPWMOutputs(TIM8, ENABLE);		
    215          
    216          	DebugMsg_printf("-- LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize END\r\n");
    217          
    218          	TimeDelay_msec(1000); 
    219          
    220          	WL9FM_LCDBL.LEVEL = DefaultLCDBLLEVEL;
    221          	WL9FM_LCDBL.PWM   = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    222          }
    223          
    224          void LCD_Display_Change(uint8_t BitData)
    225          {
    226          	//	Display Buffer를 변경하는 것이기 때문에
    227          	//	표시하고자 하는 것을 하기 전에, 다른 것을 먼저 High-Z 상태로 만든다. 
    228          	if (BitData == STM32F4_DISPLAY)
    229          	{
    230          	    GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_RESET);
    231          		TimeDelay_msec(10); 
    232          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_SET);
    233          	}
    234          	else
    235          	{
    236          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_RESET);
    237          		TimeDelay_msec(10); 
    238          		GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_SET);
    239          	}
    240          }
    241          
    242          void cam_mode_change(void)
    243          {
    244          	if(CAM_Mode<7)
    245          	{
    246          		CameraMode(CAM_Mode++,0);
    247          		LCD_Display_Change(STM32F4_DISPLAY);
    248          	}
    249          	else
    250          	{
    251          		CAM_Mode=0;
    252          		LCD_Display_Change(EXYNOS_DISPLAY);
    253          	}
    254          	
    255          }
    256          
    257          /**\
    258            * @brief  None
    259            * @param  None
    260            * @retval None
    261            */
    262          void LCD_Control_Init(void)
    263          {
    264          	TimeDelay_msec(2500); 
    265          	LCD_Display_Change(EXYNOS_DISPLAY);
    266          	LCDBL_Init();	
    267          	LCDBL_ONOFF(LCDBL_ON);	//  LCDBL Power On!!!
    268          			//	LCDBL PWM 설정 
    269          	
    270          	//LCD_Display_Change(STM32F4_DISPLAY);
    271          }
    272          
    273          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   LCDBL_Init
        48   -> TIM_Cmd
        48   -> TIM_CtrlPWMOutputs
        48   -> TIM_OC1Init
        48   -> TIM_TimeBaseInit
        48   -> TimeDelay_msec
       8   LCDBL_ONOFF
         8   -> GPIO_WriteBit
      32   LCDBL_PWM_CONTROL
        32   -> TIM_Cmd
        32   -> TIM_CtrlPWMOutputs
        32   -> TIM_OC1Init
       0   LCDBL_PWM_LEVEL
         0   -> LCDBL_PWM_CONTROL
       8   LCD_Control_Init
         8   -> GPIO_WriteBit
         8   -> LCDBL_Init
         8   -> LCD_Display_Change
         8   -> TimeDelay_msec
      16   LCD_Display_Change
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TimeDelay_msec
       0   LCD_POWER_ONOFF
         0   -> GPIO_WriteBit
       0   LED_POWER_ONOFF
         0   -> GPIO_WriteBit
       8   cam_mode_change
         8   -> CameraMode
         0   -> LCD_Display_Change


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       1  CAM_Mode
     146  LCDBL_Init
      20  LCDBL_ONOFF
      20  LCDBL_PWMLEVEL
      80  LCDBL_PWM_CONTROL
      16  LCDBL_PWM_LEVEL
      38  LCD_Control_Init
      72  LCD_Display_Change
      10  LCD_POWER_ONOFF
      12  LED_POWER_ONOFF
      34  cam_mode_change

 
   1 byte  in section .bss
 476 bytes in section .text
 
 476 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
