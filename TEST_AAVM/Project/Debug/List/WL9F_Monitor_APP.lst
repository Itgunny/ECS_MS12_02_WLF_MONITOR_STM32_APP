###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      29/Aug/2016  16:39:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c    #
#    Command line =  "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c"   #
#                    -D USE_STDPERIPH_DRIVER -D STM32F4XX -D                  #
#                    USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN                #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\Debug\List\" -o "D:\Project\[SVN]      #
#                    ECS-RD12-16 - WL9F Monitor -                             #
#                    STM32_APP\Project\Debug\Obj\" --debug --endian=little    #
#                    --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config          #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "D:\Project\[SVN]   #
#                    ECS-RD12-16 - WL9F Monitor -                             #
#                    STM32_APP\Project\..\Platform\COMMON\INC\" -I            #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\..\Platform\TaeHa - ECS\INC\" -I       #
#                    "D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -           #
#                    STM32_APP\Project\..\Libraries\CMSIS\Device\ST\STM32F4xx #
#                    \Include\" -I "D:\Project\[SVN] ECS-RD12-16 - WL9F       #
#                    Monitor - STM32_APP\Project\..\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\inc\" -Oh --use_c++_inline -I "C:\Program    #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Project\Debug\List\WL9F_Monitor_APP.lst        #
#    Object file  =  D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor -            #
#                    STM32_APP\Project\Debug\Obj\WL9F_Monitor_APP.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\[SVN] ECS-RD12-16 - WL9F Monitor - STM32_APP\Platform\TaeHa - ECS\SRC\WL9F_Monitor_APP.c
      1          /**
      2            ******************************************************************************
      3            * @file    WL9F_Monitor_APP.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   WL9F_Monitor_APP.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"
     23          #include "WL9F_Monitor_APP.h"	
     24          #include "WL9F_Monitor_Variable.h"
     25          #include "endecoder.h"
     26          /* Private typedef -----------------------------------------------------------*/
     27          /*
     28          #define RX_MSG69		0x01
     29          #define RX_MSG69_M		0x02
     30          #define RX_MSG145		0x04
     31          #define RX_MSG161		0x08
     32          #define RX_MSG162		0x10
     33          #define RX_MSG163		0x20
     34          #define RX_MSG251		0x40
     35          #define RX_MSG252		0x80
     36          #define RX_MSG202		0x100
     37          #define RX_MSG253		0x200
     38          #define RX_MSG203		0x400
     39          #define RX_MSG239		0x800
     40          #define RX_MSG247		0x1000
     41          #define RX_MSG174		0x2000
     42          #define RX_MSG239_121	0x4000
     43          */
     44          #define RX_MSG11	0x01
     45          #define RX_MSG12	0x02
     46          #define RX_MSG21	0x04
     47          #define RX_MSG23	0x08
     48          #define RX_MSG61	0x10
     49          #define RX_MSG62	0x20
     50          #define RX_MSG101	0x40
     51          #define RX_MSG104	0x80
     52          #define RX_MSG105	0x100
     53          #define RX_MSG109	0x200
     54          #define RX_MSG121	0x400
     55          #define RX_MSG123	0x800
     56          #define RX_MSG201	0x1000
     57          #define RX_MSG203	0x2000
     58          		
     59          		
     60          #define RX_MSG47	0x4000
     61          		
     62          #define RX_MSG145	0x8000
     63          #define RX_MSG247	0x10000
     64          
     65          
     66          #define UART2_Tx_BUF_SIZE		17
     67          
     68          
     69          /* Private define ------------------------------------------------------------*/
     70          #define EXT_WATCHDOG_ENALBE(x)					GPIO_WriteBit(WD_EN_PORT, WD_EN,x)		// ++, --, 160511 bwk
     71          /* Private macro -------------------------------------------------------------*/
     72          WL9FM_send_smartkey send_smartkey;
     73          WL9FM_receive_smartkey recv_smartkey;
     74          WL9FM_save_rand_value rand_value;
     75          WL9FM_flag_data smk_flag_data;	
     76          
     77          /* Private variables ---------------------------------------------------------*/
     78          u8 gAuthentication_Cnt = 0;
     79          
     80          // ++ , 141118 sys3215
     81          u8 Flag_ESL;
     82          u8 Seed_request;
     83          u8 Seed_received;
     84          u8 ESL_CTS_received;
     85          u8 ESL_ACK_received;
     86          u8 Password_Certification_Result;
     87          // -- , 141118 sys3215
     88          
     89          u8 AuthResult;
     90          u8 SMKSuccess;
     91          u8 SMK_Msg_Send;
     92          u8 SMK_Tag_Count;
     93          u8 MultiPacketSendOrder = 0;
     94          u8 TotalPacketNum = 0;
     95          u8 DiffMachInfo = 0;
     96          u8 MachInfoSendCnt = 0;
     97          u8 MoniInfoSendCnt = 0;
     98          
     99          u8 RTSFlag_61184 = 0;
    100          u8 CTSFlag_61184 = 0;
    101          u8 RMCU_CTSFlag_61184 = 0;
    102          u8 RecvTotalPacket_61184 = 0;
    103          u8 RMCU_RecvTotalPacket_61184 = 0;
    104          u8 ACK_Multi_61184[8];
    105          u8 RMCU_ACK_Multi_61184[8];
    106          
    107          u8 Flag_UartTxStart = 0;
    108          u8  SendTime_E2PROM = 0;
    109          
    110          u16 Flag_1Sec_MachInfo = 0;
    111          u16 Flag_1Min = 0;
    112          
    113          u8 MachInfoTotalPacketNum = 0;
    114          u8 MoniInfoTotalPacketNum = 0;
    115          u8 Flag_200mSec = 0;
    116          u8 SendRTCnt = 0;
    117          u16 adc_value = 0;
    118          
    119          u8 SerialMsgRTC[16];
    120          u8 eepRomReadData1[32];
    121          u8 MoniInfoData[21];
    122          u8 McuInfoData2[4];
    123          u8 McuInfoData3[4];
    124          u8 McuInfoData4[4];
    125          
    126          u8 SystemReset = 0;
    127          u8 E2PROM_Save = 0;
    128          u8 PwrOffCnt = 0;
    129          u8 gRebootCmd = 0;
    130          
    131          
    132          u8 send_mcu_data=0;
    133          u8 send_bkcu_data=0;
    134          
    135          u8 ST_Update=0;
    136          u8 UpdateMode = 0;
    137          
    138          extern u8 Uart2_RxMsg_Single_252[8];
    139          extern u8 Uart2_RxMsg_Single_253[8];
    140          extern u8 Uart2_RxMsg_Single_239[8];
    141          extern u8 Uart2_RxMsg_Single_239_121[8];
    142          extern u8 Uart2_RxMsg_Single_247[8];
    143          extern u8 Uart2_RxMsg_Save_Data1[8];
    144          extern u8 Uart2_RxMsg_Save_Data2[8];
    145          extern u8 Uart2_RxMsg_AS_Phone_Data[8];
    146          extern u8 Uart2_RxMsg_Smk_Reg_Eli[8];
    147          extern u8 McuInfoData1[79];
    148          extern u8 tmpMcuInfoData[78];
    149          extern u8 FatoryInit_Flag;
    150          
    151          extern u8 stop_send_as_phone_data;
    152          extern u8 Flag_TxE2pRomData;
    153          
    154          extern u8 Buz1;
    155          
    156          extern u8 Stm32_Update_CMD;
    157          extern u8 CANUpdateFlag;
    158          
    159          extern u16 pWriteBufPos;
    160          extern u16 pReadBufPos;
    161          
    162          extern u8 Uart2_SerialTxMsg[UART2_Tx_BUF_SIZE];
    163          extern char Illumination_Sig;
    164          
    165          // ++, 141006 fort22
    166          u8 LCDOffCount;
    167          u16 OSUpdateCount;
    168          // --, 141006 fort22
    169          
    170          u8 SmartKeyUse;
    171          
    172          u8 CameraCommFlag;
    173          
    174          u8 AAVMCommFlag;
    175          // ++, sys3215, 141211
    176          extern u8 Hardware_Revision;
    177          // --, sys3215, 141211
    178          
    179          extern u8 Flag_St_Update;
    180          
    181          
    182          //	++, kutelf, 150810
    183          //	Software_Reset
    184          #define ApplicationAddress      0x8004000
    185          #define BootLoaderAddress       0x8000000
    186          
    187          typedef  void (*pFunction)(void);
    188          
    189          pFunction Jump_To_Application_Cluster_App;
    190          uint32_t JumpAddress_Cluster_App;
    191          
    192          pFunction Jump_To_Application_Cluster_Iap;
    193          uint32_t JumpAddress_Cluster_Iap;
    194          
    195          void Software_Reset_BootLoader(void);
    196          void Software_Reset_Application(void);
    197          
    198          
    199          void Software_Reset_Application(void)
    200          { 	/* Jump to user application */
    201          		JumpAddress_Cluster_App = *(__IO uint32_t*) (ApplicationAddress + 4);
    202          		Jump_To_Application_Cluster_App = (pFunction) JumpAddress_Cluster_App;
    203          		/* Initialize user application's Stack Pointer */
    204          		__set_MSP(*(__IO uint32_t*) ApplicationAddress);
    205          		Jump_To_Application_Cluster_App();
    206          }	
    207          
    208          void Software_Reset_BootLoader(void)
    209          { 	/* Jump to user application */
    210          		JumpAddress_Cluster_Iap = *(__IO uint32_t*) (BootLoaderAddress + 4);
    211          		Jump_To_Application_Cluster_Iap = (pFunction) JumpAddress_Cluster_Iap;
    212          		/* Initialize user application's Stack Pointer */
    213          		__set_MSP(*(__IO uint32_t*) BootLoaderAddress);
    214          		Jump_To_Application_Cluster_Iap();
    215          }	
    216          //	--, kutelf, 150810
    217          
    218          /* Private function prototypes -----------------------------------------------*/
    219          /* Private functions ---------------------------------------------------------*/
    220          
    221          void Init_RTC(void)
    222          {
    223          	WL9FM_RTC.Year   = 0;
    224          	WL9FM_RTC.Month  = 1;
    225          	WL9FM_RTC.Date   = 1;
    226          	WL9FM_RTC.Day    = 1;
    227          	WL9FM_RTC.Hour   = 12;
    228          	WL9FM_RTC.Minute = 0;
    229          	WL9FM_RTC.Second = 0;
    230          
    231          	WRITE_RTC(WL9FM_RTC);
    232          }
    233          void InitE2PROM(void)
    234          {
    235          	u8 i;
    236          	u8 tmpBuf1[8];
    237          	u8 tmpBuf2[8];
    238          	u8 tmpBuf3[8];
    239          	u8 tmpBuf4[21];
    240          	
    241          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
    242          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
    243          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
    244          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
    245          
    246          	SaveE2PROM1->WorkLoad 				= 0;
    247          	SaveE2PROM1->testWorkLoad 			= 0;
    248          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
    249          	SaveE2PROM1->DispType	 			= 0;
    250          	SaveE2PROM1->InfoViewPriority 		= 0;
    251          	SaveE2PROM1->UnitPressure 			= 0;
    252          	SaveE2PROM1->Reserved0 				= 0;
    253          	SaveE2PROM1->Lang 					= 0;
    254          	SaveE2PROM1->ManualBackLight 		= 7;
    255          	SaveE2PROM1->AutoBackLight 			= 0;
    256          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
    257          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
    258          	SaveE2PROM1->InfoViewCnt 			= 2;
    259          	SaveE2PROM1->HR_Start 				= 0;
    260          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
    261          	SaveE2PROM1->ActiveCamNum 			= 1;
    262          	SaveE2PROM1->FirstCam 				= 0;
    263          	SaveE2PROM1->SecondCam 				= 1;
    264          	SaveE2PROM1->ThirdCam 				= 2;
    265          	SaveE2PROM1->Reserved1 				= 0;
    266          
    267          	SaveE2PROM2->LightMode 				= 0;
    268          	SaveE2PROM2->JobTimeView 			= 0;
    269          	SaveE2PROM2->OdoMeterView 			= 0;
    270          	SaveE2PROM2->JobOdoSelect 			= 0;
    271          	SaveE2PROM2->LightLowTime 			= 8;
    272          	SaveE2PROM2->LightUpperTime 		= 16;
    273          	SaveE2PROM2->AutoLightDay 			= 0;
    274          	SaveE2PROM2->AutoLightNight 		= 0;
    275          	SaveE2PROM2->Reserved1 				= 0;
    276          
    277          	SaveE2PROM3->Phone_1  				= 0;
    278          	SaveE2PROM3->Phone_2  				= 8;
    279          	SaveE2PROM3->Phone_3  				= 0;
    280          	SaveE2PROM3->Phone_4  				= 5;
    281          	SaveE2PROM3->Phone_5  				= 5;
    282          	SaveE2PROM3->Phone_6  				= 5;
    283          	SaveE2PROM3->Phone_7  				= 8;
    284          	SaveE2PROM3->Phone_8  				= 2;
    285          	SaveE2PROM3->Phone_9  				= 7;
    286          	SaveE2PROM3->Phone_10 				= 2;
    287          	SaveE2PROM3->Phone_11 				= 0xf;
    288          	SaveE2PROM3->Phone_12 				= 0xf;
    289          
    290          #if 1	// Monitor Change History - temp
    291          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    292          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    293          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    294          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    295          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    296          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    297          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    298          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    299          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    300          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    301          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    302          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    303          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    304          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    305          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    306          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    307          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    308          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    309          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    310          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    311          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    312          #endif
    313          
    314          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    315          
    316          	EEPROM_Write(0, 0);	// tmp
    317          	EEPROM_Write(0, 0);	// tmp
    318          	EEPROM_Write(0, 0);	// tmp
    319          
    320          	for(i = 0 ; i < 8 ; i++)
    321          	{
    322          		EEPROM_Write(i+8, tmpBuf1[i]);
    323          		TimeDelay_msec(5);
    324          		EEPROM_Write(i+16, tmpBuf2[i]);
    325          		TimeDelay_msec(5);
    326          		EEPROM_Write(i+24, tmpBuf3[i]);
    327          		TimeDelay_msec(5);
    328          	}
    329          
    330          	SerialPutString("Initialize : 30 %%\n\r");
    331          	
    332          #if 1	// Monitor Change History - temp
    333          	for(i = 0 ; i < 21 ; i++)
    334          	{
    335          		EEPROM_Write(i+50, tmpBuf4[i]);
    336          		TimeDelay_msec(5);
    337          	}
    338          #endif
    339          
    340          	for(i = 0 ; i < 79 ; i++)
    341          	{
    342          		EEPROM_Write(i+100, 0xff);
    343          		TimeDelay_msec(5);
    344          	}
    345          
    346          	SerialPutString("Initialize : 60 %%\n\r");
    347          
    348          	for(i = 0 ; i < 30 ; i++)
    349          	{
    350          		EEPROM_Write(i+200, 0xff);
    351          		TimeDelay_msec(5);
    352          	}
    353          
    354          	for(i = 0 ; i < 29 ; i++)
    355          	{
    356          		EEPROM_Write(i+230, 0xff);
    357          		TimeDelay_msec(5);
    358          	}
    359          
    360          	SerialPutString("Initialize : 95 %%\n\r");
    361          	Init_RTC();
    362          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    363          }
    364          
    365          void ReadE2PROM_ToSend()
    366          {
    367          #if 1
    368          	u8 i;
    369          
    370          	adc_value = (ADC1->DR & 0x0000FFFF);
    371          
    372          	i = EEPROM_Read(0);	
    373          	i = EEPROM_Read(0);
    374          	i = EEPROM_Read(0);
    375          	i = 0;
    376              
    377          	adc_value = (ADC1->DR & 0x0000FFFF);
    378          
    379          	for(i = 0 ; i < 24 ; i++)
    380          		eepRomReadData1[i] = EEPROM_Read(i+8);
    381          
    382          	for(i = 0 ; i < 8 ; i++)
    383          		Uart2_RxMsg_Save_Data1[i] = eepRomReadData1[i];
    384          
    385          	for(i = 0 ; i < 8 ; i++)
    386          		Uart2_RxMsg_Save_Data2[i] = eepRomReadData1[i+8];
    387          
    388          	for(i = 0 ; i < 8 ; i++)
    389          		Uart2_RxMsg_AS_Phone_Data[i] = eepRomReadData1[i+16];
    390          
    391          	for(i = 0 ; i < 21 ; i++)
    392          		MoniInfoData[i] = EEPROM_Read(i+50);
    393          	
    394          	for(i = 0 ; i < 79 ; i++)
    395          		McuInfoData1[i] = EEPROM_Read(i+100);
    396          
    397          	for(i = 0 ; i < 4 ; i++)
    398          		McuInfoData2[i] = EEPROM_Read(i+200);
    399          
    400          	for(i = 0 ; i < 4 ; i++)
    401          		McuInfoData3[i] = EEPROM_Read(i+210);
    402          
    403          	for(i = 0 ; i < 4 ; i++)
    404          		McuInfoData4[i] = EEPROM_Read(i+220);
    405          
    406          	memset(&tmpMcuInfoData[1] , 0xff, 77);
    407          	memcpy((u8*)&tmpMcuInfoData[0], (u8*)&McuInfoData1[0], 5);
    408          	memcpy((u8*)&tmpMcuInfoData[5], (u8*)&McuInfoData2[0], 4);
    409          	memcpy((u8*)&tmpMcuInfoData[9], (u8*)&McuInfoData3[0], 4);
    410          	memcpy((u8*)&tmpMcuInfoData[13], (u8*)&McuInfoData4[0], 4);
    411          
    412          
    413          	adc_value = (ADC1->DR & 0x0000FFFF);
    414          	
    415          	eepRomReadData1[12] = (adc_value & 0xff);
    416          	eepRomReadData1[13] = (adc_value & 0xff00) >> 8;
    417          //	DebugMsg_printf("%2x %2x\r\n", eepRomReadData1[13], eepRomReadData1[12]);
    418          
    419          #endif
    420          }
    421          
    422          
    423          void Init_Smart_Key_valuable(void)
    424          {
    425          	smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
    426          	AuthResult = 0xff;
    427          	SMK_Msg_Send = 0;
    428          	SMK_Tag_Count = 0;
    429          	SMKSuccess = 0;
    430          
    431          // ++, 141118 sys3215
    432          	Flag_ESL=0;
    433          	Seed_request=0;
    434          	Seed_received=0;
    435          	ESL_CTS_received=0;
    436          	ESL_ACK_received=0;
    437          	Password_Certification_Result=0;
    438          // --, 141118 sys3215
    439          
    440          }
    441          
    442          
    443          void read_clock(void)
    444          {
    445          	uint8_t Temp[Serial_COM4_TxSize];
    446          	
    447          	READ_RTC(&WL9FM_RTC);
    448          
    449          	Temp[0] = 0x02;				
    450          	Temp[1] = RTCRES;				
    451          	Temp[2] = WL9FM_RTC.Year;	
    452          	Temp[3] = WL9FM_RTC.Month;	
    453          	Temp[4] = WL9FM_RTC.Date;	
    454          	Temp[5] = WL9FM_RTC.Day;	
    455          	Temp[6] = WL9FM_RTC.Hour;	
    456          	Temp[7] = WL9FM_RTC.Minute;	
    457          	Temp[8] = WL9FM_RTC.Second;	
    458          	Temp[9] = 0xFF;	
    459          	Temp[Serial_COM4_RxSize-1] = 0x03;	
    460          	USARTx_EXYNOS(COM4, (char *)Temp);	
    461          
    462          }
    463          
    464          void SaveDataToEEPROM(void)
    465          {
    466          	u8 i;
    467          	
    468          	for(i = 0 ; i < 8 ; i++)
    469          	{
    470          		EEPROM_Write(i+8, Uart2_RxMsg_Save_Data1[i]);
    471          		TimeDelay_msec(1);
    472          	}
    473          
    474          	for(i = 0 ; i < 8 ; i++)
    475          	{
    476          		EEPROM_Write(i+16, Uart2_RxMsg_Save_Data2[i]);
    477          		TimeDelay_msec(1);
    478          	}
    479          
    480          	for(i = 0 ; i < 8 ; i++)
    481          	{
    482          		EEPROM_Write(i+24, Uart2_RxMsg_AS_Phone_Data[i]);
    483          		TimeDelay_msec(1);
    484          	}
    485          
    486          	for(i = 0 ; i < 21 ; i++)
    487          	{
    488          		EEPROM_Write(i+50, MoniInfoData[i]);
    489          		TimeDelay_msec(1);
    490          	}
    491          	
    492          	for(i = 0 ; i < 79 ; i++)
    493          	{
    494          		EEPROM_Write(i+100, McuInfoData1[i]);
    495          		TimeDelay_msec(1);
    496          	}
    497          
    498          
    499          	if(DiffMachInfo == 1)
    500          	{
    501          		memcpy((u8*)&McuInfoData2[0], (u8*)&tmpMcuInfoData[5] , 4);		
    502          		memcpy((u8*)&McuInfoData3[0], (u8*)&tmpMcuInfoData[9] , 4);
    503          		memcpy((u8*)&McuInfoData4[0], (u8*)&tmpMcuInfoData[13] , 4);
    504          	}
    505          
    506          	for(i = 0 ; i < 4 ; i++)
    507          	{
    508          		EEPROM_Write(i+200, McuInfoData2[i]);
    509          		TimeDelay_msec(1);
    510          	}
    511          
    512          	for(i = 0 ; i < 4 ; i++)
    513          	{
    514          		EEPROM_Write(i+210, McuInfoData3[i]);
    515          		TimeDelay_msec(1);
    516          	}
    517          
    518          	for(i = 0 ; i < 4 ; i++)
    519          	{
    520          		EEPROM_Write(i+220, McuInfoData4[i]);
    521          		TimeDelay_msec(1);
    522          	}
    523          }
    524          void SaveSMKUseToEEPROM(u8 Use)
    525          {
    526          	EEPROM_Write(0,Use);
    527          }
    528          u8 LoadSMKUseToEEPROM(void)
    529          {
    530          	return EEPROM_Read(0);
    531          }
    532          // ++, 160511 bwk
    533          void SaveSMKUseToFlash(u8 Use)
    534          {
    535          	u8 SaveSMKUse[1];
    536          	SaveSMKUse[0] = Use;
    537          	SPI_FLASH_SectorErase(0);		// 0 : Sector_0
    538          	SPI_FLASH_PageWrite(SaveSMKUse,0,1);		// 0 : Sector_0
    539          }
    540          u8 LoadSMKUseToFlash(void)
    541          {
    542          	u8 SaveSMKUse[1];
    543          	SPI_FLASH_BufferRead(SaveSMKUse,0,1);		// 0 : Sector_0
    544          	return SaveSMKUse[0];
    545          }
    546          // --, 160511 bwk
    547          
    548          void SaveTestToEEPROM(u8 Use)
    549          {
    550          	EEPROM_Write(1,Use);
    551          }
    552          
    553          u8 LoadTestToEEPROM(void)
    554          {
    555          	return EEPROM_Read(1);
    556          }
    557          
    558          
    559          void System_CheckPowerIG()
    560          {
    561          	// Check POWER IG
    562          	if(!WL9FM_GetPowerIG())
    563          	{
    564          		WL9FM_PowerIG(PowerIG_ON);
    565          		SystemReset = 0;
    566          	}
    567          	else
    568          	{
    569          		if(E2PROM_Save == 0)
    570          		{
    571          			//SaveDataToEEPROM();
    572          
    573          			PwrOffCnt = 0;
    574          			
    575          			while(1)
    576          			{
    577          				//	100msec 마다 15번 체크 -> 1.5초..
    578          				//	PowerIG Off 상태일 경우
    579          				//		-> while 루프를 나와서 PowerOff Logic 진행  
    580          				//	PowerIG On  상태일 경우 
    581          				//		-> PowerIG Control 신호를 Enable하고, 정상 동작으로 진행 
    582          				
    583          				if(!WL9FM_GetPowerIG())
    584          				{
    585          					
    586          					WL9FM_PowerIG(PowerIG_ON);	// PowerIG Set
    587          					
    588          					
    589          					//	1.5초 동안 체크해서 PowerIG가 다시 들어오면, Software Reset을 하지 않고, 다시 동작
    590          					SystemReset = 0;
    591          					return;
    592          				}
    593          			
    594          				TimeDelay_msec(100);
    595          
    596          				PwrOffCnt++;
    597          				if(PwrOffCnt >= 15)	
    598          					break;
    599          			}
    600          
    601          			Buzzer_Off();
    602          
    603          			//	POWER OFF Code를 3msec 마다 2번 Exynos로 보낸다. 
    604          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	TimeDelay_msec(100);
    605          			KeySwitch_SendToEXYNOS(KEYSWITCH_POWER_OFF,0);	//TimeDelay_msec(3);
    606          
    607          			//	POWER OFF 일 때, 시리얼과 캔 통신 부분을 죽여놔야지, 정상적으로 RESET 동작을 수행
    608          			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    609          			CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    610          
    611          
    612          			Buzzer_UnLimitOff();
    613          			
    614          			//	POWER OFF 일 때, LAMP Clear
    615          			LAMP_Update_Data = LAMP_ALL_OFF;
    616          
    617          			//Old_LAMP_Update_Data = LAMP_ALL_OFF;
    618          
    619          			Illumination_Sig = 0;
    620          			Lamp_Update_System();
    621          			
    622          			//	엔딩화면 딜레이 시간
    623          			//	1200msec 이상 설정하면, LCD가 하얗게 된다. -> POWER Off Time으로 인하여
    624          			TimeDelay_msec(1200);
    625          
    626          			//	LCDBL, LCD, LED Off
    627          			LCDBL_PWM_LEVEL(0);            	//  LCDBL PWM LEVEL0
    628          			LCDBL_ONOFF(LCDBL_OFF);			//  LCDBL Power On
    629          			LCD_POWER_ONOFF(LCDPWR_OFF);	//  LCD Power Off
    630          			//LED_POWER_ONOFF(LED_OFF);       //  LED Off
    631          
    632          		//	++, kutelf, 140801
    633          		//	RevD.01.01 
    634          		//	Power, PMIC On/Off 방법 변경 
    635          		#if 0
    636          
    637          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_PMIC_OFF);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
    638          			WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
    639          			WL9FM_EXYNOS_PMIC_nRESET();
    640          		#else
    641          			WL9FM_EXYNOS_PMIC_PWROFF();
    642          			
    643          			//	Exynos VDD5V0_4412 Off
    644          			WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_OFF);
    645          			
    646          			TimeDelay_msec(1000);			//	1.5초 동안. 대기한 후, 마지막으로 PowerIG를 체크 
    647          
    648          			//	엔딩화면이 지난 후에 PowerIG가 다시 들어오면, System을 RESET 시킨다. 
    649          			if(!WL9FM_GetPowerIG())
    650          			{
    651          				WL9FM_PowerIG(PowerIG_ON);	// 	PowerIG Set
    652          
    653          				//	++, kutelf, 150810
    654          				#if 1
    655          				if (Flag_St_Update==1)
    656          				{
    657          					gRebootCmd=1;
    658          					Flag_St_Update=0;
    659          
    660          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    661          					CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    662          
    663          					Software_Reset_BootLoader();
    664          				}
    665          				else
    666          				{
    667          					USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    668          					CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    669          
    670          					Software_Reset_Application();
    671          				}	
    672          				#else
    673          				if(Flag_St_Update==1)
    674          				{
    675          					gRebootCmd=1;
    676          					Flag_St_Update=0;
    677          				}
    678          				else
    679          					SystemReset = 1;			//	Software RESET
    680          
    681          				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    682          				CAN_ITConfig(CAN1,CAN_IT_FMP0, DISABLE);
    683          				return;
    684          				#endif
    685          				//	--, kutelf, 150810
    686          			}
    687          
    688          			WL9FM_PowerIG(PowerIG_OFF);		//  24v Main Power Off	 
    689          			WL9FM_PowerIG(PowerIG_OFF);		
    690          			WL9FM_PowerIG(PowerIG_OFF);		
    691          		#endif
    692          		//	--, kutelf, 140801
    693          		}
    694          	}
    695          }
    696          
    697          
    698          void JumpIAP(void)
    699          {
    700          	//#ifdef USE_WATCH_DOG
    701          	/* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
    702          	dispersion) -------------------------------------------------------------*/
    703          	/* Enable write access to IWDG_PR and IWDG_RLR registers */
    704          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
    705          
    706          	/* IWDG counter clock: 40KHz(LSI) / 32 = 156.25 Hz */
    707          	IWDG_SetPrescaler(IWDG_Prescaler_256);
    708          
    709          	/* Set counter reload value to 150   about 1sec */
    710          	IWDG_SetReload(1);
    711          
    712          	/* Reload IWDG counter */
    713          	IWDG_ReloadCounter();
    714          
    715          	IWDG_Enable();
    716          		
    717          	while(1);
    718          	//#endif		
    719          }
    720          
    721          /*******************************************************************************
    722          *
    723          *	Smart Key Test Function
    724          *
    725          *******************************************************************************/
    726          #if 1
    727          void SendSMKAuthResult(u8 result)
    728          {
    729          	// ++, 150707 bwk
    730          	#if 0
    731          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count );
    732          	#else
    733          	SMK_SendToExynos( result,0xFF, SMK_Tag_Count , 0xff, 0xff);
    734          	#endif
    735          	// --, 150707 bwk
    736          }
    737          
    738          // ++, 150710 bwk
    739          void SendSMKCountResult()
    740          {
    741          	SMK_SendToExynos( 0xFF,SMK_RESPONSE_FLAG_DUPLICATION_REG, SMK_Tag_Count , 0xff, 0xff);
    742          }
    743          // --, 150710 bwk
    744          
    745          void SendSMKMsgResult(u8 result)
    746          {
    747          	// ++, 150707 bwk
    748          	#if 0
    749          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count );
    750          	#else
    751          	SMK_SendToExynos( 0xFF, result, recv_smartkey.Registered_Tag_Count, recv_smartkey.Smk_Response_Code, recv_smartkey.Smk_Response_Flag);
    752          	#endif
    753          	// --, 150707 bwk
    754          }
    755          
    756          void SetTagLevel(u8 level)
    757          {
    758          	if((level == TAG_LEVEL_NORMAL) || (level == TAG_LEVEL_MASTER_TAG))
    759          		send_smartkey.TagLevel = level;
    760          	else
    761          		send_smartkey.TagLevel = 3;
    762          }
    763          
    764          void SetTagCmd(u8 cmd)
    765          {
    766          	if(cmd <= TAG_CMD_COMM_AUTHENTICATION)
    767          		send_smartkey.TagCommand = cmd;
    768          	else
    769          		send_smartkey.TagCommand = 0xf;
    770          }
    771          
    772          void SetVMC(void)
    773          {
    774          	if(rand_value.rand_vmc <= 64255)
    775          		send_smartkey.VMC = rand_value.rand_vmc;
    776          	else
    777          		send_smartkey.VMC = 0xffff;
    778          }
    779          
    780          void SetCPK(void)
    781          {
    782          #if 1
    783          	if(rand_value.rand_cpk <= 0xfaffffff)
    784          		send_smartkey.CPK = rand_value.rand_cpk;
    785          	else
    786          		send_smartkey.CPK = 0xffffffff;
    787          #else
    788          	send_smartkey.CPK = 0x11223344;
    789          #endif
    790          }
    791          
    792          void Srand()
    793          {
    794          	READ_RTC(&WL9FM_RTC);
    795          	srand((u32)WL9FM_RTC.Second);
    796          }
    797          
    798          void GetRandValue(u8 random)
    799          {
    800          	if(random == GET_VMC)	
    801          	{
    802          		// ++, 150710 bwk
    803          #if 0
    804          		rand_value.rand_vmc = (rand() % 64255);
    805          #else
    806          		return;
    807          #endif
    808          		// --, 150710 bwk 
    809          	}
    810          	else if(random == GET_CPK)	
    811          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    812          	else if(random == GET_VMC_CPK)		
    813          	{
    814          		rand_value.rand_vmc = (rand() % 64255);
    815          		rand_value.rand_cpk = (rand() % 0xfaffffff);
    816          	}	
    817          }
    818          
    819          void RequestFirstAuthentication(void)
    820          {
    821          	unsigned int temp;
    822          	
    823          	SetTagLevel(TAG_LEVEL_NORMAL);
    824          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    825          	GetRandValue(GET_VMC_CPK);
    826          	SetVMC();
    827          	SetCPK();
    828          
    829          	setCipherParam(0x8085, 0x8087);
    830          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    831          	
    832          	send_smartkey.CPK = temp;
    833          
    834          	// CPK 암호화 Function 추가 필요
    835          	TimeDelay_msec(10);
    836          
    837          	struct st_CAN_Message1 Send_Message;
    838          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    839          	Send_Message.Priority= 0x18;
    840          	Send_Message.PDU_Format= 0xFF;
    841          	Send_Message.PDU_Specific= 0xE7;
    842          	Send_Message.Source_Address= 0x28;
    843          	Write_CAN_Single(Send_Message);
    844          }
    845          
    846          void RequestSecondAuthentication(void)
    847          {
    848          	unsigned short upper_cpk, lower_cpk;
    849          	unsigned int temp;
    850          
    851          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    852          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    853          	
    854          	SetTagLevel(TAG_LEVEL_NORMAL);
    855          	SetTagCmd(TAG_CMD_AUTHENTICATON);
    856          	GetRandValue(GET_VMC);
    857          	SetVMC();
    858          
    859          	setCipherParam(upper_cpk, lower_cpk);
    860          	//setCipherParam(0x1122, 0x3344);
    861          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    862          
    863          	send_smartkey.CPK = temp;
    864          	
    865          	TimeDelay_msec(10);
    866          
    867          	struct st_CAN_Message1 Send_Message;
    868          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    869          	Send_Message.Priority= 0x18;
    870          	Send_Message.PDU_Format= 0xFF;
    871          	Send_Message.PDU_Specific= 0xE7;
    872          	Send_Message.Source_Address= 0x28;
    873          	Write_CAN_Single(Send_Message);
    874          
    875          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    876          }
    877          
    878          void RequestSMKRegistration(void)
    879          {
    880          	unsigned short upper_cpk, lower_cpk;
    881          	unsigned int temp;
    882          
    883          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    884          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    885          	
    886          	SetTagLevel(TAG_LEVEL_NORMAL);
    887          	SetTagCmd(TAG_CMD_REGISTRATION);
    888          	GetRandValue(GET_VMC);
    889          	SetVMC();
    890          
    891          	setCipherParam(upper_cpk, lower_cpk);
    892          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    893          
    894          	send_smartkey.CPK = temp;
    895          
    896          
    897          	struct st_CAN_Message1 Send_Message;
    898          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    899          	Send_Message.Priority= 0x18;
    900          	Send_Message.PDU_Format= 0xFF;
    901          	Send_Message.PDU_Specific= 0xE7;
    902          	Send_Message.Source_Address= 0x28;
    903          	Write_CAN_Single(Send_Message);
    904          
    905          
    906          
    907          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    908          }
    909          
    910          void RequestSMKElimination(void)
    911          {
    912          	unsigned short upper_cpk, lower_cpk;
    913          	unsigned int temp;
    914          
    915          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    916          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    917          	
    918          	SetTagLevel(TAG_LEVEL_NORMAL);
    919          	SetTagCmd(TAG_CMD_ELIMINATION);
    920          	GetRandValue(GET_VMC);
    921          	SetVMC();
    922          
    923          	setCipherParam(upper_cpk, lower_cpk);
    924          	encode((u8*)&send_smartkey.CPK, 4, (u8*)&temp, 4);
    925          
    926          	send_smartkey.CPK = temp;
    927          
    928          	struct st_CAN_Message1 Send_Message;
    929          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    930          	Send_Message.Priority= 0x18;
    931          	Send_Message.PDU_Format= 0xFF;
    932          	Send_Message.PDU_Specific= 0xE7;
    933          	Send_Message.Source_Address= 0x28;
    934          	Write_CAN_Single(Send_Message);
    935          
    936          
    937          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    938          }
    939          
    940          void RequestSMKMessage(u8 Msg)
    941          {
    942          	if(Msg == 1)
    943          		RequestSMKRegistration();
    944          	else if(Msg == 2)
    945          		RequestSMKElimination();
    946          }
    947          
    948          void RequestSMKComm(void)
    949          {
    950          	SetTagLevel(TAG_LEVEL_NORMAL);
    951          	SetTagCmd(TAG_CMD_COMM_AUTHENTICATION);
    952          	GetRandValue(GET_VMC);
    953          	SetVMC();
    954          
    955          	struct st_CAN_Message1 Send_Message;
    956          	memcpy(&Send_Message.Data,&send_smartkey,8);	
    957          	Send_Message.Priority= 0x18;
    958          	Send_Message.PDU_Format= 0xFF;
    959          	Send_Message.PDU_Specific= 0xE7;
    960          	Send_Message.Source_Address= 0x28;
    961          	Write_CAN_Single(Send_Message);
    962          
    963          	//smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
    964          }
    965          
    966          u8 CheckResponseVMC(void)
    967          {
    968          	if(send_smartkey.VMC == recv_smartkey.ReturnVMC)
    969          		return RETURN_VMC_OK;
    970          	else
    971          		return RETURN_VMC_NOT_OK;
    972          }
    973          
    974          u8 CheckResponseAuthentication(u8 Auth)
    975          {
    976          	u8 output_buf[8];
    977          	u16 upper_cpk, lower_cpk;
    978          
    979          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
    980          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
    981          	
    982          	setCipherParam(upper_cpk, lower_cpk);
    983          	//setCipherParam(0x1122, 0x3344);	// 임시
    984          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
    985          
    986          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
    987          
    988          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
    989          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
    990          	{
    991          		if((recv_smartkey.Smk_Response_Code == Auth) && 
    992          			(recv_smartkey.Smk_Response_Flag == SMK_RESPONSE_FLAG_SUCCESS))
    993          		{
    994          			return SMK_RESPONSE_FLAG_SUCCESS;
    995          		}
    996          		else
    997          			return recv_smartkey.Smk_Response_Flag;
    998          	}
    999          	else
   1000          		return SMK_RESPONSE_CODE_NOT_MATCH;
   1001          }
   1002          
   1003          void CheckResponseMsgComm(void)
   1004          {
   1005          	u8 output_buf[8];
   1006          	u16 upper_cpk, lower_cpk;
   1007          
   1008          	upper_cpk = (rand_value.rand_cpk & 0xffff0000) >> 16;
   1009          	lower_cpk = rand_value.rand_cpk & 0x0000ffff;
   1010          	
   1011          	setCipherParam(upper_cpk, lower_cpk);
   1012          	//setCipherParam(0x1122, 0x3344);	// 임시
   1013          	decode((u8*)&recv_smartkey, 8, (u8*)&output_buf[0], 8);
   1014          
   1015          	memcpy((u8*)&recv_smartkey, (u8*)&output_buf[0], 8);
   1016          
   1017          	if((send_smartkey.TagLevel == recv_smartkey.ReturnTagLevel) && (send_smartkey.TagCommand == recv_smartkey.ReturnTagCommand) 
   1018          		&& (send_smartkey.VMC == recv_smartkey.ReturnVMC))
   1019          	{
   1020          		if(recv_smartkey.Smk_Response_Code == 1)
   1021          		{
   1022          			switch(recv_smartkey.Smk_Response_Flag)
   1023          			{
   1024          				
   1025          				case 2 :
   1026          					SendSMKMsgResult(SMK_MSG_TAG_NO_REALIZE);
   1027          					break;
   1028          				
   1029          				case 1:
   1030          				case 3 :
   1031          					SendSMKMsgResult(SMK_MSG_FAIL);
   1032          					break;
   1033          				case 4 :
   1034          					SendSMKMsgResult(SMK_MSG_TAG_ALREADY_REG);
   1035          					break;
   1036          				default :
   1037          					if(recv_smartkey.ReturnTagCommand == SMK_RESPONSE_CODE_REGISTRATION)
   1038          					{
   1039          						if(recv_smartkey.Registered_Tag_Count == 1)
   1040          							SendSMKMsgResult(SMK_MSG_TAG_FIRST_REG_SUCCESS);
   1041          						else if(recv_smartkey.Registered_Tag_Count == 2)
   1042          							SendSMKMsgResult(SMK_MSG_TAG_SECOND_REG_SUCCESS);
   1043          						else if(recv_smartkey.Registered_Tag_Count == 3)
   1044          							SendSMKMsgResult(SMK_MSG_TAG_THIRD_REG_SUCCESS);
   1045          						else if(recv_smartkey.Registered_Tag_Count == 4)
   1046          							SendSMKMsgResult(SMK_MSG_TAG_FOURTH_REG_SUCCESS);
   1047          						else if(recv_smartkey.Registered_Tag_Count == 5)
   1048          							SendSMKMsgResult(SMK_MSG_TAG_FIFTH_REG_SUCCESS);
   1049          						else
   1050          							SendSMKMsgResult(SMK_MSG_FAIL);
   1051          					}
   1052          					else
   1053          					{
   1054          						// ++, 150707 sys
   1055          						#if 0
   1056          						if(SMK_Tag_Count != 0)
   1057          							SMK_Tag_Count--;
   1058          						#endif
   1059          						// --, 150707 sys
   1060          						
   1061          						SendSMKMsgResult(SMK_MSG_FAIL);
   1062          					}
   1063          					break;
   1064          			}
   1065          		}
   1066          		else if(recv_smartkey.Smk_Response_Code == 2)
   1067          			SendSMKMsgResult(SMK_MSG_TAG_ELIMINATION_SUCCESS);
   1068          		else
   1069          			SendSMKMsgResult(SMK_MSG_FAIL);
   1070          	}
   1071          	else
   1072          		SendSMKMsgResult(SMK_MSG_FAIL);
   1073          }
   1074          
   1075          
   1076          void SmartKeyAuthentication(void)
   1077          {
   1078          	u8  Auth = 0;
   1079          	u8 returnvalue;
   1080          
   1081          	if(AuthResult != 1)
   1082          	{
   1083          		if((smk_flag_data.recv_resp_packet != RESPONSE_SUCCESS) && (smk_flag_data.recv_resp_packet != RESPONSE_TIME_OUT))
   1084          		{
   1085          			if(smk_flag_data.recv_resp_packet == REQUEST_FIRST_AUTHENTICATION)
   1086          			{
   1087          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
   1088          				RequestFirstAuthentication();
   1089          			}
   1090          			else if(smk_flag_data.recv_resp_packet == REQUEST_SECOND_AUTHENTICATION)
   1091          			{
   1092          				smk_flag_data.recv_resp_packet |= RESPONSE_WAIT;
   1093          				RequestSecondAuthentication();
   1094          			}
   1095          			else if(smk_flag_data.recv_resp_packet & RESPONSE_AUTHENTICATION)
   1096          			{
   1097          
   1098          				//smk_flag_data.recv_resp_packet &= (~(RESPONSE_AUTHENTICATION));
   1099          				smk_flag_data.recv_resp_packet = (smk_flag_data.recv_resp_packet & (~(RESPONSE_AUTHENTICATION)));
   1100          
   1101          				if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1102          					Auth = SMK_RESPOSEN_CODE_COMM_AUTHENTICATION;
   1103          				else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1104          					Auth = SMK_RESPONSE_CODE_AUTHENTICATION;
   1105          					
   1106          				returnvalue = CheckResponseAuthentication(Auth);
   1107          					
   1108          				if(returnvalue == SMK_RESPONSE_FLAG_SUCCESS)	// Success
   1109          				{
   1110          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1111          					{
   1112          						gAuthentication_Cnt = 0;
   1113          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1114                                                          // ++, 150713 bwk
   1115          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;		// ++, --, 150709 bwk
   1116          						SendSMKCountResult();
   1117                                                          // --, 150713 bwk
   1118          					}
   1119          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1120          					{
   1121          						gAuthentication_Cnt = 0;
   1122          						AuthResult = 1;
   1123          						SMK_Tag_Count = recv_smartkey.Registered_Tag_Count;
   1124          						smk_flag_data.recv_resp_packet = RESPONSE_SUCCESS;
   1125          						SMKSuccess = SMK_SUCCESS;
   1126          						SendSMKAuthResult(SMK_SUCCESS);
   1127          
   1128          						// ++ , 141118 sys3215
   1129          						Flag_ESL=1;
   1130          						// -- , 141118 sys3215
   1131          						
   1132          					}
   1133          				}
   1134          				else
   1135          				{
   1136          					if(++gAuthentication_Cnt >= TIME_OUT_COUNT)
   1137          					{
   1138          						//AuthResult = 2;
   1139          						AuthResult = 1;
   1140          						smk_flag_data.recv_resp_packet = RESPONSE_TIME_OUT;
   1141          						SMKSuccess = SMK_FAIL;
   1142          						SendSMKAuthResult(SMK_FAIL);
   1143          						return;
   1144          					}
   1145          
   1146          					if(smk_flag_data.recv_resp_packet & REQUEST_FIRST_AUTHENTICATION)
   1147          						smk_flag_data.recv_resp_packet = REQUEST_FIRST_AUTHENTICATION;
   1148          					else if(smk_flag_data.recv_resp_packet & REQUEST_SECOND_AUTHENTICATION)
   1149          						smk_flag_data.recv_resp_packet = REQUEST_SECOND_AUTHENTICATION;
   1150          				}
   1151          			}
   1152          			else if(smk_flag_data.recv_resp_packet == (REQUEST_FIRST_AUTHENTICATION | RESPONSE_WAIT))
   1153          			{
   1154          				//RequestFirstAuthentication();
   1155          			}
   1156          			else if(smk_flag_data.recv_resp_packet == (REQUEST_SECOND_AUTHENTICATION | RESPONSE_WAIT))
   1157          			{
   1158          				//RequestSecondAuthentication();
   1159          			}
   1160          		}
   1161          	}
   1162          	//else if(AuthResult == 1)
   1163          	{
   1164          	
   1165          		if((Uart2_RxMsg_Smk_Reg_Eli[2] == 1) || (Uart2_RxMsg_Smk_Reg_Eli[2] == 2)) 
   1166          		{
   1167          			RequestSMKMessage(Uart2_RxMsg_Smk_Reg_Eli[2]);
   1168          			SMK_Msg_Send = 1;
   1169          			smk_flag_data.recv_resp_packet = 0;
   1170          		//	Uart2_RxMsg_Smk_Reg_Eli[7] = Uart2_RxMsg_Smk_Reg_Eli[0];
   1171          			Uart2_RxMsg_Smk_Reg_Eli[2] = 0xff;
   1172          		}
   1173          		
   1174          		if(SMK_Msg_Send == 1)
   1175          		{
   1176          			if(smk_flag_data.recv_resp_packet == RESPONSE_AUTHENTICATION)
   1177          			{
   1178          				SMK_Msg_Send = 0;
   1179          				CheckResponseMsgComm();
   1180          			}
   1181          		}
   1182          	}
   1183          }
   1184          #endif
   1185          
   1186          // ++, 141118 sys3215
   1187          void ESL_System(void)
   1188          {
   1189          	if(Seed_request==0)
   1190          	{
   1191          		Seed_request=0xff;
   1192          		Seed_Request_CAN_TX();
   1193          	}
   1194          	if(Seed_received==1)
   1195          	{
   1196          		Seed_received=0xff;
   1197          		SendMultiPacketRTS_ESL();
   1198          	}
   1199          	if(ESL_CTS_received==1)
   1200          	{
   1201          		ESL_CTS_received=0xff;
   1202          		SendMultiPacketData_ESL();
   1203                          Flag_ESL = 0;
   1204          	}
   1205          	if(ESL_ACK_received==1)
   1206          	{
   1207          		Init_Smart_Key_valuable();
   1208          	}
   1209          }
   1210          
   1211          // --, 141118 sys3215
   1212          
   1213          
   1214          
   1215          /**
   1216            * @brief  1msec OperationFunc
   1217            * @param  None
   1218            * @retval None
   1219            */
   1220          void WL9FM_1mSecOperationFunc(void)
   1221          {
   1222          #if 1
   1223          	if( Flag_UartTxStart == 1 )
   1224          	{
   1225          		if (SendTime_E2PROM++ > 3) //	25msec
   1226          		{
   1227          			SendTime_E2PROM = 0;
   1228          			SendTo_E2PROM();
   1229          			KeySwitch_SendToEXYNOS(KEYSWITCH_NONE,0);
   1230          		}			
   1231          	}
   1232          	// CAN_TX Routine
   1233          	CAN_TX();
   1234          	Write_UART_Single();
   1235          #endif
   1236          }
   1237          
   1238          /**
   1239            * @brief  10msec OperationFunc
   1240            * @param  None
   1241            * @retval None
   1242            */
   1243          
   1244          u8 flag_reset=0;
   1245          
   1246          void WL9FM_10mSecOperationFunc(void)
   1247          {
   1248          	//Lamp_Update_State();	//	LAMP Update 상태를 체크한다.
   1249          	
   1250          }
   1251          
   1252          /**
   1253            * @brief  100msec OperationFunc
   1254            * @param  None
   1255            * @retval None
   1256            */
   1257          u8 count = 0;
   1258          void WL9FM_100mSecOperationFunc(void)
   1259          {
   1260          	
   1261          	
   1262          	Lamp_Update_System();	//	체크된 LAMP 상태를 업데이트 한다.
   1263          
   1264          #if 1
   1265          	if(SmartKeyUse == 1)
   1266          		SmartKeyAuthentication();
   1267          #endif
   1268          
   1269          // ++ , 141118 sys3215
   1270          	if(Flag_ESL==1)
   1271          	{
   1272          		ESL_System();
   1273          	}
   1274          // -- , 141118 sys3215
   1275          	
   1276          	if(LCDOffCount < 30)
   1277          	{
   1278          		LCDOffCount++;
   1279          		LCDBL_ONOFF(LCDBL_OFF);
   1280          	}
   1281          	else if(LCDOffCount == 30)
   1282          	{
   1283          		LCDOffCount++;
   1284          		LCDBL_ONOFF(LCDBL_ON);
   1285          	}
   1286          	else
   1287          	{
   1288          		LCDBL_ONOFF(LCDBL_ON);
   1289          	}
   1290          	
   1291          	if(CommErrCnt > 1000)
   1292             	{
   1293             		if( Flag_TxE2pRomData == 1 )
   1294          	   	{
   1295          	   		CAN_COMInit();
   1296             			CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1297          
   1298          			Buz1 = 0;
   1299                      //RTCSend();
   1300          			if(++SendRTCnt >= 10)
   1301          			{
   1302          				SendRTCnt = 0;
   1303          				
   1304          			}
   1305          	   	}
   1306          	}	
   1307          	if(OSUpdateCount < 200)
   1308          	{
   1309          		OSUpdateCount++;
   1310          	}
   1311          	else if(OSUpdateCount == 200)
   1312          	{
   1313          		OSUpdateCount++;
   1314          		System_CheckPowerIG();
   1315          	}
   1316          	else
   1317          	{
   1318          		System_CheckPowerIG();
   1319          	}
   1320          	
   1321          
   1322          	if(ST_Update)
   1323          	{
   1324          		if(UpdateMode < 10)
   1325          			UpdateMode++;
   1326          
   1327          		if(UpdateMode >= 10)
   1328          		{
   1329          			STM32_Update(Stm32_Update_CMD,FatoryInit_Flag); 
   1330          			ST_Update=0;
   1331          		}
   1332          	}
   1333          		
   1334          	//	WL9A Monitor RESET Code
   1335          	if((SystemReset == 1) || (gRebootCmd == 1))
   1336          	{
   1337          		if(gRebootCmd == 1)
   1338          			//SaveDataToEEPROM();
   1339          				
   1340          		//	여기서 WL99F_100mSecOperationFunc() 함수를 빠져나간다.
   1341          		//	WL9F_100mSecOperationFunc() 함수가 종료되는 시점에 SYSTEM RESET을 시킨다.
   1342          		//	WL9F_Monitor_APP() 함수로 이동!!!
   1343          		return;
   1344          	}
   1345          
   1346          	if(CameraCommFlag == 1)
   1347          	{
   1348                          // ++, 150715 bwk
   1349          #if 0
   1350          		cam_mode_change(Camera_Mode);
   1351          		CameraCommFlag = 0;
   1352          #else
   1353          		CameraCommFlag = 0;
   1354          		cam_mode_change(Camera_Mode);
   1355                          cam_mode_check();
   1356          #endif
   1357                          // --, 150715 bwk
   1358          
   1359          	}
   1360                  
   1361                  if(AAVMCommFlag == 1)
   1362                  {
   1363                          AAVMCommFlag = 0;
   1364                          aavm_mode_change(AAVM_Mode);
   1365                          aavm_mode_check();
   1366                  }
   1367          
   1368          
   1369          	// ++, 150204 sys3215
   1370          	CAN_TX_Key_Status();
   1371          	// --, 150204 sys3215
   1372          }
   1373          
   1374          void WL9FM_500mSecOperationFunc(void)
   1375          {
   1376          	if(CANUpdateFlag != 1)
   1377          		MonitorStatus_CAN_TX();
   1378          
   1379          }
   1380          
   1381          
   1382          
   1383          /**
   1384            * @brief  1sec OperationFunc
   1385            * @param  None
   1386            * @retval None
   1387            */
   1388          void WL9FM_1SecOperationFunc(void)
   1389          {
   1390          	if(UpdateMode < 10)
   1391          		read_clock();
   1392          
   1393          
   1394          	//  ++, kutelf, 131007
   1395          	//	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
   1396          	//	상태를 체크하여, Video가 없으면 No Video 띄워준다.
   1397          	if (Camera_CheckFlag == 1 && Camera_Mode != 0xFF)
   1398          	{
   1399          		if (++Camera_CheckCnt == 6) Camera_CheckCnt = 0;
   1400          			
   1401          		if ((Camera_CheckCnt % 3) == 0)
   1402          		{
   1403          			cam_mode_check();
   1404          		}
   1405          	}
   1406          	else
   1407          	{
   1408          		Camera_CheckCnt = 0;
   1409          	}
   1410          	//  --, kutelf, 131007
   1411          	if (AAVM_CheckFlag == 1 && AAVM_Mode != 0xFF)
   1412          	{
   1413          		if (++AAVM_CheckCnt == 6) AAVM_CheckCnt = 0;
   1414          			
   1415          		if ((AAVM_CheckCnt % 3) == 0)
   1416          		{
   1417          			aavm_mode_check();
   1418          		}
   1419          	}
   1420          	else
   1421          	{
   1422          		AAVM_CheckCnt = 0;
   1423          	}
   1424          }
   1425          //	++, kutelf, 140801
   1426          //	RevD.01.01
   1427          //	RevD 보드와 호환성을 위하여 함수 추가 및 이름 변경
   1428          void CameraMode(u8 Mode, u8 OSD)
   1429          {
   1430          // ++, sys3215, 141211
   1431          #if 0
   1432          	#ifdef BoardVersion_RevD
   1433          		TW8816_CameraMode(Mode, OSD);
   1434          	#else
   1435          		TW2835_CameraMode(Mode, OSD);
   1436          	#endif
   1437          #endif
   1438          
   1439          	if(Hardware_Revision==REVB)
   1440          	{
   1441          		TW2835_CameraMode(Mode, OSD);
   1442          	}
   1443          	else
   1444          	{
   1445          		TW8816_CameraMode(Mode, OSD);
   1446          	}
   1447          // --, sys3215, 141211
   1448          }
   1449          
   1450          void CheckCamera_Input(u8 Mode)
   1451          {
   1452          // ++, sys3215, 141211
   1453          #if 0
   1454          	#ifdef BoardVersion_RevD
   1455          		TW8816_CheckCamera_Input(Mode);
   1456          	#else
   1457          		TW2835_CheckCamera_Input(Mode);
   1458          	#endif
   1459          #endif
   1460          
   1461          	if(Hardware_Revision==REVB)
   1462          	{
   1463          		TW2835_CheckCamera_Input(Mode);
   1464          	}
   1465          	else
   1466          	{
   1467          		TW8816_CheckCamera_Input(Mode);
   1468          	}
   1469          // --, sys3215, 14121
   1470          }
   1471          
   1472          void AAVMMode(u8 Mode, u8 OSD)
   1473          {
   1474          // ++, sys3215, 141211
   1475          #if 0
   1476          	#ifdef BoardVersion_RevD
   1477          		TW8816_AAVMMode(Mode, OSD);
   1478          	#else
   1479          		TW2835_CameraMode(Mode, OSD);
   1480          	#endif
   1481          #endif
   1482          
   1483          	if(Hardware_Revision==REVB)
   1484          	{
   1485          		TW2835_CameraMode(Mode, OSD);
   1486          	}
   1487          	else
   1488          	{
   1489          		TW8816_AAVMMode(Mode, OSD);
   1490          	}
   1491          // --, sys3215, 141211
   1492          }
   1493          
   1494          void CheckAAVM_Input(u8 Mode)
   1495          {
   1496          // ++, sys3215, 141211
   1497          #if 0
   1498          	#ifdef BoardVersion_RevD
   1499          		TW8816_CheckAAVM_Input(Mode);
   1500          	#else
   1501          		TW2835_CheckCamera_Input(Mode);
   1502          	#endif
   1503          #endif
   1504          
   1505          	if(Hardware_Revision==REVB)
   1506          	{
   1507          		TW2835_CheckCamera_Input(Mode);
   1508          	}
   1509          	else
   1510          	{
   1511          		TW8816_CheckAAVM_Input(Mode);
   1512          	}
   1513          // --, sys3215, 14121
   1514          }
   1515          //	--, kutelf, 140801
   1516          
   1517          
   1518          void WL9FM_System_Init_Start(void)
   1519          {
   1520          	//	만약에 Software RESET 일 경우, 이미 PowerIG_ON을 한 상태이므로 PowerIG_OFF를 수행하지 않는다. 
   1521          	if (SystemReset != 1)
   1522          	{
   1523          		WL9FM_PowerIG(PowerIG_OFF);				//  ->	GPIO_Control.c PowerIG를 OFF로 만들어 놓고
   1524          												//		System_CheckPowerIG() 함수에서 PowerIG 상태에 따라서 설정
   1525          	}				
   1526          
   1527          //	++, kutelf, 140801
   1528          //	RevD.01.01
   1529          //	Power, PMIC On/Off 방법 변경 
   1530          #if 0
   1531          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1532          	WL9FM_EXYNOS_PMIC_nRESET();
   1533          	WL9FM_EXYNOS_PMIC_PWRONOFF(EXYNOS_PMIC_OFF);
   1534          
   1535          #else
   1536          	WL9FM_EXYNOS_POWER_ONOFF(EXYNOS_POWER_ON);	//	->	GPIO_Control.c EXYNOS-4412 Power On..
   1537          	WL9FM_EXYNOS_PMIC_PWRON();
   1538          #endif
   1539          //	--, kutelf, 140801
   1540          
   1541          	//++,  sys3215 ,141211
   1542          	Hardware_Version_Init();					//  ->  Hardware_Version.c (Hardware Version ADC Start)
   1543          	Camera_IO_Init();
   1544          
   1545          	WL9FM_CAMERA_nRESET();	
   1546          	WL9F_CAMERA_Init();
   1547          #if 0	
   1548          //	++, kutelf, 140801
   1549          //	RevD.01.01 
   1550          //	Camera Input, LCD Controller 변경
   1551          //		=> TW2835 + TW8832 -> TW8816
   1552          //	DPRAM 삭제 - FSMC 사용 안함.
   1553          #ifdef BoardVersion_RevD
   1554          	WL9FM_CAMERA_nRESET();						//	-> 	TW8816 Power On..
   1555          	TW8816_Control_Init();
   1556          #else
   1557          	WL9FM_CAMERA_nRESET();						//	-> 	TW2835, TW8832 Power On..
   1558          	TW8832_Control_Init();						//	-> 	TW8832_Control.c (LCD Interface)
   1559          	TW2835_Control_Init();	
   1560          	//DPRAM_Init();								//	-> 	DPRAM_Control.c (Dual Port RAM Init)
   1561          #endif
   1562          //	--, kutelf, 140801	
   1563          #endif 
   1564          	//--, sys3215, 141211
   1565          	
   1566          	Buzzer_Init();              				//  ->  Buzzer.c (Buzzer Timer Start)
   1567          	// ++, 160511 bwk
   1568          	#if 0
   1569          	FM3164_Watchdog_Init(0x00);
   1570          	#else
   1571          	if(Hardware_Revision < REVH)			// ++, --, 160511 bwk
   1572          		FM3164_Watchdog_Init(0x00);					//  ->  FM31X4.c (Integrated Processor Companion ON)
   1573          	else
   1574          		EXT_WATCHDOG_ENALBE(0);
   1575          	#endif
   1576          	// --, 160511 bwk
   1577          	KeySwitch_Init();           				//  ->  KeySwitch.c
   1578          	LAMP_Control_Init();						//	-> 	LAMP_Control.c
   1579          												//		LAMP ALL ON
   1580          	LED_POWER_ONOFF(LED_OFF);					//	->	LCD_Control.c (LED On/Off)
   1581          	LCD_POWER_ONOFF(LCDPWR_ON);					//	-> 	LCD_Control.c (LCD 12V Power On/Off)
   1582          
   1583          	LCDBL_ONOFF(LCDBL_OFF); 					//	->	 부팅시 LCD에 하얀 화면 나옴
   1584          
   1585          	LCD_Control_Init();							//	-> 	LCD_Control.c (LCDBL, ON/OFF)
   1586          
   1587          	//USART_COMInit(COMPORT2);       				//      COM2 : CAN
   1588          	USART_COMInit_DMA(COMPORT2,Uart2_SerialTxMsg);   //      COM2 : CAN
   1589          	USART_COMInit(COMPORT4);       					//      COM4 : CMDData
   1590          
   1591          												
   1592          	CAN_COMInit();								//	-> 	CAN_Control.c
   1593          	//InitE2PROM();
   1594          	//ReadE2PROM_ToSend();						//	->	EEPROM Data Read
   1595          	// ++, 160511 bwk
   1596          	#if 0
   1597          	SmartKeyUse = LoadSMKUseToEEPROM();
   1598          	#else
   1599          	if(Hardware_Revision >= REVH)
   1600          		SmartKeyUse = LoadSMKUseToFlash();
   1601          	else
   1602          		SmartKeyUse = LoadSMKUseToEEPROM();
   1603          	#endif
   1604          	// --, 160511 bwk
   1605          	M25P32_Init();
   1606          
   1607          	LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1608          	//Old_LAMP_Update_Data = LAMP_ALL_OFF;			//	-> 	LAMP ALL OFF	
   1609          
   1610          	CAN_ITConfig(CAN1, CAN_IT_FMP0,ENABLE);	
   1611          
   1612          	SetFontOSDWindow();
   1613          }
   1614          
   1615          /**
   1616            * @brief  Application Program Start Point.
   1617            * @param  None
   1618            * @retval None
   1619            */
   1620          void WL9FM_Monitor_APP(void)
   1621          {
   1622          	DebugUART_Init();			//	->	Main.c
   1623          	DebugMsg_printf("== START -> DebugMsg from Exynos-4412 \r\n");    
   1624          
   1625          //	++, kutelf, 140925
   1626          //	KeyIG Off에서 무한 RESET 되는 현상 수정 => SYSTEM_RESET 위치 변경
   1627          //	System 강제 RESET시키기 위하여 goto lable 추가..
   1628          SYSTEM_RESET :
   1629          //	--, kutelf, 140925
   1630          	System_Configuration();		//  ->  System_Init.c
   1631          	                    		//      RCC, NVIC, GPIO Initialize
   1632          
   1633          	System_Initialize();		//	-> 	System_Init.c
   1634          
   1635          								//		IAP와 동일한 초기화를 한다. -> 상태 변경 없음.
   1636          	System_Variable_Init();
   1637          	WL9FM_System_Init_Start();
   1638          
   1639          	//RCC_ClearFlag();
   1640          	
   1641          	/* Infinite loop */
   1642          	while (1)
   1643          	{  
   1644          		if (WL9FM_TIME.Flag_1mSec == 1)     //  1msec
   1645          		{
   1646          			WL9FM_TIME.Flag_1mSec = 0;
   1647          
   1648          			//  WL9F_1mSecOperationState -> Func 실행..
   1649          			//  if (WL9F_1mSecOperationState != 0) WL9F_1mSecOperationFunc[WL9F_1mSecOperationState]();    
   1650          			WL9FM_1mSecOperationFunc();
   1651          		}            
   1652          		
   1653          		if (WL9FM_TIME.Flag_10mSec == 1)    //  10msec
   1654          		{
   1655          			WL9FM_TIME.Flag_10mSec = 0;
   1656          
   1657          			//  WL9F_10mSecOperationState -> Func 실행..
   1658          			//  if (WL9F_10mSecOperationState != 0) WL9F_10mSecOperationFunc[WL9F_10mSecOperationState]();    
   1659          			WL9FM_10mSecOperationFunc();
   1660          		}
   1661          		
   1662          		if (WL9FM_TIME.Flag_100mSec == 1)   //  100 msec
   1663          		{
   1664          			WL9FM_TIME.Flag_100mSec = 0;
   1665          
   1666          			//  WL9F_100mSecOperationState -> Func 실행..
   1667          			//  if (WL9F_100mSecOperationState != 0) WL9F_100mSecOperationFunc[WL9F_100mSecOperationState]();    
   1668          			WL9FM_100mSecOperationFunc();
   1669          
   1670          			#if 1
   1671          			//	WL9F Monitor RESET Code
   1672          			if((SystemReset == 1) || (gRebootCmd == 1))
   1673          			{
   1674          				//	++, kutelf, 150810
   1675          				#if 1
   1676          				if (gRebootCmd)	
   1677          				{	
   1678          					Software_Reset_BootLoader();
   1679          				}	
   1680          				else
   1681          				{
   1682          					goto SYSTEM_RESET;
   1683          				}	
   1684          
   1685          				#else
   1686          				if(gRebootCmd)	JumpIAP();
   1687          				else
   1688          					goto SYSTEM_RESET;
   1689          				#endif
   1690          				//	--, kutelf, 150810
   1691          			}
   1692          			#endif
   1693          		}
   1694          
   1695          		if(WL9FM_TIME.Flag_500mSec == 1)
   1696          		{
   1697          			WL9FM_TIME.Flag_500mSec = 0;
   1698          			WL9FM_500mSecOperationFunc();
   1699          		}
   1700          		
   1701          		if (WL9FM_TIME.Flag_1Sec == 1)      //  1000 msec
   1702          		{
   1703          			WL9FM_TIME.Flag_1Sec = 0;
   1704          
   1705          			//  WL9F_1SecOperationState -> Func 실행..
   1706          			//  if (WL9F_1SecOperationState != 0) WL9F_1SecOperationFunc[WL9F_1SecOperationState]();    
   1707          			WL9FM_1SecOperationFunc();
   1708                                  
   1709          		}
   1710          	}
   1711          }
   1712          
   1713          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
   1714          
   1715          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AAVMMode
         0   -> TW2835_CameraMode
         0   -> TW8816_AAVMMode
       0   CameraMode
         0   -> TW2835_CameraMode
         0   -> TW8816_CameraMode
       0   CheckAAVM_Input
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckAAVM_Input
       0   CheckCamera_Input
         0   -> TW2835_CheckCamera_Input
         0   -> TW8816_CheckCamera_Input
      24   CheckResponseAuthentication
        24   -> decode
        24   -> setCipherParam
      16   CheckResponseMsgComm
        16   -> SendSMKMsgResult
        16   -> decode
        16   -> setCipherParam
       0   CheckResponseVMC
       8   ESL_System
         8   -> Init_Smart_Key_valuable
         8   -> Seed_Request_CAN_TX
         8   -> SendMultiPacketData_ESL
         8   -> SendMultiPacketRTS_ESL
       8   GetRandValue
         8   -> rand
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   Init_Smart_Key_valuable
       8   JumpIAP
         8   -> IWDG_Enable
         8   -> IWDG_ReloadCounter
         8   -> IWDG_SetPrescaler
         8   -> IWDG_SetReload
         8   -> IWDG_WriteAccessCmd
       0   LoadSMKUseToEEPROM
         0   -> EEPROM_Read
       8   LoadSMKUseToFlash
         8   -> SPI_FLASH_BufferRead
       0   LoadTestToEEPROM
         0   -> EEPROM_Read
      24   ReadE2PROM_ToSend
        24   -> EEPROM_Read
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
      24   RequestFirstAuthentication
        24   -> GetRandValue
        24   -> SetTagCmd
        24   -> SetTagLevel
        24   -> TimeDelay_msec
        24   -> Write_CAN_Single
        24   -> encode
        24   -> setCipherParam
      16   RequestSMKComm
        16   -> GetRandValue
        16   -> SetTagCmd
        16   -> SetTagLevel
        16   -> Write_CAN_Single
      32   RequestSMKElimination
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
       0   RequestSMKMessage
         0   -> RequestSMKElimination
         0   -> RequestSMKRegistration
      32   RequestSMKRegistration
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      32   RequestSecondAuthentication
        32   -> GetRandValue
        32   -> SetTagCmd
        32   -> SetTagLevel
        32   -> TimeDelay_msec
        32   -> Write_CAN_Single
        32   -> encode
        32   -> setCipherParam
      16   SaveDataToEEPROM
        16   -> EEPROM_Write
         0   -> TimeDelay_msec
        16   -> TimeDelay_msec
        16   -> __aeabi_memcpy
       0   SaveSMKUseToEEPROM
         0   -> EEPROM_Write
       8   SaveSMKUseToFlash
         8   -> SPI_FLASH_PageWrite
         8   -> SPI_FLASH_SectorErase
       0   SaveTestToEEPROM
         0   -> EEPROM_Write
       8   SendSMKAuthResult
         8   -> SMK_SendToExynos
       8   SendSMKCountResult
         8   -> SMK_SendToExynos
       8   SendSMKMsgResult
         8   -> SMK_SendToExynos
       0   SetCPK
       0   SetTagCmd
       0   SetTagLevel
       0   SetVMC
      16   SmartKeyAuthentication
        16   -> CheckResponseAuthentication
         0   -> CheckResponseMsgComm
        16   -> RequestFirstAuthentication
        16   -> RequestSMKElimination
        16   -> RequestSMKRegistration
        16   -> RequestSecondAuthentication
        16   -> SMK_SendToExynos
       0   Software_Reset_Application
         0   -- Indirect call
       0   Software_Reset_BootLoader
         0   -- Indirect call
       8   Srand
         8   -> READ_RTC
         0   -> srand
      24   System_CheckPowerIG
        24   -- Indirect call
        24   -> Buzzer_Off
        24   -> Buzzer_UnLimitOff
        24   -> CAN_ITConfig
        24   -> KeySwitch_SendToEXYNOS
        24   -> LCDBL_ONOFF
        24   -> LCDBL_PWM_LEVEL
        24   -> LCD_POWER_ONOFF
        24   -> Lamp_Update_System
        24   -> TimeDelay_msec
        24   -> USART_ITConfig
        24   -> WL9FM_EXYNOS_PMIC_PWROFF
        24   -> WL9FM_EXYNOS_POWER_ONOFF
        24   -> WL9FM_GetPowerIG
         0   -> WL9FM_PowerIG
        24   -> WL9FM_PowerIG
       8   WL9FM_100mSecOperationFunc
         8   -> CAN_COMInit
         8   -> CAN_ITConfig
         0   -> CAN_TX_Key_Status
         8   -> ESL_System
         8   -> LCDBL_ONOFF
         8   -> Lamp_Update_System
         8   -> STM32_Update
         8   -> SmartKeyAuthentication
         8   -> System_CheckPowerIG
         8   -> aavm_mode_change
         8   -> aavm_mode_check
         8   -> cam_mode_change
         8   -> cam_mode_check
       0   WL9FM_10mSecOperationFunc
       8   WL9FM_1SecOperationFunc
         0   -> aavm_mode_check
         8   -> cam_mode_check
         8   -> read_clock
       8   WL9FM_1mSecOperationFunc
         8   -> CAN_TX
         8   -> KeySwitch_SendToEXYNOS
         8   -> SendTo_E2PROM
         0   -> Write_UART_Single
       0   WL9FM_500mSecOperationFunc
         0   -> MonitorStatus_CAN_TX
      16   WL9FM_Monitor_APP
        16   -- Indirect call
        16   -> CAN_TX
        16   -> DebugUART_Init
        16   -> KeySwitch_SendToEXYNOS
        16   -> MonitorStatus_CAN_TX
        16   -> SendTo_E2PROM
        16   -> System_Configuration
        16   -> System_Initialize
        16   -> System_Variable_Init
        16   -> WL9FM_100mSecOperationFunc
        16   -> WL9FM_1SecOperationFunc
        16   -> WL9FM_System_Init_Start
        16   -> Write_UART_Single
      16   WL9FM_System_Init_Start
        16   -> Buzzer_Init
        16   -> CAN_COMInit
        16   -> CAN_ITConfig
        16   -> Camera_IO_Init
        16   -> EEPROM_Read
        16   -> FM3164_Watchdog_Init
        16   -> GPIO_WriteBit
        16   -> Hardware_Version_Init
        16   -> KeySwitch_Init
        16   -> LAMP_Control_Init
        16   -> LCDBL_ONOFF
        16   -> LCD_Control_Init
        16   -> LCD_POWER_ONOFF
        16   -> LED_POWER_ONOFF
        16   -> M25P32_Init
        16   -> SPI_FLASH_BufferRead
        16   -> SetFontOSDWindow
        16   -> USART_COMInit
        16   -> USART_COMInit_DMA
        16   -> WL9FM_CAMERA_nRESET
        16   -> WL9FM_EXYNOS_PMIC_PWRON
        16   -> WL9FM_EXYNOS_POWER_ONOFF
        16   -> WL9FM_PowerIG
        16   -> WL9F_CAMERA_Init
      24   read_clock
        24   -> READ_RTC
        24   -> USARTx_EXYNOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable28
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable33
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_10
       4  ??DataTable34_11
       4  ??DataTable34_12
       4  ??DataTable34_13
       4  ??DataTable34_14
       4  ??DataTable34_15
       4  ??DataTable34_16
       4  ??DataTable34_17
       4  ??DataTable34_18
       4  ??DataTable34_19
       4  ??DataTable34_2
       4  ??DataTable34_20
       4  ??DataTable34_21
       4  ??DataTable34_22
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable34_8
       4  ??DataTable34_9
      34  ??Subroutine3_0
      10  ?Subroutine0
       6  ?Subroutine1
      40  ?Subroutine2
      16  AAVMMode
       8  ACK_Multi_61184
       1  CTSFlag_61184
      16  CameraMode
      16  CheckAAVM_Input
      16  CheckCamera_Input
      88  CheckResponseAuthentication
     168  CheckResponseMsgComm
      20  CheckResponseVMC
      66  ESL_System
       2  Flag_1Min
       2  Flag_1Sec_MachInfo
       1  Flag_200mSec
      92  GetRandValue
     458  InitE2PROM
      50  Init_RTC
      34  Init_Smart_Key_valuable
      32  JumpIAP
       4  KeySwitch_Value
       6  LoadSMKUseToEEPROM
      18  LoadSMKUseToFlash
       6  LoadTestToEEPROM
       1  MachInfoSendCnt
       1  MachInfoTotalPacketNum
      13  McuInfoData2
          McuInfoData3
          McuInfoData4
          DiffMachInfo
       1  MoniInfoSendCnt
       1  MoniInfoTotalPacketNum
       1  MultiPacketSendOrder
       4  Old_LAMP_Update_Data
       8  RMCU_ACK_Multi_61184
       1  RMCU_CTSFlag_61184
       1  RMCU_RecvTotalPacket_61184
       1  RTSFlag_61184
     326  ReadE2PROM_ToSend
       1  RecvTotalPacket_61184
     136  RequestFirstAuthentication
      84  RequestSMKComm
      40  RequestSMKElimination
      18  RequestSMKMessage
      42  RequestSMKRegistration
      88  RequestSecondAuthentication
     632  SaveDataToEEPROM
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
       8  SaveSMKUseToEEPROM
      24  SaveSMKUseToFlash
       8  SaveTestToEEPROM
      18  SendSMKAuthResult
      18  SendSMKCountResult
      28  SendSMKMsgResult
      16  SerialMsgRTC
      20  SetCPK
      28  SetTagCmd
      36  SetTagLevel
      20  SetVMC
     306  SmartKeyAuthentication
      16  Software_Reset_Application
      14  Software_Reset_BootLoader
      22  Srand
     304  System_CheckPowerIG
       1  TotalPacketNum
     224  WL9FM_100mSecOperationFunc
       2  WL9FM_10mSecOperationFunc
     138  WL9FM_1SecOperationFunc
      50  WL9FM_1mSecOperationFunc
      14  WL9FM_500mSecOperationFunc
       8  WL9FM_BUZZER
       4  WL9FM_LCDBL
     172  WL9FM_Monitor_APP
       8  WL9FM_RTC
     174  WL9FM_System_Init_Start
     532  WL9FM_USART_DATA
    1032  WL9FM_USART_FILE_DATA
       8  WL9FM_USART_INDEX
    1032  WL9FM_USART_RX_FILE_DATA
       1  count
      58  eepRomReadData1
          MoniInfoData
          adc_value
       1  flag_reset
      72  gAuthentication_Cnt
          Flag_ESL
          Seed_request
          Seed_received
          ESL_CTS_received
          ESL_ACK_received
          Password_Certification_Result
          AuthResult
          SMKSuccess
          SMK_Msg_Send
          SMK_Tag_Count
          Flag_UartTxStart
          SendTime_E2PROM
          SendRTCnt
          SystemReset
          E2PROM_Save
          PwrOffCnt
          gRebootCmd
          ST_Update
          UpdateMode
          LCDOffCount
          SmartKeyUse
          CameraCommFlag
          AAVMCommFlag
          WL9FM_TIME
          OSUpdateCount
          LAMP_Update_Data
          smk_flag_data
          Jump_To_Application_Cluster_App
          JumpAddress_Cluster_App
          Jump_To_Application_Cluster_Iap
          JumpAddress_Cluster_Iap
      82  read_clock
      24  recv_smartkey
          send_smartkey
          rand_value
       1  send_bkcu_data
       1  send_mcu_data

 
 2 867 bytes in section .bss
 4 424 bytes in section .text
 
 4 424 bytes of CODE memory
 2 867 bytes of DATA memory

Errors: none
Warnings: 5
