###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      30/Aug/2016  09:55:24 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Tools\WL9F\WLF Monitor -                              #
#                    STM32_APP\TEST_AAVM\Platform\TaeHa -                     #
#                    ECS\SRC\LCD_Control.c                                    #
#    Command line =  "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\TEST_AAVM\Platform\TaeHa -                     #
#                    ECS\SRC\LCD_Control.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\TEST_AAVM\Project\Debug\List\" -o              #
#                    "C:\Tools\WL9F\WLF Monitor -                             #
#                    STM32_APP\TEST_AAVM\Project\Debug\Obj\" --debug          #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp        #
#                    --dlib_config "C:\Tools\IAR Systems\Embedded Workbench   #
#                    6.5\arm\INC\c\DLib_Config_Full.h" -I "C:\Tools\WL9F\WLF  #
#                    Monitor - STM32_APP\TEST_AAVM\Project\..\Platform\COMMON #
#                    \INC\" -I "C:\Tools\WL9F\WLF Monitor -                   #
#                    STM32_APP\TEST_AAVM\Project\..\Platform\TaeHa -          #
#                    ECS\INC\" -I "C:\Tools\WL9F\WLF Monitor -                #
#                    STM32_APP\TEST_AAVM\Project\..\Libraries\CMSIS\Device\ST #
#                    \STM32F4xx\Include\" -I "C:\Tools\WL9F\WLF Monitor -     #
#                    STM32_APP\TEST_AAVM\Project\..\Libraries\STM32F4xx_StdPe #
#                    riph_Driver\inc\" -Oh --use_c++_inline -I "C:\Tools\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  C:\Tools\WL9F\WLF Monitor -                              #
#                    STM32_APP\TEST_AAVM\Project\Debug\List\LCD_Control.lst   #
#    Object file  =  C:\Tools\WL9F\WLF Monitor -                              #
#                    STM32_APP\TEST_AAVM\Project\Debug\Obj\LCD_Control.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Tools\WL9F\WLF Monitor - STM32_APP\TEST_AAVM\Platform\TaeHa - ECS\SRC\LCD_Control.c
      1          /**
      2            ******************************************************************************
      3            * @file    LCD_Control.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   LCD_Control.c module
      8            *
      9            * Project Name       : WL9F Monitor APP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Monitor_APP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Monitor_APP.h"	
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          
     29          /*
     30          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
     31          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
     32          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
     33          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
     34          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
     35          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
     36          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
     37          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
     38          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
     39          */
     40          //	이 값을 설정할 때, 회로적으로 Inverting 된다.
     41          //	100% -> 0%로 동작한다.
     42          const uint16_t LCDBL_PWMLEVEL[MaxBackLightLEVEL] =  
     43          {	
     44          	16638, 	//  0 Step :   0%
     45              14142, 	//  1 Step :  20%
     46              11646, 	//  2 Step :  30%
     47              9982, 	//  3 Step :  40%
     48              8319, 	//  4 Step :  50%
     49              6655, 	//  5 Step :  60%
     50              4991, 	//  6 Step :  70%
     51              3327, 	//  7 Step :  85%
     52          	0, 		//  8 Step : 100%
     53          }; 
     54          
     55          //  ++, kutelf, 131007
     56          unsigned char Camera_Mode = 0xFF;
     57          unsigned char Camera_CheckFlag = 1;
     58          unsigned char Camera_CheckCnt = 0;
     59          //  --, kutelf, 131007
     60          
     61          unsigned char AAVM_Mode = 0xFF;
     62          extern unsigned char AAVM_Icon_Index = 0xFF;
     63          extern unsigned char AAVM_Camera_Icon_Index = 0xFF;
     64          unsigned char AAVM_CheckFlag = 1;
     65          unsigned char AAVM_CheckCnt = 0;
     66          extern unsigned char AAVM_Menu_Flag = 0xFF;
     67          
     68          /* Private function prototypes -----------------------------------------------*/
     69          /* Private functions ---------------------------------------------------------*/
     70          
     71          void LED_POWER_ONOFF(uint8_t BitData)
     72          {
     73              GPIO_WriteBit(LED_PORT, LED_CTRL, (BitAction) BitData);
     74          }
     75          
     76          void LCD_POWER_ONOFF(uint8_t BitData)
     77          {
     78              GPIO_WriteBit(LCDPWR_PORT, LCDPWR_CTRL, (BitAction) BitData);
     79          }
     80          
     81          void LCDBL_ONOFF(uint8_t BitData)
     82          {
     83              GPIO_WriteBit(LCDBL_PORT, LCDBL_CTRL, (BitAction) BitData);
     84          
     85          	WL9FM_LCDBL.OnOff = BitData;
     86          }
     87          
     88          /**
     89            * @brief  PWM Level Setting (LEVEL value를 받아서 설정한다.)
     90            * @param  pwm
     91            * @retval None
     92            */
     93          void LCDBL_PWM_LEVEL(uint8_t LEVEL)
     94          {
     95              //  PWM을 변경한 후에 항상 저장해 놓는다.
     96              WL9FM_LCDBL.PWM	  = LCDBL_PWMLEVEL[LEVEL];  
     97              WL9FM_LCDBL.LEVEL = LEVEL;
     98              LCDBL_PWM_CONTROL(WL9FM_LCDBL.PWM);
     99          }
    100          
    101          /**
    102            * @brief  PWM Value Setting (pwm value를 받아서, Pulse로 설정한다.)
    103            * @param  pwm
    104            * @retval None
    105            */
    106          void LCDBL_PWM_CONTROL(uint16_t PWM_VALUE)
    107          {
    108          	TIM_OCInitTypeDef  TIM_OCInitStructure;
    109          
    110          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
    111          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    112          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    113          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    114          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    115          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    116          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    117          
    118          	//	Channel 1 Configuration in PWM mode
    119          	TIM_OCInitStructure.TIM_Pulse = PWM_VALUE;
    120          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);					
    121          
    122          	// 	TIM8 counter enable
    123          	TIM_Cmd(TIM8, ENABLE);			
    124          
    125          	//	TIM8 Main Output Enable
    126          	TIM_CtrlPWMOutputs(TIM8, ENABLE);
    127          }
    128          
    129          void LCDBL_Init(void)
    130          {
    131          	DebugMsg_printf("++ LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize START\r\n");
    132          
    133          	/* TIM8 Configuration ---------------------------------------------------
    134          	Generate 7 PWM signals with 4 different duty cycles:
    135          	TIM8 input clock (TIM8CLK) is set to 2 * APB2 clock (PCLK2), since APB2 
    136          	prescaler is different from 1.   
    137          	TIM8CLK = 2 * PCLK2  
    138          	PCLK2 = HCLK / 2 
    139          	=> TIM8CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
    140          	TIM8CLK = SystemCoreClock, Prescaler = 0, TIM8 counter clock = SystemCoreClock
    141          	SystemCoreClock is set to 168 MHz for STM32F4xx devices
    142          
    143          	The objective is to generate 7 PWM signal at 17.57 KHz:
    144          	- TIM8_Period = (SystemCoreClock / 17570) - 1
    145          	The channel 1 and channel 1N duty cycle is set to 50%
    146          	The channel 2 and channel 2N duty cycle is set to 37.5%
    147          	The channel 3 and channel 3N duty cycle is set to 25%
    148          	The channel 4 duty cycle is set to 12.5%
    149          	The Timer pulse is calculated as follows:
    150          	- ChannelxPulse = DutyCycle * (TIM8_Period - 1) / 100
    151             
    152             Note: 
    153              SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
    154              Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
    155              function to update SystemCoreClock variable value. Otherwise, any configuration
    156              based on this variable will be incorrect. 
    157            ----------------------------------------------------------------------- */
    158            
    159            	TIM_TimeBaseInitTypeDef  	TIM_TimeBaseStructure;
    160            	TIM_OCInitTypeDef  			TIM_OCInitStructure;
    161          
    162          	uint16_t TimerPeriod  = 0;
    163          	
    164          	//	PWM Frequency : 500Hz (Mitsubishi 7" LCD)
    165          	TimerPeriod = (SystemCoreClock / 250 ) - 1;
    166          #if 0
    167          	ChannelPulse = (uint16_t) (((uint32_t) 0 * (TimerPeriod - 1)) / 10);  	//    0% : 0
    168          	ChannelPulse = (uint16_t) (((uint32_t) 2 * (TimerPeriod - 1)) / 10);	//	 20% : 3327  
    169          	ChannelPulse = (uint16_t) (((uint32_t) 3 * (TimerPeriod - 1)) / 10); 	//	 30% : 4991 
    170          	ChannelPulse = (uint16_t) (((uint32_t) 4 * (TimerPeriod - 1)) / 10); 	//	 40% : 6655 
    171          	ChannelPulse = (uint16_t) (((uint32_t) 5 * (TimerPeriod - 1)) / 10);  	//	 50% : 8319
    172          	ChannelPulse = (uint16_t) (((uint32_t) 6 * (TimerPeriod - 1)) / 10);  	//	 60% : 9982
    173          	ChannelPulse = (uint16_t) (((uint32_t) 7 * (TimerPeriod - 1)) / 10);  	//	 70% : 11646
    174          	ChannelPulse = (uint16_t) (((uint32_t) 85 * (TimerPeriod - 1)) / 100);	//	 85% : 14142  
    175          	ChannelPulse = (uint16_t) (((uint32_t) 10 * (TimerPeriod - 1)) / 10);  //	100% : 16638
    176          #endif
    177          
    178              //  LCDBL GPIO는 System_Init.c 에서 설정
    179          #if 0
    180          	GPIO_InitTypeDef GPIO_InitStructure;
    181          
    182          	//	LCDBL_PWM -> PWM
    183          	GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    184          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    185          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    186          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    187          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    188          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    189          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    190          
    191          	//  LCDBL_CTRL -> GPIO Output
    192          	GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    193          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    194          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    195          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    196          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    197          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    198          
    199          #endif
    200          	
    201          	TIM_TimeBaseStructure.TIM_Prescaler         = 16;
    202          	TIM_TimeBaseStructure.TIM_CounterMode 	    = TIM_CounterMode_Up;
    203          	TIM_TimeBaseStructure.TIM_Period 			= TimerPeriod;
    204          	TIM_TimeBaseStructure.TIM_ClockDivision     = 0;
    205          	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    206          
    207          	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
    208          
    209          	TIM_OCInitStructure.TIM_OCMode 			= TIM_OCMode_PWM2;
    210          	TIM_OCInitStructure.TIM_OutputState 	= TIM_OutputState_Enable;
    211          	TIM_OCInitStructure.TIM_OutputNState 	= TIM_OutputNState_Enable;
    212          	TIM_OCInitStructure.TIM_OCPolarity 		= TIM_OCPolarity_Low;
    213          	TIM_OCInitStructure.TIM_OCNPolarity 	= TIM_OCNPolarity_High;
    214          	TIM_OCInitStructure.TIM_OCIdleState 	= TIM_OCIdleState_Set;
    215          	TIM_OCInitStructure.TIM_OCNIdleState 	= TIM_OCIdleState_Reset;
    216          
    217          	//	Channel 1 Configuration in PWM mode
    218          	TIM_OCInitStructure.TIM_Pulse = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    219          
    220          	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
    221          
    222          	// 	TIM8 counter enable
    223          	TIM_Cmd(TIM8, ENABLE);
    224          
    225          	// 	TIM8 Main Output Enable
    226          	TIM_CtrlPWMOutputs(TIM8, ENABLE);		
    227          
    228          	DebugMsg_printf("-- LCD_Control_Init, LCDBL(TIM8 : PWM), ONOFF Initialize END\r\n");
    229          
    230          	TimeDelay_msec(1000); 
    231          
    232          	WL9FM_LCDBL.LEVEL = DefaultLCDBLLEVEL;
    233          	WL9FM_LCDBL.PWM   = LCDBL_PWMLEVEL[DefaultLCDBLLEVEL];
    234          }
    235          
    236          void LCD_Display_Change(uint8_t BitData)
    237          {
    238          	//	Display Buffer를 변경하는 것이기 때문에
    239          	//	표시하고자 하는 것을 하기 전에, 다른 것을 먼저 High-Z 상태로 만든다. 
    240          	if (BitData == STM32F4_DISPLAY)
    241          	{
    242          	    GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_RESET);
    243          		TimeDelay_msec(10); 
    244          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_SET);
    245          	}
    246          	else
    247          	{
    248          	    GPIO_WriteBit(LCD_STM32_PORT , LCD_STM32 , Bit_RESET);
    249          		TimeDelay_msec(10); 
    250          		GPIO_WriteBit(LCD_EXYNOS_PORT, LCD_EXYNOS, Bit_SET);
    251          	}
    252          }
    253          
    254          //  ++, kutelf, 131007
    255          //	카메라 동작 모드 일 경우, 3초 마다 한번씩 각 채널의
    256          //	상태를 체크하여, Video가 없으면 No Video 띄워준다.
    257          void cam_mode_check(void)
    258          {
    259          	CheckCamera_Input(Camera_Mode);		
    260          }
    261          	
    262          void cam_mode_change(u8 Mode)
    263          {
    264          	if(Mode == 0xFF)
    265          	{
    266          		LCD_Display_Change(EXYNOS_DISPLAY);
    267          	}
    268          	else
    269          	{
    270          		CameraMode(Mode, 1);
    271          		LCD_Display_Change(STM32F4_DISPLAY);
    272          	}
    273          	
    274          	
    275          }
    276          // ++, 160812 cjg
    277          void aavm_mode_check(void)
    278          {
    279                    CheckAAVM_Input(AAVM_Mode);
    280          }
    281          void aavm_mode_change(u8 Mode)
    282          {
    283                    if(Mode == 0xFF)
    284                    {
    285                            LCD_Display_Change(EXYNOS_DISPLAY);
    286                    }
    287                    else
    288                    {
    289                            AAVMMode(Mode, 1);
    290                            LCD_Display_Change(STM32F4_DISPLAY);
    291                    }
    292          }
    293          
    294          // --, 160812 cjg
    295          
    296          
    297          
    298          
    299          //  --, kutelf, 131007
    300          
    301          /**\
    302            * @brief  None
    303            * @param  None
    304            * @retval None
    305            */
    306          void LCD_Control_Init(void)
    307          {
    308          	TimeDelay_msec(3000); 
    309          	LCD_Display_Change(EXYNOS_DISPLAY);
    310          	//LCD_Display_Change(STM32F4_DISPLAY);
    311          	LCDBL_Init();	
    312          	LCDBL_ONOFF(LCDBL_ON);	//  LCDBL Power On!!!
    313          			//	LCDBL PWM 설정 
    314          	
    315          	//LCD_Display_Change(STM32F4_DISPLAY);
    316          }
    317          
    318          /*********(C) COPYRIGHT 2010 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   LCDBL_Init
        48   -> TIM_Cmd
        48   -> TIM_CtrlPWMOutputs
        48   -> TIM_OC1Init
        48   -> TIM_TimeBaseInit
        48   -> TimeDelay_msec
       8   LCDBL_ONOFF
         8   -> GPIO_WriteBit
      32   LCDBL_PWM_CONTROL
        32   -> TIM_Cmd
        32   -> TIM_CtrlPWMOutputs
        32   -> TIM_OC1Init
       0   LCDBL_PWM_LEVEL
         0   -> LCDBL_PWM_CONTROL
       8   LCD_Control_Init
         8   -> GPIO_WriteBit
         8   -> LCDBL_Init
         8   -> LCD_Display_Change
         8   -> TimeDelay_msec
      16   LCD_Display_Change
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TimeDelay_msec
       0   LCD_POWER_ONOFF
         0   -> GPIO_WriteBit
       0   LED_POWER_ONOFF
         0   -> GPIO_WriteBit
       8   aavm_mode_change
         8   -> AAVMMode
         0   -> LCD_Display_Change
       0   aavm_mode_check
         0   -> CheckAAVM_Input
       8   cam_mode_change
         8   -> CameraMode
         0   -> LCD_Display_Change
       0   cam_mode_check
         0   -> CheckCamera_Input


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       6  ?Subroutine0
       1  AAVM_Camera_Icon_Index
       1  AAVM_CheckCnt
       1  AAVM_CheckFlag
       1  AAVM_Icon_Index
       1  AAVM_Menu_Flag
       1  AAVM_Mode
       1  Camera_CheckCnt
       1  Camera_CheckFlag
       1  Camera_Mode
     146  LCDBL_Init
      20  LCDBL_ONOFF
      20  LCDBL_PWMLEVEL
      80  LCDBL_PWM_CONTROL
      16  LCDBL_PWM_LEVEL
      38  LCD_Control_Init
      72  LCD_Display_Change
      10  LCD_POWER_ONOFF
      12  LED_POWER_ONOFF
      18  aavm_mode_change
       8  aavm_mode_check
      20  cam_mode_change
       8  cam_mode_check

 
   2 bytes in section .bss
   7 bytes in section .data
 506 bytes in section .text
 
 506 bytes of CODE memory
   9 bytes of DATA memory

Errors: none
Warnings: none
